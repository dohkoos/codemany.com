<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Win32 | 乐者为王]]></title>
  <link href="http://codemany.com/tags/win32/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2016-09-10T08:15:33+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用Win32备份Foxmail的邮件]]></title>
    <link href="http://codemany.com/blog/backup-foxmail-mail-using-win32/"/>
    <updated>2008-04-13T07:38:52+08:00</updated>
    <id>http://codemany.com/blog/backup-foxmail-mail-using-win32</id>
    <content type="html"><![CDATA[<p>Foxmail是一个非常不错的邮件客户端，可惜在对邮箱内邮件的备份上做的不是很好，只能手工一封一封地将邮件导出，在邮件比较少时这样处理还可以应付，但假如有成百上千封邮件时还要这样处理显然是相当郁闷的。因此写了一个可以自动将某个邮箱中所有邮件导出为独立的eml格式邮件文件（该格式可以被OutLook邮件程序识别并打开）的小程序。</p>

<p>在Foxmail的安装目录下有一个mail文件夹，该文件夹中的每个子目录分别对应着一个邮件账号。进入某个帐号对应的文件夹，可以发现文件夹中有以in.BOX、out.BOX、send.BOX、spam.BOX和trash.BOX等文件，它们分别对应于收件箱、发件箱、已发送邮件箱、垃圾邮件箱和废件箱。根据<a href="http://www.yesky.com/72/1663572.shtml">VC++实现Foxmail邮件的批量导出</a>一文可以知道每个邮件头以下面的16个字符开始：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">0x10 0x10 0x10 0x10 0x10 0x10 0x10
0x11 0x11 0x11 0x11 0x11 0x11
0x53 0x0D 0x0A
</code></pre></div>
<p>知道了邮箱所对应存储文件的格式后，以下的事情就变的简单了。</p>

<ol>
<li>获取要备份的文件夹路径；</li>
<li>遍历该文件夹，找出以BOX为后缀名的邮箱存储文件；</li>
<li>分析存储文件，将邮件导出为eml格式的邮件文本。</li>
</ol>

<p>下面是需要用到的一些Win32 API函数：</p>

<p>创建非模态对话框</p>

<ul>
<li>CreateDialog</li>
</ul>

<p>获取目录信息</p>

<ul>
<li>BROWSEINFO</li>
<li>LPITEMIDLIST</li>
<li>SHBrowseForFolder</li>
<li>SHGetPathFromIDList</li>
</ul>

<p>遍历某个目录下的文件</p>

<ul>
<li>SetCurrentDirectory</li>
<li>FindFileFirst</li>
<li>FindNextFile</li>
<li>FindClose</li>
</ul>

<p>备份邮件</p>

<ul>
<li>CreateDirectory</li>
<li>CreateFile</li>
<li>ReadFile</li>
<li>WriteFile</li>
<li>CloseHandle</li>
</ul>

<p>还有，如果在对话框模版里用到了不一般的控件(比如说进度条)，那么还需要</p>

<ol>
<li>引用头文件commctrl.h；</li>
<li>并链接comctl32.lib；</li>
<li>在WinMain中创建对话框前调用InitCommonControls()方法。</li>
</ol>

<p><a href="/uploads/box2eml.zip" title="box2eml.zip">代码下载</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何调试Win32程序]]></title>
    <link href="http://codemany.com/blog/how-to-debug-win32-program/"/>
    <updated>2008-02-13T17:00:53+08:00</updated>
    <id>http://codemany.com/blog/how-to-debug-win32-program</id>
    <content type="html"><![CDATA[<p>方法一：使用OutputDebugString函数</p>

<p>函数的原型如下：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">void OutputDebugString(LPCTSTR lpOutputString);
</code></pre></div>
<p>该函数会输出信息到系统的DEBUGER，输出结果可以使用工具<a href="http://www.microsoft.com/technet/sysinternals/Miscellaneous/DebugView.mspx">DebugView</a>观察。因为OutputDebugString的参数是字符串，而我们在实际使用过程中通常希望能像printf一样支持变参。下面的方法实现了这个效果：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">void DebugString(LPCTSTR lpszFormat, ...)
{
    va_list args;
    TCHAR szText[1024];

    va_start(args, lpszFormat);
    wvsprintf(szText, lpszFormat, args);
    OutputDebugString(szText);
    va_end(args);
}
</code></pre></div>
<p>方法二：输出调试信息到Console上</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">FILE *stream;
AllocConsole();
freopen_s(&amp;stream, &quot;CONOUT$&quot;, &quot;w&quot;, stdout);
printf(&quot;Hello, world!\n&quot;);
</code></pre></div>
<p>这里AllocConsole()用来打开Console，而freopen_s则把标准输出和Cosole关联。“CONOUT$”这个很关键。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Win32实现系统托盘程序]]></title>
    <link href="http://codemany.com/blog/create-system-tray-program-with-win32/"/>
    <updated>2005-03-30T12:36:00+08:00</updated>
    <id>http://codemany.com/blog/create-system-tray-program-with-win32</id>
    <content type="html"><![CDATA[<p>废话不多说，直接上代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">#include &lt;windows.h&gt;
#include &quot;resource.h&quot;

static LPCTSTR szAppName = TEXT(&quot;TrayHelper&quot;);
static LPCTSTR szCaption = TEXT(&quot;TrayIcon&quot;);

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    static HMENU hMenu;
    static UINT WM_TASKBARCREATED;

    POINT point;
    HINSTANCE hInstance;
    NOTIFYICONDATA nid;

    switch (message)
    {
    case WM_CREATE:
        // 不要修改TaskbarCreated字符串，这是系统任务栏自定义的消息
        WM_TASKBARCREATED = RegisterWindowMessage(TEXT(&quot;TaskbarCreated&quot;));

        hInstance = ((LPCREATESTRUCT)lParam)-&gt;hInstance;

        hMenu = LoadMenu(hInstance, MAKEINTRESOURCE(IDR_TRAYMENU));
        hMenu = GetSubMenu(hMenu, 0);

        nid.cbSize = sizeof(nid);
        nid.hWnd = hWnd;
        nid.uID = IDI_PIRAMIDE;
        nid.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;
        nid.uCallbackMessage = WM_USER;
        nid.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_PIRAMIDE));
        strcpy(nid.szTip, szAppName);
        Shell_NotifyIcon(NIM_ADD, &amp;nid);
        break;

    case WM_USER:
        if (lParam == WM_RBUTTONDOWN)
        {
            GetCursorPos(&amp;point);
            // 处理当用户按下ESCAPE键或者在菜单之外单击鼠标时菜单不会消失的情况
            SetForegroundWindow(hWnd);
            TrackPopupMenu(hMenu, TPM_RIGHTBUTTON, point.x, point.y, 0, hWnd, NULL);
        }
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDM_TRAYSETTINGS:
            MessageBox(hWnd, TEXT(&quot;Settings not yet implemented!&quot;),
                             szAppName, MB_ICONEXCLAMATION | MB_OK);
            return 0;

        case IDM_TRAYHELP:
            MessageBox(hWnd, TEXT(&quot;Help not yet implemented!&quot;),
                             szAppName, MB_ICONEXCLAMATION | MB_OK);
            return 0;

        case IDM_TRAYABOUT:
            MessageBox(hWnd, TEXT(&quot;About not yet implemented!&quot;),
                             szAppName, MB_ICONEXCLAMATION | MB_OK);
            return 0;

        case IDM_TRAYEXIT:
            SendMessage(hWnd, WM_CLOSE, 0, 0);
            return 0;
        }
        break;

    case WM_DESTROY:
        // 处理点击Exit菜单退出后图标仍在托盘区显示，要把鼠标在图标上面过一下才会消失的情况
        nid.uID = IDI_PIRAMIDE;
        nid.hWnd = hWnd;
        Shell_NotifyIcon(NIM_DELETE, &amp;nid);
        PostQuitMessage(0);
        break;

    default:
        /*
         * 防止当Explorer.exe崩溃以后，程序在系统托盘中的图标就消失了。
         *
         * 原理：Explorer.exe重新载入后会重建系统任务栏。当系统任务栏建立的时候会向系统内所有
         * 注册接收TaskbarCreated消息的顶级窗口发送一条消息，我们只需要捕捉这个消息，并重建系
         * 统托盘的图标即可。
         */
        if (message == WM_TASKBARCREATED)
        {
            SendMessage(hWnd, WM_CREATE, wParam, lParam);
        }
        break;
    }
    return DefWindowProc(hWnd, message, wParam, lParam);
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                                        LPSTR szCmdLine, int iCmdShow)
{
    HWND hWnd;
    MSG msg;
    WNDCLASS wc;

    HWND handle = FindWindow(NULL, szCaption);
    if (handle != NULL)
    {
        MessageBox(NULL, TEXT(&quot;Application is already running&quot;),
                         szAppName, MB_ICONERROR);
        return 0;
    }

    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = WndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName = NULL;
    wc.lpszClassName = szAppName;

    if (!RegisterClass(&amp;wc))
    {
        MessageBox(NULL, TEXT(&quot;This program requires Windows NT!&quot;),
                         szAppName, MB_ICONERROR);
        return 0;
    }

    // 此处使用WS_EX_TOOLWINDOW属性来隐藏显示在任务栏上的窗口程序按钮
    hWnd = CreateWindowEx(WS_EX_TOOLWINDOW,
                        szAppName, szCaption,
                        WS_POPUP,
                        CW_USEDEFAULT,
                        CW_USEDEFAULT,
                        CW_USEDEFAULT,
                        CW_USEDEFAULT,
                        NULL, NULL, hInstance, NULL);

    ShowWindow(hWnd, iCmdShow);
    UpdateWindow(hWnd);

    while (GetMessage(&amp;msg, NULL, 0, 0))
    {
        TranslateMessage(&amp;msg);
        DispatchMessage(&amp;msg);
    }

    return msg.wParam;
}
</code></pre></div>]]></content>
  </entry>
  
</feed>
