<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Win32 | 乐者为王]]></title>
  <link href="http://codemany.com/tags/win32/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2014-08-05T22:58:49+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[如何调试Win32程序]]></title>
    <link href="http://codemany.com/blog/2008/02/13/how-to-debug-win32-program/"/>
    <updated>2008-02-13T01:00:53+08:00</updated>
    <id>http://codemany.com/blog/2008/02/13/how-to-debug-win32-program</id>
    <content type="html"><![CDATA[<p>方法一：使用OutputDebugString函数</p>

<p>函数的原型如下：</p>

<p><code>
void OutputDebugString(LPCTSTR lpOutputString);
</code></p>

<p>该函数会输出信息到系统的DEBUGER，输出结果可以使用工具<a href="http://www.microsoft.com/technet/sysinternals/Miscellaneous/DebugView.mspx">DebugView</a>观察。因为OutputDebugString的参数是字符串，而我们在实际使用过程中通常希望能像printf一样支持变参。下面的方法实现了这个效果：</p>

<p>```
void DebugString(LPCTSTR lpszFormat, ...)
{</p>

<pre><code>va_list args;
TCHAR szText[1024];

va_start(args, lpszFormat);
wvsprintf(szText, lpszFormat, args);
OutputDebugString(szText);
va_end(args);
</code></pre>

<p>}
```</p>

<p>方法二：输出调试信息到Console上</p>

<p><code>
FILE *stream;
AllocConsole();
freopen_s(&amp;stream, "CONOUT$", "w", stdout);
printf("Hello, world!\n");
</code></p>

<p>这里AllocConsole()用来打开Console，而freopen_s则把标准输出和Cosole关联。“CONOUT$”这个很关键。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Win32 API实现系统托盘程序]]></title>
    <link href="http://codemany.com/blog/2005/03/30/creating-system-tray-program-with-win32-api/"/>
    <updated>2005-03-30T12:36:00+08:00</updated>
    <id>http://codemany.com/blog/2005/03/30/creating-system-tray-program-with-win32-api</id>
    <content type="html"><![CDATA[<p>废话不多说，直接上代码：</p>

<p>```</p>

<h1>include &lt;windows.h></h1>

<h1>include "resource.h"</h1>

<p>LPCTSTR szAppName = TEXT("TrayHelper");
LPCTSTR szCaption = TEXT("TrayIcon");</p>

<p>LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{</p>

<pre><code>static HMENU hMenu;
static UINT WM_TASKBARCREATED;

POINT point;
HINSTANCE hInstance;
NOTIFYICONDATA nid;

switch (message)
{
case WM_CREATE:
    // 不要修改TaskbarCreated字符串，这是系统任务栏自定义的消息
    WM_TASKBARCREATED = RegisterWindowMessage(TEXT("TaskbarCreated"));

    hInstance = ((LPCREATESTRUCT)lParam)-&gt;hInstance;

    hMenu = LoadMenu(hInstance, MAKEINTRESOURCE(IDR_TRAYMENU));
    hMenu = GetSubMenu(hMenu, 0);

    nid.cbSize = sizeof(nid);
    nid.hWnd = hWnd;
    nid.uID = IDI_PIRAMIDE;
    nid.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;
    nid.uCallbackMessage = WM_USER;
    nid.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_PIRAMIDE));
    strcpy(nid.szTip, szAppName);
    Shell_NotifyIcon(NIM_ADD, &amp;nid);
    break;

case WM_USER:
    if (lParam == WM_RBUTTONDOWN)
    {
        GetCursorPos(&amp;point);
        // 处理当用户按下ESCAPE键或者在菜单之外单击鼠标时菜单不会消失的情况
        SetForegroundWindow(hWnd);
        TrackPopupMenu(hMenu, TPM_RIGHTBUTTON, point.x, point.y, 0, hWnd, NULL);
    }
    break;

case WM_COMMAND:
    switch (LOWORD(wParam)) {
    case IDM_TRAYSETTINGS:
        MessageBox(hWnd, TEXT("not implemented!"),
                         szAppName, MB_ICONEXCLAMATION | MB_OK);
        return 0;

    case IDM_TRAYHELP:
        MessageBox(hWnd, TEXT("not implemented!"),
                         szAppName, MB_ICONEXCLAMATION | MB_OK);
        return 0;

    case IDM_TRAYABOUT:
        MessageBox(hWnd, TEXT("not implemented!"),
                         szAppName, MB_ICONEXCLAMATION | MB_OK);
        return 0;

    case IDM_TRAYEXIT:
        SendMessage(hWnd, WM_CLOSE, 0, 0);
        return 0;
    }
    break;

case WM_DESTROY:
    // 处理点击Exit菜单退出后图标仍在托盘区显示，要把鼠标在图标上面过一下才会消失的情况
    nid.uID = IDI_PIRAMIDE;
    nid.hWnd = hWnd;
    Shell_NotifyIcon(NIM_DELETE, &amp;nid);
    PostQuitMessage(0);
    break;

default:
    /*
     * 防止当Explorer.exe崩溃以后，程序在系统托盘中的图标就消失了。
     *
     * 原理：Explorer.exe重新载入后会重建系统任务栏。当系统任务栏建立的时候会向系统内所有
     * 注册接收TaskbarCreated消息的顶级窗口发送一条消息，我们只需要捕捉这个消息，并重建系
     * 统托盘的图标即可。
     */
    if (message == WM_TASKBARCREATED)
        SendMessage(hWnd, WM_CREATE, wParam, lParam);
    break;
}
return DefWindowProc(hWnd, message, wParam, lParam);
</code></pre>

<p>}</p>

<p>int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,</p>

<pre><code>                                    LPSTR szCmdLine, int iCmdShow)
</code></pre>

<p>{</p>

<pre><code>HWND hWnd;
MSG msg;
WNDCLASS wc;

HWND handle = FindWindow(NULL, szCaption);
if (handle != NULL)
{
    MessageBox(NULL, TEXT("Application is already running"),
                     szAppName, MB_ICONERROR);
    return 0;
}

wc.style = CS_HREDRAW | CS_VREDRAW;
wc.lpfnWndProc = WndProc;
wc.cbClsExtra = 0;
wc.cbWndExtra = 0;
wc.hInstance = hInstance;
wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
wc.hCursor = LoadCursor(NULL, IDC_ARROW);
wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
wc.lpszMenuName = NULL;
wc.lpszClassName = szAppName;

if (!RegisterClass(&amp;wc))
{
    MessageBox(NULL, TEXT("This program requires Windows NT!"),
                     szAppName, MB_ICONERROR);
    return 0;
}

// 此处使用WS_EX_TOOLWINDOW属性来隐藏显示在任务栏上的窗口程序按钮
hWnd = CreateWindowEx(WS_EX_TOOLWINDOW,
                    szAppName, szCaption,
                    WS_POPUP,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    NULL, NULL, hInstance, NULL);

ShowWindow(hWnd, iCmdShow);
UpdateWindow(hWnd);

while (GetMessage(&amp;msg, NULL, 0, 0))
{
    TranslateMessage(&amp;msg);
    DispatchMessage(&amp;msg);
}

return msg.wParam;
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
</feed>
