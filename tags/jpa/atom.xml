<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: JPA | 乐者为王]]></title>
  <link href="http://codemany.com/tags/jpa/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2014-10-19T18:47:47+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JPA + Spring 2入门]]></title>
    <link href="http://codemany.com/blog/getting-started-jpa-with-spring2"/>
    <updated>2007-08-10T18:33:42+08:00</updated>
    <id>http://codemany.com/blog/getting-started-jpa-with-spring2</id>
    <content type="html"><![CDATA[<p>一、配置JPA</p>

<p>Spring提供了两种方法创建JPA的EntityManagerFactory对象。</p>

<p>方法一：</p>

<p>```
<beans></p>

<pre><code>&lt;bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalEntityManagerFactoryBean"&gt;
    &lt;property name="persistenceUnitName" value="persistenceUnit" /&gt;
&lt;/bean&gt;
</code></pre>

<p></beans>
```</p>

<p>FactoryBean创建的EntityManagerFactory适用于仅通过JPA进行数据访问的环境。由于使用了PersistenceProvider自动侦测机制，所以只能从默认路径classpath:META-INF/persistence.xml中读取配置信息。</p>

<p>方法二：</p>

<p>```
<beans></p>

<pre><code>&lt;bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
    &lt;property name="dataSource" ref="someDataSource" /&gt;
    &lt;property name="loadTimeWeaver"&gt;
        &lt;bean class="org.springframework.instrument.classloading.SimpleLoadTimeWeaver" /&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>

<p></beans>
```</p>

<p>FactoryBean提供了对JPA EntityManagerFactory的完整控制，非常适合那种有简单定制需要的环境。你可以处理多个persistence.xml配置文件；覆盖persistence.xml文件的默认路径；可以传递Spring托管的JDBC DataSource给JPA PersistenceProvider，用来替代persistence.xml中的JDBC配置（这个Spring托管的DataSource通常被作为nonJtaDataSource传送给PersistenceProvider，并且覆盖persistence.xml中相同的nonJtaDataSource）。</p>

<p>二、数据访问</p>

<p>基于JPA的DAO可以通过三种方式进行数据访问JpaDaoSupport，JpaTemplate和plain JPA。其中JpaTemplate是plain JPA的封装，而JpaDaoSupport又是JpaTemplate的封装。无疑，使用不对Spring产生任何依赖的Plain JPA的API进行编程是最好选择。</p>

<p>```
public class ProductDaoImpl implements ProductDao {</p>

<pre><code>private EntityManager entityManager = null;

@PersistenceContext
public void setEntityManager(EntityManager entityManager) {
    this.entityManager = entityManager;
}

public Collection loadProductsByCategory(String category) {
     Query query = em.createQuery("from Product as p where p.category = :category");
     query.setParameter("category", category);
     return query.getResultList();
}
</code></pre>

<p>}
```</p>

<p>注意，必须激活PersistenceAnnotationBeanPostProcessor功能才能让Spring识别@PersistenceContext注解。</p>

<p>```
<beans></p>

<pre><code>&lt;!-- JPA annotations bean post processor --&gt;
&lt;bean class="org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor" /&gt;

&lt;bean id="productDao" class="com.example.shop.dao.impl.ProductDaoImpl" /&gt;
</code></pre>

<p></beans>
```</p>

<p>三、异常转化</p>

<p>Spring提供了一个允许通过使用@Repository注解进行透明的异常转化的解决方案。</p>

<p><code>
@Repository
public class ProductDaoImpl implements ProductDao {
</code></p>

<p>```
<beans></p>

<pre><code>&lt;!-- Exception translation bean post processor --&gt;
&lt;bean class="org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor" /&gt;
</code></pre>

<p>```</p>

<p>后置处理器将自动的寻找所有的异常转化器（PersistenceExceptionTranslator这个接口的实现类）并通知所有打上@Repository注解的bean，从而能够使得被找到的异常转化器能够在抛出异常时做相应的异常转化工作。</p>

<p>总结来说：DAO能够基于普通的Java持久层API和注解来实现，但同样也能享受到由Spring管理事务、IoC和透明的异常转化（转化成为Spring的异常体系）等好处。</p>
]]></content>
  </entry>
  
</feed>
