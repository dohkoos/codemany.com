<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Database | 乐者为王]]></title>
  <link href="http://codemany.com/tags/database/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2017-11-13T15:38:27+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SQL连接总结]]></title>
    <link href="http://codemany.com/blog/summary-of-sql-join/"/>
    <updated>2012-07-02T09:44:51+08:00</updated>
    <id>http://codemany.com/blog/summary-of-sql-join</id>
    <content type="html"><![CDATA[<p>连接（join）可以在SELECT语句的FROM子句或WHERE子句中建立，在FROM子句中指出连接时有助于将连接操作与WHERE子句中的搜索条件区分开来。连接可以对同一个表操作，也可以对多个表操作，对同一个表操作的连接称为自连接（self join）。</p>

<p>连接类型（join type）分为三种：内连接、外连接和交叉连接。</p>

<ul>
<li>内连接（inner join）：使用比较运算符进行表间某（些）列数据的比较操作，并列出这些表中与连接条件相匹配的数据行。</li>
<li>外连接（outer join）：与内连接不同的是外连接不只列出与连接条件相匹配的行，而且列出左表（左外连接时）、右表（右外连接时）或两个表（全外连接时）中所有符合条件的数据行。</li>
<li>交叉连接（cross join）：返回连接表中所有数据行的笛卡尔积。</li>
</ul>

<p>内/外链接可以分为等值连接和不等连接：</p>

<ul>
<li>等值连接（equijoin）：在连接条件中使用等于（=）运算符比较被连接列的列值，其查询结果中列出被连接表中的所有列，包括其中的重复列。</li>
<li>不等连接（non-equijoin）：在连接条件使用除等于运算符以外的其它比较运算符比较被连接的列的列值。</li>
</ul>

<p>注意：自然连接（natural join）是一种特殊的等值连接。它使用选择列表指出查询结果中所包括的列，由此删除连接表中的重复列。</p>

<p>books数据表：</p>

<p><img src="/uploads/books-table.png" alt="books-table"></p>

<p>publishers数据表：</p>

<p><img src="/uploads/publishers-table.png" alt="publishers-table"></p>

<p>自连接查询：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SELECT * FROM books b1 [INNER] JOIN books b2 ON b1.price = b2.price
</code></pre></div>
<p><img src="/uploads/self-join.png" alt="self-join"></p>

<p>内连接（简称连接）查询：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SELECT * FROM books b [INNER] JOIN publishers p ON b.publisher_id = p.publisher_id
</code></pre></div>
<p><img src="/uploads/inner-join.png" alt="inner-join"></p>

<p>自然连接查询：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SELECT b.*, p.name FROM books b [INNER] JOIN publishers p ON b.publisher_id = p.publisher_id
</code></pre></div>
<p><img src="/uploads/natural-join.png" alt="natural-join"></p>

<p>左外连接（简称左连接）查询：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SELECT * FROM books b LEFT [OUTER] JOIN publishers p ON b.publisher_id = p.publisher_id
</code></pre></div>
<p><img src="/uploads/left-outer-join.png" alt="left-outer-join"></p>

<p>右外连接（简称右连接）查询：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SELECT * FROM books b RIGHT [OUTER] JOIN publishers p ON b.publisher_id = p.publisher_id
</code></pre></div>
<p><img src="/uploads/right-outer-join.png" alt="right-outer-join"></p>

<p>全外连接（简称全连接）查询：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SELECT * FROM books b FULL [OUTER] JOIN publishers p ON b.publisher_id = p.publisher_id
</code></pre></div>
<p><img src="/uploads/full-outer-join.png" alt="full-outer-join"></p>

<p>交叉连接查询：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SELECT * FROM books CROSS JOIN publishers
</code></pre></div>
<p><img src="/uploads/cross-join.png" alt="cross-join"></p>

<p>下图是由Moffatt在2008年制作的连接集合表示：</p>

<p><img src="/uploads/sql-joins.jpg" alt="sql-joins"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[创建视图时的with check option选项]]></title>
    <link href="http://codemany.com/blog/with-check-option-in-view/"/>
    <updated>2010-06-28T20:33:27+08:00</updated>
    <id>http://codemany.com/blog/with-check-option-in-view</id>
    <content type="html"><![CDATA[<p>通过有with check option选项的视图操作基表，有以下结论：</p>

<ol>
<li>首先视图只操作它可以查询出来的数据，对于它查询不出的数据，即使基表有，也不可以通过视图来操作；</li>
<li>对于update，有with check option，要保证update后，数据能被视图查询出来；</li>
<li>对于delete，有无with check option都一样；</li>
<li>对于insert，有with check option，要保证insert后，数据要被视图查询出来。</li>
</ol>

<p>对于没有where子句的视图，使用with check option是多余的。</p>

<p>下面用一个例子来说明第4条：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">CREATE TABLE students (
    id int NOT NULL AUTO_INCREMENT,
    name varchar(50) NOT NULL,
    age int,
    sex char(1),
    PRIMARY KEY (id)
);

CREATE VIEW male_students_view AS
    SELECT name, age FROM students
    WHERE sex = &#39;M&#39;
    WITH CHECK OPTION;
</code></pre></div><div class="highlight"><pre><code class="language-text" data-lang="text">-- 报CHECK OPTION failed错误，原因如4，插入数据后要还能被视图查询出来。
INSERT INTO male_students_view VALUES(&#39;WU&#39;, 18);
</code></pre></div><div class="highlight"><pre><code class="language-text" data-lang="text">-- 报Column count doesn&#39;t match value count错误，因为视图中根本没有sex列。
INSERT INTO male_students_view VALUES(&#39;WU&#39;, 18, &#39;M&#39;);
</code></pre></div>
<p>将students.sex列改成默认值为M：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">ALTER TABLE students MODIFY sex char(1) NOT NULL DEFAULT &#39;M&#39;
</code></pre></div><div class="highlight"><pre><code class="language-text" data-lang="text">-- 执行成功，1 row affected。
INSERT INTO male_students_view VALUES(&#39;WU&#39;, 18);
</code></pre></div><div class="highlight"><pre><code class="language-text" data-lang="text">-- 还是同样的问题，Column count doesn&#39;t match value count。
INSERT INTO male_students_view VALUES(&#39;WU&#39;, 18, &#39;M&#39;);
</code></pre></div>
<p>或者不修改students.sex的属性，将视图改成：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">CREATE VIEW male_students_view AS
    SELECT name, age, sex FROM students
    WHERE sex = &#39;M&#39;
    WITH CHECK OPTION;
</code></pre></div><div class="highlight"><pre><code class="language-text" data-lang="text">-- 会报CHECK OPTION failed错误。
INSERT INTO male_students_view VALUES(&#39;WU&#39;, 18);
</code></pre></div><div class="highlight"><pre><code class="language-text" data-lang="text">-- 执行成功，1 row affected。
INSERT INTO male_students_view VALUES(&#39;WU&#39;, 18, &#39;M&#39;);
</code></pre></div>
<p>以上例子都在MySQL上实际执行过。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用SQL Server 2000个人版出现的问题]]></title>
    <link href="http://codemany.com/blog/problem-using-sql-server-2000-personal-edition/"/>
    <updated>2010-06-01T12:52:33+08:00</updated>
    <id>http://codemany.com/blog/problem-using-sql-server-2000-personal-edition</id>
    <content type="html"><![CDATA[<p>下午在机房值班，14:00的时候有人报告说交易客户端不能登录了，确定问题后两同事急忙重启AR和AS以及交易网关，可是还是不能登录。紧急重启数据库后问题才解决。</p>

<p>出了问题不可怕，关键是找到问题根源所在，解决问题，使同样的错误不再重复地发生。</p>

<p>打电话联系恒生的工程师，向他们提供系统的日志文件，希望他们那边能提供帮助，找到原因。我也在这边分析系统的事件和日志文件，想找出到底是在哪里出的问题。分析着从SQL Server的LOG目录下找到的几个ERRORLOG文件，发现从13:57开始有连续多条如下的警告语句出现：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SQL Server已为8个并发查询而优化。36个查询超过了此限制，因而性能可能会受到不良影响。
</code></pre></div>
<p>很快，恒生工程师也打电话来说可能是查询数据库过多导致的问题。这个我们一开始就想过，但关键是那时候只连接进来了400个左右的客户，怎么可能查询过多呢？而且平时也没出现过这种情况。</p>

<p>在网上搜索资料后知道出现这个问题通常是数据库版本的原因，检查我们的SQL Server数据库，发现竟然是2000个人版。后来又从交易结算部们了解到他们因为要做报表执行了查询所有客户资料的操作，并且我们的备份数据库在几个星期前曾因损坏做过恢复，恢复的同事忘记修改备份数据库的时间，导致本应该执行在备份数据库上的查询执行在了主数据库上，引起了数据库崩溃。</p>

<p>再次联系恒生的工程师，准备这个周末切换数据库到企业版。唉，又要加班了！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[允许客户端远程连接Lunarpages上的MySQL数据库]]></title>
    <link href="http://codemany.com/blog/allow-remote-client-to-connect-to-mysql-on-lunarpages/"/>
    <updated>2009-07-09T14:54:05+08:00</updated>
    <id>http://codemany.com/blog/allow-remote-client-to-connect-to-mysql-on-lunarpages</id>
    <content type="html"><![CDATA[<p>Lunarpages虚拟主机上的MySQL服务默认仅有本机能访问。只有在cPanel中向某IP地址或地址段或者所有地址开放访问权限后，才可以从外部用客户端连接数据库。</p>

<p>如果想允许任何主机的访问，直接在Host处填写百分号%，然后Add Host即可。如果只想特定主机访问，就输入客户端机器的IP地址。</p>

<p><img src="/uploads/lunarpages-mysql-remote.png" alt="lunarpages-mysql-remote"></p>

<p>客户端远程连接时使用的地址就是虚拟空间的地址，可以通过ping域名得到。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[com.sybase.jdbc2.jdbc.SybSQLException: SQL Anywhere Error -143: Column '@p3' not found]]></title>
    <link href="http://codemany.com/blog/comsybasejdbc2jdbcsybsqlexception-sql-anywhere-error-143-column-not-found/"/>
    <updated>2008-09-19T00:24:13+08:00</updated>
    <id>http://codemany.com/blog/comsybasejdbc2jdbcsybsqlexception-sql-anywhere-error-143-column-not-found</id>
    <content type="html"><![CDATA[<p>数据库：Sybase ASA 10</p>

<p>在移植PB程序到Java程序时，碰到了如下的嵌入式SQL语句：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SELECT DISTINCT
    bhr_emp_job.emp_nbr,
    bhr_emp_job.cyr_nyr_flg,
    bhr_emp_job.pay_freq,
    bhr_emp_job.job_cd,
    bhr_emp_job.contr_non_std_flg,
    bhr_emp_job.pay_type
FROM bhr_emp_job
WHEN :as_cal_code &lt;&gt; &#39;&#39;
AND :as_cal_code = bhr_emp_job.cal_cd
</code></pre></div>
<p>转换后的SQL代码如下：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SELECT DISTINCT
    bhr_emp_job.emp_nbr,
    bhr_emp_job.cyr_nyr_flg,
    bhr_emp_job.pay_freq,
    bhr_emp_job.job_cd,
    bhr_emp_job.contr_non_std_flg,
    bhr_emp_job.pay_type
FROM bhr_emp_job
WHEN ? &lt;&gt; &#39;&#39;
AND ? = bhr_emp_job.cal_cd
</code></pre></div>
<p>结果在执行的时候出现了下面的异常：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&lt;ERROR&gt;openQuery in org.rsccc.dao.hrs4300.DHrs4300JobcopyDao when executing SELECT DISTINCT
    bhr_emp_job.emp_nbr,
    bhr_emp_job.cyr_nyr_flg,
    bhr_emp_job.pay_freq,
    bhr_emp_job.job_cd,
    bhr_emp_job.contr_non_std_flg,
    bhr_emp_job.pay_type
FROM bhr_emp_job
WHEN ? &lt;&gt; &#39;&#39;
AND ? = bhr_emp_job.cal_cd
com.sybase.jdbc2.jdbc.SybSQLException: SQL Anywhere Error -143: Column &#39;@p3&#39; not found
</code></pre></div>
<p>在Sybase站点上找到的相关资料是<a href="http://www.ianywhere.com/developer/product_manuals/sqlanywhere/1000/en/html/dberen10/er-errm143.html">Column &#39;%1&#39; not found</a></p>

<blockquote>
<p>Probable cause: You misspelled the name of a column, or the column you are looking for is in a different table.</p>
</blockquote>

<p>想到在PB中是在填充变量值后再将SQL语句扔到数据库中执行，而移植后的Java程序中采用的是PreparedStatement来执行SQL语句，所以会出现Column not found的错误。解决方法是将?移到赋值符号的右边：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SELECT DISTINCT
    bhr_emp_job.emp_nbr,
    bhr_emp_job.cyr_nyr_flg,
    bhr_emp_job.pay_freq,
    bhr_emp_job.job_cd,
    bhr_emp_job.contr_non_std_flg,
    bhr_emp_job.pay_type
FROM bhr_emp_job
WHEN &#39;&#39; &lt;&gt; ?
AND bhr_emp_job.cal_cd = ?
</code></pre></div>]]></content>
  </entry>
  
</feed>
