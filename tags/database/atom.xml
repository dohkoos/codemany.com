<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Database | 乐者为王]]></title>
  <link href="http://codemany.com/tags/database/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2014-10-09T23:55:15+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SQL连接总结]]></title>
    <link href="http://codemany.com/blog/2012/07/02/summary-of-sql-join/"/>
    <updated>2012-07-02T09:44:51+08:00</updated>
    <id>http://codemany.com/blog/2012/07/02/summary-of-sql-join</id>
    <content type="html"><![CDATA[<p>连接（join）可以在SELECT语句的FROM子句或WHERE子句中建立，在FROM子句中指出连接时有助于将连接操作与WHERE子句中的搜索条件区分开来。连接可以对同一个表操作，也可以对多个表操作，对同一个表操作的连接称为自连接（self join）。</p>

<p>连接类型（join type）分为三种：内连接、外连接和交叉连接。</p>

<ul>
<li>内连接（inner join）：使用比较运算符进行表间某（些）列数据的比较操作，并列出这些表中与连接条件相匹配的数据行。</li>
<li>外连接（outer join）：与内连接不同的是外连接不只列出与连接条件相匹配的行，而且列出左表（左外连接时）、右表（右外连接时）或两个表（全外连接时）中所有符合条件的数据行。</li>
<li>交叉连接（cross join）：返回连接表中所有数据行的笛卡尔积。</li>
</ul>


<p>内/外链接可以分为等值连接和不等连接：</p>

<ul>
<li>等值连接（equijoin）：在连接条件中使用等于（=）运算符比较被连接列的列值，其查询结果中列出被连接表中的所有列，包括其中的重复列。</li>
<li>不等连接（non-equijoin）：在连接条件使用除等于运算符以外的其它比较运算符比较被连接的列的列值。</li>
</ul>


<p>注意：自然连接（natural join）是一种特殊的等值连接。它使用选择列表指出查询结果中所包括的列，由此删除连接表中的重复列。</p>

<p>books数据表：</p>

<p><img src="/uploads/books-table.png" title="books-table" ></p>

<p>publishers数据表：</p>

<p><img src="/uploads/publishers-table.png" title="publishers-table" ></p>

<p>自连接查询：</p>

<p><code>
SELECT * FROM books b1 [INNER] JOIN books b2 ON b1.price = b2.price
</code></p>

<p><img src="/uploads/self-join.png" title="self-join" ></p>

<p>内连接（简称连接）查询：</p>

<p><code>
SELECT * FROM books b [INNER] JOIN publishers p ON b.publisher_id = p.publisher_id
</code></p>

<p><img src="/uploads/inner-join.png" title="inner-join" ></p>

<p>自然连接查询：</p>

<p><code>
SELECT b.*, p.name FROM books b [INNER] JOIN publishers p ON b.publisher_id = p.publisher_id
</code></p>

<p><img src="/uploads/natural-join.png" title="natural-join" ></p>

<p>左外连接（简称左连接）查询：</p>

<p><code>
SELECT * FROM books b LEFT [OUTER] JOIN publishers p ON b.publisher_id = p.publisher_id
</code></p>

<p><img src="/uploads/left-outer-join.png" title="left-outer-join" ></p>

<p>右外连接（简称右连接）查询：</p>

<p><code>
SELECT * FROM books b RIGHT [OUTER] JOIN publishers p ON b.publisher_id = p.publisher_id
</code></p>

<p><img src="/uploads/right-outer-join.png" title="right-outer-join" ></p>

<p>全外连接（简称全连接）查询：</p>

<p><code>
SELECT * FROM books b FULL [OUTER] JOIN publishers p ON b.publisher_id = p.publisher_id
</code></p>

<p><img src="/uploads/full-outer-join.png" title="full-outer-join" ></p>

<p>交叉连接查询：</p>

<p><code>
SELECT * FROM books CROSS JOIN publishers
</code></p>

<p><img src="/uploads/cross-join.png" title="cross-join" ></p>

<p>下图是由Moffatt在2008年制作的连接集合表示：</p>

<p><img src="/uploads/sql-joins.jpg" title="sql-joins" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据库设计范式阅读笔记]]></title>
    <link href="http://codemany.com/blog/2012/03/18/reading-notes-database-design-normal-form/"/>
    <updated>2012-03-18T17:24:06+08:00</updated>
    <id>http://codemany.com/blog/2012/03/18/reading-notes-database-design-normal-form</id>
    <content type="html"><![CDATA[<p>下面三个范式是当前网上到处流传的关于数据库范式的定义。不知道是从哪里找来的，想来应该是从国内的数据库教科书上吧。光看定义的话很难明白，即使在例子的帮助下也难以理解1NF的内容，而且所说的与实践也有很大不同。上Wiki去查找相关内容，才发现完全是胡言乱语，不知所云，就是想把你搞糊涂，让你弄不懂。下面针对每个范式说说我对它们的理解。</p>

<p>第一范式（1NF）：数据表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值<del>或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。</del>在1NF中表的每一行只包含一个实例的信息。</p>

<p>划线部分是纯粹的学院派做法，想要达到数据的零冗余。实际上是既没理解1NF的本质，也对实践过程中的性能问题缺乏认识。</p>

<p>员工信息表：</p>

<table>
<thead>
<tr>
<th>Employee </th>
<th> Job Title </th>
<th> Skill </th>
<th> Salary</th>
</tr>
</thead>
<tbody>
<tr>
<td>Peter    </td>
<td> Developer </td>
<td> C#    </td>
<td> 2000</td>
</tr>
<tr>
<td>Kevin    </td>
<td> Developer </td>
<td> Java  </td>
<td> 2000</td>
</tr>
<tr>
<td>Sarah    </td>
<td> Manager   </td>
<td> PRIN2 </td>
<td> 3000</td>
</tr>
</tbody>
</table>


<p>“如果出现重复的属性，就可能需要定义一个新的实体”。上表中Job Title和Salary都出现了重复的属性，按照给出的说法，是不是要把Salary提出来变成一个单独的表呢？1NF要满足的基本条件：</p>

<ol>
<li>没有重复行，就是每一行的记录都是不完全相同的；</li>
<li>每个行列（row-and-column intersection）必须包含唯一的值，空或未定义也可以；</li>
<li>所有列是基本的，不能有隐藏行ID，对象ID或时间戳等。</li>
</ol>


<p>因此，我们只要给员工信息表加上个员工编码（emp_id）就符合1NF了，更本不需要去定义什么新的实体。</p>

<p>事实上，在当前所有的关系数据库管理系统中，都已经在建表的时候强制满足第一范式。通常就是加上个自增量id列作为主键。</p>

<p>第二范式（2NF）：要满足2NF必须先满足1NF。<del>2NF要求数据表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。</del>2NF要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，2NF就是非主属性非部分依赖于主关键字。</p>

<p>划线部分实际上是1NF的内容，所以2NF肯定要符合这个。还有就是，所有单关键字的数据表都符合2NF，因为不存在组合关键字。</p>

<p>第三范式（3NF）：满足3NF必须先满足2NF。3NF要求一个数据表中不包含已在其它表中已包含的非主关键字信息。简而言之，第三范式就是属性不依赖于其它非主属性。</p>

<p>数据表只能包含其它表中包含的主关键字信息。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[创建视图时的with check option选项]]></title>
    <link href="http://codemany.com/blog/2010/06/28/with-check-option-in-view/"/>
    <updated>2010-06-28T20:33:27+08:00</updated>
    <id>http://codemany.com/blog/2010/06/28/with-check-option-in-view</id>
    <content type="html"><![CDATA[<p>通过有with check option选项的视图操作基表，有以下结论：</p>

<ol>
<li>首先视图只操作它可以查询出来的数据，对于它查询不出的数据，即使基表有，也不可以通过视图来操作；</li>
<li>对于update，有with check option，要保证update后，数据能被视图查询出来；</li>
<li>对于delete，有无with check option都一样；</li>
<li>对于insert，有with check option，要保证insert后，数据要被视图查询出来。</li>
</ol>


<p>对于没有where子句的视图，使用with check option是多余的。</p>

<p>下面用一个例子来说明第4条：</p>

<p>```
CREATE TABLE students (</p>

<pre><code>id int NOT NULL AUTO_INCREMENT,
name varchar(50) NOT NULL,
age int,
sex char(1),
PRIMARY KEY (id)
</code></pre>

<p>);</p>

<p>CREATE VIEW male_students_view AS</p>

<pre><code>SELECT name, age FROM students
WHERE sex = 'M'
WITH CHECK OPTION;
</code></pre>

<p>```</p>

<p><code>
-- 报CHECK OPTION failed错误，原因如4，插入数据后要还能被视图查询出来。
INSERT INTO male_students_view values('WU', 18);
</code></p>

<p><code>
-- 报Column count doesn't match value count错误，因为视图中根本没有sex列。
INSERT INTO male_students_view values('WU', 18, 'M');
</code></p>

<p>将students.sex列改成默认值为M：</p>

<p><code>
ALTER TABLE students MODIFY sex char(1) NOT NULL DEFAULT 'M'
</code></p>

<p><code>
-- 执行成功，1 row affected。
INSERT INTO male_students_view values('WU', 18);
</code></p>

<p><code>
-- 还是同样的问题，Column count doesn't match value count。
INSERT INTO male_students_view values('WU', 18, 'M');
</code></p>

<p>或者不修改students.sex的属性，将视图改成：</p>

<p>```
CREATE VIEW male_students_view AS</p>

<pre><code>SELECT name, age, sex FROM students
WHERE sex = 'M'
WITH CHECK OPTION;
</code></pre>

<p>```</p>

<p><code>
-- 会报CHECK OPTION failed错误。
INSERT INTO male_students_view values('WU', 18);
</code></p>

<p><code>
-- 执行成功，1 row affected。
INSERT INTO male_students_view values('WU', 18, 'M');
</code></p>

<p>以上例子都在MySQL上实际执行过，绝对不会像<a href="http://blog.csdn.net/kowity/article/details/1657899">这篇文章</a>中讲的某本教科书那样胡言乱语。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用SQL Server 2000个人版出现的问题]]></title>
    <link href="http://codemany.com/blog/2010/06/01/problem-using-sql-server-2000-personal-edition/"/>
    <updated>2010-06-01T12:52:33+08:00</updated>
    <id>http://codemany.com/blog/2010/06/01/problem-using-sql-server-2000-personal-edition</id>
    <content type="html"><![CDATA[<p>下午在机房值班，14:00的时候有人报告说交易客户端不能登录了，确定问题后两同事急忙重启AR和AS以及交易网关，可是还是不能登录。紧急重启数据库后问题才解决。</p>

<p>出了问题不可怕，关键是找到问题根源所在，解决问题，使同样的错误不再重复地发生。</p>

<p>打电话联系恒生的工程师，向他们提供系统的日志文件，希望他们那边能提供帮助，找到原因。我也在这边分析系统的事件和日志文件，想找出到底是在哪里出的问题。分析着从SQL Server的LOG目录下找到的几个ERRORLOG文件，发现从13:57开始有连续多条如下的警告语句出现：</p>

<p><code>
SQL Server已为8个并发查询而优化。36个查询超过了此限制，因而性能可能会受到不良影响。
</code></p>

<p>很快，恒生工程师也打电话来说可能是查询数据库过多导致的问题。这个我们一开始就想过，但关键是那时候只连接进来了400个左右的客户，怎么可能查询过多呢？而且平时也没出现过这种情况。</p>

<p>在网上搜索资料后知道出现这个问题通常是数据库版本的原因，检查我们的SQL Server数据库，发现竟然是2000个人版。后来又从交易结算部们了解到他们因为要做报表执行了查询所有客户资料的操作，并且我们的备份数据库在几个星期前曾因损坏做过恢复，恢复的同事忘记修改备份数据库的时间，导致本应该执行在备份数据库上的查询执行在了主数据库上，引起了数据库崩溃。</p>

<p>再次联系恒生的工程师，准备这个周末切换数据库到企业版。唉，又要加班了！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[允许客户端远程连接Lunarpages上的MySQL数据库]]></title>
    <link href="http://codemany.com/blog/2009/07/09/allow-remote-client-to-connect-to-mysql-on-lunarpages/"/>
    <updated>2009-07-09T14:54:05+08:00</updated>
    <id>http://codemany.com/blog/2009/07/09/allow-remote-client-to-connect-to-mysql-on-lunarpages</id>
    <content type="html"><![CDATA[<p>Lunarpages虚拟主机上的MySQL服务默认仅有本机能访问。只有在cPanel中向某IP地址或地址段或者所有地址开放访问权限后，才可以从外部用客户端连接数据库。</p>

<p>如果想允许任何主机的访问，直接在Host处填写百分号%，然后Add Host即可。如果只想特定主机访问，就输入客户端机器的IP地址。</p>

<p><img src="/uploads/lunarpages-mysql-remote.png" title="lunarpages-mysql-remote" ></p>

<p>客户端远程连接时使用的地址就是虚拟空间的地址，可以通过ping域名得到。</p>
]]></content>
  </entry>
  
</feed>
