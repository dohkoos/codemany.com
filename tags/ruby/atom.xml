<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Ruby | 乐者为王]]></title>
  <link href="http://codemany.com/tags/ruby/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2015-03-22T21:22:24+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[根据Exif时间信息归类照片]]></title>
    <link href="http://codemany.com/blog/move-photos-to-folders-based-on-exif-date/"/>
    <updated>2014-11-20T22:52:37+08:00</updated>
    <id>http://codemany.com/blog/move-photos-to-folders-based-on-exif-date</id>
    <content type="html"><![CDATA[<p>先要把Exif中的信息解析出来，得到其中的时间，有个<a href="https://github.com/remvee/exifr">exif</a>的gem很不错。然后再根据时间创建目录，把照片移动到对应的目录中。</p>

<pre><code>require 'rubygems'
require 'exifr'
require 'fileutils'

root = ARGV[0] || Dir.pwd

Dir.foreach(root) do |file|
  next if File.extname(file) != '.jpg'

  obj = EXIFR::JPEG.new(file)
  date_time_original = obj.exif.date_time_original if obj.exif?
  next if date_time_original.nil?

  dir = date_time_original.year.to_s
  Dir.mkdir(dir) unless Dir.exist?(dir)
  FileUtils.move(file, dir)
end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby中读二进制文件时大小错误]]></title>
    <link href="http://codemany.com/blog/read-binary-file-give-wrong-size-in-ruby/"/>
    <updated>2014-10-09T23:37:59+08:00</updated>
    <id>http://codemany.com/blog/read-binary-file-give-wrong-size-in-ruby</id>
    <content type="html"><![CDATA[<p>经常会遇到这类场景，要把文件内容一次性全部读取出来。使用IO.read(&lsquo;example.bin&rsquo;)读取二进制文件时，发现读出来的大小与实际结果不符合。原来默认不加参数时仅限于读文本文件，需要指定mode为b。</p>

<pre><code>IO.read('example.bin', { mode: 'rb' })
</code></pre>

<p>还有种简洁的读取方式是：</p>

<pre><code>File.open('example.bin', 'rb').readlines.join
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nokogiri抓取页面URL含有中文参数的问题]]></title>
    <link href="http://codemany.com/blog/problem-with-nokogiri-when-url-containing-chinese-character/"/>
    <updated>2014-07-17T22:48:00+08:00</updated>
    <id>http://codemany.com/blog/problem-with-nokogiri-when-url-containing-chinese-character</id>
    <content type="html"><![CDATA[<p>使用Nokogiri抓取某网站的长江现货数据，被抓取页面的URL中含有中文参数，使用以下的代码抓取数据失败：</p>

<pre><code>url = 'http://example.com/search.asp?type=长江有色&amp;sort=asc'
doc = Nokogiri::HTML(open(url))
</code></pre>

<p>据 <a href="http://dingr.iteye.com/blog/647244">http://dingr.iteye.com/blog/647244</a> 讲是因为浏览器给服务器发送参数的时候是经过编码的，按照该文的意思试着也给URL里的中文编了下码：</p>

<pre><code>url = 'http://example.com/search.asp?type=长江有色&amp;sort=asc'
url = URI.escape(url)
doc = Nokogiri::HTML(open(url))
</code></pre>

<p>结果还是抓取失败。查看URL的编码信息：</p>

<pre><code>puts url.encoding  # 输出utf-8
</code></pre>

<p>网站页面采用的是GB2132编码，猜测网站后台处理数据时很有可能也是采用的GB2132。做个实验就清楚了，将URL转成GB2132后再编码：</p>

<pre><code>url = 'http://example.com/search.asp?type=长江有色&amp;sort=asc'
url = url.encode('gbk', 'utf-8')
url = URI.escape(url)
doc = Nokogiri::HTML(open(url))
</code></pre>

<p>发现果然OK了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我是如何让Ruby脚本速度提升156倍的]]></title>
    <link href="http://codemany.com/blog/how-i-made-ruby-script-156x-faster/"/>
    <updated>2014-06-28T13:04:08+08:00</updated>
    <id>http://codemany.com/blog/how-i-made-ruby-script-156x-faster</id>
    <content type="html"><![CDATA[<p>以前写过<a href="http://codemany.com/blog/using-ruby-to-batch-rename-filename-from-traditional-to-simplified/">使用Ruby批量修改繁体文件名为简体</a>，可惜脚本的性能很有问题，批量重命名时运行速度非常慢。这次准备优化下代码，提升脚本的执行效率。</p>

<p>profile.rb是为Ruby程序准备的profiler，它可以统计并输出各方法的运行时间，以便于找到程序执行的性能瓶颈。这次就用它来剖析脚本的运行时间。使用方法很简单，加上命令行选项-r profile就可以：</p>

<pre><code>ruby -r profile rename.rb
</code></pre>

<p>运行结束后，会把统计信息输出到标准错误输出中。如下图所示：</p>

<p>{% img /uploads/profile-before-tuning.png profile-before-tuning %}</p>

<p>profile统计的是各方法的运行时间，分为两类。一类是计算的是从方法调用到方法返回之间的时间，称为整体时间；另一类则是从整体时间中扣除在该方法中调用其它方法所耗费时间之后得到的时间，称为实际时间。</p>

<p>上图输出信息每行中各字段含义如下（从左到右）：</p>

<ul>
<li>该方法执行时间占整体时间的百分比，比例越高越说明这行代码可能需要优化</li>
<li>整体时间的总和</li>
<li>实际时间的总和</li>
<li>被调用的次数</li>
<li>每次调用的平均实际时间（毫秒）</li>
<li>每次调用的平均整体时间（毫秒）</li>
<li>方法名</li>
</ul>


<p>由上图可以看出，脚本执行的时间大部分耗在了循环上。解决方法有两个：消除循环或减少循环次数。前者很难实现，暂且还没有想到办法，也许根本就没有可能。脚本中mapping的大小为2685，所以每修改一个文件名需要执行2685次循环，且循环中的encode和gsub!都是耗时操作。通常文件名的长度不超过30个字符，通过遍历文件名中每个字符的方式重命名就可以把循环次数缩减到不超过30次。</p>

<p>修改代码后重新执行分析命令，得到的结果是脚本运行时间从379395秒变成2418秒，性能整整提升了156倍，达到2个数量级的效果。</p>

<p>{% img /uploads/profile-after-tuning.png profile-after-tuning %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Ruby批量修改繁体文件名为简体]]></title>
    <link href="http://codemany.com/blog/using-ruby-to-batch-rename-filename-from-traditional-to-simplified/"/>
    <updated>2012-08-08T14:44:13+08:00</updated>
    <id>http://codemany.com/blog/using-ruby-to-batch-rename-filename-from-traditional-to-simplified</id>
    <content type="html"><![CDATA[<p>首先是遍历目录所有文件，使用了 <a href="http://beike.iteye.com/blog/361108">http://beike.iteye.com/blog/361108</a> 的代码，稍微做了下修改。主要是在Windows下处理系统目录时会停止遍历，加上了异常处理。</p>

<pre><code>def traverse(path)
  begin
    if File.directory?(path)
      Dir.foreach(path) do |file|
        if file != "." and file != ".." 
          traverse(path + "/" + file) {|x| yield x}
        end
      end
    else
      yield path
    end
  rescue
    puts "Error: #{$!}"
  end
end
</code></pre>

<p>如果不输入文件夹路径，就使用当前目录作为根目录：</p>

<pre><code>root = ARGV[0] || Dir.pwd
</code></pre>

<p>将繁体中文改成简体的代码：</p>

<pre><code>mapping = {}
mapping["無"] = "无"
mapping["龍"] = "龙"

mapping.each do |key, value|
  file.gsub!(key.encode('gbk', 'utf-8'), value.encode('gbk', 'utf-8'))
end
</code></pre>

<p>文件重命名：
<code>
File.rename(old_file_name, new_file_name)
</code></p>

<p>代码下载：<a href="https://github.com/dohkoos/big2gb">https://github.com/dohkoos/big2gb</a></p>
]]></content>
  </entry>
  
</feed>
