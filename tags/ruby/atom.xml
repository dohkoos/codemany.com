<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Ruby | 乐者为王]]></title>
  <link href="http://codemany.com/tags/ruby/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2014-08-05T22:58:49+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Nokogiri抓取页面URL含有中文参数的问题]]></title>
    <link href="http://codemany.com/blog/2014/07/17/problem-with-nokogiri-when-url-containing-chinese-character/"/>
    <updated>2014-07-17T22:48:00+08:00</updated>
    <id>http://codemany.com/blog/2014/07/17/problem-with-nokogiri-when-url-containing-chinese-character</id>
    <content type="html"><![CDATA[<p>使用Nokogiri抓取某网站的长江现货数据，被抓取页面的URL中含有中文参数，使用以下的代码抓取数据失败：
<code>
url = 'http://example.com/search.asp?type=长江有色&amp;sort=asc'
doc = Nokogiri::HTML(open(url))
</code></p>

<p>据 <a href="http://dingr.iteye.com/blog/647244">http://dingr.iteye.com/blog/647244</a> 讲是因为浏览器给服务器发送参数的时候是经过编码的，按照该文的意思试着也给URL里的中文编了下码：
<code>
url = 'http://example.com/search.asp?type=长江有色&amp;sort=asc'
url = URI.escape(url)
doc = Nokogiri::HTML(open(url))
</code></p>

<p>结果还是抓取失败。查看URL的编码信息：
<code>
puts url.encoding # 输出utf-8
</code></p>

<p>网站页面采用的是GB2132编码，猜测网站后台处理数据时很有可能也是采用的GB2132。做个实验就清楚了，将URL转成GB2132后再编码：
<code>
url = 'http://example.com/search.asp?type=长江有色&amp;sort=asc'
url = url.encode('gbk', 'utf-8')
url = URI.escape(url)
doc = Nokogiri::HTML(open(url))
</code></p>

<p>发现果然OK了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Pry调试Rails项目]]></title>
    <link href="http://codemany.com/blog/2014/07/07/debugging-rails-with-pry/"/>
    <updated>2014-07-07T23:26:08+08:00</updated>
    <id>http://codemany.com/blog/2014/07/07/debugging-rails-with-pry</id>
    <content type="html"><![CDATA[<p>调试Rails程序的工具有ruby-debug、irb、rails-console等，不过现在这些工具都可以歇着了，因为有了Pry。</p>

<p>首先，在Gemfile中申明gem包：</p>

<p><code>
gem 'pry', group: :development
</code></p>

<p>然后执行</p>

<p><code>
bundle install
</code></p>

<p>用Pry代替irb，直接运行：</p>

<p><code>
pry
</code></p>

<p>用Pry代替rails console，运行：</p>

<p><code>
pry -r ./config/environment.rb
</code></p>

<p>调试Rails项目时，在需要调试的地方添加binding.pry，当rails server运行到这行代码时会自动调出一个pry终端，可以在这里进行交互，退出调试用exit-all。例如：</p>

<p>```</p>

<h1>/app/controllers/articles_controller.rb</h1>

<p>def index
  @articles = Article.all
  binding.pry
end
```</p>

<p>如何退出循环</p>

<p><code>
(1..100).each do |i|
  binding.pry
  puts i
end
</code></p>

<p>可以使用exit-program命令无条件地退出循环。</p>

<p>Pry默认没有调试中经常用到的上一步，下一步等命令，可以安装pry-nav，然后就可以使用step, next, continue跳来跳去了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我是如何让Ruby脚本速度提升156倍的]]></title>
    <link href="http://codemany.com/blog/2014/06/28/how-i-made-ruby-script-156x-faster/"/>
    <updated>2014-06-28T13:04:08+08:00</updated>
    <id>http://codemany.com/blog/2014/06/28/how-i-made-ruby-script-156x-faster</id>
    <content type="html"><![CDATA[<p>以前写过<a href="http://codemany.com/blog/2012/08/08/write-a-ruby-script-to-bulk-modify-traditional-file-called-simplified/">批量修改繁体文件名为简体的Ruby脚本</a>，可惜脚本的性能很有问题，批量重命名时运行速度非常慢。这次准备优化下代码，提升脚本的执行效率。</p>

<p>profile.rb是为Ruby程序准备的profiler，它可以统计并输出各方法的运行时间，以便于找到程序执行的性能瓶颈。这次就用它来剖析脚本的运行时间。使用方法很简单，加上命令行选项-r profile就可以：
<code>
ruby -r profile rename.rb
</code></p>

<p>运行结束后，会把统计信息输出到标准错误输出中。如下图所示：
<img src="/uploads/profile-before-tuning.png" title="profile-before-tuning" ></p>

<p>profile统计的是各方法的运行时间，分为两类。一类是计算的是从方法调用到方法返回之间的时间，称为整体时间；另一类则是从整体时间中扣除在该方法中调用其它方法所耗费时间之后得到的时间，称为实际时间。</p>

<p>上图输出信息每行中各字段含义如下（从左到右）：<br />
该方法执行时间占整体时间的百分比，比例越高越说明这行代码可能需要优化<br />
整体时间的总和<br />
实际时间的总和<br />
被调用的次数<br />
每次调用的平均实际时间（毫秒）<br />
每次调用的平均整体时间（毫秒）<br />
方法名</p>

<p>由上图可以看出，脚本执行的时间大部分耗在了循环上。解决方法有两个：消除循环或减少循环次数。前者很难实现，暂且还没有想到办法，也许根本就没有可能。脚本中mapping的大小为2685，所以每修改一个文件名需要执行2685次循环，且循环中的encode和gsub!都是耗时操作。通常文件名的长度不超过30个字符，通过遍历文件名中每个字符的方式重命名就可以把循环次数缩减到不超过30次。</p>

<p>修改代码后重新执行分析命令，得到的结果是脚本运行时间从379395秒优化到2418秒，性能整整提升了156倍，达到2个数量级的效果。
<img src="/uploads/profile-after-tuning.png" title="profile-after-tuning" ></p>

<p>参考资料：<br />
<a href="http://www.kuqin.com/rubycndocument/man/addlib/profile.html">http://www.kuqin.com/rubycndocument/man/addlib/profile.html</a><br />
<a href="http://ruby.about.com/od/advancedruby/a/profile.htm">http://ruby.about.com/od/advancedruby/a/profile.htm</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[写了个批量修改繁体文件名为简体的Ruby脚本]]></title>
    <link href="http://codemany.com/blog/2012/08/08/write-a-ruby-script-to-bulk-modify-traditional-file-called-simplified/"/>
    <updated>2012-08-08T14:44:13+08:00</updated>
    <id>http://codemany.com/blog/2012/08/08/write-a-ruby-script-to-bulk-modify-traditional-file-called-simplified</id>
    <content type="html"><![CDATA[<p>首先是遍历目录所有文件，使用了<a href="http://beike.iteye.com/blog/361108"><a href="http://beike.iteye.com/blog/361108">http://beike.iteye.com/blog/361108</a></a>的代码，稍微做了下修改。主要是在Windows下处理系统目录时会停止遍历，加上了异常处理。<br />
```
def traverse(path)<br />
  begin<br /></p>

<pre><code>if File.directory?(path)&lt;br /&gt;
  Dir.foreach(path) do |file|&lt;br /&gt;
    if file != "." and file != ".." &lt;br /&gt;
      traverse(path + "/" + file) {|x| yield x}&lt;br /&gt;
    end&lt;br /&gt;
  end&lt;br /&gt;
else&lt;br /&gt;
  yield path&lt;br /&gt;
end&lt;br /&gt;
</code></pre>

<p>  rescue<br /></p>

<pre><code>puts "Error: #{$!}"&lt;br /&gt;
</code></pre>

<p>  end<br />
end<br />
```</p>

<p>如果不输入文件夹路径，就使用当前目录作为根目录：<br />
<code>
root = ARGV[0] || Dir.pwd&lt;br /&gt;
</code></p>

<p>将繁体中文改成简体的代码：<br />
```
mapping = {}<br />
mapping["無"] = "无"<br />
mapping["龍"] = "龙"</p>

<p>mapping.each do |key, value|<br />
  file.gsub!(key.encode('gbk', 'utf-8'), value.encode('gbk', 'utf-8'))<br />
end<br />
```</p>

<p>文件重命名：<br />
<code>
File.rename(old_file_name, new_file_name)&lt;br /&gt;
</code></p>

<p>代码下载：<a href="https://github.com/dohkoos/big2gb">https://github.com/dohkoos/big2gb</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Plugin not found]]></title>
    <link href="http://codemany.com/blog/2010/09/17/plugin-not-found/"/>
    <updated>2010-09-17T03:24:50+08:00</updated>
    <id>http://codemany.com/blog/2010/09/17/plugin-not-found</id>
    <content type="html"><![CDATA[<p>使用Ruby 1.8.7和Rails 2.3.5，每次执行script/plugin install ...都出现<br />
<code>
Plugin not found: [...]&lt;br /&gt;
</code></p>

<p>无论是使用http协议，还是在末尾添加斜杠都不起作用。</p>

<p>出现这个问题的原因是因为Ruby 1.8.7是用mingw32编译的，可以通过ruby -v查看：<br />
<code>
$ ruby -v&lt;br /&gt;
ruby 1.8.7 (2010-08-16 patchlevel 302) [i386-mingw32]&lt;br /&gt;
</code></p>

<p>RUBY_PLATFORM常量的值是i386-mingw32-xxx，而许多库在判断当前操作系统时是这么判断的（伪代码）：<br />
<code>
file.open(RUBY_PLATFORM.match(/mswin/) ? 'NUL', '/dev/null') &lt;br /&gt;
</code></p>

<p>这些库只判断了RUBY_PLATFORM里是否含有mswin，如果没有就认为是*nix平台，从而使用/dev/null，结果可想而知，文件必然打开失败，于是就会出现上述错误。</p>

<p>解决方式(推荐使用第4种方式):<br />
方法1：打开script/plugin文件加入一行RUBY_PLATFORM = 'mswin'，运行时会打印一条警告说常量重新赋值，不过不影响使用。<br />
方法2：卸载掉1.8.7，重新安装Ruby 1.8.6-p26，这个版本是使用VC6编译的，RUBY_PLATFORM的值是mswin，不会出现平台判断错误。<br />
方法3：使用VC自己编译Ruby 1.8.7，确保RUBY_PLATFORM的值是mswin即可。<br />
方法4：打开RUBY_GEMS/activesupport-2.3.5/lib/active_support/core_ext/kernel/reporting.rb，找到<br />
<code>
stream.reopen(RUBY_PLATFORM =~ /mswin/ ? 'NUL:' : '/dev/null')&lt;br /&gt;
</code></p>

<p>将之修改以下代码即可<br />
<code>
stream.reopen(RUBY_PLATFORM =~ /mswin|mingw/ ? 'NUL:' : '/dev/null')&lt;br /&gt;
</code></p>
]]></content>
  </entry>
  
</feed>
