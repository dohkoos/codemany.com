<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Ruby | 乐者为王]]></title>
  <link href="http://codemany.com/tags/ruby/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2015-10-27T21:56:13+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby调试工具概览]]></title>
    <link href="http://codemany.com/blog/ruby-debugger-overview/"/>
    <updated>2015-10-19T10:50:09+08:00</updated>
    <id>http://codemany.com/blog/ruby-debugger-overview</id>
    <content type="html"><![CDATA[<p>调试Ruby代码最简单的方式就是使用puts或p方法。当有很多变量需要查看时，到处添加puts或p方法就可能变的不那么实际。幸好，Ruby社区提供了许多强大的调试工具。</p>

<h3 id="ruby-1-8-时代">Ruby 1.8+时代</h3>

<p>调试Ruby代码使用<a href="https://github.com/ruby-debug/ruby-debug">ruby-debug</a>。调试Rails代码则是<a href="https://github.com/nixme/pry-nav">pry-nav</a>。不过在Ruby 1.9出来后ruby-debug就有问题了，于是就有了<a href="https://github.com/mark-moseley/ruby-debug">ruby-debug19</a>，一个针对Ruby 1.9的ruby-debug移植版本。</p>

<h3 id="ruby-1-9-2-时代">Ruby 1.9.2+时代</h3>

<p>等到Ruby 1.9.2发布，ruby-debug彻底歇菜，然后<a href="https://github.com/cldwalker/debugger">debugger</a>就出现了。pry-nav也不好使了，还好有<a href="https://github.com/nixme/pry-debugger">pry-debugger</a>。</p>

<h3 id="ruby-2-时代">Ruby 2+时代</h3>

<p>新的Ruby调试工具<a href="https://github.com/deivid-rodriguez/byebug">byebug</a>来了。虽然byebug也能调试Rails应用，但它不提供语法高亮，所以使用<a href="https://github.com/deivid-rodriguez/pry-byebug">pry-byebug</a>是个更好的选择。</p>

<table><thead>
<tr>
<th></th>
<th>Ruby 1.8+</th>
<th>Ruby 1.9</th>
<th>Ruby 1.9.2+</th>
<th>Ruby 2+</th>
</tr>
</thead><tbody>
<tr>
<td>Ruby</td>
<td>ruby-debug</td>
<td>ruby-debug19</td>
<td>debugger</td>
<td>byebug</td>
</tr>
<tr>
<td>Rails</td>
<td>pry-nav</td>
<td>pry-nav</td>
<td>pry-debugger</td>
<td>pry-byebug</td>
</tr>
</tbody></table>

<h3 id="其它">其它</h3>

<p><a href="https://github.com/pry/pry">Pry</a>其实不是纯粹的调试工具，它只是IRB的替代品，所以缺乏必要的调试指令。pry-nav、pry-debugger和pry-byebug做的只是分别把ruby-debug、debugger和byebug中的step、next、continue等指令添加到Pry中。</p>

<ul>
<li>pry-nav = Pry + ruby-debug</li>
<li>pry-debugger = Pry + debugger</li>
<li>pry-byebug = Pry + byebug</li>
</ul>

<p>如果要调试view怎么办？可以使用<a href="https://github.com/rails/web-console">Web Console</a>。在view里面加上&lt;%= console %&gt;，当view出现异常时，就会在异常界面下方，出现一个网页版的IRB，方便调试。Web Console默认只接受localhost的请求，假如需要让别的IP也能访问的话，可以这样做：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class Application &lt; Rails::Application
  config.web_console.whitelisted_ips = &#39;192.168.0.100&#39;
end
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[根据Exif时间信息归类照片]]></title>
    <link href="http://codemany.com/blog/move-photos-to-folders-based-on-exif-date/"/>
    <updated>2014-11-20T22:52:37+08:00</updated>
    <id>http://codemany.com/blog/move-photos-to-folders-based-on-exif-date</id>
    <content type="html"><![CDATA[<p>先要把Exif中的信息解析出来，得到其中的时间，有个<a href="https://github.com/remvee/exifr">exif</a>的gem很不错。然后再根据时间创建目录，把照片移动到对应的目录中。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">require &#39;rubygems&#39;
require &#39;exifr&#39;
require &#39;fileutils&#39;

root = ARGV[0] || Dir.pwd

Dir.foreach(root) do |file|
  next if File.extname(file) != &#39;.jpg&#39;

  obj = EXIFR::JPEG.new(file)
  date_time_original = obj.exif.date_time_original if obj.exif?
  next if date_time_original.nil?

  dir = date_time_original.year.to_s
  Dir.mkdir(dir) unless Dir.exist?(dir)
  FileUtils.move(file, dir)
end
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby中读二进制文件时大小错误]]></title>
    <link href="http://codemany.com/blog/read-binary-file-give-wrong-size-in-ruby/"/>
    <updated>2014-10-09T23:37:59+08:00</updated>
    <id>http://codemany.com/blog/read-binary-file-give-wrong-size-in-ruby</id>
    <content type="html"><![CDATA[<p>经常会遇到这类场景，要把文件内容一次性全部读取出来。使用IO.read(&#39;example.bin&#39;)读取二进制文件时，发现读出来的大小与实际结果不符合。原来默认不加参数时仅限于读文本文件，需要指定mode为b。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">IO.read(&#39;example.bin&#39;, { mode: &#39;rb&#39; })
</code></pre></div>
<p>还有种简洁的读取方式是：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">File.open(&#39;example.bin&#39;, &#39;rb&#39;).readlines.join
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nokogiri抓取页面URL含有中文参数的问题]]></title>
    <link href="http://codemany.com/blog/problem-with-nokogiri-when-url-containing-chinese-character/"/>
    <updated>2014-07-17T22:48:00+08:00</updated>
    <id>http://codemany.com/blog/problem-with-nokogiri-when-url-containing-chinese-character</id>
    <content type="html"><![CDATA[<p>使用Nokogiri抓取某网站的长江现货数据，被抓取页面的URL中含有中文参数，使用以下的代码抓取数据失败：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">url = &#39;http://example.com/search.asp?type=长江有色&amp;sort=asc&#39;
doc = Nokogiri::HTML(open(url))
</code></pre></div>
<p>据 <a href="http://dingr.iteye.com/blog/647244">http://dingr.iteye.com/blog/647244</a> 讲是因为浏览器给服务器发送参数的时候是经过编码的，按照该文的意思试着也给URL里的中文编了下码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">url = &#39;http://example.com/search.asp?type=长江有色&amp;sort=asc&#39;
url = URI.escape(url)
doc = Nokogiri::HTML(open(url))
</code></pre></div>
<p>结果还是抓取失败。查看URL的编码信息：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">puts url.encoding  # 输出utf-8
</code></pre></div>
<p>网站页面采用的是GB2132编码，猜测网站后台处理数据时很有可能也是采用的GB2132。做个实验就清楚了，将URL转成GB2132后再编码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">url = &#39;http://example.com/search.asp?type=长江有色&amp;sort=asc&#39;
url = url.encode(&#39;gbk&#39;, &#39;utf-8&#39;)
url = URI.escape(url)
doc = Nokogiri::HTML(open(url))
</code></pre></div>
<p>发现果然OK了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我是如何让Ruby脚本速度提升156倍的]]></title>
    <link href="http://codemany.com/blog/how-i-made-ruby-script-156x-faster/"/>
    <updated>2014-06-28T13:04:08+08:00</updated>
    <id>http://codemany.com/blog/how-i-made-ruby-script-156x-faster</id>
    <content type="html"><![CDATA[<p>以前写过<a href="http://codemany.com/blog/using-ruby-to-batch-rename-filename-from-traditional-to-simplified/">使用Ruby批量修改繁体文件名为简体</a>，可惜脚本的性能很有问题，批量重命名时运行速度非常慢。这次准备优化下代码，提升脚本的执行效率。</p>

<p>profile.rb是为Ruby程序准备的profiler，它可以统计并输出各方法的运行时间，以便于找到程序执行的性能瓶颈。这次就用它来剖析脚本的运行时间。使用方法很简单，加上命令行选项-r profile就可以：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">ruby -r profile rename.rb
</code></pre></div>
<p>运行结束后，会把统计信息输出到标准错误输出中。如下图所示：</p>

<p><img src="/uploads/profile-before-tuning.png" title="profile-before-tuning" ></p>

<p>profile统计的是各方法的运行时间，分为两类。一类是计算的是从方法调用到方法返回之间的时间，称为整体时间；另一类则是从整体时间中扣除在该方法中调用其它方法所耗费时间之后得到的时间，称为实际时间。</p>

<p>上图输出信息每行中各字段含义如下（从左到右）：</p>

<ul>
<li>该方法执行时间占整体时间的百分比，比例越高越说明这行代码可能需要优化</li>
<li>整体时间的总和</li>
<li>实际时间的总和</li>
<li>被调用的次数</li>
<li>每次调用的平均实际时间（毫秒）</li>
<li>每次调用的平均整体时间（毫秒）</li>
<li>方法名</li>
</ul>

<p>由上图可以看出，脚本执行的时间大部分耗在了循环上。解决方法有两个：消除循环或减少循环次数。前者很难实现，暂且还没有想到办法，也许根本就没有可能。脚本中mapping的大小为2685，所以每修改一个文件名需要执行2685次循环，且循环中的encode和gsub!都是耗时操作。通常文件名的长度不超过30个字符，通过遍历文件名中每个字符的方式重命名就可以把循环次数缩减到不超过30次。</p>

<p>修改代码后重新执行分析命令，得到的结果是脚本运行时间从379395秒变成2418秒，性能整整提升了156倍，达到2个数量级的效果。</p>

<p><img src="/uploads/profile-after-tuning.png" title="profile-after-tuning" ></p>
]]></content>
  </entry>
  
</feed>
