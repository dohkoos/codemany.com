<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: PowerScript | 乐者为王]]></title>
  <link href="http://codemany.com/tags/powerscript/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2016-05-01T15:17:52+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用ANTLR构建PowerScript语法分析器（6）]]></title>
    <link href="http://codemany.com/blog/using-antlr-to-build-powerscript-grammar-parser-part6/"/>
    <updated>2008-05-03T19:07:10+08:00</updated>
    <id>http://codemany.com/blog/using-antlr-to-build-powerscript-grammar-parser-part6</id>
    <content type="html"><![CDATA[<p>构建完表达式的语法规则后就可以开始分析语句（statement）的语法规则。不过在这之前还需要先修复两个小缺陷：没有识别日期、时间和内建常量的词法规则。</p>

<p>在PowerScript中，日期的格式是0000-00-00，年份是4位数从1000到3000，月份从01到12，天数从01到31；时间是24小时格式00:00:00:000000，秒的小数部分可有可无，最多能有6位数字，所以时间范围是从00:00:00到23:59:59:999999。内建常量则以字母开头，字母数字组合，以“!”符号结束的字符串。</p>

<p>根据这些描述我们可以得到日期、时间和内建常量的词法规则：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">DATE_LITERAL    // 1996-09-26
    : &#39;1&#39;..&#39;3&#39; &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39; &#39;-&#39; &#39;0&#39;..&#39;1&#39; &#39;0&#39;..&#39;9&#39; &#39;-&#39; &#39;0&#39;..&#39;3&#39; &#39;0&#39;..&#39;9&#39;
      {
          System.out.println(&quot;date&gt;&quot; + getText());
      }
    ;

TIME_LITERAL    // 00:00:00:000000
    : &#39;0&#39;..&#39;2&#39; &#39;0&#39;..&#39;9&#39; &#39;:&#39; &#39;0&#39;..&#39;5&#39; &#39;0&#39;..&#39;9&#39; &#39;:&#39; &#39;0&#39;..&#39;5&#39; &#39;0&#39;..&#39;9&#39;
      ( &#39;.&#39; &#39;0&#39;..&#39;9&#39;
      | &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39;
      | &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39;
      | &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39;
      | &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39;
      | &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39;
      )?
      {
          System.out.println(&quot;time&gt;&quot; + getText());
      }
    ;

ENUM_LITERAL
    : Letter (Letter|&#39;0&#39;..&#39;9&#39;)* &#39;!&#39;
      {
          System.out.println(&quot;enum&gt;&quot; + getText());
      }
    ;
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用ANTLR构建PowerScript语法分析器（5）]]></title>
    <link href="http://codemany.com/blog/using-antlr-to-build-powerscript-grammar-parser-part5/"/>
    <updated>2008-05-02T19:27:12+08:00</updated>
    <id>http://codemany.com/blog/using-antlr-to-build-powerscript-grammar-parser-part5</id>
    <content type="html"><![CDATA[<p>基本表达式的语法规则构建完毕，那么表达式的语法规则构建就颇为简单了。<a href="http://localhost:4000/blog/using-antlr-to-build-powerscript-grammar-parser-part4/">使用ANTLR构建PowerScript语法分析器（4）</a>中已经说过表达式是由运算元和运算符复合组成。所以在编写表达式语法规则前先要分析下PowerScript的运算符以及它们的优先级。</p>

<p>PowerScript支持四种类型的运算符，分别是：</p>

<ul>
<li>针对数字数据类型的算术运算符，执行算术计算；</li>
<li>针对所有类型的关系运算符，比较数字，文本和布尔值；</li>
<li>针对布尔类型的逻辑运算符，执行布尔值上的关系运算符</li>
<li>针对字符串类型连接运算符，连接字符串和二进制大对象。</li>
</ul>

<h3 id="算术运算符">算术运算符</h3>

<table><thead>
<tr>
<th>Operator</th>
<th>Meaning</th>
</tr>
</thead><tbody>
<tr>
<td>+</td>
<td>Addition</td>
</tr>
<tr>
<td>-</td>
<td>Subtraction</td>
</tr>
<tr>
<td>*</td>
<td>Multiplication</td>
</tr>
<tr>
<td>/</td>
<td>Division</td>
</tr>
<tr>
<td>^</td>
<td>Exponentiation</td>
</tr>
</tbody></table>

<h3 id="关系运算符">关系运算符</h3>

<table><thead>
<tr>
<th>Operator</th>
<th>Meaning</th>
</tr>
</thead><tbody>
<tr>
<td>=</td>
<td>Equals</td>
</tr>
<tr>
<td>&gt;</td>
<td>Greater than</td>
</tr>
<tr>
<td>&lt;</td>
<td>Less than</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>Not equal</td>
</tr>
<tr>
<td>&gt;=</td>
<td>Greater than or equal</td>
</tr>
<tr>
<td>&lt;=</td>
<td>Less than or equal</td>
</tr>
</tbody></table>

<h3 id="逻辑运算符">逻辑运算符</h3>

<table><thead>
<tr>
<th>Operator</th>
<th>Meaning</th>
</tr>
</thead><tbody>
<tr>
<td>NOT</td>
<td>Logical negation</td>
</tr>
<tr>
<td>AND</td>
<td>Logical and</td>
</tr>
<tr>
<td>OR</td>
<td>Logical or</td>
</tr>
</tbody></table>

<h3 id="连接运算符">连接运算符</h3>

<table><thead>
<tr>
<th>Operator</th>
<th>Meaning</th>
</tr>
</thead><tbody>
<tr>
<td>+</td>
<td>Concatenate</td>
</tr>
</tbody></table>

<h3 id="运算符优先级">运算符优先级</h3>

<table><thead>
<tr>
<th>Operator</th>
<th>Purpose</th>
</tr>
</thead><tbody>
<tr>
<td>( )</td>
<td>Grouping (see note below on overriding)</td>
</tr>
<tr>
<td>+, -</td>
<td>Unary plus and unary minus (indicates positive or negative number)</td>
</tr>
<tr>
<td>^</td>
<td>Exponentiation</td>
</tr>
<tr>
<td>*, /</td>
<td>Multiplication and division</td>
</tr>
<tr>
<td>+, -</td>
<td>Addition and subtraction; string concatenation</td>
</tr>
<tr>
<td>=, &gt;, &lt;, &lt;=, &gt;=, &lt;&gt;</td>
<td>Relational operators</td>
</tr>
<tr>
<td>NOT</td>
<td>Negation</td>
</tr>
<tr>
<td>AND</td>
<td>Logical and</td>
</tr>
<tr>
<td>OR</td>
<td>Logical or</td>
</tr>
</tbody></table>

<p>清楚运算符和优先级后，该如何表示这些表达式的语法关系呢？有个标准的分析表达式的递归定义可以套用，大部分表达式都遵循这个模式：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">thisLevelExpression
    : nextHigherPrecedenceExpression (OPERATOR nextHigherPrecedenceExpression)*
</code></pre></div>
<p>现在我们就可以根据PowerScript的运算符优先级写出表达式的语法规则了：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">expression
    : logical_or_expression
    ;

logical_or_expression
    : logical_and_expression (&#39;or&#39; logical_and_expression)*
    ;

logical_and_expression
    : logical_not_expression (&#39;and&#39; logical_not_expression)*
    ;

logical_not_expression
    : &#39;not&#39;? relational_expression
    ;

relational_expression
    : additive_expression ((&#39;=&#39;|&#39;&gt;&#39;|&#39;&lt;&#39;|&#39;&lt;&gt;&#39;|&#39;&gt;=&#39;|&#39;&lt;=&#39;) additive_expression)*
    ;

additive_expression
    : multiplicative_expression ((&#39;+&#39;|&#39;-&#39;) multiplicative_expression)*
    ;

multiplicative_expression
    : exponentive_expression ((&#39;*&#39;|&#39;/&#39;) exponentive_expression)*
    ;

exponentive_expression
    : unary_expression (&#39;^&#39; unary_expression)*
    ;

unary_expression
    : (&#39;+&#39;|&#39;-&#39;)? primary_expression
    ;
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用ANTLR构建PowerScript语法分析器（4）]]></title>
    <link href="http://codemany.com/blog/using-antlr-to-build-powerscript-grammar-parser-part4/"/>
    <updated>2008-04-26T22:17:05+08:00</updated>
    <id>http://codemany.com/blog/using-antlr-to-build-powerscript-grammar-parser-part4</id>
    <content type="html"><![CDATA[<p>到目前为止，PowerScript的词法分析已经完成的差不多了，接下来就要开始实现它的语法规则。我们准备先从表达式（expression）开始下手，因为它是语法规则中最核心的部分。</p>

<p>简单的来说，表达式是计算的最小单元，是可以被计算产生值的代码的任何部分。一般是由一个或多个运算元和通常是一个运算符构成，运算元本身也可以是表达式。这样层层递归嵌套，直到被称为基本表达式（primary expression）的最简单部分。</p>

<p>基本表达式包含有标志符、字面量（literal）、字段存取、函数调用和数组存取等，圆括号括起的表达式通常也被认为是基本表达式。以下是它们的大致表现形式：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">rating
&#39;This is a string&#39;
x.y
f(x)
a[x]
(x)
</code></pre></div>
<p>在PowerScript中调用函数和事件的语法如下：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">{ objectname. } { ancestorname :: } { type } { calltype } { when } name ( { argumentlist } )
</code></pre></div>
<p>其中，花括号中的项表示可以有可以无。type有两个值function和event，calltype有两个值static和dynamic，when有两个值trigger和post，并且type，calltype和when的顺序可以任意调换。如果ancestorclass是当前对象的直接父类的话，那么可以使用super关键字代替。</p>

<p>这里是收集的一些基本表达式：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">this.ls_array[1]
this.event pfc_addrow()
this.event rowfocuschanged(ll_row)
this.event post doubleclicked(xpos, ypos, row, dwo)
this.uo_1.function hallo()
post function column_order_update_from_grid()
event ue_process()

close(parent)
parent.enabled
parent.hide()
parent.event ue_postconstructor()
parent.function static trigger wf_process( )
parent.post uf_process_item ()

super::create
super::event clicked()
super::event clicked(xpos, ypos, row, dwo)
super::of_remove_tail(anv_tailnode)
super::event trigger selectionchanging(oldindex, newindex)

iu_tab_postings.post of_enable_sort(dw_main, dw_detail, false)
lw_sheet.dynamic event pfc_close()
w_main.event doubleclicked(flags, xpos, ypos)
dw_main.event pfc_retrieve()
cb_ok.event trigger clicked()
cb_ok.triggerevent(clicked!)
</code></pre></div>
<p>有了以上的这些信息，我们就可以很容易地得到基本表达式的语法规则：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">expression_list
    : expression (&#39;,&#39; expression)*
    ;

expression
    : primary_expression
    ;

primary_expression
    : &#39;(&#39; expression &#39;)&#39;
    | (object_name &#39;.&#39;)* (ancestor_name &#39;::&#39;)? call_specifier* IDENTIFIER identifier_suffix?
    | literal
    | &#39;::&#39;? object_name
    ;

object_name
    : &#39;this&#39;
    | &#39;parent&#39;
    | IDENTIFIER
    ;

ancestor_name
    : &#39;super&#39;
    | IDENTIFIER
    ;

call_specifier
    : &#39;function&#39;
    | &#39;event&#39;
    | &#39;static&#39;
    | &#39;dynamic&#39;
    | &#39;trigger&#39;
    | &#39;post&#39;
    ;

identifier_suffix
    : arguments (&#39;.&#39; IDENTIFIER arguments)*    // cascaded calling
    | &#39;[&#39; expression_list? &#39;]&#39;
    ;

arguments
    : &#39;(&#39; expression_list? &#39;)&#39;
    ;

literal
    : STRING_LITERAL
    | INTEGER_LITERAL
    | FLOAT_LITERAL
    | BOOLEAN_LITERAL
    | LINE_COMMENT
    | BLOCK_COMMENT
    ;
</code></pre></div>
<p>不过，如果到这里就开始用ANTLR工具生成词法分析器和语法分析器的话，你会得到一堆的警告信息。要消除这些警告需要在语法文件头部添加：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">options {
    backtrack=true;
}
</code></pre></div>
<p>它的作用是告诉ANTLR在LL(*)语法分析失败的时候要去尝试匹配其它选项。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用ANTLR构建PowerScript语法分析器（3）]]></title>
    <link href="http://codemany.com/blog/using-antlr-to-build-powerscript-grammar-parser-part3/"/>
    <updated>2007-09-07T16:40:49+08:00</updated>
    <id>http://codemany.com/blog/using-antlr-to-build-powerscript-grammar-parser-part3</id>
    <content type="html"><![CDATA[<h3 id="转义字符（special-ascii-characters）">转义字符（Special ASCII Characters）</h3>

<p>PowerScript中转义字符是以波浪号（~）开头。下图是PowerScript支持的完整的转义字符，#字符表示数字。Decimal由三个十进制数组成，范围是000-255；Hexadecimal由两个十六进制数组成，范围是00-FF；Octal由三个八进制数组成，范围是000-377。</p>

<p><img src="/uploads/pb-spefial-char.png" title="pb-spefial-char" ></p>

<p>注意：#表示数字是必须的。譬如，必须用~007这种样式来表示转义字符，而不能是~7这种。</p>

<p>这里是转义字符的词法规则：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">fragment
Escape
    : &#39;~&#39; (&#39;n&#39;|&#39;t&#39;|&#39;v&#39;|&#39;r&#39;|&#39;f&#39;|&#39;b&#39;|&#39;\&quot;&#39;|&#39;\&#39;&#39;|&#39;~&#39;)
    | DecimalEscape
    | HexEscape
    | OctalEscape
    ;

fragment
DecimalEscape
    : &#39;~&#39; (&#39;0&#39;..&#39;1&#39;) (&#39;0&#39;..&#39;9&#39;) (&#39;0&#39;..&#39;9&#39;)    // 000 - 199
    | &#39;~&#39; &#39;2&#39; (&#39;0&#39;..&#39;5&#39;) (&#39;0&#39;..&#39;5&#39;)           // 200 - 255
    ;

fragment
HexEscape
    : &#39;~h&#39; (&#39;0&#39;..&#39;9&#39;|&#39;a&#39;..&#39;f&#39;|&#39;A&#39;..&#39;F&#39;) (&#39;0&#39;..&#39;9&#39;|&#39;a&#39;..&#39;f&#39;|&#39;A&#39;..&#39;F&#39;)    // 00 - FF
    ;

fragment
OctalEscape
    : &#39;~o&#39; (&#39;0&#39;..&#39;3&#39;) (&#39;0&#39;..&#39;7&#39;) (&#39;0&#39;..&#39;7&#39;)   // 000 - 377
    ;
</code></pre></div>
<h3 id="字符和字符串字面量（character-and-string-literals）">字符和字符串字面量（Character and String Literals）</h3>

<p>PowerScript程序中字符和字符串字面量没有明显的区别。字符是指由单引号（&#39;）或双引号（&quot;）括起来的一个ASCII字符，例如：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">char c
c = &#39;T&#39;
c = &quot;T&quot;
</code></pre></div>
<p>字符串字面量则是指由单引号或双引号括起来的不多于1024个的ASCII字符串，例如：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">string s
s = &#39;This is a string&#39;
s = &quot;This is a string&quot;
</code></pre></div>
<p>由于两者没有明显区别，因此在词法分析时只能将两者都作为字符串字面量来处理。至于到底是字符还是字符串，只有到了语意分析阶段才能作出判断。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">STRING_LITERAL
    : ( &#39;\&#39;&#39; (Escape|~(&#39;~&#39;|&#39;\r&#39;|&#39;\n&#39;|&#39;\&#39;&#39;))* &#39;\&#39;&#39;
      | &#39;\&quot;&#39; (Escape|~(&#39;~&#39;|&#39;\r&#39;|&#39;\n&#39;|&#39;\&quot;&#39;))* &#39;\&quot;&#39;
      )
      {
          System.out.println(&quot;string&gt;&quot; + getText());
      }
    ;
</code></pre></div>
<h3 id="数字和布尔字面量（numeric-and-boolean-literals）">数字和布尔字面量（Numeric and Boolean Literals）</h3>
<div class="highlight"><pre><code class="language-text" data-lang="text">INTEGER_LITERAL
    : (&#39;0&#39;|&#39;1&#39;..&#39;9&#39; (&#39;0&#39;..&#39;9&#39;)*)
      {
          System.out.println(&quot;integer&gt;&quot; + getText());
      }
    ;

FLOAT_LITERAL
    : ( (&#39;0&#39;..&#39;9&#39;)+ &#39;.&#39; (&#39;0&#39;..&#39;9&#39;)* Exponent?
      | &#39;.&#39; (&#39;0&#39;..&#39;9&#39;)+ Exponent?
      | (&#39;0&#39;..&#39;9&#39;)+ Exponent?
      )
      {
          System.out.println(&quot;float&gt;&quot; + getText());
      }
    ;

BOOLEAN_LITERAL
    : (&#39;true&#39;|&#39;false&#39;)
      {
          System.out.println(&quot;boolean&gt;&quot; + getText());
      }

    ;

fragment
Exponent
    : (&#39;e&#39;|&#39;E&#39;) (&#39;+&#39;|&#39;-&#39;)? (&#39;0&#39;..&#39;9&#39;)+
    ;
</code></pre></div>
<h3 id="标识符（identifier）">标识符（Identifier）</h3>

<p>标识符规则可以参看<a href="http://codemany.com/blog/powerscript-identifier/">PowerScript标识符</a>一文，以下是标识符的词法规则：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">IDENTIFIER
    : Letter (Letter|&#39;0&#39;..&#39;9&#39;|&#39;$&#39;|&#39;#&#39;|&#39;%&#39;)*    // 暂时不支持短横线（-）
      {
          System.out.println(&quot;identifier&gt;&quot; + getText());
      }
    ;

fragment
Letter
    : (&#39;A&#39;..&#39;Z&#39;|&#39;a&#39;..&#39;z&#39;|&#39;_&#39;)
    ;
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用ANTLR构建PowerScript语法分析器（2）]]></title>
    <link href="http://codemany.com/blog/using-antlr-to-build-powerscript-grammar-parser-part2/"/>
    <updated>2007-09-02T16:44:22+08:00</updated>
    <id>http://codemany.com/blog/using-antlr-to-build-powerscript-grammar-parser-part2</id>
    <content type="html"><![CDATA[<p>在<a href="http://codemany.com/blog/using-antlr-to-build-powerscript-grammar-parser-part1/">使用ANTLR构建PowerScript语法分析器（1）</a>中写的词法规则存在几个小问题：</p>

<ol>
<li>换行符和回车符同时存在于WS和EndOfLine两个词法规则中，属于重复定义；</li>
<li>输出单行注释时紧随其后会额外多输出一个空行；</li>
<li>单行注释是文件的最后一行时不能被词法分析器识别；</li>
<li>像<code>/* comments /* nested comments */ */</code>这种嵌套注释会被输出成：</li>
</ol>
<div class="highlight"><pre><code class="language-text" data-lang="text">bc&gt;/* comments /* nested comments */
bc&gt;/* comments /* nested comments */ */
</code></pre></div>
<p>下面我们将逐个修复它们。</p>

<p>解决第1个问题前先要问问自己，单行注释的词法规则中真的需要包含EndOfLine这个词法规则吗？真的需要吗？如果没有的话，当词法分析器识别到换行符或回车符时，就会去匹配词法规则WS。这样看来，EndOfLine这个词法规则在这里其实是不必要的，完全可以删除掉。</p>

<p>第2个问题因为词法规则EndOfLine已经被删除，所以也就不存在了。这儿仅仅分析下问题的原因。词法分析器分析单行注释时，EndOfLine会被当作单行注释的一部分予以识别。翻看生成的词法识别器代码，可以看到打印代码块出现在词法规则EndOfLine调用的后面。打印代码块中的getText()方法是从CharStream中获取文本的，如果在词法规则EndOfLine被调用后才执行，因为词法规则EndOfLine被调用时会将CharStream的当前索引向尾部移动，这时获得的文本就会包含EndOfLine，导致打印时额外输出一个空行。</p>

<p>第3个问题同样也由于第1个问题的修复而不存在了。它出现的原因是因为文件最后一行的结尾字符是EOF，无法匹配词法规则EndOfLine。</p>

<p>第4个问题则可以通过计数器来处理。先初始化一个计数器变量depthOfComments来标记块注释的深度，当遇到<code>“/*”</code>时就加1，遇到<code>“*/”</code>时则减1。输出时只要判断depthOfComments是否等于0就行了。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">@lexer::members {
    int depthOfComments = 0;
}

BLOCK_COMMENT
    : &#39;/*&#39; {depthOfComments++;}
      ( options {greedy=false;}
      : (&#39;/&#39; &#39;*&#39;)=&gt; BLOCK_COMMENT
      | &#39;/&#39; ~(&#39;*&#39;)
      | ~(&#39;/&#39;)
      )*
      &#39;*/&#39; {depthOfComments--;}
      {
          if (depthOfComments == 0) {
              System.out.println(&quot;bc&gt;&quot; + getText());
          }
      }
    ;
</code></pre></div>]]></content>
  </entry>
  
</feed>
