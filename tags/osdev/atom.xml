<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: OSDev | 乐者为王]]></title>
  <link href="http://codemany.com/tags/osdev/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2017-12-08T10:13:00+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C语言的扬声器发声程序]]></title>
    <link href="http://codemany.com/blog/speaker-sound-program-in-c-language/"/>
    <updated>2005-10-05T09:55:46+08:00</updated>
    <id>http://codemany.com/blog/speaker-sound-program-in-c-language</id>
    <content type="html"><![CDATA[<p>计算机的主板通常装有8253/8254定时与计数器芯片和8255可编程并行接口芯片，由它们组成的硬件电路可用来产生扬声器的声音。目前的计算机由于采用了超大规模集成电路，因而看不到这些芯片，它们均集成在外围电路芯片中。以下是扬声器的电路图：</p>

<p><img src="/uploads/speaker-sound.png" alt="speaker-sound"></p>

<p>使用程序对这些电路编程可以控制声音的长短和音调的高低。在扬声器电路中，定时器的频率决定了扬声器发音的频率，所以可通过设定定时器电路的频率来使扬声器发出不同的声音。对定时器电路进行频率设定时，首先对其命令寄存器端口地址0x43写命令来选择定时器的通道，接着向计数寄存器端口地址0x42发送频率计数值，先送低8位，后送高8位。通过这两步使定时器电路产生一系列的方波信号，此信号能否推动扬声器发音，还要看由8255产生的送数信号和门控信号是否为1，而它们也是可以编程的，端口地址为0x61。以下是完整的实现代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">#include &lt;dos.h&gt;
#include &lt;conio.h&gt;

#define FREQ 1193180.0

unsigned long getticks()
{
    union REGS regs;

    regs.h.ah = 0x00;
    int86(0x1a, &amp;regs, &amp;regs);
    return ((unsigned long)regs.x.cx &lt;&lt; 16) + regs.x.dx;
}

void beep(int tone)
{
    unsigned long ticks;
    unsigned char bits;
    unsigned short count;

    count = FREQ / tone;
    outportb(0x43, 0xb6);    /* 选择定时器的某个通道 */
    outportb(0x42, (unsigned char)(count &amp; 0xff));    /* 发声频率计数值的低8位 */
    outportb(0x42, (unsigned char)(count &gt;&gt; 8));    /* 发声频率计数值的高8位 */

    ticks = getticks();
    while (ticks == getticks())
        ;

    /*
     * 当8255的PB端口的第0位和第1位为1时，表示允许发声；
     * 为0时，表示禁止发声。
     */
    bits = inportb(0x61);
    outportb(0x61, bits | 3);    /* 允许发声 */
    ticks += 2;
    while (getticks() &lt; ticks)
        ;
    outportb(0x61, bits &amp; 0xfc);    /* 禁止发声 */
}

void main()
{
    do
    {
        beep(1046.50);
    } while (!kbhit());
}
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[系统I/O地址表]]></title>
    <link href="http://codemany.com/blog/system-io-address-table/"/>
    <updated>2005-09-13T19:00:03+08:00</updated>
    <id>http://codemany.com/blog/system-io-address-table</id>
    <content type="html"><![CDATA[<p>PC机中仅使用A[0]-A[9]地址位来表示I/O地址，即可有1024个地址。前512个供系统电路使用，后512个供扩充插槽使用。当A[9]=0时表示为系统板上的I/O地址；A[9]=1时表示为扩充插槽接口卡上的地址。</p>

<p>系统I/O地址使用情况：</p>

<table><thead>
<tr>
<th style="text-align: center">I/O地址范围</th>
<th>用途</th>
<th style="text-align: center">I/O地址范围</th>
<th>用途</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0000-001F</td>
<td>8237A DMA控制器1</td>
<td style="text-align: center">00E0-00EF</td>
<td></td>
</tr>
<tr>
<td style="text-align: center">0020-003F</td>
<td>8259A中断控制器1</td>
<td style="text-align: center">00F0</td>
<td>重置协处理器总线</td>
</tr>
<tr>
<td style="text-align: center">0040-005F</td>
<td>8253/8254定时/计数器（PIT）</td>
<td style="text-align: center">00F1</td>
<td>设置协处理器总线</td>
</tr>
<tr>
<td style="text-align: center">0060-006F</td>
<td>8042键盘控制器（AT）</td>
<td style="text-align: center">00F2-00F7</td>
<td></td>
</tr>
<tr>
<td style="text-align: center">0070-007F</td>
<td>CMOS RAM与NMI屏蔽寄存器（AT）</td>
<td style="text-align: center">00F8-00FF</td>
<td>协处理器</td>
</tr>
<tr>
<td style="text-align: center">0080-009F</td>
<td>DMA页寄存器</td>
<td style="text-align: center">0100-01EF</td>
<td></td>
</tr>
<tr>
<td style="text-align: center">00A0-00BF</td>
<td>8259A中断控制器2</td>
<td style="text-align: center">01F0-01F7</td>
<td>硬盘</td>
</tr>
<tr>
<td style="text-align: center">00C0-00DF</td>
<td>8237A DMA控制器2</td>
<td style="text-align: center">01F8-01FF</td>
<td></td>
</tr>
</tbody></table>

<p>扩充插槽I/O地址使用情况：</p>

<table><thead>
<tr>
<th style="text-align: center">I/O地址范围</th>
<th>用途</th>
<th style="text-align: center">I/O地址范围</th>
<th>用途</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0200-0207</td>
<td>游戏卡I/O</td>
<td style="text-align: center">0360-036F</td>
<td>保留</td>
</tr>
<tr>
<td style="text-align: center">0208-020F</td>
<td></td>
<td style="text-align: center">0370-0377</td>
<td></td>
</tr>
<tr>
<td style="text-align: center">0210-0217</td>
<td>扩展部件（仅XT用）</td>
<td style="text-align: center">0378-037F</td>
<td>并行口打印机1</td>
</tr>
<tr>
<td style="text-align: center">0218-021F</td>
<td></td>
<td style="text-align: center">0380-038F</td>
<td>SDLC 通信及同步通信1</td>
</tr>
<tr>
<td style="text-align: center">0220-024F</td>
<td>保留</td>
<td style="text-align: center">0390-039F</td>
<td></td>
</tr>
<tr>
<td style="text-align: center">0250-0277</td>
<td></td>
<td style="text-align: center">03A0-03AF</td>
<td>同步通信2</td>
</tr>
<tr>
<td style="text-align: center">0278-027F</td>
<td>并行口打印机2</td>
<td style="text-align: center">03B0-03BF</td>
<td>MDA 单色显示器</td>
</tr>
<tr>
<td style="text-align: center">0280-02EF</td>
<td></td>
<td style="text-align: center">03C0-03CF</td>
<td>保留</td>
</tr>
<tr>
<td style="text-align: center">02F0-02F7</td>
<td>保留</td>
<td style="text-align: center">03D0-03DF</td>
<td>彩色图形适配器</td>
</tr>
<tr>
<td style="text-align: center">02F8-02FF</td>
<td>串行口2</td>
<td style="text-align: center">03E0-03EF</td>
<td></td>
</tr>
<tr>
<td style="text-align: center">0300-031F</td>
<td>试验卡</td>
<td style="text-align: center">03F0-03F7</td>
<td>软盘适配器</td>
</tr>
<tr>
<td style="text-align: center">0320-032F</td>
<td>硬盘适配器</td>
<td style="text-align: center">03F8-03FF</td>
<td>串行口1</td>
</tr>
<tr>
<td style="text-align: center">0330-035F</td>
<td></td>
<td style="text-align: center"></td>
<td></td>
</tr>
</tbody></table>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[POSIX Conventions for Command Line Arguments]]></title>
    <link href="http://codemany.com/blog/posix-conventions-for-command-line-arguments/"/>
    <updated>2005-09-10T00:03:07+08:00</updated>
    <id>http://codemany.com/blog/posix-conventions-for-command-line-arguments</id>
    <content type="html"><![CDATA[<ol>
<li>An option is a hyphen followed by a single alphanumeric character, like this: -o.</li>
<li>An option may require an argument (which must appear immediately after the option); for example, -oargument or -o argument.</li>
<li>Options that do not require arguments can be grouped after a hyphen, so, for example, -lst is equivalent to -t -l -s.</li>
<li>Options can appear in any order; thus -lst is equivalent to -tls.</li>
<li>Options can appear multiple times.</li>
<li>Options precede other nonoption arguments: -lst nonoption.</li>
<li>The -- argument terminates options.</li>
<li>The - option is typically used to represent one of the standard input streams.</li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[操作系统分区类型大全]]></title>
    <link href="http://codemany.com/blog/the-operating-system-partition-type-list/"/>
    <updated>2005-01-31T13:05:09+08:00</updated>
    <id>http://codemany.com/blog/the-operating-system-partition-type-list</id>
    <content type="html"><![CDATA[<p>大概是最全的操作系统分区类型列表了:)</p>

<table><thead>
<tr>
<th style="text-align: center">分区类型</th>
<th>操作系统</th>
<th style="text-align: center">分区类型</th>
<th>操作系统</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x0</td>
<td>UNUSED</td>
<td style="text-align: center">0x80</td>
<td>Old Minix</td>
</tr>
<tr>
<td style="text-align: center">0x1</td>
<td>DOS FAT12</td>
<td style="text-align: center">0x81</td>
<td>Minix/Old Linux</td>
</tr>
<tr>
<td style="text-align: center">0x2</td>
<td>Xenix root</td>
<td style="text-align: center">0x82</td>
<td>Linux Swap</td>
</tr>
<tr>
<td style="text-align: center">0x3</td>
<td>Xenix user</td>
<td style="text-align: center">0x83</td>
<td>Linux EXT2</td>
</tr>
<tr>
<td style="text-align: center">0x4</td>
<td>DOS FAT16 &lt; 32MB</td>
<td style="text-align: center">0x84</td>
<td></td>
</tr>
<tr>
<td style="text-align: center">0x5</td>
<td>DOS Extended</td>
<td style="text-align: center">0x85</td>
<td>Linux EXT</td>
</tr>
<tr>
<td style="text-align: center">0x6</td>
<td>DOS FAT16 &gt;= 32M</td>
<td style="text-align: center">0x86</td>
<td></td>
</tr>
<tr>
<td style="text-align: center">0x7</td>
<td>HPFS/NTFS</td>
<td style="text-align: center">0x87</td>
<td></td>
</tr>
<tr>
<td style="text-align: center">0x8</td>
<td>AIX</td>
<td style="text-align: center">0x88</td>
<td></td>
</tr>
<tr>
<td style="text-align: center">0x9</td>
<td>AIX bootable</td>
<td style="text-align: center">0x89</td>
<td></td>
</tr>
<tr>
<td style="text-align: center">0xA</td>
<td>OS/2 boot manager</td>
<td style="text-align: center">0x8A</td>
<td></td>
</tr>
<tr>
<td style="text-align: center">0xB</td>
<td>OS FAT32</td>
<td style="text-align: center">0x8B</td>
<td></td>
</tr>
<tr>
<td style="text-align: center">0xC</td>
<td>DOS FAT Cyl &gt; 1024</td>
<td style="text-align: center">0x8C</td>
<td></td>
</tr>
<tr>
<td style="text-align: center">0xE</td>
<td>DOS FAT system</td>
<td style="text-align: center">0x8E</td>
<td></td>
</tr>
<tr>
<td style="text-align: center">0xF</td>
<td>DOS big Extended</td>
<td style="text-align: center">0x8F</td>
<td></td>
</tr>
<tr>
<td style="text-align: center">0x13</td>
<td></td>
<td style="text-align: center">0x93</td>
<td>Amoeba</td>
</tr>
<tr>
<td style="text-align: center">0x14</td>
<td></td>
<td style="text-align: center">0x94</td>
<td>Amoeba BBT</td>
</tr>
<tr>
<td style="text-align: center">0x25</td>
<td></td>
<td style="text-align: center">0xA5</td>
<td>FreeBSD</td>
</tr>
<tr>
<td style="text-align: center">0x26</td>
<td>[Hidden]</td>
<td style="text-align: center">0xA6</td>
<td>OpenBSD</td>
</tr>
<tr>
<td style="text-align: center">0x27</td>
<td></td>
<td style="text-align: center">0xA7</td>
<td>NeXT STEP</td>
</tr>
<tr>
<td style="text-align: center">0x29</td>
<td></td>
<td style="text-align: center">0xA9</td>
<td>NetBSD</td>
</tr>
<tr>
<td style="text-align: center">0x37</td>
<td></td>
<td style="text-align: center">0xB7</td>
<td>BSDI</td>
</tr>
<tr>
<td style="text-align: center">0x38</td>
<td></td>
<td style="text-align: center">0xB8</td>
<td>BSDI Swap</td>
</tr>
<tr>
<td style="text-align: center">0x40</td>
<td>Venix 80286</td>
<td style="text-align: center">0xC0</td>
<td></td>
</tr>
<tr>
<td style="text-align: center">0x41</td>
<td>PPC PReP boot</td>
<td style="text-align: center">0xC1</td>
<td></td>
</tr>
<tr>
<td style="text-align: center">0x47</td>
<td></td>
<td style="text-align: center">0xC7</td>
<td>Syrinx</td>
</tr>
<tr>
<td style="text-align: center">0x51</td>
<td>Novell ?</td>
<td style="text-align: center">0xD1</td>
<td></td>
</tr>
<tr>
<td style="text-align: center">0x52</td>
<td>MicroPort</td>
<td style="text-align: center">0xD2</td>
<td></td>
</tr>
<tr>
<td style="text-align: center">0x5B</td>
<td></td>
<td style="text-align: center">0xDB</td>
<td>CP/M</td>
</tr>
<tr>
<td style="text-align: center">0x61</td>
<td></td>
<td style="text-align: center">0xE1</td>
<td>DOS access</td>
</tr>
<tr>
<td style="text-align: center">0x63</td>
<td>GNU hurd</td>
<td style="text-align: center">0xE3</td>
<td>DOS R/0</td>
</tr>
<tr>
<td style="text-align: center">0x64</td>
<td>Novell NetWare</td>
<td style="text-align: center">0xE4</td>
<td></td>
</tr>
<tr>
<td style="text-align: center">0x65</td>
<td>Novell NetWare</td>
<td style="text-align: center">0xE5</td>
<td></td>
</tr>
<tr>
<td style="text-align: center">0x6B</td>
<td></td>
<td style="text-align: center">0xEB</td>
<td>BeOS</td>
</tr>
<tr>
<td style="text-align: center">0x72</td>
<td></td>
<td style="text-align: center">0xF2</td>
<td>DOS secondary</td>
</tr>
<tr>
<td style="text-align: center">0x75</td>
<td>PC/IX</td>
<td style="text-align: center">0xF5</td>
<td></td>
</tr>
<tr>
<td style="text-align: center">0x7F</td>
<td></td>
<td style="text-align: center">0xFF</td>
<td>BBT</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Inside Protected Mode]]></title>
    <link href="http://codemany.com/blog/inside-protected-mode/"/>
    <updated>2004-11-23T13:10:07+08:00</updated>
    <id>http://codemany.com/blog/inside-protected-mode</id>
    <content type="html"><![CDATA[<p>以下所说的书指的是杨季文的《80X86汇编语言程序设计教程》。</p>

<p>在380页，他说是“在实方式下被预取，在保护方式下被执行”。这个说法不太正确。现在就来说说在进/出保护模式时究竟发生了什么？</p>

<p>在实模式时，通过指令lgdt fword ptr vgdtr把vgdtr处6个字节的内容装入GDTR中（记住，仅仅只是装入）。然后打开A20地址线（打开A20地址线是为了能存取1M以上的内存，和进不进保护模式其实没有必然的联系，也就是说不打开A20也能进入保护模式，只不过这时在保护模式下就不能存取1M以上的内存）。然后把CR0寄存器的PE位置1，这是告诉CPU开启保护模式。</p>

<p>讲到这里，就要先来说说shadow cache了。shadow cache的布局可以看388页。在实模式下的时候有些位是只读的。大家还记的实模式下取址的算法吗？对，段寄存器值 * 16 + offset。是直接由MMU这样做然后再取址的吗？不是，实际上是：当你往段寄存器（比如说CS）送值后，MMU同时会把CS * 16的值放入到CS的shadow cache中。这样以后只要不改变CS的值，那么，在同一段代码段中的寻址将是offset加上shadow cache中的段基址部分。明白了吗？好，我们再回过来讲。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">mov eax, cr0
or eax, 1
mov cr0, eax
</code></pre></div>
<p>这段代码究竟做了什么呢？其实它做的是开放段寄存器shadow cache的每个位（也就是每个位的值都能修改了，而在实模式下有些位是只读的）。还有就是告诉CPU开启保护模式。记住，这时候在shadow cache中的内容还没有变，还是原来实模式下的地址值。</p>

<p>现在再来谈谈保护模式下的寻址。在386以后的机器，保护模式下的寻址其实和在实模式下的寻址是一样的，也是offset加上shadow cache中的段基址部分。这样就可以理解为什么把CR0的PE位置1后还能执行后面的指令了。因为把CR0的PE位置1虽然使系统进入了保护模式。但因为在shadow cache中的内容还是实模式下的内容，所以才能在保护模式下执行实地址处的指令。然后呢？</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">jump selector, offset
</code></pre></div>
<p>这个指令做了什么？它的意思是跳到选择子为selector的段的偏移为offset处，执行那里的指令。这时CPU究竟做了什么呢？因为是段间跳转（就是带selector的跳转啦）。又因为现在是在保护模式下，所以MMU根据selector从GDT（知道LDGT的作用了吧）来找到段的真实段基址，然后再把它放入到相应段的shadow cache中。接着MMU再把offset和shadow cache中的段基址部分相加。这样就得到了下一个指令的地址。同样的道理，从保护模式出来时用</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">mov eax，cr0
and eax，0xffffffff
mov cr0，eax
</code></pre></div>
<p>使各段的shadow cache中部分位固定，并且宣告进入实模式，即以后的寻址将采用实模式方式。然后通过执行jump cs, offset来把CS * 16的值装入shadow cache中。</p>
]]></content>
  </entry>
  
</feed>
