<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: OSDev | 乐者为王]]></title>
  <link href="http://codemany.com/tags/osdev/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2015-03-22T21:22:24+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[系统I/O地址表]]></title>
    <link href="http://codemany.com/blog/system-io-address-table/"/>
    <updated>2005-09-13T19:00:03+08:00</updated>
    <id>http://codemany.com/blog/system-io-address-table</id>
    <content type="html"><![CDATA[<p>PC机中仅使用A[0]-A[9]地址位来表示I/O地址，即可有1024个地址。前512个供系统电路使用，后512个供扩充插槽使用。当A[9]=0时表示为系统板上的I/O地址；A[9]=1时表示为扩充插槽接口卡上的地址。</p>

<p>系统I/O地址使用情况</p>

<table>
<thead>
<tr>
<th>I/O地址范围 </th>
<th> 用途                        </th>
<th></th>
<th> I/O地址范围 </th>
<th> 用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>0000-001F  </td>
<td> 8237A DMA控制器1            </td>
<td></td>
<td> 00E0-00EF   </td>
<td></td>
</tr>
<tr>
<td>0020-003F  </td>
<td> 8259A中断控制器1            </td>
<td></td>
<td> 00F0        </td>
<td> 重置协处理器总线</td>
</tr>
<tr>
<td>0040-005F  </td>
<td> 8253/8254定时/计数器(PIT)   </td>
<td></td>
<td> 00F1        </td>
<td> 设置协处理器总线</td>
</tr>
<tr>
<td>0060-006F  </td>
<td> 8042键盘控制器(AT)          </td>
<td></td>
<td> 00F2-00F7   </td>
<td></td>
</tr>
<tr>
<td>0070-007F  </td>
<td> CMOS RAM与NMI屏蔽寄存器(AT) </td>
<td></td>
<td> 00F8-00FF   </td>
<td> 协处理器</td>
</tr>
<tr>
<td>0080-009F  </td>
<td> DMA页寄存器                 </td>
<td></td>
<td> 0100-01EF   </td>
<td></td>
</tr>
<tr>
<td>00A0-00BF  </td>
<td> 8259A中断控制器2            </td>
<td></td>
<td> 01F0-01F7   </td>
<td> 硬盘</td>
</tr>
<tr>
<td>00C0-00DF  </td>
<td> 8237A DMA控制器2            </td>
<td></td>
<td> 01F8-01FF   </td>
<td></td>
</tr>
</tbody>
</table>


<p>扩充插槽I/O地址使用情况</p>

<table>
<thead>
<tr>
<th>I/O地址范围 </th>
<th> 用途             </th>
<th></th>
<th> I/O地址范围 </th>
<th> 用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>0200-0207  </td>
<td> 游戏卡I/O        </td>
<td></td>
<td>  0360-036F  </td>
<td> 保留</td>
</tr>
<tr>
<td>0208-020F  </td>
<td>                  </td>
<td></td>
<td>  0370-0377  </td>
<td></td>
</tr>
<tr>
<td>0210-0217  </td>
<td> 扩展部件(仅XT用) </td>
<td></td>
<td>  0378-037F  </td>
<td> 并行口打印机1</td>
</tr>
<tr>
<td>0218-021F  </td>
<td>                  </td>
<td></td>
<td>  0380-038F  </td>
<td> SDLC 通信及同步通信1</td>
</tr>
<tr>
<td>0220-024F  </td>
<td> 保留             </td>
<td></td>
<td>  0390-039F  </td>
<td></td>
</tr>
<tr>
<td>0250-0277  </td>
<td>                  </td>
<td></td>
<td>  03A0-03AF  </td>
<td> 同步通信2</td>
</tr>
<tr>
<td>0278-027F  </td>
<td> 并行口打印机2    </td>
<td></td>
<td>  03B0-03BF  </td>
<td> MDA 单色显示器</td>
</tr>
<tr>
<td>0280-02EF  </td>
<td>                  </td>
<td></td>
<td>  03C0-03CF  </td>
<td> 保留</td>
</tr>
<tr>
<td>02F0-02F7  </td>
<td> 保留             </td>
<td></td>
<td>  03D0-03DF  </td>
<td> 彩色图形适配器</td>
</tr>
<tr>
<td>02F8-02FF  </td>
<td> 串行口2          </td>
<td></td>
<td>  03E0-03EF  </td>
<td></td>
</tr>
<tr>
<td>0300-031F  </td>
<td> 试验卡           </td>
<td></td>
<td>  03F0-03F7  </td>
<td> 软盘适配器</td>
</tr>
<tr>
<td>0320-032F  </td>
<td> 硬盘适配器       </td>
<td></td>
<td>  03F8-03FF  </td>
<td> 串行口1</td>
</tr>
<tr>
<td>0330-035F  </td>
<td>                  </td>
<td></td>
<td>             </td>
<td></td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[POSIX Conventions for Command Line Arguments]]></title>
    <link href="http://codemany.com/blog/posix-conventions-for-command-line-arguments/"/>
    <updated>2005-09-10T00:03:07+08:00</updated>
    <id>http://codemany.com/blog/posix-conventions-for-command-line-arguments</id>
    <content type="html"><![CDATA[<ol>
<li>An option is a hyphen followed by a single alphanumeric character, like this: -o.</li>
<li>An option may require an argument (which must appear immediately after the option); for example, -oargument or -o argument.</li>
<li>Options that do not require arguments can be grouped after a hyphen, so, for example, -lst is equivalent to -t -l -s.</li>
<li>Options can appear in any order; thus -lst is equivalent to -tls.</li>
<li>Options can appear multiple times.</li>
<li>Options precede other nonoption arguments: -lst nonoption.</li>
<li>The <code>--</code> argument terminates options.</li>
<li>The - option is typically used to represent one of the standard input streams.</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[操作系统分区类型大全]]></title>
    <link href="http://codemany.com/blog/the-operating-system-partition-type-list/"/>
    <updated>2005-01-31T13:05:09+08:00</updated>
    <id>http://codemany.com/blog/the-operating-system-partition-type-list</id>
    <content type="html"><![CDATA[<p>大概是最全的操作系统分区类型列表了^_^</p>

<table>
<thead>
<tr>
<th>分区类型 </th>
<th> 操作系统           </th>
<th></th>
<th> 分区类型 </th>
<th> 操作系统</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x0   </td>
<td> UNUSED             </td>
<td></td>
<td>   0x80   </td>
<td> Old Minix</td>
</tr>
<tr>
<td>0x1   </td>
<td> DOS FAT12          </td>
<td></td>
<td>   0x81   </td>
<td> Minix/Old Linux</td>
</tr>
<tr>
<td>0x2   </td>
<td> Xenix root         </td>
<td></td>
<td>   0x82   </td>
<td> Linux Swap</td>
</tr>
<tr>
<td>0x3   </td>
<td> Xenix user         </td>
<td></td>
<td>   0x83   </td>
<td> Linux EXT2</td>
</tr>
<tr>
<td>0x4   </td>
<td> DOS FAT16 &lt; 32MB   </td>
<td></td>
<td>   0x84   </td>
<td></td>
</tr>
<tr>
<td>0x5   </td>
<td> DOS Extended       </td>
<td></td>
<td>   0x85   </td>
<td> Linux EXT</td>
</tr>
<tr>
<td>0x6   </td>
<td> DOS FAT16 >= 32M   </td>
<td></td>
<td>   0x86   </td>
<td></td>
</tr>
<tr>
<td>0x7   </td>
<td> HPFS/NTFS          </td>
<td></td>
<td>   0x87   </td>
<td></td>
</tr>
<tr>
<td>0x8   </td>
<td> AIX                </td>
<td></td>
<td>   0x88   </td>
<td></td>
</tr>
<tr>
<td>0x9   </td>
<td> AIX bootable       </td>
<td></td>
<td>   0x89   </td>
<td></td>
</tr>
<tr>
<td>0xA   </td>
<td> OS/2 boot manager  </td>
<td></td>
<td>   0x8A   </td>
<td></td>
</tr>
<tr>
<td>0xB   </td>
<td> OS FAT32           </td>
<td></td>
<td>   0x8B   </td>
<td></td>
</tr>
<tr>
<td>0xC   </td>
<td> DOS FAT Cyl > 1024 </td>
<td></td>
<td>   0x8C   </td>
<td></td>
</tr>
<tr>
<td>0xE   </td>
<td> DOS FAT system     </td>
<td></td>
<td>   0x8E   </td>
<td></td>
</tr>
<tr>
<td>0xF   </td>
<td> DOS big Extended   </td>
<td></td>
<td>   0x8F   </td>
<td></td>
</tr>
<tr>
<td>0x13  </td>
<td>                    </td>
<td></td>
<td>   0x93   </td>
<td> Amoeba</td>
</tr>
<tr>
<td>0x14  </td>
<td>                    </td>
<td></td>
<td>   0x94   </td>
<td> Amoeba BBT</td>
</tr>
<tr>
<td>0x25  </td>
<td>                    </td>
<td></td>
<td>   0xA5   </td>
<td> FreeBSD</td>
</tr>
<tr>
<td>0x26  </td>
<td> [Hidden]           </td>
<td></td>
<td>   0xA6   </td>
<td> OpenBSD</td>
</tr>
<tr>
<td>0x27  </td>
<td>                    </td>
<td></td>
<td>   0xA7   </td>
<td> NeXT STEP</td>
</tr>
<tr>
<td>0x29  </td>
<td>                    </td>
<td></td>
<td>   0xA9   </td>
<td> NetBSD</td>
</tr>
<tr>
<td>0x37  </td>
<td>                    </td>
<td></td>
<td>   0xB7   </td>
<td> BSDI</td>
</tr>
<tr>
<td>0x38  </td>
<td>                    </td>
<td></td>
<td>   0xB8   </td>
<td> BSDI Swap</td>
</tr>
<tr>
<td>0x40  </td>
<td> Venix 80286        </td>
<td></td>
<td>   0xC0   </td>
<td></td>
</tr>
<tr>
<td>0x41  </td>
<td> PPC PReP boot      </td>
<td></td>
<td>   0xC1   </td>
<td></td>
</tr>
<tr>
<td>0x47  </td>
<td>                    </td>
<td></td>
<td>   0xC7   </td>
<td> Syrinx</td>
</tr>
<tr>
<td>0x51  </td>
<td> Novell ?           </td>
<td></td>
<td>   0xD1   </td>
<td></td>
</tr>
<tr>
<td>0x52  </td>
<td> MicroPort          </td>
<td></td>
<td>   0xD2   </td>
<td></td>
</tr>
<tr>
<td>0x5B  </td>
<td>                    </td>
<td></td>
<td>   0xDB   </td>
<td> CP/M</td>
</tr>
<tr>
<td>0x61  </td>
<td>                    </td>
<td></td>
<td>   0xE1   </td>
<td> DOS access</td>
</tr>
<tr>
<td>0x63  </td>
<td> GNU hurd           </td>
<td></td>
<td>   0xE3   </td>
<td> DOS R/0</td>
</tr>
<tr>
<td>0x64  </td>
<td> Novell NetWare     </td>
<td></td>
<td>   0xE4   </td>
<td></td>
</tr>
<tr>
<td>0x65  </td>
<td> Novell NetWare     </td>
<td></td>
<td>   0xE5   </td>
<td></td>
</tr>
<tr>
<td>0x6B  </td>
<td>                    </td>
<td></td>
<td>   0xEB   </td>
<td> BeOS</td>
</tr>
<tr>
<td>0x72  </td>
<td>                    </td>
<td></td>
<td>   0xF2   </td>
<td> DOS secondary</td>
</tr>
<tr>
<td>0x75  </td>
<td> PC/IX              </td>
<td></td>
<td>   0xF5   </td>
<td></td>
</tr>
<tr>
<td>0x7F  </td>
<td>                    </td>
<td></td>
<td>   0xFF   </td>
<td> BBT</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Inside Protected Mode]]></title>
    <link href="http://codemany.com/blog/inside-protected-mode/"/>
    <updated>2004-11-23T13:10:07+08:00</updated>
    <id>http://codemany.com/blog/inside-protected-mode</id>
    <content type="html"><![CDATA[<p>以下所说的书指的是杨季文的《80X86汇编语言程序设计教程》。</p>

<p>在380页，他说是“在实方式下被预取，在保护方式下被执行”。这个说法不太正确。现在就来说说在进/出保护模式时究竟发生了什么？</p>

<p>在实模式时，通过指令lgdt fword ptr vgdtr把vgdtr处6个字节的内容装入GDTR中（记住，仅仅只是装入）。然后打开A20地址线（打开A20地址线是为了能存取1M以上的内存，和进不进保护模式其实没有必然的联系，也就是说不打开A20也能进入保护模式，只不过这时在保护模式下就不能存取1M以上的内存了）。然后把CR0寄存器的PE位置1，这是告诉CPU开启保护模式。</p>

<p>讲到这里，就要先来说说shadow cache了。shadow cache的layout可以看388页。在实模式下的时候有些位是只读的。大家还记的实模式下取址的方法吗？对，段寄存器值 * 16 + offset。是直接由MMU这样做然后再取址的吗？不是，实际上是：当你往段寄存器（比如说CS）送值后，MMU同时会把CS * 16的值放入到CS的shadow cache中。这样以后只要不改变CS的值，那么，在同一段代码段中的寻址将是offset加上shadow cache中的段基址部分。明白了吗？好，我们再回过来讲。</p>

<pre><code>mov eax, cr0
or eax, 1
mov cr0, eax
</code></pre>

<p>这段代码究竟做了什么呢？其实它做的是开放段寄存器shadow cache的每个位（也就是每个位的值都能修改了，而在实模式下有些位是只读的）。还有就是告诉CPU开启保护模式。记住，这时候在shadow cache中的内容还没有变，还是原来实模式下的地址值。</p>

<p>现在再来谈谈保护模式下的寻址。在386以后的机器，保护模式下的寻址其实和在实模式下的寻址是一样的，也是offset加上shadow cache中的段基址部分。这样就可以理解为什么把CR0的PE位置1后还能执行后面的指令了。因为把CR0的PE位置1虽然使系统进入了保护模式。但因为在shadow cache中的内容还是实模式下的内容，所以才能在保护模式下执行实地址处的指令。然后呢！看看jump指令做了什么？</p>

<pre><code>jump selector, offset
</code></pre>

<p>这个指令做了什么？它的意思是要跳到选择子为selector的段的偏移为offset处，执行那里的指令。这时CPU究竟做了什么呢？因为是段间跳转（就是带selector的跳转啦）。又因为现在是在保护模式下，所以MMU根据selector从GDT（知道LDGT的作用了吧）来找到段的真实段基址，然后再把它放入到相应段的shadow cache中。接着MMU再把offset和（shadow cache中的段基址部分）相加。这样就得到了下一个指令的地址。同样的道理，从保护模式出来时用</p>

<pre><code>mov eax，cr0
and eax，0xffffffff
mov cr0，eax
</code></pre>

<p>使各段的shadow cache中一部分位固定，并且宣告进入实模式，即以后的寻址将采用实模式方式。然后通过执行jump cs, offset来把CS * 16的值装入shadow cache中。</p>
]]></content>
  </entry>
  
</feed>
