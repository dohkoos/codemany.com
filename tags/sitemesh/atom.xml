<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: SiteMesh | 乐者为王]]></title>
  <link href="http://codemany.com/tags/sitemesh/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2016-08-26T09:15:11+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用SiteMesh做网页布局]]></title>
    <link href="http://codemany.com/blog/page-layout-using-sitemesh/"/>
    <updated>2013-04-09T08:18:33+08:00</updated>
    <id>http://codemany.com/blog/page-layout-using-sitemesh</id>
    <content type="html"><![CDATA[<p>SiteMesh是一个基于GoF的Decorator模式，用于页面布局的框架。能帮助我们在由大量页面构成的项目中创建一致的页面布局和外观。</p>

<p>这里我们将会把它整合到JBookShelf里去。要和Struts 2整合，先在pom.xml添加以下插件，该插件会将依赖的SiteMesh也一并包含到项目中。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.struts&lt;/groupId&gt;
    &lt;artifactId&gt;struts2-sitemesh-plugin&lt;/artifactId&gt;
    &lt;version&gt;2.3.12&lt;/version&gt;
&lt;/dependency&gt;
</code></pre></div>
<p>将web.xml配置中原来的</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&lt;filter&gt;
    &lt;filter-name&gt;struts2&lt;/filter-name&gt;
    &lt;filter-class&gt;
        org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter
    &lt;/filter-class&gt;
&lt;/filter&gt;

&lt;filter-mapping&gt;
    &lt;filter-name&gt;struts2&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre></div>
<p>改成</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&lt;filter&gt;
    &lt;filter-name&gt;struts-prepare&lt;/filter-name&gt;
    &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareFilter&lt;/filter-class&gt;
&lt;/filter&gt;

&lt;filter&gt;
    &lt;filter-name&gt;sitemesh&lt;/filter-name&gt;
    &lt;filter-class&gt;com.opensymphony.sitemesh.webapp.SiteMeshFilter&lt;/filter-class&gt;
&lt;/filter&gt;

&lt;filter&gt;
    &lt;filter-name&gt;struts-execute&lt;/filter-name&gt;
    &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsExecuteFilter&lt;/filter-class&gt;
&lt;/filter&gt;

&lt;filter-mapping&gt;
    &lt;filter-name&gt;struts-prepare&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;

&lt;filter-mapping&gt;
    &lt;filter-name&gt;sitemesh&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;

&lt;filter-mapping&gt;
    &lt;filter-name&gt;struts-execute&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre></div>
<p>这里要注意过滤器的位置。SiteMesh过滤器必须在StrutsPrepareFilter之后和StrutsExecuteFilter之前，否则在SiteMesh的修饰器页面中将访问不到ActionContext。这是因为Struts 2的所有值是保存在Stack Context或者ValueStack中的。默认情况下，某个过滤器一旦访问了该Stack Context或ValueStack，里面对应的值会被清洗掉。如果先使用Struts 2的StrutsPrepareAndExecuteFilter来过滤用户请求，则SiteMesh的过滤器将无法取得Stack Context或者ValueStack中的数据。为了解决这个问题，Struts 2提供了StrutsPrepareFilter和StrutsExecuteFilter类（在2.1.3版本前是ActionContextCleanUp和FilterDispatcher），通过它们协同来确保SiteMesh正常工作。</p>

<p>在WEB-INF下添加decorators.xml文档：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;decorators defaultdir=&quot;/layouts&quot;&gt;
    &lt;excludes&gt;
        &lt;pattern&gt;/stylesheets/*&lt;/pattern&gt;
        &lt;pattern&gt;/javascripts/*&lt;/pattern&gt;
        &lt;pattern&gt;/images/*&lt;/pattern&gt;
    &lt;/excludes&gt;

    &lt;decorator name=&quot;application&quot; page=&quot;application.jsp&quot;&gt;
        &lt;pattern&gt;/*&lt;/pattern&gt;
    &lt;/decorator&gt;
&lt;/decorators&gt;
</code></pre></div>
<p>stylesheets、javascripts、images目录下的内容是不需要被修饰的，可以把它们放到execludes块中排除掉。</p>

<p>新建/layouts/application.jsp模版页：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&lt;%@ taglib uri=&quot;/struts-tags&quot; prefix=&quot;s&quot; %&gt;
&lt;%@ taglib uri=&quot;http://www.opensymphony.com/sitemesh/decorator&quot; prefix=&quot;decorator&quot; %&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;&lt;decorator:title default=&quot;JBookShelf&quot; /&gt;&lt;/title&gt;
    &lt;decorator:head /&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div&gt;
        &lt;s:if test=&quot;#session.user_session_key != null&quot;&gt;
        &lt;s:a action=&quot;listBook&quot;&gt;All Books&lt;/s:a&gt;
        Welcome, you have logined.
        &lt;s:a action=&quot;logout&quot;&gt;Logout&lt;/s:a&gt;
        &lt;/s:if&gt;
        &lt;s:else&gt;
        &lt;s:a action=&quot;login!input&quot;&gt;Login&lt;/s:a&gt; |
        &lt;s:a action=&quot;register!input&quot;&gt;Register&lt;/s:a&gt;
        &lt;/s:else&gt;
    &lt;/div&gt;
    &lt;hr /&gt;
    &lt;div&gt;Navigation&lt;/div&gt;
    &lt;hr /&gt;
    &lt;decorator:body /&gt;
    &lt;hr /&gt;
    &lt;div&gt;Footer&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></div>
<p>代码下载：<a href="https://github.com/dohkoos/JBookShelf">https://github.com/dohkoos/JBookShelf</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何解决含有中文的页面末尾内容会被SiteMesh截掉的问题]]></title>
    <link href="http://codemany.com/blog/how-to-solve-sitemesh-truncate-the-page-containing-chinese-character/"/>
    <updated>2005-07-22T14:33:59+08:00</updated>
    <id>http://codemany.com/blog/how-to-solve-sitemesh-truncate-the-page-containing-chinese-character</id>
    <content type="html"><![CDATA[<p>首先，我们要了解一下ServletResponse.setContentLength(int len)的含义。setContentLength是设置返回内容体长度的方法，len是内容体的长度。由于网络上传输内容是以字节（byte）为单位的，所以len就是指内容体有多少个字节。假设现在有长度为100个字节的数据，在输出数据到客户端前我们用setContentLength(90)设置内容体的长度为90个字节。那么在客户端接收到的数据长度就是90个字节而不是100。下面我们来做个试验：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class PageTruncateFilter implements Filter {

    public void init(FilterConfig config) throws ServletException {
    }

    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
                        throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest)req;
        HttpServletResponse response = (HttpServletResponse)res;

        String content = &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Truncated Page&lt;/title&gt;&lt;/head&gt;&quot;;
               content += &quot;&lt;body&gt;这个页面的内容will be truncated.&lt;/body&gt;&lt;/html&gt;&quot;;
        response.setCharacterEncoding(&quot;gbk&quot;);
        response.setContentLength(content.length());
        PrintWriter out = response.getWriter();
        out.println(content);
        out.close();
    }

    public void destroy() {
    }
}
</code></pre></div>
<p>由于content字符串含有两个中文字符，每一个中文字符又是由两个字节组成，所以content.length()的值比content的字节数要少2。在客户端显示的内容也会因此少2个字节，即缺少“l&gt;”这两个字符。</p>

<p>现在我们来浏览SiteMesh的源代码找出问题的原因。首先从PageFilter.java的doFilter方法开始。由于页面没有在decorators.xml中注册修饰，所以writeOriginal方法会被调用。下面是writeOriginal方法的源代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">/** Write the original page data to the response. */
private void writeOriginal(HttpServletRequest request, HttpServletResponse response,
                          Page page) throws IOException {
    response.setContentLength(page.getContentLength());

    if (request.getAttribute(USING_STREAM).equals(Boolean.TRUE)) {
        PrintWriter writer = new PrintWriter(response.getOutputStream());
        page.writePage(writer);
        // flush writer to underlying outputStream
        writer.flush();
        response.getOutputStream().flush();
    } else {
        page.writePage(response.getWriter());
        response.getWriter().flush();
    }
}
</code></pre></div>
<p>首行代码就是设置内容体长度的，让我们追到page.getContentLength()里面去看看（Page接口的getContentLength方法是由AbstractPage.java实现的）：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public int getContentLength() {
    return pageData.length;
}
</code></pre></div>
<p>它返回pageData数组的长度。但是pageData数组是char类型的，假如pageData中有中文内容时，设置的内容体长度就会小于pageData的字节数。这时就会出现输出到客户端的数据截掉的问题。所以只要修改getContentLength方法返回的值就可以了，下面是修改后的getContentLength方法：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public int getContentLength() {
    String content = new String(pageData);
    return content.getBytes().length;
}
</code></pre></div>]]></content>
  </entry>
  
</feed>
