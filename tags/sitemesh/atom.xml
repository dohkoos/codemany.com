<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: SiteMesh | 乐者为王]]></title>
  <link href="http://codemany.com/tags/sitemesh/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2014-08-25T10:22:50+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用SiteMesh做网页布局]]></title>
    <link href="http://codemany.com/blog/2013/04/09/page-layout-using-sitemesh/"/>
    <updated>2013-04-09T08:18:33+08:00</updated>
    <id>http://codemany.com/blog/2013/04/09/page-layout-using-sitemesh</id>
    <content type="html"><![CDATA[<p>SiteMesh是一个基于GoF的Decorator模式，用于页面布局的框架。能帮助我们在由大量页面构成的项目中创建一致的页面布局和外观。</p>

<p>这里我们将会把它整合到JBookShelf里去。要和Struts2整合，先在pom.xml添加以下插件，该插件会将依赖的SiteMesh也一并包含到项目中。
```
<dependency></p>

<pre><code>&lt;groupId&gt;org.apache.struts&lt;/groupId&gt;
&lt;artifactId&gt;struts2-sitemesh-plugin&lt;/artifactId&gt;
&lt;version&gt;2.3.12&lt;/version&gt;
</code></pre>

<p></dependency>
```</p>

<p>将web.xml配置中原来的
```
<filter></p>

<pre><code>&lt;filter-name&gt;struts2&lt;/filter-name&gt;
&lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;
</code></pre>

<p></filter></p>

<p>&lt;filter-mapping></p>

<pre><code>&lt;filter-name&gt;struts2&lt;/filter-name&gt;
&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
</code></pre>

<p>&lt;/filter-mapping>
```</p>

<p>改成
```
<filter></p>

<pre><code>&lt;filter-name&gt;struts-prepare&lt;/filter-name&gt;
&lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareFilter&lt;/filter-class&gt;
</code></pre>

<p></filter></p>

<p><filter></p>

<pre><code>&lt;filter-name&gt;sitemesh&lt;/filter-name&gt;
&lt;filter-class&gt;com.opensymphony.sitemesh.webapp.SiteMeshFilter&lt;/filter-class&gt;
</code></pre>

<p></filter></p>

<p><filter></p>

<pre><code>&lt;filter-name&gt;struts-execute&lt;/filter-name&gt;
&lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsExecuteFilter&lt;/filter-class&gt;
</code></pre>

<p></filter></p>

<p>&lt;filter-mapping></p>

<pre><code>&lt;filter-name&gt;struts-prepare&lt;/filter-name&gt;
&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
</code></pre>

<p>&lt;/filter-mapping></p>

<p>&lt;filter-mapping></p>

<pre><code>&lt;filter-name&gt;sitemesh&lt;/filter-name&gt;
&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
</code></pre>

<p>&lt;/filter-mapping></p>

<p>&lt;filter-mapping></p>

<pre><code>&lt;filter-name&gt;struts-execute&lt;/filter-name&gt;
&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
</code></pre>

<p>&lt;/filter-mapping>
```</p>

<p>这里要注意过滤器的位置。SiteMesh过滤器必须在StrutsPrepareFilter之后和StrutsExecuteFilter之前，否则在SiteMesh的修饰器页面中将访问不到ActionContext。这是因为Struts2的所有值是保存在Stack Context或者ValueStack中的。默认情况下，某个过滤器一旦访问了该Stack Context或ValueStack，里面对应的值会被清洗掉。如果先使用Struts2的StrutsPrepareAndExecuteFilter来过滤用户请求，则SiteMesh的过滤器将无法取得Stack Context或者ValueStack中的数据。为了解决这个问题，Struts2提供了StrutsPrepareFilter和StrutsExecuteFilter类（在2.1.3版本前是ActionContextCleanUp和FilterDispatcher），通过它们协同来确保SiteMesh正常工作。</p>

<p>在WEB-INF下添加decorators.xml文档：
```
&lt;?xml version="1.0" encoding="utf-8"?>
<decorators defaultdir="/layouts"></p>

<pre><code>&lt;excludes&gt;
    &lt;pattern&gt;/stylesheets/*&lt;/pattern&gt;
    &lt;pattern&gt;/javascripts/*&lt;/pattern&gt;
    &lt;pattern&gt;/images/*&lt;/pattern&gt;
&lt;/excludes&gt;

&lt;decorator name="application" page="application.jsp"&gt;
    &lt;pattern&gt;/*&lt;/pattern&gt;
&lt;/decorator&gt;
</code></pre>

<p></decorators>
```</p>

<p>stylesheets、javascripts、images目录下的内容是不需要被修饰的，可以把它们放到execludes块中排除掉。</p>

<p>新建/layouts/application.jsp模版页：
```
&lt;%@ taglib uri="/struts-tags" prefix="s" %>
&lt;%@ taglib uri="<a href="http://www.opensymphony.com/sitemesh/decorator">http://www.opensymphony.com/sitemesh/decorator</a>" prefix="decorator" %></p>

<p>&lt;!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>&lt;decorator:title default="JBookShelf" /></title>
&lt;decorator:head />
</head></p>

<p><body></p>

<pre><code>&lt;div&gt;
    &lt;s:if test="#session.user_session_key != null"&gt;
    &lt;s:a action="listBook"&gt;All Books&lt;/s:a&gt;
    Welcome, you have logined.
    &lt;s:a action="logout"&gt;Logout&lt;/s:a&gt;
    &lt;/s:if&gt;
    &lt;s:else&gt;
    &lt;s:a action="login!input"&gt;Login&lt;/s:a&gt; |
    &lt;s:a action="register!input"&gt;Register&lt;/s:a&gt;
    &lt;/s:else&gt;
&lt;/div&gt;
&lt;hr /&gt;
&lt;div&gt;Navigation&lt;/div&gt;
&lt;hr /&gt;
&lt;decorator:body /&gt;
&lt;hr /&gt;
&lt;div&gt;Footer&lt;/div&gt;
</code></pre>

<p></body>
</html>
```</p>

<p>代码下载：<a href="https://github.com/dohkoos/JBookShelf">https://github.com/dohkoos/JBookShelf</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何解决含有中文的页面末尾内容会被SiteMesh截掉的问题]]></title>
    <link href="http://codemany.com/blog/2005/07/22/how-to-solve-sitemesh-truncate-the-page-containing-chinese-character/"/>
    <updated>2005-07-22T14:33:59+08:00</updated>
    <id>http://codemany.com/blog/2005/07/22/how-to-solve-sitemesh-truncate-the-page-containing-chinese-character</id>
    <content type="html"><![CDATA[<p>首先我们先要了解一下ServletResponse.setContentLength(int len)的含义。setContentLength是设置返回内容体长度的方法，len是内容体的长度。由于网络上传输内容是以字节（byte）为单位的，所以len就是指内容体有多少个字节。假设现在有长度为100个字节的数据，在输出数据到客户端前我们用setContentLength(90)设置内容体的长度为90个字节。那么在客户端接收到的数据长度就是90个字节而不是100。下面我们来做个试验：</p>

<p>```
public class PageTruncateFilter implements Filter {</p>

<pre><code>public void init(FilterConfig config) throws ServletException {
}

public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
                    throws IOException, ServletException {
    HttpServletRequest request = (HttpServletRequest)req;
    HttpServletResponse response = (HttpServletResponse)res;

    String content = "&lt;html&gt;&lt;head&gt;&lt;title&gt;Truncated Page&lt;/title&gt;&lt;/head&gt;";
           content += "&lt;body&gt;这个页面的内容will be truncated.&lt;/body&gt;&lt;/html&gt;";
    response.setCharacterEncoding("gbk");
    response.setContentLength(content.length());
    PrintWriter out = response.getWriter();
    out.println(content);
    out.close();
}

public void destroy() {
}
</code></pre>

<p>}
```</p>

<p>由于content字符串含有两个中文字符，每一个中文字符又是由两个字节组成，所以content.length()的值比content的字节数要少2。在客户端显示的内容也会因此少2个字节，即缺少“l>”这两个字符。</p>

<p>现在我们来浏览SiteMesh的源码找出问题的原因。首先从PageFilter.java的doFilter方法开始。由于页面没有在decorators.xml中注册修饰，所以writeOriginal方法会被调用。下面是writeOriginal方法的源代码：</p>

<p>```
/<em>* Write the original page data to the response. </em>/
private void writeOriginal(HttpServletRequest request, HttpServletResponse response,</p>

<pre><code>                      Page page) throws IOException {
response.setContentLength(page.getContentLength());

if (request.getAttribute(USING_STREAM).equals(Boolean.TRUE)) {
    PrintWriter writer = new PrintWriter(response.getOutputStream());
    page.writePage(writer);
    // flush writer to underlying outputStream
    writer.flush();
    response.getOutputStream().flush();
} else {
    page.writePage(response.getWriter());
    response.getWriter().flush();
}
</code></pre>

<p>}
```</p>

<p>首行代码就是设置内容体长度的，让我们追到page.getContentLength()里面去看看（Page接口的getContentLength方法是由AbstractPage.java实现的）：</p>

<p>```
public int getContentLength() {</p>

<pre><code>return pageData.length;
</code></pre>

<p>}
```</p>

<p>它返回pageData数组的长度。但是pageData数组是char类型的，假如pageData中有中文内容时，设置的内容体长度就会小于pageData的字节数。这时就会出现输出到客户端的数据截掉的问题。所以只要修改getContentLength方法返回的值就可以了，下面是修改后的getContentLength方法：</p>

<p>```
public int getContentLength() {</p>

<pre><code>String content = new String(pageData);
return content.getBytes().length;
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
</feed>
