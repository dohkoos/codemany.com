<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: PowerBuilder | 乐者为王]]></title>
  <link href="http://codemany.com/tags/powerbuilder/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2014-11-19T18:10:15+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PowerBuilder生成可执行文件的小技巧]]></title>
    <link href="http://codemany.com/blog/tips-for-creating-executable-file-in-powerbuilder/"/>
    <updated>2013-03-29T14:10:04+08:00</updated>
    <id>http://codemany.com/blog/tips-for-creating-executable-file-in-powerbuilder</id>
    <content type="html"><![CDATA[<p>1、使用资源文件（.pbr）引用资源</p>

<p>在资源相同目录下建立.pbr文件，其中列出在应用中动态引用的资源文件，每行一个资源，格式如下：</p>

<pre><code>appico.ico
appbmp1.bmp
appbmp2.bmp
appbmp3.bmp
appbmp4.bmp
</code></pre>

<p>在.pbr文件中指定的文件名必须与在脚本中引用的资源匹配，若引用时包含路径，则在.pbr中也必须包含同一路径，否则因PowerBuilder在执行时只是简单地进行字符串比较而导致无法发现该资源。</p>

<p>2、设置可执行文件图标</p>

<p>应用 -> 属性 -> General -> Additional Properties按钮 -> Icon标签页 -> Icon Name</p>

<p>3、可执行文件所需的环境DLL</p>

<p>最简便的方式是使用自带的打包程序PowerBuilder Runtime Packager。这个应用会自动把脱离环境运行所需的DLL等文件筛选出来。运行后会生成一个MSI应用，执行下就可以解压出需要的DLL文件了。</p>

<p>4、Deploy时出现“The current library list is different”信息</p>

<p>在生成可执行文件时经常会碰到这样的异常情况。Debug没问题，Run没问题，Incremental Build或Full Build也没问题，但在Deploy时就出现：</p>

<blockquote><p>The current library list is different than the library list contained within this project. The project library list has been updated. specify build options for the updated list and try again.</p></blockquote>

<p>上面的信息告诉我们当前的库列表和项目配置中的库列表不一致，但明明先前在其它机器上可以Deploy成功的呀！几经周折，终于找到了原因。</p>

<p>首先导出项目配置文件example.srj，可以看到Deploy失败时的配置内容为：</p>

<pre><code>CMP:0,0,0,2,0,0
COM:
DES:
CPY:
PRD:
PVS:1,0,0,x
PVN:1,0,0,x
FVS:1,0,0,x
FVN:1,0,0,x
PBD:C:\example\example.pbl,,0
</code></pre>

<p>最后一行表明库文件在C盘？可当前的项目文件都是在D盘啊！修改路径后导入配置，点击Deploy按钮，执行成功。</p>

<pre><code>CMP:0,0,0,2,0,0
COM:
DES:
CPY:
PRD:
PVS:1,0,0,x
PVN:1,0,0,x
FVS:1,0,0,x
FVN:1,0,0,x
PBD:D:\example\example.pbl,,0
</code></pre>

<p>总结了下原因，出现这种失败通常是实际库文件路径和项目配置中的库文件路径不一致导致。修改项目配置或删除重建项目配置就没问题了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DataWindow的数据缓冲区]]></title>
    <link href="http://codemany.com/blog/datawindows-data-buffer/"/>
    <updated>2009-10-15T09:03:29+08:00</updated>
    <id>http://codemany.com/blog/datawindows-data-buffer</id>
    <content type="html"><![CDATA[<p>在PowerBuilder中，DataWindow是用来存储和操纵数据的对象。在每个DataWindow对象中都有4个二维表作为数据缓冲区来存储数据。用户在DataWindow中对数据的操作实际上都是将数据在这几个缓冲区中进行修改和移动，最后在用户提交数据库时，系统根据这四个缓冲区中的信息形成SQL的INSERT、UPDATE、DELETE等语句。这四个缓冲区是：</p>

<p>Primary Buffer</p>

<p>这个缓冲区是存放填充窗口中DataWindow控件的数据的，调用DataWindow控件的Retrieve()函数和InsertRow()函数可以将数据填入这个缓冲区中。当使用有关DataWindow删除和过滤函数时，相应记录将从这一缓冲区中删除。而在执行DataWindow的Update()函数时，PowerBuilder将查看这一缓冲区中的记录以形成INSERT和UPDATE语句。</p>

<p>Delete Buffer</p>

<p>这个缓冲区保存的是用DeleteRow()函数从Primary Buffer中删除的记录，执行Update()函数时，系统根据这一缓冲区的记录形成DELETE语句。</p>

<p>Filter Buffer</p>

<p>这个缓冲区存储的是从Original Buffer使用Filter()函数过滤到Primary Buffer中后剩余的记录。</p>

<p>Original Buffer</p>

<p>这一缓冲区存储的是DataWindow最初执行Retrieve()函数时得到的全部记录。当提交数据库时，根据Primary Buffer生成的UPDATE语句和根据Delete Buffer生成的DELETE语句都要依据这一缓冲区来构造这些SQL语句中的WHERE子句。</p>

<p>Original Buffer由PowerBuilder内部维护，PowerBuilder所提供的任何函数都无法改变它的值，不过通过PowerBuilder所提供的GetItem系列函数可以读出DataWindow最初从数据库中查到的原始值。通过这些函数我们可以编程实现所谓的Undo功能，并且得到在使用乐观锁时形成提交数据库的WHERE子句。如果您当前使用的DataWindow没有设置修改的权力，您将不能对Delete Buffer和Original Buffer进行操作，而且当调用Update()时也将引起系统错误。</p>

<p>Primary Buffer和Delete Buffer都有行级和列级的状态值，这个状态值是一个枚举类型。在提交时由该行的状态值来决定是否要产生SQL语句，其中Primary Buffer产生的是INSERT和UPDATE语句，而Delete Buffer产生的是DELETE语句。我们用GetItemStatus()函数和SetItemStatus()函数可以对这一状态值进行操纵。这一枚举状态有以下四种：</p>

<pre><code>NotModified! —— 指定单元的数据和原始数据相同，没有发生改变。
DataModified! —— 指定单元的数据和原始数据不同，发生了改变。
New! —— 该数据行是新增加的，但数据没有发生改变（数据为空或缺省值）。
NewModified! —— 该数据行是新增加的，且数据已发生改变（用户键盘输入或调用SetItem()函数）。
</code></pre>

<p>在上面的这四个值中，NotModifed!和DataModified!可以表示行和列的状态，而New!和NewModified!只可以表示行的状态。</p>

<p>让我们来看一个实例。有这样一张表，表中有3个字段，其中item是主键。</p>

<pre><code>item CHAR(5)
name CHAR(20)
quantity INT
</code></pre>

<p>在代码中我们查询这张表的记录，得到以下的这些信息，它们被存储在Primary Buffer和Origianal Buffer中。</p>

<p>{% img /uploads/dwbuffer-1.png dwbuffer-1 %}</p>

<p>在窗口中，我们过滤掉数量为0的行，并且加上一个空行：</p>

<pre><code>dw_1.SetFilter("quantity=0")
dw_1.Filter()
dw_1.InsertRow()
</code></pre>

<p>这时Primary Buffer的状态为：</p>

<p>{% img /uploads/dwbuffer-2.png dwbuffer-2 %}</p>

<p>在Filter Buffer中的记录为：</p>

<p>{% img /uploads/dwbuffer-3.png dwbuffer-3 %}</p>

<p>用户在新插入行中输入数据，删除了第3行数据，并修改了第2行数据。当他离开这个DataWindow时，Primary Buffer和Delete Buffer的状态如下：</p>

<p>{% img /uploads/dwbuffer-4.png dwbuffer-4 %}</p>

<p>{% img /uploads/dwbuffer-5.png dwbuffer-5 %}</p>

<p>这时执行dw_1.Update()函数，系统将基于这两个缓冲区生成SQL语句。</p>

<p>{% img /uploads/dwbuffer-6.png dwbuffer-6 %}</p>

<p>在Primary Buffer中，状态为NotModified!和New!的行将被忽略而不产生SQL语句。状态为DataModified!的行将产生UPDATE语句，状态为NewModified!的行将产生INSERT语句，在Delete Buffer中的行将产生DELETE语句。使用DataWindow的Reset()函数和Retrieve()函数以及改变DataObject属性时，系统将重置这几个缓冲区。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何设置数据窗口中某行某列的背景颜色]]></title>
    <link href="http://codemany.com/blog/how-to-setup-background-color-of-cell-on-datawindow/"/>
    <updated>2008-10-18T20:25:59+08:00</updated>
    <id>http://codemany.com/blog/how-to-setup-background-color-of-cell-on-datawindow</id>
    <content type="html"><![CDATA[<p>假设数据窗口有多行数据，在修改某个Cell的数据后希望能将该Cell的背景色变成红色，代码该如何写呢？</p>

<p>要对某行某列的属性进行更改，可以使用modify函数。在对某行某列的属性进行改变时，你需要先判断当前行是否是被修改数据的那行，如果知道行号的话（例如在itemchanged事件中），你可以使用下面的代码：</p>

<pre><code>dw_main.modify(ls_colname + "background.color = '0~tIf(getrow() = " + string(row) + ", 255, 16777215)'")
</code></pre>

<p>当然，你也可以这么写：</p>

<pre><code>dw_main.modify(ls_colname + "background.color = '0~tIf(getrow() = currentrow(), 255, 16777215)'")
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用ANTLR构建PowerScript语法分析器（4）]]></title>
    <link href="http://codemany.com/blog/using-antlr-to-build-powerscript-grammar-parser-part4/"/>
    <updated>2008-04-26T22:17:05+08:00</updated>
    <id>http://codemany.com/blog/using-antlr-to-build-powerscript-grammar-parser-part4</id>
    <content type="html"><![CDATA[<p>什么是表达式</p>

<p>简单的来说，表达式就是操作数和操作符根据语法规则结合后的结果，它通常被用来执行在变量或值上的操作处理。</p>

<p>主表达式（Primary Expression）</p>

<p>到现在PowerScript的词法分析已经写的差不多了，接下来就要开始写语法分析。语法分析的主要组成部分是表达式（expression），而表达式的主要组成部分则是主表达式。主表达式包含了大部分简单的表达式，如字面量（literals），字段存取，方法调用和数组存取等。带圆括号的表达式通常也被认为是主表达式。其常见形式如下：</p>

<pre><code>(x)
x.y
f(x)
a[x]
x++
x--
new
</code></pre>

<p>当直接子类存有和父类相同签名的事件或函数时，可以通过super调用父类的事件或函数，但是：</p>

<ol>
<li>它不能调用父类中控件的脚本（猜测super后只能跟随“::”符号）；</li>
<li>它只能在直接子类的函数或事件中调用父类的事件或函数。</li>
</ol>


<p>在哪些脚本中可以使用parent：</p>

<ol>
<li>窗口中的控件，此时parent指代包含该控件的窗口；</li>
<li>定制的用户对象中的控件，这时parent指代定制的用户对象；</li>
<li>菜单，这时候parent指代该菜单的上一级菜单。</li>
</ol>


<p>收集的一些语句：</p>

<pre><code>this.ls_array[1]
this.event pfc_addrow()
this.event rowfocuschanged(ll_row)
this.uo_1.function hallo()
post function column_order_update_from_grid()
event ue_process()

close(parent)
parent.enabled
parent.hide()
parent.event ue_postconstructor()
parent.function static trigger wf_process( )

super::create
super::clicked;
super::event clicked()
super::event clicked(xpos, ypos, row, dwo)
super::of_remove_tail(anv_tailnode)
super::event trigger selectionchanging(oldindex, newindex)

iu_tab_postings.post of_enable_sort(dw_main, dw_detail, false)
w_main.event doubleclicked(flags, xpos, ypos)
dw_main.event pfc_retrieve()
cb_ok.event trigger clicked()
cb_ok.triggerevent(clicked!)
</code></pre>

<p>主表达式语法：</p>

<pre><code>primary_expression
    : '(' expression ')'
    | IDENTIFIER '!'?                   // build-in constant
    | literal
    | '::' IDENTIFIER                   // global variables
    | call_type IDENTIFIER arguments    // example: post function to_string()
    | 'create' 'using'? (STRING_LITERAL|IDENTIFIER)
    | 'destroy' IDENTIFIER
    | 'super' '::' call_type? IDENTIFIER arguments?
    | object_name ('.' IDENTIFIER)* identifier_suffix?
    ;

object_name
    : 'this'
    | 'parent'
    | IDENTIFIER
    ;

call_type
    : ( 'function'
      | 'event'
      | 'static'
      | 'dynamic'
      | 'trigger'
      | 'post'
      )+
    ;

identifier_suffix
    : arguments ('.' IDENTIFIER arguments)*    // cascaded calling
    | '[' expression_list? ']'
    | call_type IDENTIFIER arguments
    ;

arguments
    : '(' expression_list? ')'
    ;

literal
    : STRING_LITERAL
    | INTEGER_LITERAL
    | FLOAT_LITERAL
    | BOOLEAN_LITERAL
    ;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PowerBuilder中如何调用默认的邮件客户端]]></title>
    <link href="http://codemany.com/blog/how-to-call-the-default-mail-client-in-powerbuilder/"/>
    <updated>2007-09-20T00:17:40+08:00</updated>
    <id>http://codemany.com/blog/how-to-call-the-default-mail-client-in-powerbuilder</id>
    <content type="html"><![CDATA[<p>在某个窗口上有一个文字超链接（StaticHyperLink控件），点击后就打开默认的邮件客户端，并且把指定收件人的邮件地址填写到收件人地址栏中。</p>

<p>如果在StaticHyperLink控件的URL中使用mailto协议，的确能够做到上述的要求。但是有个问题是在打开邮件客户端前总是先打开一个IE窗口，这样使得用户的体验非常差。而PowerBuilder自带的mailsession对象则只能调用Outlook Express，根本就不用考虑。</p>

<p>查找资料后发现可以通过调用外部函数ShellExecute来解决这个问题。首先在Global/Local External Functions中添加如下声明：</p>

<pre><code>function ulong ShellExecuteA(ulong hwnd, &amp;
                            string lpOperation, &amp;
                            string lpFile, &amp;
                            string lpParameters, &amp;
                            string lpDirectory, &amp;
                            long nShowCmd) library "shell32"
</code></pre>

<p>然后在StaticHyperLink控件的Clicked事件中添加代码：</p>

<pre><code>string ls_null

SetNull(ls_null)
ShellExecuteA(Handle(parent), &amp;
            "open", &amp;
            "mailto:yourname@example.com", &amp;
            ls_null, &amp;
            ls_null, &amp;
            1)    // SW_SHOWNORMAL
</code></pre>

<p>还有要注意4个string类型的参数，一定是string xxx，千万不要使用下面这种声明方式：</p>

<pre><code>function ulong ShellExecuteA(ulong hwnd, &amp;
                             ref string lpOperation, &amp;
                             ref string lpFile, &amp;
                             ref string lpParameters, &amp;
                             ref string lpDirectory, &amp;
                             long nShowCmd) library "shell32"
</code></pre>

<p>刚开始的时候我就使用了这种声明方式，结果每次程序执行到ShellExecuteA时都会弹出一个异常对话框，搞的我非常郁闷。</p>
]]></content>
  </entry>
  
</feed>
