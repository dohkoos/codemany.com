<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: PowerBuilder | 乐者为王]]></title>
  <link href="http://codemany.com/tags/powerbuilder/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2017-04-09T22:38:01+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PBL文件格式解析]]></title>
    <link href="http://codemany.com/blog/pbl-file-format-analysis/"/>
    <updated>2015-12-13T17:33:08+08:00</updated>
    <id>http://codemany.com/blog/pbl-file-format-analysis</id>
    <content type="html"><![CDATA[<p>PBL文件是PowerBuilder库文件，在其中存储了应用程序所使用到的所有系统对象和用户自定义对象的集合，同时PBL文件中还存储了源代码控制信息（Source Code Control，简称SCC）。对其文件格式的研究，可以准确地了解程序结构并能对PBL文件中的对象进行修改，同时也有利于库文件的修复，程序动态执行等方面的工作。</p>

<h3 id="pbl文件的存储结构">PBL文件的存储结构</h3>

<p>PBL文件存储信息时是以块（Block）为单位为对象分配存储空间的，每个块的大小固定为512字节，块号从0开始计算，块号与块首字节的偏移地址有如下关系：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">块号 = 块首字节的偏移地址 / 512
</code></pre></div>
<p>整个PBL文件由Header块、Bitmap块、Node块、Data块组成。其中除Header块外，其它块均以链表结构组织，其中Data块是Node块中Entry表项的具体内容，是从属于Node块的。下图说明了这些块的关系。</p>

<p><img src="/uploads/pbl-datastruct.png" title="pbl-datastruct" ></p>

<p>图中Header块、首个Bitmap块及首个Node块在存储空间上是相邻的，其中Node块比较特别，占6个块共3072字节，其余块只占512字节，其空间大小及起始地址如下表所示：</p>

<table><thead>
<tr>
<th style="text-align: right">块号</th>
<th>地址范围</th>
<th>描述</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: right">0</td>
<td>0000-01FF</td>
<td>Header块</td>
</tr>
<tr>
<td style="text-align: right">1</td>
<td>0200-03FF</td>
<td>首个Bitmap块</td>
</tr>
<tr>
<td style="text-align: right">2-7</td>
<td>0400-0FFF</td>
<td>首个Node块</td>
</tr>
</tbody></table>

<h3 id="header块解析">Header块解析</h3>

<p>Header块是整个PBL的描述信息，它包含了PBL的版本标志，库注释，首个SCC数据块的偏移地址等信息。具体内容如下表所示：</p>

<table><thead>
<tr>
<th>块内地址范围</th>
<th>所占字节</th>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead><tbody>
<tr>
<td>0000-0003</td>
<td>4</td>
<td>char</td>
<td>&#39;HDR*&#39;</td>
</tr>
<tr>
<td>0004-0011</td>
<td>14</td>
<td>char</td>
<td>&#39;PowerBuilder&#39; + 0x00 + 0x00</td>
</tr>
<tr>
<td>0012-0015</td>
<td>4</td>
<td>char</td>
<td>PBL格式版本（如0900表示9.0版本）</td>
</tr>
<tr>
<td>0016-0019</td>
<td>4</td>
<td>long</td>
<td>创建/修改日期时间</td>
</tr>
<tr>
<td>001A-001B</td>
<td>2</td>
<td>byte</td>
<td>保留</td>
</tr>
<tr>
<td>001C-011B</td>
<td>256</td>
<td>char</td>
<td>库注释</td>
</tr>
<tr>
<td>011C-011F</td>
<td>4</td>
<td>long</td>
<td>首个SCC数据块的偏移地址</td>
</tr>
<tr>
<td>0120-0123</td>
<td>4</td>
<td>long</td>
<td>SCC数据块实际大小</td>
</tr>
<tr>
<td>0124-01FF</td>
<td>220</td>
<td>byte</td>
<td>保留</td>
</tr>
</tbody></table>

<h3 id="bitmap块解析">Bitmap块解析</h3>

<p>Bitmap块中存放的是表示PBL文件存储空间的使用情况。该块数据结构如下表所示：</p>

<table><thead>
<tr>
<th>块内地址范围</th>
<th>所占字节</th>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead><tbody>
<tr>
<td>0000-0003</td>
<td>4</td>
<td>char</td>
<td>&#39;FRE*&#39;</td>
</tr>
<tr>
<td>0004-0007</td>
<td>4</td>
<td>long</td>
<td>下一个Bitmap块的偏移地址或0</td>
</tr>
<tr>
<td>0008-01FF</td>
<td>504</td>
<td>bit</td>
<td>位图（每个位标识一个块）</td>
</tr>
</tbody></table>

<p>由上表可知，包含一个Bitmap块的PBL文件最多可使用504 * 8 = 4032个块。当文件空间超过4032个块时，就需要使用第二个Bitmap块，它的偏移地址由当前Bitmap块块内偏移0004-0007处的值表示。如果是最后一个Bitmap块，则对应的字节处为00 00 00 00，即偏移地址为0。这样就形成了Bitmap块的单向链表。</p>

<p><img src="/uploads/bitmap-block-chain.png" title="bitmap-block-chain" ></p>

<p>位图用于标识块的使用/空闲情况。在位图中为1的位，表示与该位序号对应的块已被使用；反之，表示对应块未使用。例如FF FF 40 00还原为位图则为11111111 11111111 01000000 00000000，该位图表示PBL文件共有18个块，其中的第16号块空闲未使用。</p>

<p><strong>注意：在实际分析多个PBL文件后发现，位图中的位并不能真实反映对应块的空闲/使用情况，只是记录PBL文件使用了多少个块。</strong></p>

<h3 id="node块解析">Node块解析</h3>

<p>Node块是目录块，主要用于存放Entry目录表项。下表是Node块的数据结构：</p>

<table><thead>
<tr>
<th>块内地址范围</th>
<th>所占字节</th>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead><tbody>
<tr>
<td>0000-0003</td>
<td>4</td>
<td>char</td>
<td>&#39;NOD*&#39;</td>
</tr>
<tr>
<td>0004-0007</td>
<td>4</td>
<td>long</td>
<td>左Node块的偏移地址或0</td>
</tr>
<tr>
<td>0008-001B</td>
<td>4</td>
<td>long</td>
<td>父Node块的偏移地址或0</td>
</tr>
<tr>
<td>000C-000F</td>
<td>4</td>
<td>long</td>
<td>右Node块的偏移地址或0</td>
</tr>
<tr>
<td>0010-0011</td>
<td>2</td>
<td>short</td>
<td>块内可用空间（初始值3040）</td>
</tr>
<tr>
<td>0012-0013</td>
<td>2</td>
<td>short</td>
<td>按字母顺序最后一个对象名的位置</td>
</tr>
<tr>
<td>0014-0015</td>
<td>2</td>
<td>short</td>
<td>该Node块中的Entry表项数</td>
</tr>
<tr>
<td>0016-0017</td>
<td>2</td>
<td>short</td>
<td>按字母顺序第一个对象名的位置</td>
</tr>
<tr>
<td>0018-001F</td>
<td>8</td>
<td>char</td>
<td>保留</td>
</tr>
<tr>
<td>0020-00BF</td>
<td>3040</td>
<td>chunks</td>
<td>Entry目录表</td>
</tr>
</tbody></table>

<p>其中Entry目录表是顺序表。当一个Node块的空间不足以存储所有Entry表项时，可以再使用一个Node块来存储，并且Entry表项不能跨Node块存储，因此Node块中的空间不能完全利用，会有一定的剩余，这个值记录在块内偏移0010-0011处。</p>

<p>Node块的链接方式有些复杂，它使用一种称之为三叉链表（节点包含四个域：数据域、左指针域、右指针域、父指针域）的链式存储结构把所有Node块组织成为一颗二叉树，这可能是PowerBuilder为了提高查找速度而做的一些优化吧。</p>

<p><img src="/uploads/node-block-tree.png" title="node-block-tree" ></p>

<h3 id="entry表项解析">Entry表项解析</h3>

<p>每个Entry表项对应于一个对象的源代码或PCODE的描述信息，因此Entry目录表就是整个库中各个对象的索引表，存储了各对象的索引信息。例如，在编程中创建一个名为“pbltest”的Window对象类型，那么在Entry目录表中要存放该对象的两个索引表项，分别为“pbltest.srw”用于存储源代码，“pbltest.win”用于存储PCODE。在Entry目录表中存储的对象有以下这些：</p>

<table><thead>
<tr>
<th>对象类型</th>
<th>源代码后缀</th>
<th>PCODE后辍</th>
</tr>
</thead><tbody>
<tr>
<td>Application</td>
<td>sra</td>
<td>apl</td>
</tr>
<tr>
<td>Window</td>
<td>srw</td>
<td>win</td>
</tr>
<tr>
<td>DataWindow</td>
<td>srd</td>
<td>dwo</td>
</tr>
<tr>
<td>Menu</td>
<td>srm</td>
<td>men</td>
</tr>
<tr>
<td>Function</td>
<td>srf</td>
<td>fun</td>
</tr>
<tr>
<td>Query</td>
<td>srq</td>
<td>-</td>
</tr>
<tr>
<td>Structure</td>
<td>srs</td>
<td>str</td>
</tr>
<tr>
<td>User object</td>
<td>sru</td>
<td>udo</td>
</tr>
<tr>
<td>Pipeline</td>
<td>srp</td>
<td>-</td>
</tr>
<tr>
<td>Project</td>
<td>srj</td>
<td>-</td>
</tr>
<tr>
<td>?</td>
<td>-</td>
<td>pra</td>
</tr>
<tr>
<td>?</td>
<td>-</td>
<td>prp</td>
</tr>
</tbody></table>

<p>Entry表项的具体数据结构如下表所示：</p>

<table><thead>
<tr>
<th>块内地址范围</th>
<th>所占字节</th>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead><tbody>
<tr>
<td>0000-0003</td>
<td>4</td>
<td>char</td>
<td>&#39;ENT*&#39;</td>
</tr>
<tr>
<td>0004-0007</td>
<td>4</td>
<td>char</td>
<td>PBL格式版本（如0900表示9.0版本）</td>
</tr>
<tr>
<td>0008-000B</td>
<td>4</td>
<td>long</td>
<td>首个Data块的偏移地址</td>
</tr>
<tr>
<td>000C-000F</td>
<td>4</td>
<td>long</td>
<td>对象的实际大小</td>
</tr>
<tr>
<td>0010-0013</td>
<td>4</td>
<td>long</td>
<td>对象的创建/修改日期时间</td>
</tr>
<tr>
<td>0014-0015</td>
<td>2</td>
<td>short</td>
<td>对象的注释长度</td>
</tr>
<tr>
<td>0016-0017</td>
<td>2</td>
<td>short</td>
<td>对象名的长度</td>
</tr>
<tr>
<td>0018-????</td>
<td>?</td>
<td>char</td>
<td>对象名 + 0x00</td>
</tr>
</tbody></table>

<p>这里需要说明的是，每个Entry表项的长度并不是固定的，它随着对象名的长度变化而变化，所以要读取下一个Entry表项，只能通过计算上一个Entry表项的长度即24 + 对象名长度来得
到，或者通过搜索下一个ENT*得到。</p>

<h3 id="data块解析">Data块解析</h3>

<p>在Entry目录表中的各对象的实际数据内容是存储在Data块中的。Data块的数据结构如下表所示：</p>

<table><thead>
<tr>
<th>块内地址范围</th>
<th>所占字节</th>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead><tbody>
<tr>
<td>0000-0003</td>
<td>4</td>
<td>char</td>
<td>&#39;DAT*&#39;</td>
</tr>
<tr>
<td>0004-0007</td>
<td>4</td>
<td>char</td>
<td>下一个Data块的偏移地址或0</td>
</tr>
<tr>
<td>0008-0009</td>
<td>2</td>
<td>short</td>
<td>本块内存储的数据的实际长度</td>
</tr>
<tr>
<td>0010-01FF</td>
<td>502</td>
<td>char</td>
<td>对象的实际数据</td>
</tr>
</tbody></table>

<p>由上表可知，若对象的数据内容在502字节以上时，就需用多个Data块存放，这些Data块形成一个单向链表。链表的最后一个Data块的0004-0007中存储的偏移地址为00 00 00 00，表示链表结束。0010-01FF处存放的是对象的实际数据，只有最后一个Data块的长度有可能小于502，且以0x00字节表示结束。</p>

<p>根据上面对PBL文件格式的解析，使用Ruby开发了一个小工具，用来输出PBL文件中存储的各种信息。源代码被放在GitHub上面，供大家参考。</p>

<p>代码下载：<a href="https://github.com/dohkoos/pblanalyzer">https://github.com/dohkoos/pblanalyzer</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DataWindow的数据缓冲区]]></title>
    <link href="http://codemany.com/blog/datawindows-data-buffer/"/>
    <updated>2009-10-15T09:03:29+08:00</updated>
    <id>http://codemany.com/blog/datawindows-data-buffer</id>
    <content type="html"><![CDATA[<p>在PowerBuilder中，DataWindow是用来存储和操纵数据的对象。在每个DataWindow对象中都有4个二维表作为数据缓冲区来存储数据。用户在DataWindow中对数据的操作实际上都是将数据在这几个缓冲区中进行修改和移动，最后在用户提交数据库时，系统根据这四个缓冲区中的信息形成SQL的INSERT、UPDATE、DELETE等语句。这四个缓冲区是：</p>

<p>Primary Buffer</p>

<p>这个缓冲区是存放填充窗口中DataWindow控件的数据的，调用DataWindow控件的Retrieve()函数和InsertRow()函数可以将数据填入这个缓冲区中。当使用有关DataWindow删除和过滤函数时，相应记录将从这一缓冲区中删除。而在执行DataWindow的Update()函数时，PowerBuilder将查看这一缓冲区中的记录以形成INSERT和UPDATE语句。</p>

<p>Delete Buffer</p>

<p>这个缓冲区保存的是用DeleteRow()函数从Primary Buffer中删除的记录，执行Update()函数时，系统根据这一缓冲区的记录形成DELETE语句。</p>

<p>Filter Buffer</p>

<p>这个缓冲区存储的是从Original Buffer使用Filter()函数过滤到Primary Buffer中后剩余的记录。</p>

<p>Original Buffer</p>

<p>这一缓冲区存储的是DataWindow最初执行Retrieve()函数时得到的全部记录。当提交数据库时，根据Primary Buffer生成的UPDATE语句和根据Delete Buffer生成的DELETE语句都要依据这一缓冲区来构造这些SQL语句中的WHERE子句。</p>

<p>Original Buffer由PowerBuilder内部维护，PowerBuilder所提供的任何函数都无法改变它的值，不过通过PowerBuilder所提供的GetItem系列函数可以读出DataWindow最初从数据库中查到的原始值。通过这些函数我们可以编程实现所谓的Undo功能，并且得到在使用乐观锁时形成提交数据库的WHERE子句。如果你当前使用的DataWindow没有设置修改的权力，你将不能对Delete Buffer和Original Buffer进行操作，而且当调用Update()时也将引起系统错误。</p>

<p>Primary Buffer和Delete Buffer都有行级和列级的状态值，这个状态值是一个枚举类型。在提交时由该行的状态值来决定是否要产生SQL语句，其中Primary Buffer产生的是INSERT和UPDATE语句，而Delete Buffer产生的是DELETE语句。我们用GetItemStatus()函数和SetItemStatus()函数可以对这一状态值进行操纵。这一枚举状态有以下四种：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">NotModified! —— 指定单元的数据和原始数据相同，没有发生改变。
DataModified! —— 指定单元的数据和原始数据不同，发生了改变。
New! —— 该数据行是新增加的，但数据没有发生改变（数据为空或缺省值）。
NewModified! —— 该数据行是新增加的，且数据已发生改变（用户键盘输入或调用SetItem()函数）。
</code></pre></div>
<p>在上面的这四个值中，NotModifed!和DataModified!可以表示行和列的状态，而New!和NewModified!只可以表示行的状态。</p>

<p>让我们来看一个实例。有这样一张表，表中有3个字段，其中item是主键。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">item CHAR(5)
name CHAR(20)
quantity INT
</code></pre></div>
<p>在代码中我们查询这张表的记录，得到以下的这些信息，它们被存储在Primary Buffer和Origianal Buffer中。</p>

<p><img src="/uploads/dwbuffer-1.png" title="dwbuffer-1" ></p>

<p>在窗口中，我们过滤掉数量为0的行，并且加上一个空行：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">dw_1.SetFilter(&quot;quantity=0&quot;)
dw_1.Filter()
dw_1.InsertRow()
</code></pre></div>
<p>这时Primary Buffer的状态为：</p>

<p><img src="/uploads/dwbuffer-2.png" title="dwbuffer-2" ></p>

<p>在Filter Buffer中的记录为：</p>

<p><img src="/uploads/dwbuffer-3.png" title="dwbuffer-3" ></p>

<p>用户在新插入行中输入数据，删除了第3行数据，并修改了第2行数据。当他离开这个DataWindow时，Primary Buffer和Delete Buffer的状态如下：</p>

<p><img src="/uploads/dwbuffer-4.png" title="dwbuffer-4" ></p>

<p><img src="/uploads/dwbuffer-5.png" title="dwbuffer-5" ></p>

<p>这时执行dw_1.Update()函数，系统将基于这两个缓冲区生成SQL语句。</p>

<p><img src="/uploads/dwbuffer-6.png" title="dwbuffer-6" ></p>

<p>在Primary Buffer中，状态为NotModified!和New!的行将被忽略而不产生SQL语句。状态为DataModified!的行将产生UPDATE语句，状态为NewModified!的行将产生INSERT语句，在Delete Buffer中的行将产生DELETE语句。使用DataWindow的Reset()函数和Retrieve()函数以及改变DataObject属性时，系统将重置这几个缓冲区。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何设置数据窗口中某行某列的背景颜色]]></title>
    <link href="http://codemany.com/blog/how-to-setup-background-color-of-cell-on-datawindow/"/>
    <updated>2008-10-18T20:25:59+08:00</updated>
    <id>http://codemany.com/blog/how-to-setup-background-color-of-cell-on-datawindow</id>
    <content type="html"><![CDATA[<p>假设数据窗口有多行数据，在修改某个Cell的数据后希望能将该Cell的背景色变成红色，代码该如何写呢？</p>

<p>要对某行某列的属性进行更改，可以使用modify函数。在对某行某列的属性进行改变时，你需要先判断当前行是否是被修改数据的那行，如果知道行号的话（例如在itemchanged事件中），你可以使用下面的代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">dw_main.modify(ls_colname + &quot;background.color = &#39;0~tIf(getrow() = &quot; + string(row) + &quot;, 255, 16777215)&#39;&quot;)
</code></pre></div>
<p>当然，你也可以这么写：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">dw_main.modify(ls_colname + &quot;background.color = &#39;0~tIf(getrow() = currentrow(), 255, 16777215)&#39;&quot;)
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用ANTLR构建PowerScript语法分析器（6）]]></title>
    <link href="http://codemany.com/blog/using-antlr-to-build-powerscript-parser-part6/"/>
    <updated>2008-05-03T19:07:10+08:00</updated>
    <id>http://codemany.com/blog/using-antlr-to-build-powerscript-parser-part6</id>
    <content type="html"><![CDATA[<p>构建完表达式的语法规则后就可以开始分析语句（statement）的语法规则。不过在这之前还需要先修复两个小缺陷：没有识别日期、时间和内建常量的词法规则。</p>

<p>在PowerScript中，日期的格式是0000-00-00，年份是4位数从1000到3000，月份从01到12，天数从01到31；时间是24小时格式00:00:00:000000，秒的小数部分可有可无，最多能有6位数字，所以时间范围是从00:00:00到23:59:59:999999。内建常量则以字母开头，字母数字组合，以“!”符号结束的字符串。</p>

<p>根据这些描述我们可以得到日期、时间和内建常量的词法规则：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">DATE_LITERAL    // 1996-09-26
    : &#39;1&#39;..&#39;3&#39; &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39; &#39;-&#39; &#39;0&#39;..&#39;1&#39; &#39;0&#39;..&#39;9&#39; &#39;-&#39; &#39;0&#39;..&#39;3&#39; &#39;0&#39;..&#39;9&#39;
      {
          System.out.println(&quot;date&gt;&quot; + getText());
      }
    ;

TIME_LITERAL    // 00:00:00:000000
    : &#39;0&#39;..&#39;2&#39; &#39;0&#39;..&#39;9&#39; &#39;:&#39; &#39;0&#39;..&#39;5&#39; &#39;0&#39;..&#39;9&#39; &#39;:&#39; &#39;0&#39;..&#39;5&#39; &#39;0&#39;..&#39;9&#39;
      ( &#39;.&#39; &#39;0&#39;..&#39;9&#39;
      | &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39;
      | &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39;
      | &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39;
      | &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39;
      | &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39;
      )?
      {
          System.out.println(&quot;time&gt;&quot; + getText());
      }
    ;

ENUM_LITERAL
    : Letter (Letter|&#39;0&#39;..&#39;9&#39;)* &#39;!&#39;
      {
          System.out.println(&quot;enum&gt;&quot; + getText());
      }
    ;
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用ANTLR构建PowerScript语法分析器（5）]]></title>
    <link href="http://codemany.com/blog/using-antlr-to-build-powerscript-parser-part5/"/>
    <updated>2008-05-02T19:27:12+08:00</updated>
    <id>http://codemany.com/blog/using-antlr-to-build-powerscript-parser-part5</id>
    <content type="html"><![CDATA[<p>基本表达式的语法规则构建完毕，那么表达式的语法规则构建就颇为简单了。<a href="http://codemany.com/blog/using-antlr-to-build-powerscript-parser-part4/">使用ANTLR构建PowerScript语法分析器（4）</a>中已经说过表达式是由运算元和运算符复合组成。所以在编写表达式语法规则前先要分析下PowerScript的运算符以及它们的优先级。</p>

<p>PowerScript支持四种类型的运算符，分别是：</p>

<ul>
<li>针对数字数据类型的算术运算符，执行算术计算；</li>
<li>针对所有类型的关系运算符，比较数字，文本和布尔值；</li>
<li>针对布尔类型的逻辑运算符，执行布尔值上的关系运算符</li>
<li>针对字符串类型连接运算符，连接字符串和二进制大对象。</li>
</ul>

<h3 id="算术运算符">算术运算符</h3>

<table><thead>
<tr>
<th>Operator</th>
<th>Meaning</th>
</tr>
</thead><tbody>
<tr>
<td>+</td>
<td>Addition</td>
</tr>
<tr>
<td>-</td>
<td>Subtraction</td>
</tr>
<tr>
<td>*</td>
<td>Multiplication</td>
</tr>
<tr>
<td>/</td>
<td>Division</td>
</tr>
<tr>
<td>^</td>
<td>Exponentiation</td>
</tr>
</tbody></table>

<h3 id="关系运算符">关系运算符</h3>

<table><thead>
<tr>
<th>Operator</th>
<th>Meaning</th>
</tr>
</thead><tbody>
<tr>
<td>=</td>
<td>Equals</td>
</tr>
<tr>
<td>&gt;</td>
<td>Greater than</td>
</tr>
<tr>
<td>&lt;</td>
<td>Less than</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>Not equal</td>
</tr>
<tr>
<td>&gt;=</td>
<td>Greater than or equal</td>
</tr>
<tr>
<td>&lt;=</td>
<td>Less than or equal</td>
</tr>
</tbody></table>

<h3 id="逻辑运算符">逻辑运算符</h3>

<table><thead>
<tr>
<th>Operator</th>
<th>Meaning</th>
</tr>
</thead><tbody>
<tr>
<td>NOT</td>
<td>Logical negation</td>
</tr>
<tr>
<td>AND</td>
<td>Logical and</td>
</tr>
<tr>
<td>OR</td>
<td>Logical or</td>
</tr>
</tbody></table>

<h3 id="连接运算符">连接运算符</h3>

<table><thead>
<tr>
<th>Operator</th>
<th>Meaning</th>
</tr>
</thead><tbody>
<tr>
<td>+</td>
<td>Concatenate</td>
</tr>
</tbody></table>

<h3 id="运算符优先级">运算符优先级</h3>

<table><thead>
<tr>
<th>Operator</th>
<th>Purpose</th>
</tr>
</thead><tbody>
<tr>
<td>( )</td>
<td>Grouping (see note below on overriding)</td>
</tr>
<tr>
<td>+, -</td>
<td>Unary plus and unary minus (indicates positive or negative number)</td>
</tr>
<tr>
<td>^</td>
<td>Exponentiation</td>
</tr>
<tr>
<td>*, /</td>
<td>Multiplication and division</td>
</tr>
<tr>
<td>+, -</td>
<td>Addition and subtraction; string concatenation</td>
</tr>
<tr>
<td>=, &gt;, &lt;, &lt;=, &gt;=, &lt;&gt;</td>
<td>Relational operators</td>
</tr>
<tr>
<td>NOT</td>
<td>Negation</td>
</tr>
<tr>
<td>AND</td>
<td>Logical and</td>
</tr>
<tr>
<td>OR</td>
<td>Logical or</td>
</tr>
</tbody></table>

<p>清楚运算符和优先级后，该如何表示这些表达式的语法关系呢？有个标准的分析表达式的递归定义可以套用，大部分表达式都遵循这个模式：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">thisLevelExpression
    : nextHigherPrecedenceExpression (OPERATOR nextHigherPrecedenceExpression)*
</code></pre></div>
<p>现在我们就可以根据PowerScript的运算符优先级写出表达式的语法规则了：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">expression
    : logical_or_expression
    ;

logical_or_expression
    : logical_and_expression (&#39;or&#39; logical_and_expression)*
    ;

logical_and_expression
    : logical_not_expression (&#39;and&#39; logical_not_expression)*
    ;

logical_not_expression
    : &#39;not&#39;? relational_expression
    ;

relational_expression
    : additive_expression ((&#39;=&#39;|&#39;&gt;&#39;|&#39;&lt;&#39;|&#39;&lt;&gt;&#39;|&#39;&gt;=&#39;|&#39;&lt;=&#39;) additive_expression)*
    ;

additive_expression
    : multiplicative_expression ((&#39;+&#39;|&#39;-&#39;) multiplicative_expression)*
    ;

multiplicative_expression
    : exponentive_expression ((&#39;*&#39;|&#39;/&#39;) exponentive_expression)*
    ;

exponentive_expression
    : unary_expression (&#39;^&#39; unary_expression)*
    ;

unary_expression
    : (&#39;+&#39;|&#39;-&#39;)? primary_expression
    ;
</code></pre></div>]]></content>
  </entry>
  
</feed>
