<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: PowerBuilder | 乐者为王]]></title>
  <link href="http://codemany.com/tags/powerbuilder/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2017-12-25T15:35:03+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PBL文件格式解析]]></title>
    <link href="http://codemany.com/blog/pbl-file-format-analysis/"/>
    <updated>2015-12-13T17:33:08+08:00</updated>
    <id>http://codemany.com/blog/pbl-file-format-analysis</id>
    <content type="html"><![CDATA[<p>PBL文件是PowerBuilder库文件，在其中存储了应用程序所使用到的所有系统对象和用户自定义对象的集合，同时PBL文件中还存储了源代码控制信息（Source Code Control，简称SCC）。对其文件格式的研究，可以准确地了解程序结构并能对PBL文件中的对象进行修改，同时也有利于库文件的修复，程序动态执行等方面的工作。</p>

<h3 id="pbl文件的存储结构">PBL文件的存储结构</h3>

<p>PBL文件存储信息时是以块（Block）为单位为对象分配存储空间的，每个块的大小固定为512字节，块号从0开始计算，块号与块首字节的偏移地址有如下关系：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">块号 = 块首字节的偏移地址 / 512
</code></pre></div>
<p>整个PBL文件由Header块、Bitmap块、Node块、Data块组成。其中除Header块外，其它块均以链表结构组织，其中Data块是Node块中Entry表项的具体内容，是从属于Node块的。下图说明了这些块的关系。</p>

<p><img src="/uploads/pbl-datastruct.png" alt="pbl-datastruct"></p>

<p>图中Header块、首个Bitmap块及首个Node块在存储空间上是相邻的，其中Node块比较特别，占6个块共3072字节，其余块只占512字节，其空间大小及起始地址如下表所示：</p>

<table><thead>
<tr>
<th style="text-align: right">块号</th>
<th>地址范围</th>
<th>描述</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: right">0</td>
<td>0000-01FF</td>
<td>Header块</td>
</tr>
<tr>
<td style="text-align: right">1</td>
<td>0200-03FF</td>
<td>首个Bitmap块</td>
</tr>
<tr>
<td style="text-align: right">2-7</td>
<td>0400-0FFF</td>
<td>首个Node块</td>
</tr>
</tbody></table>

<h3 id="header块解析">Header块解析</h3>

<p>Header块是整个PBL的描述信息，它包含了PBL的版本标志，库注释，首个SCC数据块的偏移地址等信息。具体内容如下表所示：</p>

<table><thead>
<tr>
<th>块内地址范围</th>
<th>所占字节</th>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead><tbody>
<tr>
<td>0000-0003</td>
<td>4</td>
<td>char</td>
<td>&#39;HDR*&#39;</td>
</tr>
<tr>
<td>0004-0011</td>
<td>14</td>
<td>char</td>
<td>&#39;PowerBuilder&#39; + 0x00 + 0x00</td>
</tr>
<tr>
<td>0012-0015</td>
<td>4</td>
<td>char</td>
<td>PBL格式版本（如0900表示9.0版本）</td>
</tr>
<tr>
<td>0016-0019</td>
<td>4</td>
<td>long</td>
<td>创建/修改日期时间</td>
</tr>
<tr>
<td>001A-001B</td>
<td>2</td>
<td>byte</td>
<td>保留</td>
</tr>
<tr>
<td>001C-011B</td>
<td>256</td>
<td>char</td>
<td>库注释</td>
</tr>
<tr>
<td>011C-011F</td>
<td>4</td>
<td>long</td>
<td>首个SCC数据块的偏移地址</td>
</tr>
<tr>
<td>0120-0123</td>
<td>4</td>
<td>long</td>
<td>SCC数据块实际大小</td>
</tr>
<tr>
<td>0124-01FF</td>
<td>220</td>
<td>byte</td>
<td>保留</td>
</tr>
</tbody></table>

<h3 id="bitmap块解析">Bitmap块解析</h3>

<p>Bitmap块中存放的是表示PBL文件存储空间的使用情况。该块数据结构如下表所示：</p>

<table><thead>
<tr>
<th>块内地址范围</th>
<th>所占字节</th>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead><tbody>
<tr>
<td>0000-0003</td>
<td>4</td>
<td>char</td>
<td>&#39;FRE*&#39;</td>
</tr>
<tr>
<td>0004-0007</td>
<td>4</td>
<td>long</td>
<td>下一个Bitmap块的偏移地址或0</td>
</tr>
<tr>
<td>0008-01FF</td>
<td>504</td>
<td>bit</td>
<td>位图（每个位标识一个块）</td>
</tr>
</tbody></table>

<p>由上表可知，包含一个Bitmap块的PBL文件最多可使用504 * 8 = 4032个块。当文件空间超过4032个块时，就需要使用第二个Bitmap块，它的偏移地址由当前Bitmap块块内偏移0004-0007处的值表示。如果是最后一个Bitmap块，则对应的字节处为00 00 00 00，即偏移地址为0。这样就形成了Bitmap块的单向链表。</p>

<p><img src="/uploads/bitmap-block-chain.png" alt="bitmap-block-chain"></p>

<p>位图用于标识块的使用/空闲情况。在位图中为1的位，表示与该位序号对应的块已被使用；反之，表示对应块未使用。例如FF FF 40 00还原为位图则为11111111 11111111 01000000 00000000，该位图表示PBL文件共有18个块，其中的第16号块空闲未使用。</p>

<p><strong>注意：在实际分析多个PBL文件后发现，位图中的位并不能真实反映对应块的空闲/使用情况，只是记录PBL文件使用了多少个块。</strong></p>

<h3 id="node块解析">Node块解析</h3>

<p>Node块是目录块，主要用于存放Entry目录表项。下表是Node块的数据结构：</p>

<table><thead>
<tr>
<th>块内地址范围</th>
<th>所占字节</th>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead><tbody>
<tr>
<td>0000-0003</td>
<td>4</td>
<td>char</td>
<td>&#39;NOD*&#39;</td>
</tr>
<tr>
<td>0004-0007</td>
<td>4</td>
<td>long</td>
<td>左Node块的偏移地址或0</td>
</tr>
<tr>
<td>0008-001B</td>
<td>4</td>
<td>long</td>
<td>父Node块的偏移地址或0</td>
</tr>
<tr>
<td>000C-000F</td>
<td>4</td>
<td>long</td>
<td>右Node块的偏移地址或0</td>
</tr>
<tr>
<td>0010-0011</td>
<td>2</td>
<td>short</td>
<td>块内可用空间（初始值3040）</td>
</tr>
<tr>
<td>0012-0013</td>
<td>2</td>
<td>short</td>
<td>按字母顺序最后一个对象名的位置</td>
</tr>
<tr>
<td>0014-0015</td>
<td>2</td>
<td>short</td>
<td>该Node块中的Entry表项数</td>
</tr>
<tr>
<td>0016-0017</td>
<td>2</td>
<td>short</td>
<td>按字母顺序第一个对象名的位置</td>
</tr>
<tr>
<td>0018-001F</td>
<td>8</td>
<td>char</td>
<td>保留</td>
</tr>
<tr>
<td>0020-00BF</td>
<td>3040</td>
<td>chunks</td>
<td>Entry目录表</td>
</tr>
</tbody></table>

<p>其中Entry目录表是顺序表。当一个Node块的空间不足以存储所有Entry表项时，可以再使用一个Node块来存储，并且Entry表项不能跨Node块存储，因此Node块中的空间不能完全利用，会有一定的剩余，这个值记录在块内偏移0010-0011处。</p>

<p>Node块的链接方式有些复杂，它使用一种称之为三叉链表（节点包含四个域：数据域、左指针域、右指针域、父指针域）的链式存储结构把所有Node块组织成为一颗二叉树，这可能是PowerBuilder为了提高查找速度而做的一些优化吧。</p>

<p><img src="/uploads/node-block-tree.png" alt="node-block-tree"></p>

<h3 id="entry表项解析">Entry表项解析</h3>

<p>每个Entry表项对应于一个对象的源代码或PCODE的描述信息，因此Entry目录表就是整个库中各个对象的索引表，存储了各对象的索引信息。例如，在编程中创建一个名为“pbltest”的Window对象类型，那么在Entry目录表中要存放该对象的两个索引表项，分别为“pbltest.srw”用于存储源代码，“pbltest.win”用于存储PCODE。在Entry目录表中存储的对象有以下这些：</p>

<table><thead>
<tr>
<th>对象类型</th>
<th>源代码后缀</th>
<th>PCODE后辍</th>
</tr>
</thead><tbody>
<tr>
<td>Application</td>
<td>sra</td>
<td>apl</td>
</tr>
<tr>
<td>Window</td>
<td>srw</td>
<td>win</td>
</tr>
<tr>
<td>DataWindow</td>
<td>srd</td>
<td>dwo</td>
</tr>
<tr>
<td>Menu</td>
<td>srm</td>
<td>men</td>
</tr>
<tr>
<td>Function</td>
<td>srf</td>
<td>fun</td>
</tr>
<tr>
<td>Query</td>
<td>srq</td>
<td>-</td>
</tr>
<tr>
<td>Structure</td>
<td>srs</td>
<td>str</td>
</tr>
<tr>
<td>User object</td>
<td>sru</td>
<td>udo</td>
</tr>
<tr>
<td>Pipeline</td>
<td>srp</td>
<td>-</td>
</tr>
<tr>
<td>Project</td>
<td>srj</td>
<td>-</td>
</tr>
<tr>
<td>?</td>
<td>-</td>
<td>pra</td>
</tr>
<tr>
<td>?</td>
<td>-</td>
<td>prp</td>
</tr>
</tbody></table>

<p>Entry表项的具体数据结构如下表所示：</p>

<table><thead>
<tr>
<th>块内地址范围</th>
<th>所占字节</th>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead><tbody>
<tr>
<td>0000-0003</td>
<td>4</td>
<td>char</td>
<td>&#39;ENT*&#39;</td>
</tr>
<tr>
<td>0004-0007</td>
<td>4</td>
<td>char</td>
<td>PBL格式版本（如0900表示9.0版本）</td>
</tr>
<tr>
<td>0008-000B</td>
<td>4</td>
<td>long</td>
<td>首个Data块的偏移地址</td>
</tr>
<tr>
<td>000C-000F</td>
<td>4</td>
<td>long</td>
<td>对象的实际大小</td>
</tr>
<tr>
<td>0010-0013</td>
<td>4</td>
<td>long</td>
<td>对象的创建/修改日期时间</td>
</tr>
<tr>
<td>0014-0015</td>
<td>2</td>
<td>short</td>
<td>对象的注释长度</td>
</tr>
<tr>
<td>0016-0017</td>
<td>2</td>
<td>short</td>
<td>对象名的长度</td>
</tr>
<tr>
<td>0018-????</td>
<td>?</td>
<td>char</td>
<td>对象名 + 0x00</td>
</tr>
</tbody></table>

<p>这里需要说明的是，每个Entry表项的长度并不是固定的，它随着对象名的长度变化而变化，所以要读取下一个Entry表项，只能通过计算上一个Entry表项的长度即24 + 对象名长度来得
到，或者通过搜索下一个ENT*得到。</p>

<h3 id="data块解析">Data块解析</h3>

<p>在Entry目录表中的各对象的实际数据内容是存储在Data块中的。Data块的数据结构如下表所示：</p>

<table><thead>
<tr>
<th>块内地址范围</th>
<th>所占字节</th>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead><tbody>
<tr>
<td>0000-0003</td>
<td>4</td>
<td>char</td>
<td>&#39;DAT*&#39;</td>
</tr>
<tr>
<td>0004-0007</td>
<td>4</td>
<td>char</td>
<td>下一个Data块的偏移地址或0</td>
</tr>
<tr>
<td>0008-0009</td>
<td>2</td>
<td>short</td>
<td>本块内存储的数据的实际长度</td>
</tr>
<tr>
<td>0010-01FF</td>
<td>502</td>
<td>char</td>
<td>对象的实际数据</td>
</tr>
</tbody></table>

<p>由上表可知，若对象的数据内容在502字节以上时，就需用多个Data块存放，这些Data块形成一个单向链表。链表的最后一个Data块的0004-0007中存储的偏移地址为00 00 00 00，表示链表结束。0010-01FF处存放的是对象的实际数据，只有最后一个Data块的长度有可能小于502，且以0x00字节表示结束。</p>

<p>根据上面对PBL文件格式的解析，使用Ruby开发了一个小工具，用来输出PBL文件中存储的各种信息。源代码被放在GitHub上面，供大家参考。</p>

<p>代码下载：<a href="https://github.com/dohkoos/pblanalyzer">https://github.com/dohkoos/pblanalyzer</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[身份证工具IDCardTool]]></title>
    <link href="http://codemany.com/blog/idcardtool-tool-for-chinese-identity-card/"/>
    <updated>2007-09-16T11:42:20+08:00</updated>
    <id>http://codemany.com/blog/idcardtool-tool-for-chinese-identity-card</id>
    <content type="html"><![CDATA[<p>周末赶了两天，终于把这个工具完成了。界面几乎完全仿制了“身份证生成与查询BBSt（共享版）”。</p>

<p><img src="/uploads/ict-main.png" alt="ict-main"></p>

<h3 id="中国居民身份证的常识">中国居民身份证的常识</h3>

<p>我国现行使用公民身份证号码有两种尊循两个国家标准，〖GB 11643-1989〗和〖GB 11643-1999〗。</p>

<p>〖GB 11643-1989〗中规定的是15位身份证号码：排列顺序从左至右依次为：六位数字地址码，六位数字出生日期码，三位数字顺序码，其中出生日期码不包含世纪数。</p>

<p><img src="/uploads/ict-15.png" alt="ict-15"></p>

<p>〖GB 11643-1999〗中规定的是18位身份证号码：排列顺序从左至右依次为：六位数字地址码，八位数字出生日期码，三位数字顺序码，一位数字校验码。</p>

<p><img src="/uploads/ict-18.png" alt="ict-18"></p>

<ol>
<li>地址码：表示编码对象常住户口所在县（市、旗、区）的<a href="http://www.stats.gov.cn/tjsj/tjbz/xzqhdm/">行政区划代码</a>。</li>
<li>出生日期码：表示编码对象出生的年、月、日，年、月、日之间不用分隔符。</li>
<li>顺序码：表示同一地址码所标识的区域范围内，对同年、同月、同日出生的人员编定的顺序号。顺序码的奇数分给男性，偶数分给女性。</li>
<li>校验码：根据前面十七位数字码，按照国际标准ISO 7064:1983.MOD 11-2规定的校验算法计算出来的检验码。</li>
</ol>

<p>关于身份证号码最后一位校验码的算法如下：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&amp;sum;(a[i] * W[i]) mod 11 (i = 2, 3, ..., 18)
</code></pre></div>
<ul>
<li>*：表示乘号；</li>
<li>i：表示身份证号码每一位字符的位置序号，从右至左，最左侧为18，最右侧为1；</li>
<li>a[i]：表示身份证号码第i位上的号码数字值；</li>
<li>W[i]：表示第i位上的加权因子，其数值依据公式W[i] = 2<sup>i-1</sup> mod 11计算得出。</li>
</ul>

<p>设：R = &sum;(a[i] * W[i]) mod 11 (i = 2, 3, ..., 18)，C = 身份证号码的校验码，则R和C之间的对应关系如下表：</p>

<p><img src="/uploads/ict-check.png" alt="ict-check"></p>

<p>由此看出Ⅹ相当于10（罗马数字中的10就是用Ⅹ表示），所以在新标准的身份证号码中可能含有非数字的字母Ⅹ。</p>

<p>代码下载：<a href="https://github.com/dohkoos/IDCardTool">https://github.com/dohkoos/IDCardTool</a></p>
]]></content>
  </entry>
  
</feed>
