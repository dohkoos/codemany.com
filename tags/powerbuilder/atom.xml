<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: PowerBuilder | 乐者为王]]></title>
  <link href="http://codemany.com/tags/powerbuilder/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2016-10-04T16:31:40+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PBL文件格式解析]]></title>
    <link href="http://codemany.com/blog/pbl-file-format-analysis/"/>
    <updated>2015-12-13T17:33:08+08:00</updated>
    <id>http://codemany.com/blog/pbl-file-format-analysis</id>
    <content type="html"><![CDATA[<p>PBL文件是PowerBuilder库文件，在其中存储了应用程序所使用到的所有系统对象和用户自定义对象的集合，同时PBL文件中还存储了源代码控制信息（Source Code Control，简称SCC）。对其文件格式的研究，可以准确地了解程序结构并能对PBL文件中的对象进行修改，同时也有利于库文件的修复，程序动态执行等方面的工作。</p>

<h3 id="pbl文件的存储结构">PBL文件的存储结构</h3>

<p>PBL文件存储信息时是以块（Block）为单位为对象分配存储空间的，每个块的大小固定为512字节，块号从0开始计算，块号与块首字节的偏移地址有如下关系：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">块号 = 块首字节的偏移地址 / 512
</code></pre></div>
<p>整个PBL文件由Header块、Bitmap块、Node块、Data块组成。其中除Header块外，其它块均以链表结构组织，其中Data块是Node块中Entry表项的具体内容，是从属于Node块的。下图说明了这些块的关系。</p>

<p><img src="/uploads/pbl-datastruct.png" title="pbl-datastruct" ></p>

<p>图中Header块、首个Bitmap块及首个Node块在存储空间上是相邻的，其中Node块比较特别，占6个块共3072字节，其余块只占512字节，其空间大小及起始地址如下表所示：</p>

<table><thead>
<tr>
<th style="text-align: right">块号</th>
<th>地址范围</th>
<th>描述</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: right">0</td>
<td>0000-01FF</td>
<td>Header块</td>
</tr>
<tr>
<td style="text-align: right">1</td>
<td>0200-03FF</td>
<td>首个Bitmap块</td>
</tr>
<tr>
<td style="text-align: right">2-7</td>
<td>0400-0FFF</td>
<td>首个Node块</td>
</tr>
</tbody></table>

<h3 id="header块解析">Header块解析</h3>

<p>Header块是整个PBL的描述信息，它包含了PBL的版本标志，库注释，首个SCC数据块的偏移地址等信息。具体内容如下表所示：</p>

<table><thead>
<tr>
<th>块内地址范围</th>
<th>所占字节</th>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead><tbody>
<tr>
<td>0000-0003</td>
<td>4</td>
<td>char</td>
<td>&#39;HDR*&#39;</td>
</tr>
<tr>
<td>0004-0011</td>
<td>14</td>
<td>char</td>
<td>&#39;PowerBuilder&#39; + 0x00 + 0x00</td>
</tr>
<tr>
<td>0012-0015</td>
<td>4</td>
<td>char</td>
<td>PBL格式版本（如0900表示9.0版本）</td>
</tr>
<tr>
<td>0016-0019</td>
<td>4</td>
<td>long</td>
<td>创建/修改日期时间</td>
</tr>
<tr>
<td>001A-001B</td>
<td>2</td>
<td>byte</td>
<td>保留</td>
</tr>
<tr>
<td>001C-011B</td>
<td>256</td>
<td>char</td>
<td>库注释</td>
</tr>
<tr>
<td>011C-011F</td>
<td>4</td>
<td>long</td>
<td>首个SCC数据块的偏移地址</td>
</tr>
<tr>
<td>0120-0123</td>
<td>4</td>
<td>long</td>
<td>SCC数据块实际大小</td>
</tr>
<tr>
<td>0124-01FF</td>
<td>220</td>
<td>byte</td>
<td>保留</td>
</tr>
</tbody></table>

<h3 id="bitmap块解析">Bitmap块解析</h3>

<p>Bitmap块中存放的是表示PBL文件存储空间的使用情况。该块数据结构如下表所示：</p>

<table><thead>
<tr>
<th>块内地址范围</th>
<th>所占字节</th>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead><tbody>
<tr>
<td>0000-0003</td>
<td>4</td>
<td>char</td>
<td>&#39;FRE*&#39;</td>
</tr>
<tr>
<td>0004-0007</td>
<td>4</td>
<td>long</td>
<td>下一个Bitmap块的偏移地址或0</td>
</tr>
<tr>
<td>0008-01FF</td>
<td>504</td>
<td>bit</td>
<td>位图（每个位标识一个块）</td>
</tr>
</tbody></table>

<p>由上表可知，包含一个Bitmap块的PBL文件最多可使用504 * 8 = 4032个块。当文件空间超过4032个块时，就需要使用第二个Bitmap块，它的偏移地址由当前Bitmap块块内偏移0004-0007处的值表示。如果是最后一个Bitmap块，则对应的字节处为00 00 00 00，即偏移地址为0。这样就形成了Bitmap块的单向链表。</p>

<p><img src="/uploads/bitmap-block-chain.png" title="bitmap-block-chain" ></p>

<p>位图用于标识块的使用/空闲情况。在位图中为1的位，表示与该位序号对应的块已被使用；反之，表示对应块未使用。例如FF FF 40 00还原为位图则为11111111 11111111 01000000 00000000，该位图表示PBL文件共有18个块，其中的第16号块空闲未使用。</p>

<p><strong>注意：在实际分析多个PBL文件后发现，位图中的位并不能真实反映对应块的空闲/使用情况，只是记录PBL文件使用了多少个块。</strong></p>

<h3 id="node块解析">Node块解析</h3>

<p>Node块是目录块，主要用于存放Entry目录表项。下表是Node块的数据结构：</p>

<table><thead>
<tr>
<th>块内地址范围</th>
<th>所占字节</th>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead><tbody>
<tr>
<td>0000-0003</td>
<td>4</td>
<td>char</td>
<td>&#39;NOD*&#39;</td>
</tr>
<tr>
<td>0004-0007</td>
<td>4</td>
<td>long</td>
<td>左Node块的偏移地址或0</td>
</tr>
<tr>
<td>0008-001B</td>
<td>4</td>
<td>long</td>
<td>父Node块的偏移地址或0</td>
</tr>
<tr>
<td>000C-000F</td>
<td>4</td>
<td>long</td>
<td>右Node块的偏移地址或0</td>
</tr>
<tr>
<td>0010-0011</td>
<td>2</td>
<td>short</td>
<td>块内可用空间（初始值3040）</td>
</tr>
<tr>
<td>0012-0013</td>
<td>2</td>
<td>short</td>
<td>按字母顺序最后一个对象名的位置</td>
</tr>
<tr>
<td>0014-0015</td>
<td>2</td>
<td>short</td>
<td>该Node块中的Entry表项数</td>
</tr>
<tr>
<td>0016-0017</td>
<td>2</td>
<td>short</td>
<td>按字母顺序第一个对象名的位置</td>
</tr>
<tr>
<td>0018-001F</td>
<td>8</td>
<td>char</td>
<td>保留</td>
</tr>
<tr>
<td>0020-00BF</td>
<td>3040</td>
<td>chunks</td>
<td>Entry目录表</td>
</tr>
</tbody></table>

<p>其中Entry目录表是顺序表。当一个Node块的空间不足以存储所有Entry表项时，可以再使用一个Node块来存储，并且Entry表项不能跨Node块存储，因此Node块中的空间不能完全利用，会有一定的剩余，这个值记录在块内偏移0010-0011处。</p>

<p>Node块的链接方式有些复杂，它使用一种称之为三叉链表（节点包含四个域：数据域、左指针域、右指针域、父指针域）的链式存储结构把所有Node块组织成为一颗二叉树，这可能是PowerBuilder为了提高查找速度而做的一些优化吧。</p>

<p><img src="/uploads/node-block-tree.png" title="node-block-tree" ></p>

<h3 id="entry表项解析">Entry表项解析</h3>

<p>每个Entry表项对应于一个对象的源代码或PCODE的描述信息，因此Entry目录表就是整个库中各个对象的索引表，存储了各对象的索引信息。例如，在编程中创建一个名为“pbltest”的Window对象类型，那么在Entry目录表中要存放该对象的两个索引表项，分别为“pbltest.srw”用于存储源代码，“pbltest.win”用于存储PCODE。在Entry目录表中存储的对象有以下这些：</p>

<table><thead>
<tr>
<th>对象类型</th>
<th>源代码后缀</th>
<th>PCODE后辍</th>
</tr>
</thead><tbody>
<tr>
<td>Application</td>
<td>sra</td>
<td>apl</td>
</tr>
<tr>
<td>Window</td>
<td>srw</td>
<td>win</td>
</tr>
<tr>
<td>DataWindow</td>
<td>srd</td>
<td>dwo</td>
</tr>
<tr>
<td>Menu</td>
<td>srm</td>
<td>men</td>
</tr>
<tr>
<td>Function</td>
<td>srf</td>
<td>fun</td>
</tr>
<tr>
<td>Query</td>
<td>srq</td>
<td>-</td>
</tr>
<tr>
<td>Structure</td>
<td>srs</td>
<td>str</td>
</tr>
<tr>
<td>User object</td>
<td>sru</td>
<td>udo</td>
</tr>
<tr>
<td>Pipeline</td>
<td>srp</td>
<td>-</td>
</tr>
<tr>
<td>Project</td>
<td>srj</td>
<td>-</td>
</tr>
<tr>
<td>?</td>
<td>-</td>
<td>pra</td>
</tr>
<tr>
<td>?</td>
<td>-</td>
<td>prp</td>
</tr>
</tbody></table>

<p>Entry表项的具体数据结构如下表所示：</p>

<table><thead>
<tr>
<th>块内地址范围</th>
<th>所占字节</th>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead><tbody>
<tr>
<td>0000-0003</td>
<td>4</td>
<td>char</td>
<td>&#39;ENT*&#39;</td>
</tr>
<tr>
<td>0004-0007</td>
<td>4</td>
<td>char</td>
<td>PBL格式版本（如0900表示9.0版本）</td>
</tr>
<tr>
<td>0008-000B</td>
<td>4</td>
<td>long</td>
<td>首个Data块的偏移地址</td>
</tr>
<tr>
<td>000C-000F</td>
<td>4</td>
<td>long</td>
<td>对象的实际大小</td>
</tr>
<tr>
<td>0010-0013</td>
<td>4</td>
<td>long</td>
<td>对象的创建/修改日期时间</td>
</tr>
<tr>
<td>0014-0015</td>
<td>2</td>
<td>short</td>
<td>对象的注释长度</td>
</tr>
<tr>
<td>0016-0017</td>
<td>2</td>
<td>short</td>
<td>对象名的长度</td>
</tr>
<tr>
<td>0018-????</td>
<td>?</td>
<td>char</td>
<td>对象名 + 0x00</td>
</tr>
</tbody></table>

<p>这里需要说明的是，每个Entry表项的长度并不是固定的，它随着对象名的长度变化而变化，所以要读取下一个Entry表项，只能通过计算上一个Entry表项的长度即24 + 对象名长度来得
到，或者通过搜索下一个ENT*得到。</p>

<h3 id="data块解析">Data块解析</h3>

<p>在Entry目录表中的各对象的实际数据内容是存储在Data块中的。Data块的数据结构如下表所示：</p>

<table><thead>
<tr>
<th>块内地址范围</th>
<th>所占字节</th>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead><tbody>
<tr>
<td>0000-0003</td>
<td>4</td>
<td>char</td>
<td>&#39;DAT*&#39;</td>
</tr>
<tr>
<td>0004-0007</td>
<td>4</td>
<td>char</td>
<td>下一个Data块的偏移地址或0</td>
</tr>
<tr>
<td>0008-0009</td>
<td>2</td>
<td>short</td>
<td>本块内存储的数据的实际长度</td>
</tr>
<tr>
<td>0010-01FF</td>
<td>502</td>
<td>char</td>
<td>对象的实际数据</td>
</tr>
</tbody></table>

<p>由上表可知，若对象的数据内容在502字节以上时，就需用多个Data块存放，这些Data块形成一个单向链表。链表的最后一个Data块的0004-0007中存储的偏移地址为00 00 00 00，表示链表结束。0010-01FF处存放的是对象的实际数据，只有最后一个Data块的长度有可能小于502，且以0x00字节表示结束。</p>

<p>根据上面对PBL文件格式的解析，使用Ruby开发了一个小工具，用来输出PBL文件中存储的各种信息。源代码被放在GitHub上面，供大家参考。</p>

<p>代码下载：<a href="https://github.com/dohkoos/pblanalyzer">https://github.com/dohkoos/pblanalyzer</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DataWindow的数据缓冲区]]></title>
    <link href="http://codemany.com/blog/datawindows-data-buffer/"/>
    <updated>2009-10-15T09:03:29+08:00</updated>
    <id>http://codemany.com/blog/datawindows-data-buffer</id>
    <content type="html"><![CDATA[<p>在PowerBuilder中，DataWindow是用来存储和操纵数据的对象。在每个DataWindow对象中都有4个二维表作为数据缓冲区来存储数据。用户在DataWindow中对数据的操作实际上都是将数据在这几个缓冲区中进行修改和移动，最后在用户提交数据库时，系统根据这四个缓冲区中的信息形成SQL的INSERT、UPDATE、DELETE等语句。这四个缓冲区是：</p>

<p>Primary Buffer</p>

<p>这个缓冲区是存放填充窗口中DataWindow控件的数据的，调用DataWindow控件的Retrieve()函数和InsertRow()函数可以将数据填入这个缓冲区中。当使用有关DataWindow删除和过滤函数时，相应记录将从这一缓冲区中删除。而在执行DataWindow的Update()函数时，PowerBuilder将查看这一缓冲区中的记录以形成INSERT和UPDATE语句。</p>

<p>Delete Buffer</p>

<p>这个缓冲区保存的是用DeleteRow()函数从Primary Buffer中删除的记录，执行Update()函数时，系统根据这一缓冲区的记录形成DELETE语句。</p>

<p>Filter Buffer</p>

<p>这个缓冲区存储的是从Original Buffer使用Filter()函数过滤到Primary Buffer中后剩余的记录。</p>

<p>Original Buffer</p>

<p>这一缓冲区存储的是DataWindow最初执行Retrieve()函数时得到的全部记录。当提交数据库时，根据Primary Buffer生成的UPDATE语句和根据Delete Buffer生成的DELETE语句都要依据这一缓冲区来构造这些SQL语句中的WHERE子句。</p>

<p>Original Buffer由PowerBuilder内部维护，PowerBuilder所提供的任何函数都无法改变它的值，不过通过PowerBuilder所提供的GetItem系列函数可以读出DataWindow最初从数据库中查到的原始值。通过这些函数我们可以编程实现所谓的Undo功能，并且得到在使用乐观锁时形成提交数据库的WHERE子句。如果你当前使用的DataWindow没有设置修改的权力，你将不能对Delete Buffer和Original Buffer进行操作，而且当调用Update()时也将引起系统错误。</p>

<p>Primary Buffer和Delete Buffer都有行级和列级的状态值，这个状态值是一个枚举类型。在提交时由该行的状态值来决定是否要产生SQL语句，其中Primary Buffer产生的是INSERT和UPDATE语句，而Delete Buffer产生的是DELETE语句。我们用GetItemStatus()函数和SetItemStatus()函数可以对这一状态值进行操纵。这一枚举状态有以下四种：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">NotModified! —— 指定单元的数据和原始数据相同，没有发生改变。
DataModified! —— 指定单元的数据和原始数据不同，发生了改变。
New! —— 该数据行是新增加的，但数据没有发生改变（数据为空或缺省值）。
NewModified! —— 该数据行是新增加的，且数据已发生改变（用户键盘输入或调用SetItem()函数）。
</code></pre></div>
<p>在上面的这四个值中，NotModifed!和DataModified!可以表示行和列的状态，而New!和NewModified!只可以表示行的状态。</p>

<p>让我们来看一个实例。有这样一张表，表中有3个字段，其中item是主键。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">item CHAR(5)
name CHAR(20)
quantity INT
</code></pre></div>
<p>在代码中我们查询这张表的记录，得到以下的这些信息，它们被存储在Primary Buffer和Origianal Buffer中。</p>

<p><img src="/uploads/dwbuffer-1.png" title="dwbuffer-1" ></p>

<p>在窗口中，我们过滤掉数量为0的行，并且加上一个空行：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">dw_1.SetFilter(&quot;quantity=0&quot;)
dw_1.Filter()
dw_1.InsertRow()
</code></pre></div>
<p>这时Primary Buffer的状态为：</p>

<p><img src="/uploads/dwbuffer-2.png" title="dwbuffer-2" ></p>

<p>在Filter Buffer中的记录为：</p>

<p><img src="/uploads/dwbuffer-3.png" title="dwbuffer-3" ></p>

<p>用户在新插入行中输入数据，删除了第3行数据，并修改了第2行数据。当他离开这个DataWindow时，Primary Buffer和Delete Buffer的状态如下：</p>

<p><img src="/uploads/dwbuffer-4.png" title="dwbuffer-4" ></p>

<p><img src="/uploads/dwbuffer-5.png" title="dwbuffer-5" ></p>

<p>这时执行dw_1.Update()函数，系统将基于这两个缓冲区生成SQL语句。</p>

<p><img src="/uploads/dwbuffer-6.png" title="dwbuffer-6" ></p>

<p>在Primary Buffer中，状态为NotModified!和New!的行将被忽略而不产生SQL语句。状态为DataModified!的行将产生UPDATE语句，状态为NewModified!的行将产生INSERT语句，在Delete Buffer中的行将产生DELETE语句。使用DataWindow的Reset()函数和Retrieve()函数以及改变DataObject属性时，系统将重置这几个缓冲区。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用ANTLR构建PowerScript语法分析器（9）]]></title>
    <link href="http://codemany.com/blog/using-antlr-to-build-powerscript-parser-part9/"/>
    <updated>2009-04-09T19:30:37+08:00</updated>
    <id>http://codemany.com/blog/using-antlr-to-build-powerscript-parser-part9</id>
    <content type="html"><![CDATA[<p>续行符和分隔符</p>

<h3 id="续行（statement-continuation）">续行（Statement Continuation）</h3>

<p>通常情况下，PowerScript的一条语句书写在一行上，语句书写完毕后，按Enter键转到下一行，开始下一条语句。有时候，为了阅读方便等原因，需要把一条语句书写在几行上，这时就需要使用续行符了。PowerScript的续行符是“&amp;”字符，它放在一行的末尾指示下一行是当前行的继续，并且续行符必须是一行的最后一个字符。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">LINE_CONTINUATION
    : &#39;&amp;&#39; NEWLINE
    ;
</code></pre></div>
<ol>
<li>注释中的续行符不起作用，会被认为是注释的一部分；</li>
<li>字符串字面量支持续行符；</li>
<li>SQL语句中的续行符被认作是SQL语句的一部分，导致在运行时引起错误；</li>
<li>续行符的作用是连接语句，所以在标识符中使用会导致不能通过编译；</li>
</ol>

<p>PowerScript是否支持变量名的续行？</p>

<blockquote>
<p>Do not split a line by inserting the continuation character within a variable name. This causes an error and the statement fails.</p>
</blockquote>

<p>经过实际测试V9.0 Build 5507、V9.0.1 Build 7171和V8.0.3 Build 9704都不支持变量名的续行。</p>

<h3 id="续行符-amp-的处理">续行符(&amp;)的处理</h3>

<p>经过这段时间的学习，发现在语法分析中处理续行是个非常麻烦的事，譬如在if语句中，if和then后都可以有续行符，</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&#39;if&#39; LINE_CONTINUATION expression &#39;then&#39; LINE_CONTINUATION statement
</code></pre></div>
<p>这样写既麻烦又影响可读性
是否可以将续行符(&amp;\r\n)当作WS处理</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">WS
    :   &#39; &#39;
    |   &#39;&amp;&#39; &#39;\r&#39; &#39;\n&#39;
    {
        &lt;&lt;action&gt;&gt;
    }
    ;
</code></pre></div>
<p>在词法分析器之前，把续行符(&#39;&amp;\r\n&#39;)转化为空格</p>

<p>在PowerScript中语句通常以分隔符结束。PowerScript语句可以以行结束符(\r\n)及分号(;)结束；嵌入SQL语句必须以“;”结束。</p>

<p>PowerScript是以行为单位的语言</p>

<p>在PB中，逗号(,)和分号(;)被当作分隔符</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&gt;&gt; Statement separation
semicolon(;)
Statement1; statement2

Delimiters
The following tokens are used as delimiters.
( ) [ ] { } &lt; &gt; : , ;


&gt;&gt; Detecting statement terminator
It is common for statements to be optionally terminated by a new line or a semicolon.
(Python, VisualBasic, Bash, etc.)

There is also a distinction between physical source lines and logical source
lines. A backslash acts as a logical line continuation character. A physical line
ending in a backslash will be joined with the next physical line to represent a
single logical line. Logical line continuations also exist for content between the
delimiter pairs (), {} and []. The following code example is treated as a single
logical line.
a = [1;
     2]
The NEWLINE token represents the end of a logical line. The example above
therefore consists of the following tokens a = [ 1 ; 2 ] NEWLINE.

&amp; ampersand [&#39;æmpərsænd]
; semicolon
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用ANTLR构建PowerScript语法分析器（8）]]></title>
    <link href="http://codemany.com/blog/using-antlr-to-build-powerscript-parser-part8/"/>
    <updated>2009-03-25T21:26:42+08:00</updated>
    <id>http://codemany.com/blog/using-antlr-to-build-powerscript-parser-part8</id>
    <content type="html"><![CDATA[<p>申明和定义</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用ANTLR构建PowerScript语法分析器（7）]]></title>
    <link href="http://codemany.com/blog/using-antlr-to-build-powerscript-parser-part7/"/>
    <updated>2009-02-13T17:59:25+08:00</updated>
    <id>http://codemany.com/blog/using-antlr-to-build-powerscript-parser-part7</id>
    <content type="html"><![CDATA[<p>耽搁这么长的时间，现在终于要开始分析语句了。</p>

<p>语句通常出现在命令式语言中，主要是用来告诉计算机执行某些操作。语句不像表达式，它通常没有返回值，所以语句只能一条接一条的纵向结合。</p>

<p>在PowerScript中，赋值被当作语句来处理。例如A=B=0，因为B=0必须要有返回值，所以它不是赋值语句，而是关系表达式，它其实相当于A=(B==0)。PowerScript也没有表达式语句（expression statement）这个说法，纯粹的表达式后跟分隔符会报语法错误，函数调用是个例外。</p>

<p>语句不同于声明，声明不会让计算机做任何事，但会去学习一些事情。</p>

<p>赋值语句左值分析</p>

<p>如何处理赋值运算符(=)和关系运算符(=)使用同一个字符(=)的问题</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">f(x)[g(y)] = answer = 42

simple_assign: (simple_assign_expr ASSIGN)+ expr;
simple_assign_expr: (variable_name)
    | (STAR variable_name)
    | (variable_name &#39;(&#39; (variable_name | integer_constant) &#39;)&#39; );

I constantly got errors when replacing the code between the LBRACKET and RBRACKET with an generic expression.
or
simple_assign: expr (ASSIGN expr)+;
</code></pre></div>
<p>PowerScript支持如下的几种语句：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Assignment
CALL
CHOOSE CASE
CONTINUE
CREATE
DESTROY
DO...LOOP
EXIT
FOR...NEXT
GOTO
HALT
IF...THEN
RETURN
THROW
THROWS
TRY CATCH FINALLY END TRY
</code></pre></div><div class="highlight"><pre><code class="language-text" data-lang="text">halt [close]    // 遇到不包含CLOSE参数的HALT语句时，应用程序立即终止。
                // 遇到包含CLOSE的时候，应用先执行CLOSE事件所对应的处理程序，然后再终止应用程序

&#39;create&#39; &#39;using&#39;? (STRING_LITERAL|IDENTIFIER)
&#39;destroy&#39; IDENTIFIER

call w_ancestor::event ue_process()
call ancestorobject {`controlname}::event
call w_response::create
m_bud_master`m_file
</code></pre></div>
<p>完整的语法定义如下：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">// S t a t e m e n t
compound_statement
    :   (declaration|statement)*
//    |   statement*
    ;
call_statement
    :   &#39;call&#39; expression &#39;;&#39;
//    |   &#39;call&#39; &#39;super&#39; &#39;::&#39; IDENTIFIER
//    |   &#39;call&#39; IDENTIFIER (&#39;`&#39; IDENTIFIER)* &#39;::&#39; call_type? IDENTIFIER arguments?
    ;

statement_list
    :   statement (SEMICOLON? statement)* SEMICOLON?
    ;

labeled_statement
    :   IDENTIFIER &#39;:&#39; statement
    ;

selection_statement
// 形式：1, 2, 3 或 1 to 9 或 IS &gt; 9 或 6, 6 to 16, IS &gt; 36
    :   &#39;if&#39; expression &#39;then&#39; statement (&#39;else&#39; statement)?
    |   &#39;if&#39; expression &#39;then&#39;
            statement* /*compound_statement*/
        (&#39;elseif&#39; expression &#39;then&#39;
            statement/*compound_statement*/)*
        (&#39;else&#39;
            statement/*compound_statement*/)?
        &#39;end&#39; &#39;if&#39;
    | &#39;choose&#39; &#39;case&#39; expression
          (&#39;case&#39; expression_list /*expression*/
                statement* /*compound_statement*/)+
            (&#39;case&#39; &#39;else&#39;
                statement* /*compound_statement*/)?
      &#39;end&#39; &#39;choose&#39;
    ;

iteration_statement
    :   &#39;for&#39; IDENTIFIER &#39;=&#39; expression &#39;to&#39; expression (&#39;step&#39; expression)?
//    :   &#39;for&#39; IDENTIFIER &#39;=&#39; range_expression (&#39;step&#39; expression)?
            statement* /*compound_statement*/
        &#39;next&#39;
    |   &#39;do&#39; (&#39;until&#39;|&#39;while&#39;) expression /*boolean_expression*/
            statement* /*compound_statement*/
        &#39;loop&#39;
    |   &#39;do&#39;
            statement* /*compound_statement*/
        &#39;loop&#39; (&#39;until&#39;|&#39;while&#39;) expression /*boolean_expression*/
    ;

jump_statement
    :   &#39;goto&#39; IDENTIFIER
    |   &#39;continue&#39;
    |   &#39;exit&#39;
    |   &#39;return&#39; expression?
    |   &#39;halt&#39; &#39;close&#39;?
    ;

exception_statement
    :   &#39;try&#39;
            statement*
        (&#39;catch&#39; &#39;(&#39; IDENTIFIER IDENTIFIER &#39;)&#39;
            statement*)*
        (&#39;finally&#39;
            statement*)?
        &#39;end&#39; &#39;try&#39;
    ;

if_statement
    :   &#39;if&#39; expression &#39;then&#39;
            statement
        (elseif_statement)?
        &#39;end&#39; &#39;if&#39;
    ;

elseif_statement
    :   &#39;elseif&#39; expression &#39;then&#39;
            statement
        (elseif_statement|else_statement)?
    ;

else_statement
    :   &#39;else&#39; statement
    ;
</code></pre></div>]]></content>
  </entry>
  
</feed>
