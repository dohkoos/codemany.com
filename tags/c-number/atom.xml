<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: C# | 乐者为王]]></title>
  <link href="http://codemany.com/tags/c-number/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2014-11-05T11:52:45+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C#开发BHO插件UrlTrack]]></title>
    <link href="http://codemany.com/blog/develop-bho-plugin-urltrack-with-csharp/"/>
    <updated>2008-01-23T17:53:24+08:00</updated>
    <id>http://codemany.com/blog/develop-bho-plugin-urltrack-with-csharp</id>
    <content type="html"><![CDATA[<p>最近忽然突发奇想，想统计一下我最经常上的网站是哪些，并且在这些网站上都停留了多久。为此决定写一个BHO插件来做这件事。</p>

<p>BHO（Browser Help Objects）是实现了特定接口（IObjectWithSite）的COM组件。开发好的BHO插件除了要在注册表中注册为COM Server外，还必须将它的CLSID在HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Browser Helper Objects下注册为子键。每当浏览器[1]启动时，首先会在上述注册表位置查看是否有注册的BHO CLSID，如果有则分别创建一个实例，并对BHO实例进行初始化。BHO实例运行在浏览器的地址空间内，能对可访问的对象（如窗口、模块等等）执行任何操作，且因为它依附于浏览器的主窗口，所以其生命周期与浏览器实例的生命周期一致。下图演示了BHO的创建过程：</p>

<p><img src="/uploads/bho-process.png" title="bho-process" ></p>

<p>下面就来介绍一下如何开发BHO插件。首先创建一个C#项目，类型为Class Library。然后将Class1.cs改名为IObjectWithSite.cs，还要给IObjectWithSite添加两个功能：GetSite和SetSite。</p>

<pre><code>Public Interface Iobjectwithsite
{
    [Preservesig]
    Int Setsite([Marshalas(Unmanagedtype.Iunknown)]Object Site);
    [Preservesig]
    Int Getsite(Ref Guid Guid, Out Intptr Ppvsite);
}
</code></pre>

<p>添加一个UrlTrack.cs文件，并且实现IObjectWithSite接口。使用BHO还需要添加两个引用SHDocVw.dll和MSHTML.dll，可以在Windows\System32目录下找到。</p>

<p><img src="/uploads/bho-references.png" title="bho-references" ></p>

<p>在IObjectWithSite.cs中，还需要为我们的程序指出IE的GUID，使得它可以挂接（attach）到IE上：</p>

<pre><code>[
ComVisible(true),
InterfaceType(ComInterfaceType.InterfaceIsIUnknown),
Guid("FC4801A3-2BA9-11CF-A229-00AA003D7352")
]
</code></pre>

<p>另外，还需要给BHO程序分配一个GUID，这个可以通过System.Guid.NewGuid()方法得到。</p>

<pre><code>[
ComVisible(true),
Guid("e90da13b-117a-4178-8111-0f712da09ff9"),
ClassInterface(ClassInterfaceType.None)
]
</code></pre>

<p>在UrlTrack.cs中，我们还需要写两个方法用来DLL注册和移除注册。</p>

<pre><code>public static string BHOKEYNAME = @"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Browser Helper Objects";

[ComRegisterFunction]
public static void RegisterBHO(Type type)
{
    RegistryKey registryKey = Registry.LocalMachine.OpenSubKey(BHO_KEY_NAME, true);
    if (registryKey == null)
    {
        registryKey = Registry.LocalMachine.CreateSubKey(BHO_KEY_NAME);
    }

    string guid = type.GUID.ToString("B");
    RegistryKey bhoKey = registryKey.OpenSubKey(guid, true);
    if (bhoKey == null)
    {
        bhoKey = registryKey.CreateSubKey(guid);
    }
    // NoExplorer: dword = 1 prevents the BHO to be loaded by Explorer.exe
    bhoKey.SetValue("NoExplorer", 1);
    bhoKey.Close();

    registryKey.Close();
}

[ComUnregisterFunction]
public static void UnregisterBHO(Type type)
{
    RegistryKey registryKey = Registry.LocalMachine.OpenSubKey(BHO_KEY_NAME, true);
    string guid = type.GUID.ToString("B");

    if (registryKey != null)
        registryKey.DeleteSubKey(guid, false);
}
</code></pre>

<p>接下来就是实现具体的统计功能了。考虑一下，当输入网址后，我们需要记录下网址以及当前的时间；当在同一浏览窗口中切换网址时，不仅需要记录下网址和当前时间，还要设置前一个浏览记录的结束时间；并且在关闭浏览器时，也要记下结束时间。所以在SetSite中需要挂载NavigateComplete2和OnQuit事件。</p>

<pre><code>private void NavigateComplete2(object pDisp, ref object URL)
{
    string url = URL as string;
    if (url.IndexOf("about:blank") &gt;= 0)
    {
        return;
    }
    if (visitHists.Count &gt; 0)
    {
        VisitHist currentHist = visitHists[visitHists.Count - 1];
        if (currentHist.VisitUrl != url)
        {
            currentHist.EndTime = System.DateTime.Now;
        }
        else
        {
            return;
        }
    }
    VisitHist newHist = new VisitHist();
    newHist.StartTime = System.DateTime.Now;
    newHist.VisitUrl = url;
    visitHists.Add(newHist);
}

private void OnQuit()
{
    if (visitHists.Count &gt; 0)
    {
        VisitHist currentHist = visitHists[visitHists.Count - 1];
        currentHist.EndTime = System.DateTime.Now;
    }

    // 输出统计记录
</code></pre>

<p>开始编译，然后就可以在bin目录下找到项目的dll文件了。在Console中使用regasm /codebase &ldquo;UrlTrack.dll&#8221;注册dll。打开注册表，在HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Browser Helper Objects可以看到多出了一个子项{E90DA13B-117A-4178-8111-0F712DA09FF9}。</p>

<p>需要注意的是，需要将AssemblyInfo.cs文件中的ComVisible属性设为true，否则在注册BHO时会得到这样的信息：</p>

<pre><code>RegAsm : warning RA0000 : No types were registered.
</code></pre>

<p>更多的BHO资料可以看<a href="http://msdn.microsoft.com/en-us/library/aa753587.aspx">Browser Extensions</a>。</p>

<p>[1] 在Windows操作系统上有两种浏览器：资源浏览器（Explorer.exe，应用于文件系统）和Internet浏览器（IEXPLORE.EXE，应用于互联网资源）。</p>

<p>代码下载：<a href="https://github.com/dohkoos/UrlTrack">https://github.com/dohkoos/UrlTrack</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Visual C#中调试C++的DLL]]></title>
    <link href="http://codemany.com/blog/debugging-cpp-dll-in-visual-csharp/"/>
    <updated>2007-07-03T21:09:09+08:00</updated>
    <id>http://codemany.com/blog/debugging-cpp-dll-in-visual-csharp</id>
    <content type="html"><![CDATA[<p>在Visual C#中调试C++的DLL很简单，只要在C#项目属性的Debug一项中钩上“Enable unmanaged code debugging”，然后你就可以像调试一般程序那样调试DLL了。</p>
]]></content>
  </entry>
  
</feed>
