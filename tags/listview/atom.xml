<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: ListView | 乐者为王]]></title>
  <link href="http://codemany.com/tags/listview/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2014-08-04T00:34:54+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[给ListView添加卸载功能的button]]></title>
    <link href="http://codemany.com/blog/2011/06/06/add-uninstall-functionality-to-the-listview-button/"/>
    <updated>2011-06-06T09:25:43+08:00</updated>
    <id>http://codemany.com/blog/2011/06/06/add-uninstall-functionality-to-the-listview-button</id>
    <content type="html"><![CDATA[<p>修改main.xml，添加button控件：<br />
```
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"<br /></p>

<pre><code>android:orientation="vertical"&lt;br /&gt;
android:layout_width="fill_parent"&lt;br /&gt;
android:layout_height="fill_parent"&gt;
&lt;LinearLayout&lt;br /&gt;
    android:layout_width="fill_parent"&lt;br /&gt;
    android:layout_height="wrap_content"&lt;br /&gt;
    android:layout_weight="1.0"&gt;
    &lt;ListView&lt;br /&gt;
        android:id="@+id/list_view"&lt;br /&gt;
        android:layout_width="fill_parent"&lt;br /&gt;
        android:layout_height="wrap_content" /&gt;
&lt;/LinearLayout&gt;
&lt;LinearLayout&lt;br /&gt;
    android:layout_width="fill_parent"&lt;br /&gt;
    android:layout_height="wrap_content"&gt;
    &lt;Button&lt;br /&gt;
        android:id="@+id/uninstall_button"&lt;br /&gt;
        android:text="Uninstall Selected Apps"&lt;br /&gt;
        android:layout_width="fill_parent"&lt;br /&gt;
        android:layout_height="wrap_content" /&gt;
&lt;/LinearLayout&gt;
</code></pre>

<p></LinearLayout>
```</p>

<p>然后在主Activity类Main.java中添加卸载应用的功能代码：<br />
```
private UninstallReceiver mUninstallReceiver;</p>

<p>@Override<br />
public void onCreate(Bundle savedInstanceState) {<br /></p>

<pre><code>...

Button btn = (Button)findViewById(R.id.uninstall_button);&lt;br /&gt;
btn.setOnClickListener(new OnClickListener() {&lt;br /&gt;
    @Override&lt;br /&gt;
    public void onClick(View v) {&lt;br /&gt;
        for (int i = 0; i &lt; mListData.size(); i++) {&lt;br /&gt;
            HashMap&lt;String, Object&gt; map = mListData.get(i);&lt;br /&gt;
            boolean isSelected = (Boolean)map.get("app_select");&lt;br /&gt;
            if (isSelected) {&lt;br /&gt;
                Uri packageUri = Uri.parse("package:" + map.get("app_package"));&lt;br /&gt;
                Intent intent = new Intent(Intent.ACTION_DELETE, packageUri);&lt;br /&gt;
                startActivity(intent);&lt;br /&gt;
            }&lt;br /&gt;
        }&lt;br /&gt;
    }&lt;br /&gt;
});

    // 监听卸载广播&lt;br /&gt;
mUninstallReceiver = new UninstallReceiver();&lt;br /&gt;
IntentFilter filter = new IntentFilter(Intent.ACTION_PACKAGE_REMOVED);&lt;br /&gt;
filter.addDataScheme("package");&lt;br /&gt;
registerReceiver(mUninstallReceiver, filter);&lt;br /&gt;
</code></pre>

<p>}</p>

<p>// 有时选择移除的程序在确认时被取消了，因此要用BroadcastReceiver监听应用是否被真正地卸载<br />
private class UninstallReceiver extends BroadcastReceiver {<br /></p>

<pre><code>@Override&lt;br /&gt;
public void onReceive(Context ctx, Intent intent) {&lt;br /&gt;
    Log.d("UninstallReceiver.onReceive()", intent.getDataString());

    for (int i = 0; i &lt; mListData.size(); i++) {&lt;br /&gt;
        HashMap&lt;String, Object&gt; map = mListData.get(i);&lt;br /&gt;
        String packageUri = "package:" + map.get("app_package");&lt;br /&gt;
        if (packageUri.equals(intent.getDataString())) {&lt;br /&gt;
            mListData.remove(map);&lt;br /&gt;
        }&lt;br /&gt;
    }&lt;br /&gt;
    mHandler.sendEmptyMessage(0);&lt;br /&gt;
}&lt;br /&gt;
</code></pre>

<p>}</p>

<p>@Override<br />
public void onDestroy() {<br /></p>

<pre><code>super.onDestroy();&lt;br /&gt;
unregisterReceiver(mUninstallReceiver);&lt;br /&gt;
</code></pre>

<p>}
[/code]
</p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[向ListView中添加CheckBox]]></title>
    <link href="http://codemany.com/blog/2011/06/03/adding-checkbox-to-the-listview/"/>
    <updated>2011-06-03T14:30:01+08:00</updated>
    <id>http://codemany.com/blog/2011/06/03/adding-checkbox-to-the-listview</id>
    <content type="html"><![CDATA[<p>修改list_item.xml文件，添加CheckBox控件：<br />
```
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"<br /></p>

<pre><code>android:layout_width="fill_parent"&lt;br /&gt;
android:layout_height="wrap_content"&gt;
&lt;ImageView&lt;br /&gt;
    android:id="@+id/app_icon"&lt;br /&gt;
    android:layout_gravity="center_vertical"&lt;br /&gt;
    android:layout_width="32.0dip"&lt;br /&gt;
    android:layout_height="32.0dip"&lt;br /&gt;
    android:layout_marginLeft="3.0dip"&lt;br /&gt;
    android:layout_marginRight="3.0dip" /&gt;
&lt;LinearLayout&lt;br /&gt;
    android:orientation="vertical"&lt;br /&gt;
    android:layout_width="fill_parent"&lt;br /&gt;
    android:layout_height="wrap_content"&lt;br /&gt;
    android:layout_weight="1.0"&gt;
    &lt;TextView&lt;br /&gt;
        android:id="@+id/app_title"&lt;br /&gt;
        android:layout_width="fill_parent"&lt;br /&gt;
        android:layout_height="wrap_content"&lt;br /&gt;
        android:textSize="16.0dip"&lt;br /&gt;
        android:textStyle="bold" /&gt;
    &lt;TextView&lt;br /&gt;
        android:id="@+id/app_package"&lt;br /&gt;
        android:layout_width="fill_parent"&lt;br /&gt;
        android:layout_height="wrap_content"&lt;br /&gt;
        android:textSize="13.0dip" /&gt;
&lt;/LinearLayout&gt;
&lt;CheckBox&lt;br /&gt;
    android:id="@+id/app_select"&lt;br /&gt;
    android:layout_width="wrap_content"&lt;br /&gt;
    android:layout_height="wrap_content"&lt;br /&gt;
    android:focusable="false"&lt;br /&gt;
    android:focusableInTouchMode="false"&lt;br /&gt;
    android:clickable="false"&lt;br /&gt;
    android:checkMark="?android:attr/listChoiceIndicatorMultiple" /&gt;
</code></pre>

<p></LinearLayout>
```</p>

<p>android:focusable=&ldquo;false&rdquo;<br />
android:focusableInTouchMode=&ldquo;false&rdquo;<br />
android:clickable=&ldquo;false&rdquo;<br />
上面三句话很重要，如果不加会出现一些奇怪的错误。</p>

<p>原因：加入CheckBox后，在程序运行过程中会发现整个ListView无法响应onItemClick，onItemLongClick或是onCreateContextMenu事件。原因在于CheckBox是拥有焦点的，它的优先级比ListItem的焦点优先级更高，于是屏蔽了ListItem的点击事件。解决方法是让CheckBox不能获得焦点。android:focusable=&ldquo;false"就是做这个的。</p>

<p>修改整个SimpleIconAdapter类为以下内容：<br />
```
public class SimpleIconAdapter extends BaseAdapter {<br /></p>

<pre><code>private LayoutInflater mInflater;&lt;br /&gt;
private List&lt;? extends Map&lt;String, ?&gt;&gt; mData;

public SimpleIconAdapter(Context context, List&lt;? extends Map&lt;String, ?&gt;&gt; data) {&lt;br /&gt;
    mInflater = LayoutInflater.from(context);&lt;br /&gt;
    mData = data;&lt;br /&gt;
}

@Override&lt;br /&gt;
public int getCount() {&lt;br /&gt;
    return mData.size();&lt;br /&gt;
}

@Override&lt;br /&gt;
public Object getItem(int position) {&lt;br /&gt;
    return mData.get(position);&lt;br /&gt;
}

@Override&lt;br /&gt;
public long getItemId(int position) {&lt;br /&gt;
    return position;&lt;br /&gt;
}

@SuppressWarnings({ "rawtypes", "unchecked" })&lt;br /&gt;
@Override&lt;br /&gt;
public View getView(int position, View convertView, ViewGroup parent) {&lt;br /&gt;
    View view;&lt;br /&gt;
    if (convertView != null) {&lt;br /&gt;
        view = convertView;&lt;br /&gt;
    } else {&lt;br /&gt;
        view = mInflater.inflate(R.layout.list_item, parent, false);&lt;br /&gt;
    }

    Map map = (Map)getItem(position);&lt;br /&gt;
    TextView tv = (TextView)view.findViewById(R.id.app_title);&lt;br /&gt;
    tv.setText((String)map.get("app_title"));

    tv = (TextView)view.findViewById(R.id.app_package);&lt;br /&gt;
    tv.setText((String)map.get("app_package"));

    ImageView iv = (ImageView)view.findViewById(R.id.app_icon);&lt;br /&gt;
    iv.setImageDrawable((Drawable)map.get("app_icon"));

    CheckBox cb = (CheckBox)view.findViewById(R.id.app_select);&lt;br /&gt;
    if ((Boolean)map.get("app_select") ==  null) {&lt;br /&gt;
        map.put("app_select", false);&lt;br /&gt;
    }&lt;br /&gt;
    cb.setChecked((Boolean)map.get("app_select"));

    return view;&lt;br /&gt;
}&lt;br /&gt;
</code></pre>

<p>}
```</p>

<p>再就是修改主文件：<br />
```
public class Main extends Activity {<br /></p>

<pre><code>...

@Override&lt;br /&gt;
public void onCreate(Bundle savedInstanceState) {&lt;br /&gt;
    super.onCreate(savedInstanceState);&lt;br /&gt;
    setContentView(R.layout.main);

    mListView = (ListView)findViewById(R.id.list_view);&lt;br /&gt;
    mListData = new ArrayList&lt;HashMap&lt;String, Object&gt;&gt;();&lt;br /&gt;
    mAdapter = new SimpleIconAdapter(this, mListData);&lt;br /&gt;
    mListView.setAdapter(mAdapter);&lt;br /&gt;
    mListView.setItemsCanFocus(false);&lt;br /&gt;
    mListView.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE);&lt;br /&gt;
    mListView.setOnItemClickListener(new OnItemClickListener() {&lt;br /&gt;
        @SuppressWarnings({ "unchecked", "rawtypes" })&lt;br /&gt;
        @Override&lt;br /&gt;
        public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {&lt;br /&gt;
            // 这里如此处理是因为当选中CheckBox，滚动ListView的时候，会出现一些&lt;br /&gt;
            // CheckBox选择错位的现象，所以在选择CheckBox时，记下其状态，然后在&lt;br /&gt;
            // getView方法中进行设置。&lt;br /&gt;
            // 原因：&lt;br /&gt;
            // ListView中的getChildCount()并不总是等于Adapter中的数据行数。当手&lt;br /&gt;
            // 机一屏显示不了所有数据时（需要翻页），getChildCount()就等于一屏&lt;br /&gt;
            // 所显示的行数（一般为10），小于Adapter中的数据行数。而ListView的&lt;br /&gt;
            // getCount()与Adapter中的数据行数相等。&lt;br /&gt;
            // 当光标下移到屏幕最底部，新显示出来的View，在调用Adapter的getView&lt;br /&gt;
            // 方法中，会判断convertView为null，而再有新的View显示就会发现&lt;br /&gt;
            // convertView不为空，所以新显示的View其实使用了之前某个View的对象。&lt;br /&gt;
            // 这就造成了状态可能混乱。比如第一行的CheckBox点选时，第11行的也同&lt;br /&gt;
            // 时会被点选。&lt;br /&gt;
            CheckBox cb = (CheckBox)view.findViewById(R.id.app_select);&lt;br /&gt;
            cb.toggle();&lt;br /&gt;
            ((Map)mListData.get(position)).put("app_select", cb.isChecked());&lt;br /&gt;
        }&lt;br /&gt;
    });

    mProgressDialog = ProgressDialog.show(this, "Wait", "loading...");&lt;br /&gt;
    new Thread() {&lt;br /&gt;
        @Override&lt;br /&gt;
        public void run() {&lt;br /&gt;
            mListData.addAll(getInstalledApps(false));&lt;br /&gt;
            mHandler.sendEmptyMessage(0);&lt;br /&gt;
        }&lt;br /&gt;
    }.start();&lt;br /&gt;
}

...&lt;br /&gt;
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实现带icon的ListView（改进版）]]></title>
    <link href="http://codemany.com/blog/2011/06/02/achieved-with-the-icon-of-the-listview-improved-version/"/>
    <updated>2011-06-02T02:47:58+08:00</updated>
    <id>http://codemany.com/blog/2011/06/02/achieved-with-the-icon-of-the-listview-improved-version</id>
    <content type="html"><![CDATA[<p>带icon的ListView工作起来还不错，但是如果手机里安装的软件比较多的话就有问题了。在程序启动时会黑屏一段时间，就好像程序挂起了一样。所以这时需要显示一个对话框，告诉用户正在加载数据，最好还能准确告诉用户加载的进度。</p>

<p>显示对话框用ProgressDialog，它有两种样式：HORIZONTAL和SPINNER。这里暂时选择SPINNER，等以后有机会再改成HORIZONTAL。</p>

<p>我们在加载数据前显示ProgressDialog，在之后关闭对话框。示例代码如下：<br />
```
ProgressDialog pd = ProgressDialog.show(this, &ldquo;Wait&rdquo;, &ldquo;loading&hellip;&rdquo;);</p>

<pre><code>ListView lv = (ListView)findViewById(R.id.list_view);&lt;br /&gt;
adapter = new SimpleIconAdapter(this,&lt;br /&gt;
        getInstalledApps(false),&lt;br /&gt;
        R.layout.list_item,&lt;br /&gt;
        new String[] {APP_ICON, APP_TITLE, APP_PACKAGE},&lt;br /&gt;
        new int[] {R.id.app_icon, R.id.app_title, R.id.app_package});&lt;br /&gt;
lv.setAdapter(adapter);
</code></pre>

<p>pd.dismiss();<br />
```</p>

<p>但结果ProgressDialog没有显示出来，因为加载数据的代码也执行在UI线程中，所以对话框的显示被阻塞了。怎么办呢？可以试着创建一个新线程，然后把加载数据这个耗时的操作放到这个非UI线程中去执行，这样不就可以了么：<br />
```
ProgressDialog pd = ProgressDialog.show(this, &ldquo;Wait&rdquo;, &ldquo;loading&hellip;&rdquo;);<br />
new Thread() {<br /></p>

<pre><code>public void run() {

    ListView lv = (ListView)findViewById(R.id.list_view);&lt;br /&gt;
    adapter = new SimpleIconAdapter(Main.this,&lt;br /&gt;
            getInstalledApps(false),&lt;br /&gt;
            R.layout.list_item,&lt;br /&gt;
            new String[] {APP_ICON, APP_TITLE, APP_PACKAGE},&lt;br /&gt;
            new int[] {R.id.app_icon, R.id.app_title, R.id.app_package});&lt;br /&gt;
    lv.setAdapter(adapter);

}&lt;br /&gt;
</code></pre>

<p>}.start();<br />
pd.dismiss();<br />
```</p>

<p>这下更惨了，直接报Runtime异常，连界面都打不开了。</p>

<p>深入研究一下Android的线程模型，看看Android到底是怎么处理UI线程和其它线程的交互的，为什么上面的代码会报异常?</p>

<blockquote>
When an application is launched, the system creates a thread called "main" for the application. The main thread, also called the UI thread, is very important because it is in charge of dispatching the events to the appropriate widgets, including drawing events. It is also the thread where your application interacts with running components of the Android UI toolkit.

For instance, if you touch the a button on screen, the UI thread dispatches the touch event to the widget, which in turn sets its pressed state and posts an invalidate request to the event queue. The UI thread dequeues the request and notifies the widget to redraw itself.

This single-thread model can yield poor performance unless your application is implemented properly. Specifically, if everything is happening in a single thread, performing long operations such as network access or database queries on the UI thread will block the whole user interface. No event can be dispatched, including drawing events, while the long operation is underway. From the user's perspective, the application appears hung. Even worse, if the UI thread is blocked for more than a few seconds (about 5 seconds currently) the user is presented with the infamous "application not responding" (ANR) dialog.
</blockquote>


<p>看了上面这段话可以知道为啥程序一打开就黑屏，像挂掉了一样。</p>

<p>那为什么用新建线程来执行耗时操作的代码也有问题呢？这是因为它虽然没有阻塞UI线程，但它违背了单线程模型，Android的UI操作并不是线程安全的，并且这些操作必须在UI线程中执行。在这段代码片段中，在另一个线程中执行数据加载，这会引起一些古怪的问题。</p>

<p>Andriod提供了几种在其他线程中访问UI线程的方法。下面是所有这些方法的列表：
<a href="http://developer.android.com/reference/android/app/Activity.html#runOnUiThread(java.lang.Runnable)">Activity.runOnUiThread(Runnable)</a>
<a href="http://developer.android.com/reference/android/view/View.html#post(java.lang.Runnable)">View.post(Runnable)</a>
<a href="http://developer.android.com/reference/android/view/View.html#postDelayed(java.lang.Runnable,%20long)">View.postDelayed(Runnable, long)</a>
<a href="http://developer.android.com/reference/android/os/Handler.html">Hanlder</a></p>

<p>上面的任何一个类或方法都可以修复我们前面代码中出现的问题，很不幸的是这些类或方法同样会使你的代码很复杂很难理解。然而当你需要实现一些很复杂的操作并需要频繁地更新UI时这会变得更糟糕。为了解决这个问题，Android 1.5提供了一个工具类AsyncTask，它使创建需要与用户界面交互的长时间运行的任务变得更简单。在Android 1.0和1.1中具有与AsyncTask相同功能的类UserTask。它提供了完全一样的API，你需要做的只是把它的代码拷贝的你的程序中。</p>

<p>其实这些方案都是采用的Handler，所以这里仍然使用旧有的，复杂的Handler来修复上述问题。至于为什么和如何利用Handler更新UI就不讲了，也许以后会做这样的一个整理，而且网上有很多这样的内容。这里直接上代码：<br />
```
package com.codemany.apkmgt;</p>

<p>import java.util.ArrayList;<br />
import java.util.HashMap;<br />
import java.util.List;</p>

<p>import android.app.Activity;<br />
import android.app.ProgressDialog;<br />
import android.content.pm.ApplicationInfo;<br />
import android.content.pm.PackageInfo;<br />
import android.graphics.drawable.Drawable;<br />
import android.os.Bundle;<br />
import android.os.Handler;<br />
import android.os.Message;<br />
import android.widget.ListView;</p>

<p>public class Main extends Activity {<br /></p>

<pre><code>private static final String APP_ICON = "app_icon";&lt;br /&gt;
private static final String APP_TITLE = "app_title";&lt;br /&gt;
private static final String APP_PACKAGE = "app_package";

private SimpleIconAdapter adapter;&lt;br /&gt;
private List&lt;HashMap&lt;String, Object&gt;&gt; listData;&lt;br /&gt;
private ProgressDialog pd;

@Override&lt;br /&gt;
public void onCreate(Bundle savedInstanceState) {&lt;br /&gt;
    super.onCreate(savedInstanceState);&lt;br /&gt;
    setContentView(R.layout.main);

    ListView lv = (ListView)findViewById(R.id.list_view);&lt;br /&gt;
    listData = new ArrayList&lt;HashMap&lt;String, Object&gt;&gt;();&lt;br /&gt;
    adapter = new SimpleIconAdapter(this,&lt;br /&gt;
            listData,&lt;br /&gt;
            R.layout.list_item,&lt;br /&gt;
            new String[] {APP_ICON, APP_TITLE, APP_PACKAGE},&lt;br /&gt;
            new int[] {R.id.app_icon, R.id.app_title, R.id.app_package});&lt;br /&gt;
    lv.setAdapter(adapter);

    pd = ProgressDialog.show(this, "Wait", "loading...");&lt;br /&gt;
    new Thread() {&lt;br /&gt;
        @Override&lt;br /&gt;
        public void run() {&lt;br /&gt;
            // 耗时操作，加载数据&lt;br /&gt;
            listData.addAll(getInstalledApps(false));&lt;br /&gt;
            handler.sendEmptyMessage(0);&lt;br /&gt;
        }&lt;br /&gt;
    }.start();&lt;br /&gt;
}

private Handler handler = new Handler() {&lt;br /&gt;
    @Override&lt;br /&gt;
    public void handleMessage(Message msg) {&lt;br /&gt;
        // 通知UI更新。必须要放在这里&lt;br /&gt;
        adapter.notifyDataSetChanged();&lt;br /&gt;
        pd.dismiss();&lt;br /&gt;
    }&lt;br /&gt;
};

private List&lt;HashMap&lt;String, Object&gt;&gt; getInstalledApps(boolean getSysPackages) {&lt;br /&gt;
    ...&lt;br /&gt;
}&lt;br /&gt;
</code></pre>

<p>}
```</p>

<p>参考资料：
<a href="http://developer.android.com/resources/articles/painless-threading.html"><a href="http://developer.android.com/resources/articles/painless-threading.html">http://developer.android.com/resources/articles/painless-threading.html</a></a>
<a href="http://kiminotes.iteye.com/blog/382683"><a href="http://kiminotes.iteye.com/blog/382683">http://kiminotes.iteye.com/blog/382683</a></a> 这个实际上是上面文章的译文</p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实现带icon的ListView]]></title>
    <link href="http://codemany.com/blog/2011/05/26/achieved-with-the-icon-in-the-listview/"/>
    <updated>2011-05-26T08:26:55+08:00</updated>
    <id>http://codemany.com/blog/2011/05/26/achieved-with-the-icon-in-the-listview</id>
    <content type="html"><![CDATA[<p><img src="/uploads/apkmgt-screenshot.png" title="apkmgt-screenshot" ></p>

<p>main.xml不需要修改，还是用原来的那个：<br />
```
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"<br /></p>

<pre><code>android:orientation="vertical"&lt;br /&gt;
android:layout_width="fill_parent"&lt;br /&gt;
android:layout_height="wrap_content"&gt;
&lt;ListView&lt;br /&gt;
    android:id="@+id/list_view"&lt;br /&gt;
    android:layout_width="fill_parent"&lt;br /&gt;
    android:layout_height="wrap_content" /&gt;
</code></pre>

<p></LinearLayout>
```</p>

<p>在list_item.xml中添加ImageView控件，设置高度和宽度分别为32dip，这是因为有些应用icon尺寸比较大的缘故，如果不设置的话有些行就会撑大：<br />
```
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"<br /></p>

<pre><code>android:layout_width="fill_parent"&lt;br /&gt;
android:layout_height="wrap_content"&gt;
&lt;ImageView&lt;br /&gt;
    android:id="@+id/app_icon"&lt;br /&gt;
    android:layout_gravity="center_vertical"&lt;br /&gt;
    android:layout_width="32.0dip"&lt;br /&gt;
    android:layout_height="32.0dip"&lt;br /&gt;
    android:layout_marginLeft="3.0dip"&lt;br /&gt;
    android:layout_marginRight="3.0dip" /&gt;
&lt;LinearLayout&lt;br /&gt;
    android:orientation="vertical"&lt;br /&gt;
    android:layout_width="fill_parent"&lt;br /&gt;
    android:layout_height="wrap_content"&lt;br /&gt;
    android:layout_weight="1.0"&gt;
    &lt;TextView&lt;br /&gt;
        android:id="@+id/app_title"&lt;br /&gt;
        android:layout_width="fill_parent"&lt;br /&gt;
        android:layout_height="wrap_content"&lt;br /&gt;
        android:textSize="16.0dip"&lt;br /&gt;
        android:textStyle="bold" /&gt;
    &lt;TextView&lt;br /&gt;
        android:id="@+id/app_package"&lt;br /&gt;
        android:layout_width="fill_parent"&lt;br /&gt;
        android:layout_height="wrap_content"&lt;br /&gt;
        android:textSize="13.0dip" /&gt;
&lt;/LinearLayout&gt;
</code></pre>

<p></LinearLayout>
```</p>

<p>新建SimpleIconAdapter类，继承SimpleAdapter适配器：<br />
```
package com.codemany.apkmgt;</p>

<p>import java.util.List;<br />
import java.util.Map;</p>

<p>import android.content.Context;<br />
import android.graphics.drawable.Drawable;<br />
import android.view.View;<br />
import android.view.ViewGroup;<br />
import android.widget.ImageView;<br />
import android.widget.SimpleAdapter;</p>

<p>public class SimpleIconAdapter extends SimpleAdapter {</p>

<pre><code>public SimpleIconAdapter(Context context, List&lt;? extends Map&lt;String, ?&gt;&gt; data, int resource, String[] from, int[] to) {&lt;br /&gt;
    super(context, data, resource, from, to);&lt;br /&gt;
}

@SuppressWarnings("rawtypes")&lt;br /&gt;
@Override&lt;br /&gt;
public View getView(int position, View convertView, ViewGroup parent) {&lt;br /&gt;
    View view = super.getView(position, convertView, parent);&lt;br /&gt;
    ImageView iv = (ImageView)view.findViewById(R.id.app_icon);&lt;br /&gt;
    iv.setImageDrawable((Drawable)((Map)getItem(position)).get("app_icon"));&lt;br /&gt;
    return view;&lt;br /&gt;
}&lt;br /&gt;
</code></pre>

<p>}
```</p>

<p>修改Activity文件：<br />
```
package com.codemany.apkmgt;</p>

<p>import java.util.ArrayList;<br />
import java.util.HashMap;<br />
import java.util.List;</p>

<p>import android.app.Activity;<br />
import android.content.pm.ApplicationInfo;<br />
import android.content.pm.PackageInfo;<br />
import android.graphics.drawable.Drawable;<br />
import android.os.Bundle;<br />
import android.widget.ListView;<br />
import android.widget.SimpleAdapter;</p>

<p>public class Main extends Activity {<br /></p>

<pre><code>private static final String APP_ICON = "app_icon";&lt;br /&gt;
private static final String APP_TITLE = "app_title";&lt;br /&gt;
private static final String APP_PACKAGE = "app_package";

@Override&lt;br /&gt;
public void onCreate(Bundle savedInstanceState) {&lt;br /&gt;
    super.onCreate(savedInstanceState);&lt;br /&gt;
    setContentView(R.layout.main);

    ListView listView = (ListView)findViewById(R.id.list_view);&lt;br /&gt;
    SimpleAdapter adapter = new SimpleIconAdapter(this,&lt;br /&gt;
            getInstalledApps(false),&lt;br /&gt;
            R.layout.list_item,&lt;br /&gt;
            new String[] {APP_ICON, APP_TITLE, APP_PACKAGE},&lt;br /&gt;
            new int[] {R.id.app_icon, R.id.app_title, R.id.app_package});&lt;br /&gt;
    listView.setAdapter(adapter);&lt;br /&gt;
}

private List&lt;HashMap&lt;String, Object&gt;&gt; getInstalledApps(boolean getSysPackages) {&lt;br /&gt;
    List&lt;HashMap&lt;String, Object&gt;&gt; listItem = new ArrayList&lt;HashMap&lt;String, Object&gt;&gt;();

    List&lt;PackageInfo&gt; pkgs = getPackageManager().getInstalledPackages(0);&lt;br /&gt;
    for (int i = 0; i&lt; pkgs.size(); i++) {&lt;br /&gt;
        PackageInfo pkg = pkgs.get(i);&lt;br /&gt;
        if (!getSysPackages &amp;&amp; (pkg.applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) &gt; 0) {&lt;br /&gt;
            continue;&lt;br /&gt;
        }&lt;br /&gt;
        Drawable icon = pkg.applicationInfo.loadIcon(getPackageManager());&lt;br /&gt;
        String label = pkg.applicationInfo.loadLabel(getPackageManager()).toString();&lt;br /&gt;
        String version = pkg.versionName;&lt;br /&gt;
        String packageName = pkg.packageName;

        HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();&lt;br /&gt;
        map.put(APP_ICON, icon);&lt;br /&gt;
        map.put(APP_TITLE, label + " " + version);&lt;br /&gt;
        map.put(APP_PACKAGE, packageName);&lt;br /&gt;
        listItem.add(map);&lt;br /&gt;
    }&lt;br /&gt;
    return listItem;&lt;br /&gt;
}&lt;br /&gt;
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[不使用ListActivity实现ListView的方法]]></title>
    <link href="http://codemany.com/blog/2011/05/25/implement-a-listview-without-listactivity/"/>
    <updated>2011-05-25T05:29:57+08:00</updated>
    <id>http://codemany.com/blog/2011/05/25/implement-a-listview-without-listactivity</id>
    <content type="html"><![CDATA[<p>// main.xml
```
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
&lt;LinearLayout xmlns:android=&ldquo;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&rdquo;</p>

<pre><code>android:orientation="vertical"
android:layout_width="fill_parent"
android:layout_height="wrap_content"&gt;
&lt;ListView
    android:id="@+id/list_view"
    android:layout_width="fill_parent"
    android:layout_height="wrap_content" /&gt;
</code></pre>

<p></LinearLayout>
```</p>

<p>// list_item.xml
```
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
&lt;LinearLayout xmlns:android=&ldquo;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&rdquo;</p>

<pre><code>android:layout_width="fill_parent"
android:layout_height="wrap_content"&gt;
&lt;LinearLayout
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="wrap_content"
    android:layout_weight="1.0"&gt;
    &lt;TextView
        android:id="@+id/app_title"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:textSize="16dip" /&gt;
    &lt;TextView
        android:id="@+id/app_package"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content" /&gt;
&lt;/LinearLayout&gt;
</code></pre>

<p></LinearLayout>
```</p>

<p>创建一个继承自Activitiy的类，重写onCreate方法：
```
package com.codemany.apkmgt;</p>

<p>import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;</p>

<p>import android.app.Activity;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageInfo;
import android.os.Bundle;
import android.widget.ListView;
import android.widget.SimpleAdapter;</p>

<p>public class Main extends Activity {</p>

<pre><code>@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main);

    ListView listView = (ListView)findViewById(R.id.list_view);
    SimpleAdapter adapter = new SimpleAdapter(this,
            getInstalledApps(false),
            R.layout.list_item,
            new String[] {"app_title", "app_package"},
            new int[] {R.id.app_title, R.id.app_package});
    listView.setAdapter(adapter);
}

private List&lt;HashMap&lt;String, Object&gt;&gt; getInstalledApps(boolean getSysPackages) {
    List&lt;HashMap&lt;String, Object&gt;&gt; listItem = new ArrayList&lt;HashMap&lt;String, Object&gt;&gt;();

    List&lt;PackageInfo&gt; pkgs = getPackageManager().getInstalledPackages(0);
    for (int i = 0; i&lt; pkgs.size(); i++) {
        PackageInfo pkg = pkgs.get(i);
        if (!getSysPackages &amp;&amp; (pkg.applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) &gt; 0) {
            continue;
        }
        String label = pkg.applicationInfo.loadLabel(getPackageManager()).toString();
        String version = pkg.versionName;
        String packageName = pkg.packageName;

        HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
        map.put("app_title", label + " " + version);
        map.put("app_package", packageName);
        listItem.add(map);
    }
    return listItem;
}
</code></pre>

<p>}
```</p>

<p>至此，一个不使用ListActivity实现的ListView就完成了。</p>
]]></content>
  </entry>
  
</feed>
