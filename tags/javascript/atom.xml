<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: JavaScript | 乐者为王]]></title>
  <link href="http://codemany.com/tags/javascript/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2014-08-13T19:23:22+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用jQuery显示隐藏侧边栏]]></title>
    <link href="http://codemany.com/blog/2012/10/26/using-jquery-show-hide-sidebar/"/>
    <updated>2012-10-26T08:13:14+08:00</updated>
    <id>http://codemany.com/blog/2012/10/26/using-jquery-show-hide-sidebar</id>
    <content type="html"><![CDATA[<p>需要在记账应用使用侧边栏开关功能，在网上找了段代码修改修改，可惜没有找到漂亮的小图标，只好使用大于和小于号来表示，太丑陋了！</p>

<p>把jquery.toggle.sidebar.js的代码贴上：
```
jQuery(function() {
  var sidebar = $.cookie("sidebar");
  if (sidebar == "hide") {</p>

<pre><code>$('#sidebar').hide();
$(".toggle").text("&gt;&gt;");
</code></pre>

<p>  }</p>

<p>  $(".toggle").click(function() {</p>

<pre><code>if ($('#sidebar').is(':visible')) {
  $(this).text("&gt;&gt;");
  $('#sidebar').hide();
  $.cookie("sidebar", "hide", { expires: 7 }); // expires in 7 days
} else {
  $(this).text("&lt;&lt;");
  $('#sidebar').show();
  $.removeCookie("sidebar");
};
return false;
</code></pre>

<p>  });
});
```</p>

<p>因为jQuery本身不支持Cookie操作，需要使用官方的插件，可以在 <a href="http://plugins.jquery.com/project/Cookie">http://plugins.jquery.com/project/Cookie</a> 或 <a href="https://github.com/carhartl/jquery-cookie">https://github.com/carhartl/jquery-cookie</a> 下载。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于input[text]里的光标定位]]></title>
    <link href="http://codemany.com/blog/2008/11/30/on-the-input-text-in-the-cursor-positioning/"/>
    <updated>2008-11-30T02:09:25+08:00</updated>
    <id>http://codemany.com/blog/2008/11/30/on-the-input-text-in-the-cursor-positioning</id>
    <content type="html"><![CDATA[<p>当使用Tab键切换时，想把光标定位在input[text][/text]的首部。在网上找了一些光标定位的资料发现大多数都是用createTextRange来实现的，而且都出自一个实例。可惜的是在Firefox下createTextRange无效。</p>

<p>后来在Firefox的developer站点上发现有个setSelectionRange可以实现这样的功能。<br />
使用格式：<br />
o.setSelectionRange(start, end);<br />
o：为文本输入框对象<br />
start：为字符串的起始位置<br />
end：为字符串的末位置</p>

<p>尝试后发现并不能定位到文本首位，总是全选所有的文本内容，在后面加上获的焦点的命令也不管用。最后还是在国外的一个站点上找到了解决的办法。</p>

<p>下面的代码在Firefox下不能定位到首位，只能选中全部：<br />
```
function setCaretPosition(aCtrl, aPos) {<br /></p>

<pre><code>if (aCtrl.setSelectionRange) {&lt;br /&gt;
    aCtrl.setSelectionRange(aPos, aPos);&lt;br /&gt;
    aCtrl.focus();&lt;br /&gt;
} else if (aCtrl.createTextRange) {&lt;br /&gt;
    var rng = aCtrl.createTextRange();&lt;br /&gt;
    rng.collapse(true);&lt;br /&gt;
    rng.moveStart('character', aPos);&lt;br /&gt;
    rng.moveEnd('character', aPos);&lt;br /&gt;
    rng.select();&lt;br /&gt;
}&lt;br /&gt;
</code></pre>

<p>}
```</p>

<p>经过修改后的代码就可以适用于FF，IE，Opera的光标定位了：</p>

<p>```
function setCaretPosition(aCtrl, aPos) {</p>

<pre><code>if (aCtrl.setSelectionRange) {
    setTimeout(function() {
        aCtrl.setSelectionRange(aPos, aPos);
        aCtrl.focus();
    }, 0);
} else if (aCtrl.createTextRange) {
    var rng = aCtrl.createTextRange();
    rng.collapse(true);
    rng.moveStart('character', aPos);
    rng.moveEnd('character', aPos);
    rng.select();
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript中的undefined]]></title>
    <link href="http://codemany.com/blog/2007/04/20/javascript-in-undefined/"/>
    <updated>2007-04-20T16:03:06+08:00</updated>
    <id>http://codemany.com/blog/2007/04/20/javascript-in-undefined</id>
    <content type="html"><![CDATA[<p>JavaScript有6种类型，undefined、null、boolean、number、string和object。其中，null类型只有一个值null。undefined类型也只有一个值，即undefined，当声明的变量没有被赋值的时候，该变量的默认值就是undefined。<br />
<code>
var foo;&lt;br /&gt;
</code></p>

<p>前面一行代码声明变量foo，没有赋值。脚本引擎在处理代码的时候会给该变量赋予值undefined。实际上，前面一行代码等价于<br />
<code>
var foo = undefined;&lt;br /&gt;
</code></p>

<p>可以用下面的代码测试：<br />
<code>
var foo;&lt;br /&gt;
alert(foo == undefined); // true&lt;br /&gt;
alert(foo === undefined); // true&lt;br /&gt;
alert(typeof(foo)); // undefined&lt;br /&gt;
</code></p>

<p>JavaScript另一个有趣的方面是在使用变量之前不必声明。例如：</p>

<p><code>
var foo = "Hello ";
bar = foo + "world!";
alert(bar); // Hello world!
</code></p>

<p>变量bar并没有用var运算符定义，这里只是使用了它，就像已经声明过它一样。脚本引擎遇到未声明过的标识符时，用该变量名创建一个全局变量，并将其初始化为指定的值（这里是foo + "world"）。这是该语言的便利之处，不过如果不能紧密跟踪变量，这样做也很危险。考虑下面的代码：<br />
<code>
var foo;
// Make sure this variable isn't defined
//var bar;
alert(foo);
alert(bar);
</code></p>

<p>执行的结果是：
<img src="/uploads/undefined.png" title="undefined" >
<img src="/uploads/undefined-error.png" title="undefined-error" ></p>

<p>alert(bar)出现错误是因为bar被创建成全局变量后没有被初始化，还处在未初始化（uninitialized）状态。但是，typeof运算符并不真正区分这两种值。考虑下面的代码：</p>

<p><code>
var foo;&lt;br /&gt;
// Make sure this variable isn't defined&lt;br /&gt;
//var bar;&lt;br /&gt;
alert(typeof(foo)); // undefined&lt;br /&gt;
alert(typeof(bar)); // undefined&lt;br /&gt;
</code></p>

<p>前面的代码对两个变量的输出都是"undefined"，即使变量bar在使用前没有被声明。</p>

<p>另外还有：<br />
1、当函数无明确返回值时，返回的也是值undefined，如下所示：<br />
<code>
function foobar() { }&lt;br /&gt;
alert(foobar() == undefined); // true&lt;br /&gt;
alert(foobar() === undefined); // true&lt;br /&gt;
</code></p>

<p>2、ECMAScript认为undefined是从null派生出来的，所以把它们定义为相等的。</p>

<p><code>
alert(null == undefined); // true
</code></p>

<p>尽管这两个值相等，但它们的含义不同。undefined是声明了变量但未赋值时赋予该变量的值，null则用于表示尚未存在的对象（但从技术上来说，null仍然是原始值）。如果要区分两者，要使用===或typeof运算符。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JSON in JavaScript]]></title>
    <link href="http://codemany.com/blog/2007/02/09/json-in-javascript/"/>
    <updated>2007-02-09T23:29:14+08:00</updated>
    <id>http://codemany.com/blog/2007/02/09/json-in-javascript</id>
    <content type="html"><![CDATA[<p>英文原文：<a href="http://www.json.org/js.html">http://www.json.org/js.html</a></p>

<p><a href="http://www.crockford.com/javascript">JavaScript</a>是一种通用的编程语言，被当作页面脚本语言引入Netscape Navigator。<a href="http://www.crockford.com/javascript/javascript.html">它仍被广泛地认为是Java的一个子集，但它不是。</a>它是一门有着<a href="http://www.crockford.com/javascript/survey.html">类C语法</a>和<a href="http://www.crockford.com/javascript/inheritance.html">soft objects</a>的类<a href="http://www.crockford.com/javascript/little.html">Scheme</a>语言，JavaScript在<a href="http://www.ecma-international.org/publications/files/ecma-st/ECMA-262.pdf">ECMAScript Language Specification, <del>Third Edition</del>当前版本已经是5.1了，下个版本将是6</a>中被标准化。</p>

<p><a href="http://www.json.org/">JSON</a>是JavaScript对象字面量表示法（object literal notation）的一个子集。因为JSON是JavaScript的一个子集，所以在语言中可以毫不费力地使用它。
```
var myJSONObject = {"bindings": [</p>

<pre><code>    {"ircEvent": "PRIVMSG", "method": "newURI", "regex": "^http://.*"},
    {"ircEvent": "PRIVMSG", "method": "deleteURI", "regex": "^delete.*"},
    {"ircEvent": "PRIVMSG", "method": "randomURI", "regex": "^random.*"}
]
</code></pre>

<p>};
```</p>

<p>在这个例子中，创建了一个包含单个成员"bindings"的对象，该成员又包含了一个拥有三个对象的数组，每个对象含有"ircEvent"，"method"和"regex"三个成员。</p>

<p>成员可以通过点或下标操作符检索。
<code>
myJSONObject.bindings[0].method // "newURI"
</code></p>

<p>你可以使用eval()函数把JSON文本转换成对象，eval()会调用JavaScript编译器。因为JSON是JavaScript的一个真子集（a proper subset），编译器将正确的分析文本并产生一个对象结构。文本必须被包裹在括号内，避免在JavaScript的语法歧义上失误。<br />
<code>
var myObject = eval('(' + myJSONtext + ')');
</code></p>

<p>eval函数是非常快的。然而，它可以编译和执行任何JavaScript程序，所以可能会有安全问题。当源代码是可信的与完善的时候才可以使用eval函数。使用JSON语法分析器则安全的多。在基于XMLHttpRequest的web应用中，通讯只被允许朝着提供该页面的同源的方向，所以是可信的。但它可能不胜任。如果服务器在它的JSON编码里不是严格的，或者它没有严谨地校验所有它的输入，然后它可能投递无效的JSON文本，这些文本可能携带危险的脚本。eval函数将执行脚本，释放恶意。</p>

<p>为了抵御这些，应该使用JSON语法分析器。JSON分析器只能识别JSON文本，拒绝所有的脚本。在提供本地JSON支持的浏览器里，JSON分析器也远远快于eval。预计本地JSON支持将会被包含在下一个ECMAScript标准中。<br />
<code>
var myObject = JSON.parse(myJSONtext, reviver);
</code></p>

<p>可选的reviver参数是一个函数，它会被最终结果的各个层面上的每个键值调用。每个值都会被reviver函数的返回结果替换。这可以用来把通用对象转变为伪类实例，或者将date字符串转换为Date对象。<br />
```
myData = JSON.parse(text, function (key, value) {</p>

<pre><code>var type;
if (value &amp;&amp; typeof value === 'object') {
    type = value.type;
    if (typeof type === 'string' &amp;&amp; typeof window[type] === 'function') {
        return new (window[type])(value);
    }
}
return value;
</code></pre>

<p>});
```</p>

<p>JSON字符串转化器（stringifier）则作相反的工作，它将JavaScript数据结构转换为JSON文本。JSON不支持循环的数据结构，所以注意不要把循环的结构交给JSON字符串转化器。
<code>
var myJSONText = JSON.stringify(myObject, replacer);
</code></p>

<p>如果stringify方法看到某个对象含有toJSON方法，会调用该方法，并且把转化成字符串后的值被返回。这允许一个对象去确定其自己的JSON表示。</p>

<p>字符转化器方法可以接收一个可选的字符串数组。这些字符串用于选取那些将会被包含在JSON文本中的属性。</p>

<p>字符转化器方法可以接收一个可选的replacer函数。该函数将会在结构中每个值的toJSON方法（如果有）后面被调用。它将每个键和值作为参数传递，this将会被绑定到持有键的对象上。返回的值会被字符串化。</p>

<p>没有在JSON中表示的值（例如函数和undefined）会被排除。</p>

<p>非限定的数字被替换为null。要替换成其它的值，你可以使用像这样的replacer函数：
```
function replacer(key, value) {</p>

<pre><code>if (typeof value === 'number' &amp;&amp; !isFinite(value)) {
    return String(value);
}
return value;
</code></pre>

<p>}
```</p>

<p>给JSON.parse一个相应的reviver可以还原那些。</p>

<p><a href="https://github.com/douglascrockford/JSON-js">The open source code of a JSON parser and JSON stringifier is available.</a> When <a href="http://www.crockford.com/javascript/jsmin.html">minified</a> it is less than 2.5K.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Javascript学习笔记之正则表达式]]></title>
    <link href="http://codemany.com/blog/2005/07/30/javascript-study-notes-regular-expressions/"/>
    <updated>2005-07-30T11:09:06+08:00</updated>
    <id>http://codemany.com/blog/2005/07/30/javascript-study-notes-regular-expressions</id>
    <content type="html"><![CDATA[<p>JavaScript的正则表达式有两种格式：文本格式/pattern/flags和构造函数格式new RegExp("pattern"[, "flags"])。其中，pattern表示正则表达式的匹配模式，如果指定flags项，它可以是下列值之一：</p>

<table>
<thead>
<tr>
<th>Flags </th>
<th> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>g     </td>
<td> global match</td>
</tr>
<tr>
<td>i     </td>
<td> case-insensitive match</td>
</tr>
<tr>
<td>m     </td>
<td> multiline match</td>
</tr>
</tbody>
</table>


<h3>正则表达式中的特殊字符</h3>

<table>
<thead>
<tr>
<th>Character </th>
<th> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[abc]     </td>
<td> Find any character between the brackets. 可以用短横线（-）指定一个范围</td>
</tr>
<tr>
<td>[^abc]    </td>
<td> Find any character NOT between the brackets. 可以用短横线（-）指定一个范围</td>
</tr>
<tr>
<td>x</td>
<td>y       | Find any of the alternatives specified</td>
</tr>
<tr>
<td>.         </td>
<td> Find a single character, except newline or line terminator</td>
</tr>
<tr>
<td>\w        </td>
<td> Find a word character</td>
</tr>
<tr>
<td>\W        </td>
<td> Find a non-word character</td>
</tr>
<tr>
<td>\d        </td>
<td> Find a digit</td>
</tr>
<tr>
<td>\D        </td>
<td> Find a non-digit character</td>
</tr>
<tr>
<td>\s        </td>
<td> Find a whitespace character</td>
</tr>
<tr>
<td>\S        </td>
<td> Find a non-whitespace character</td>
</tr>
<tr>
<td>\b        </td>
<td> Find a match at the beginning/end of a word</td>
</tr>
<tr>
<td>\B        </td>
<td> Find a match not at the beginning/end of a word</td>
</tr>
<tr>
<td>[\b]      </td>
<td> 匹配一个退格符（不要与\b混淆）</td>
</tr>
<tr>
<td>\0        </td>
<td> Find a NUL character</td>
</tr>
<tr>
<td>\n        </td>
<td> Find a new line character</td>
</tr>
<tr>
<td>\f        </td>
<td> Find a form feed character</td>
</tr>
<tr>
<td>\r        </td>
<td> Find a carriage return character</td>
</tr>
<tr>
<td>\t        </td>
<td> Find a tab character</td>
</tr>
<tr>
<td>\v        </td>
<td> Find a vertical tab character</td>
</tr>
<tr>
<td>\cX       </td>
<td> The control character ^X; for example, \cJ is equivalent to the newline character \n</td>
</tr>
<tr>
<td>\xxx      </td>
<td> Find the character specified by an octal number xxx</td>
</tr>
<tr>
<td>\xnn      </td>
<td> The character specified by the hexadecimal number nn</td>
</tr>
<tr>
<td>\uxxxx    </td>
<td> The Unicode character specified by the hexadecimal number xxxx</td>
</tr>
<tr>
<td>^         </td>
<td> Match the beginning of the string and, in multiline searches, the beginning of a line</td>
</tr>
<tr>
<td>$         </td>
<td> Match the end of the string and, in multiline searches, the end of a line.</td>
</tr>
<tr>
<td>*         </td>
<td> 匹配前面的字符0次或n次</td>
</tr>
<tr>
<td>+         </td>
<td> 匹配前面的字符1次或n次</td>
</tr>
<tr>
<td>?         </td>
<td> 匹配前面的字符0次或1次</td>
</tr>
<tr>
<td>(x)       </td>
<td> 匹配x并记录匹配的值。匹配子串可以通过结果数组中的[1], ..., [n]获取，或通过RegExp对象的属性$1, ..., $9返回</td>
</tr>
<tr>
<td>{n}       </td>
<td> 前面的字符n次</td>
</tr>
<tr>
<td>{n,}      </td>
<td> 前面的字符至少n次</td>
</tr>
<tr>
<td>{n, m}    </td>
<td> 前面的字符至少n次，最多m次</td>
</tr>
<tr>
<td>\n        </td>
<td> ?? 这里的n是一个正整数。匹配一个正则表达式的最后一个子串的n的值(计数左圆括号)</td>
</tr>
</tbody>
</table>


<p>?=x
?!x</p>

<h3>正则表达式方法</h3>

<p>exec(string) 对string进行正则处理，并返回匹配结果<br />
test(string) 测试string是否含有匹配结果，返回true或false<br />
match(pattern) 根据pattern进行正则匹配，如果匹配到则返回匹配结果，否则返回null<br />
search(pattern) 根据pattern进行正则匹配，如果匹配到一个结果，则返回它的索引数，否则返回-1<br />
replace(pattern, replacement) 根据pattern进行正则匹配，把匹配结果替换为replacement<br />
split(pattern) 根据pattern进行正则分割，返回一个分割的数组﻿</p></p>
]]></content>
  </entry>
  
</feed>
