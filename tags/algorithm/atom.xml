<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Algorithm | 乐者为王]]></title>
  <link href="http://codemany.com/tags/algorithm/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2014-09-20T18:12:25+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[逻辑题-几条病狗]]></title>
    <link href="http://codemany.com/blog/2014/07/09/logic-problems-how-many-sick-dogs/"/>
    <updated>2014-07-09T19:35:00+08:00</updated>
    <id>http://codemany.com/blog/2014/07/09/logic-problems-how-many-sick-dogs</id>
    <content type="html"><![CDATA[<p>村子中有50个人，每人有一条狗，在这50条狗中有病狗（这种病不会传染），于是人们就要找出病狗，每个人可以观察其他49条狗，以判断它们是否生病，只有自己的狗不能看。观察后得到的结果不得交流，也不能通知病狗的主人。主人一旦推算出自己家的是病狗就要枪毙自己的狗，而且每个人只有权利枪毙自己的狗，没有权利打死其他人的狗。第一天，第二天都没有枪响，到了第三天传来一阵枪响，问有几条病狗？</p>

<p>推论：</p>

<p>A、假设有1条病狗，病狗的主人会看到其他狗都没有病，那么就知道自己的狗有病，所以第一天晚上就会有枪响。因为没有枪响，说明病狗数大于1。</p>

<p>B、假设有2条病狗，病狗的主人会看到有1条病狗，因为第一天没有听到枪响，是病狗数大于1，所以病狗的主人会知道自己的狗是病狗，因而第二天会有枪响。既然第二天也没有枪响，说明病狗数大于2。</p>

<p>由此推理，如果第三天枪响，则有3条病狗，第n天枪响，则有n条病狗。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[逻辑题-老师的生日]]></title>
    <link href="http://codemany.com/blog/2013/03/13/logic-problems-the-teachers-birthday/"/>
    <updated>2013-03-13T10:01:28+08:00</updated>
    <id>http://codemany.com/blog/2013/03/13/logic-problems-the-teachers-birthday</id>
    <content type="html"><![CDATA[<p>小明和小强都是某老师的学生，老师的生日是M月N日，他们都知道老师的生日是以下十组中的一个。老师把M告诉了小明，把N告诉了小强，然后问他们是否知道自己的生日。小明说“如果我不知道小强也不知道”，小强说“本来我不知道，你说了这话我就知道了”，小明说“那我也知道了 ”。问老师的生日是以下的哪个？</p>

<p>3/4, 3/5, 3/8, 6/4, 6/7, 9/1, 9/5, 12/1, 12/2, 12/8</p>

<p>按M排：<br />
3/4, 3/5, 3/8<br />
6/4, 6/7<br />
9/1, 9/5<br />
12/1, 12/2, 12/8</p>

<p>按N排：<br />
9/1, 12/1<br />
12/2<br />
3/4, 6/4<br />
3/5, 9/5<br />
6/7<br />
3/8, 12/8</p>

<p>条件一：小明说“如果我不知道小强也不知道”<br />
分析：因为M都是重复的，所以小明一定不知道。小明知道M以后肯定小强不知道，说明N肯定也是重复，可以剔除12/2和6/7这两个日期。另外，还可以排队N为2与7所对应的月份，因为当老师生日的M为6或12时，小强是有可能知道的，与已知条件相违背。<br />
结果：3/4, 3/5, 3/8, 9/1, 9/5</p>

<p>按M排：<br />
3/4, 3/5, 3/8<br />
9/1, 9/5</p>

<p>按N排：<br />
3/4<br />
3/5, 9/5<br />
3/8<br />
9/1</p>

<p>条件二：小强说“本来我不知道，你说了这话我就知道了”<br />
分析：根据上面的结果和条件二可以知道，现在N一定不能是重复的，可以把3/5和9/5排除。<br />
结果：3/4, 3/8, 9/1</p>

<p>按M排：<br />
3/4, 3/8<br />
9/1</p>

<p>按N排：<br />
3/4<br />
3/8<br />
9/1</p>

<p>条件三：小明说“那我也知道了”<br />
分析：综合条件二的结果和条件三可以判定现在M应该是单一的，所以只能是9。<br />
结果：9/1</p>

<p>老师的生日为9/1。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[逻辑题-100盏电灯]]></title>
    <link href="http://codemany.com/blog/2013/02/26/logic-problems-100-lamps/"/>
    <updated>2013-02-26T08:56:21+08:00</updated>
    <id>http://codemany.com/blog/2013/02/26/logic-problems-100-lamps</id>
    <content type="html"><![CDATA[<p>房间里有100盏电灯，编号为1，2，3...100，每盏灯上有一个按钮，初始时灯全都是关的。</p>

<p>编好号的100位同学由房间外依次走进去，将自己编号的倍数的灯的按钮全部按一次，例如第一位同学把编号是1的倍数的灯的按钮按一下（此时100盏灯全亮），第二位同学把编号是2的倍数的灯的按钮按一下（此时只有50盏灯亮着，50盏被这个人按灭了）...第100位同学把编号是100的倍数的灯（即编号为100的灯）的按钮按一下，请问依次走完后，还有多少盏灯亮着？</p>

<p>解题思路：</p>

<p>被按过奇数次的灯亮着，偶数次的灯关了。因为每个同学会把自己编号的倍数的灯全部按一次，所以：</p>

<p><code>
1号灯会被1号同学按下；
2号灯会被1，2号同学按下；
3号灯会被1，3号同学按下；
4号灯会被1，2，4号同学按下；
5号灯会被1，5号同学按下；
6号灯会被1，2，3，6号同学按下；
7号灯会被1，7号同学按下；
...
依此类推
</code></p>

<p>从上面可以总结出n号灯会被以它所有约数为编号的同学按下。</p>

<p>这样，问题就变成了求每盏灯的编号有多少个约数的数学问题。如果约数个数为奇数，灯亮着；反之，灯关着。</p>

<p>Ruby代码：</p>

<p>```</p>

<h1>Light state: ON/OFF = true/false</h1>

<p>lamps = Array.new(100, false)</p>

<p>1.upto(lamps.length) do |lno|
  1.upto(lno) do |fno|</p>

<pre><code>lamps[lno - 1] = !lamps[lno - 1] if lno % fno == 0
</code></pre>

<p>  end
end</p>

<p>lamps.each_index do |i|
  print "Light #{i + 1} is "
  puts lamps[i] ? "ON" : "OFF"
end
```</p>

<p>最后，我们会发现编号1，4，9，16，25...100的灯是亮着的，其它都是灭的。即编号值可以开出整数平方根的灯是亮的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何从数组中抽取随机不重复的数字]]></title>
    <link href="http://codemany.com/blog/2012/12/06/how-to-extract-random-digit-without-replacement-from-array/"/>
    <updated>2012-12-06T21:49:29+08:00</updated>
    <id>http://codemany.com/blog/2012/12/06/how-to-extract-random-digit-without-replacement-from-array</id>
    <content type="html"><![CDATA[<p>今天浏览订阅的博客时发现了一个巧妙的从数组中抽取随机不重复数字的算法。譬如，在100个不重复的数字中选择10个不相同的数字，通过这个算法就不需要修改数组长度和删除数组元素等。具体算法如下：</p>

<p>```
int[] numbers = new int[100];
int[] selected = new int[10];</p>

<p>for (int i = 0, n = numbers.length; i &lt; selected.length; i++) {</p>

<pre><code>int idx = (int)(Math.random() * n);    // 随机产生一个从0 - (n-1)的数字
selected[i] = numbers[idx];
numbers[idx] = numbers[n - 1];
n--;    // 减1，从而在下次循环时产生的随机的numbers数组下标的范围从0 - (n-1)-1，
        // 保证了上一步中已经赋值给数组中其它数的numbers[n-1]不会在下次循环中给
        // 取得，确保了产生的数组selected中的数为不重复的。
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我写的二分查找算法有bug！]]></title>
    <link href="http://codemany.com/blog/2012/07/25/binary-search-algorithm-i-wrote-has-a-bug/"/>
    <updated>2012-07-25T08:07:17+08:00</updated>
    <id>http://codemany.com/blog/2012/07/25/binary-search-algorithm-i-wrote-has-a-bug</id>
    <content type="html"><![CDATA[<p>看完 <a href="http://reprog.wordpress.com/2010/04/19/are-you-one-of-the-10-percent/">http://reprog.wordpress.com/2010/04/19/are-you-one-of-the-10-percent/</a> 觉得很不服气，写个二分查找算法还不简单吗？分分钟搞定的事情。</p>

<p>按照它的要求，用Java写出以下代码：</p>

<p>```
public int binarySearch(int[] array, int value) {</p>

<pre><code>int low = 0;
int high = array.length - 1;
int mid;
while (low &lt;= high) {
    mid = (low + high) / 2;
    if (array[mid] &lt; value) {
        low = mid + 1;
    } else if (array[mid] &gt; value) {
        high = mid - 1;
    } else {
        return mid;
    }
}
return -1;
</code></pre>

<p>}
```</p>

<p>把代码贴到评论区参加测试。</p>

<p>写代码和检查总共花费20分钟，75%的时间是用来在脑袋里模拟运算，防止数组索引溢出。然后编译2次，消除了两个语法错误（好久没写Java代码和使用Ruby的关系，竟然连个数组初始化都不会写了）。也想过数值溢出的问题，但是没想到点子上。结果恰恰倒在了这个地方。具体原因在 <a href="http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html">http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html</a> 有描述。因为low + high的和会形成数值溢出，解决方法是采用：</p>

<p><code>
int mid = low + ((high - low) / 2);
</code></p>

<p>或</p>

<p><code>
int mid = (low + high) &gt;&gt;&gt; 1;
</code></p>
]]></content>
  </entry>
  
</feed>
