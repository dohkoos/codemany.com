<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Algorithm | 乐者为王]]></title>
  <link href="http://codemany.com/tags/algorithm/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2015-11-03T15:18:05+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[逻辑题-共打了多少鱼]]></title>
    <link href="http://codemany.com/blog/logic-problems-how-many-fish/"/>
    <updated>2015-11-03T15:07:14+08:00</updated>
    <id>http://codemany.com/blog/logic-problems-how-many-fish</id>
    <content type="html"><![CDATA[<p>abcde五人打渔，打完睡觉，a先醒来，扔掉1条鱼，把剩下的分成5份，拿1份走了；b再醒来，也扔掉1条，把剩下的分成5份，拿1份走了；然后cde都按上面的方法取鱼。问他们最少打了多少条鱼？</p>

<table><thead>
<tr>
<th>渔民</th>
<th>醒来时鱼的总数</th>
<th>取走的鱼数</th>
</tr>
</thead><tbody>
<tr>
<td>a</td>
<td>x</td>
<td>(x - 1) / 5</td>
</tr>
<tr>
<td>b</td>
<td>y = 4 * (x - 1) / 5</td>
<td>(y - 1) / 5</td>
</tr>
<tr>
<td>c</td>
<td>z = 4 * (y - 1) / 5</td>
<td>(z - 1) / 5</td>
</tr>
<tr>
<td>d</td>
<td>m = 4 * (z - 1) / 5</td>
<td>(m - 1) / 5</td>
</tr>
<tr>
<td>e</td>
<td>n = 4 * (m - 1) / 5</td>
<td>(n - 1) / 5</td>
</tr>
</tbody></table>

<p>由于扔掉1条鱼后，还能被分成5份，设渔民醒来时鱼的总数为remain，那么(remain - 1) % 5的值为0，即remain % 5的值为1。</p>

<p>最简单的方法就是枚举，最小值从1开始：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">fishmen = [0, 0, 0, 0, 0]  # 渔民取走的鱼数
total = 1

while true do
  remain = total  # 渔民a醒来时鱼的总数
  5.times do |i|  # 5个渔民轮流取鱼
    break if remain % 5 != 1  # 如果不符合扔掉1条鱼后还能分成5份的条件，就枚举下个值
    fishmen[i] = (remain - 1) / 5  # 渔民取走的鱼数
    remain = 4 * fishmen[i]  # 渔民取走鱼后剩下的鱼数
  end
  break if fishmen[4] != 0  # 如果渔民e也取到了鱼，那么就得到了鱼的总数
  total += 1
end

puts total  # 结果是3121条鱼
</code></pre></div>
<p>上面的代码总过做了3121 * 5 = 15605次循环，下面来做进一步的优化。</p>

<p>从表格可以看出，因为(n - 1) % 5 == 0，推导出n &gt;= 6；又x % 5 == 1，因此x的个位数必须是1或者6。所以，枚举的最小值可以从11开始，每次步进为5。优化后的代码如下：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">fishmen = Array.new(n, 0)
total = 11

while true do
  remain = total
  5.times do |i|
    break if remain % 5 != 1
    fishmen[i] = (remain - 1) / 5
    remain = 4 * fishmen[i]
  end
  break if fishmen[4] != 0
  total += 5
end

puts total
</code></pre></div>
<p>总的循环次数减少到(3121 - 11) / 5 + 1 = 623次，减少了整整96%的循环。</p>

<p>推而广之：n个渔民打渔，每个渔民依次扔掉1条鱼后，把鱼分成n份，然后拿走其中一份，求最少打了多少条鱼？</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">fishmen = Array.new(n, 0)
total = 2 * n + 1

while true do
  remain = total
  n.times do |i|
    break if remain % n != 1
    fishmen[i] = (remain - 1) / n
    remain = remain - 1 - fishmen[i]
  end
  break if fishmen[n - 1] != 0
  total += n
end

puts total
</code></pre></div>
<p>这下子无论多少个渔民打渔都可以用这段代码搞定了。我试了试9个渔民，发现竟然可以打近3.9亿条鱼，那得有多少鱼啊！另外，计算时间也明显开始变长了。不知道还能不能做更进一步的优化。如果你有更好的算法，请快点告诉我吧！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[逻辑题-几条病狗]]></title>
    <link href="http://codemany.com/blog/logic-problems-how-many-sick-dogs/"/>
    <updated>2014-07-09T19:35:00+08:00</updated>
    <id>http://codemany.com/blog/logic-problems-how-many-sick-dogs</id>
    <content type="html"><![CDATA[<p>村子中有50个人，每人有一条狗，在这50条狗中有病狗（这种病不会传染），于是人们就要找出病狗，每个人可以观察其他49条狗，以判断它们是否生病，只有自己的狗不能看。观察后得到的结果不得交流，也不能通知病狗的主人。主人一旦推算出自己家的是病狗就要枪毙自己的狗，而且每个人只有权利枪毙自己的狗，没有权利打死其他人的狗。第一天，第二天都没有枪响，到了第三天传来一阵枪响，问有几条病狗？</p>

<p>推论：</p>

<p>A、假设有1条病狗，病狗的主人会看到其他狗都没有病，那么就知道自己的狗有病，所以第一天晚上就会有枪响。因为没有枪响，说明病狗数大于1。</p>

<p>B、假设有2条病狗，病狗的主人会看到有1条病狗，因为第一天没有听到枪响，是病狗数大于1，所以病狗的主人会知道自己的狗是病狗，因而第二天会有枪响。既然第二天也没有枪响，说明病狗数大于2。</p>

<p>由此推理，如果第三天枪响，则有3条病狗，第n天枪响，则有n条病狗。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[逻辑题-老师的生日]]></title>
    <link href="http://codemany.com/blog/logic-problems-the-teachers-birthday/"/>
    <updated>2013-03-13T10:01:28+08:00</updated>
    <id>http://codemany.com/blog/logic-problems-the-teachers-birthday</id>
    <content type="html"><![CDATA[<p>小明和小强都是某老师的学生，老师的生日是M月N日，他们都知道老师的生日是以下十组中的一个。老师把M告诉了小明，把N告诉了小强，然后问他们是否知道自己的生日。小明说“如果我不知道小强也不知道”，小强说“本来我不知道，你说了这话我就知道了”，小明说“那我也知道了 ”。问老师的生日是以下的哪个？</p>

<p>3/4, 3/5, 3/8, 6/4, 6/7, 9/1, 9/5, 12/1, 12/2, 12/8</p>

<p>按M排：<br />
3/4, 3/5, 3/8<br />
6/4, 6/7<br />
9/1, 9/5<br />
12/1, 12/2, 12/8</p>

<p>按N排：<br />
9/1, 12/1<br />
12/2<br />
3/4, 6/4<br />
3/5, 9/5<br />
6/7<br />
3/8, 12/8</p>

<p>条件一：小明说“如果我不知道小强也不知道”<br />
分析：因为M都是重复的，所以小明一定不知道。小明知道M以后肯定小强不知道，说明N肯定也是重复，可以剔除12/2和6/7这两个日期。另外，还可以排队N为2与7所对应的月份，因为当老师生日的M为6或12时，小强是有可能知道的，与已知条件相违背。<br />
结果：3/4, 3/5, 3/8, 9/1, 9/5</p>

<p>按M排：<br />
3/4, 3/5, 3/8<br />
9/1, 9/5</p>

<p>按N排：<br />
3/4<br />
3/5, 9/5<br />
3/8<br />
9/1</p>

<p>条件二：小强说“本来我不知道，你说了这话我就知道了”<br />
分析：根据上面的结果和条件二可以知道，现在N一定不能是重复的，可以把3/5和9/5排除。<br />
结果：3/4, 3/8, 9/1</p>

<p>按M排：<br />
3/4, 3/8<br />
9/1</p>

<p>按N排：<br />
3/4<br />
3/8<br />
9/1</p>

<p>条件三：小明说“那我也知道了”<br />
分析：综合条件二的结果和条件三可以判定现在M应该是单一的，所以只能是9。<br />
结果：9/1</p>

<p>老师的生日为9/1。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[逻辑题-100盏电灯]]></title>
    <link href="http://codemany.com/blog/logic-problems-100-lamps/"/>
    <updated>2013-02-26T08:56:21+08:00</updated>
    <id>http://codemany.com/blog/logic-problems-100-lamps</id>
    <content type="html"><![CDATA[<p>房间里有100盏电灯，编号为1，2，3...100，每盏灯上有一个按钮，初始时灯全都是关的。</p>

<p>编好号的100位同学由房间外依次走进去，将自己编号的倍数的灯的按钮全部按一次，例如第一位同学把编号是1的倍数的灯的按钮按一下（此时100盏灯全亮），第二位同学把编号是2的倍数的灯的按钮按一下（此时只有50盏灯亮着，50盏被这个人按灭了）...第100位同学把编号是100的倍数的灯（即编号为100的灯）的按钮按一下，请问依次走完后，还有多少盏灯亮着？</p>

<p>解题思路：</p>

<p>被按过奇数次的灯亮着，偶数次的灯关了。因为每个同学会把自己编号的倍数的灯全部按一次，所以：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">1号灯会被1号同学按下；
2号灯会被1，2号同学按下；
3号灯会被1，3号同学按下；
4号灯会被1，2，4号同学按下；
5号灯会被1，5号同学按下；
6号灯会被1，2，3，6号同学按下；
7号灯会被1，7号同学按下；
...
依此类推
</code></pre></div>
<p>从上面可以总结出n号灯会被以它所有约数为编号的同学按下。</p>

<p>这样，问题就变成了求每盏灯的编号有多少个约数的数学问题。如果约数个数为奇数，灯亮着；反之，灯关着。</p>

<p>Ruby代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"># Light state: ON/OFF = true/false
lamps = Array.new(100, false)

1.upto(lamps.length) do |lno|
  1.upto(lno) do |fno|
    lamps[lno - 1] = !lamps[lno - 1] if lno % fno == 0
  end
end

lamps.each_index do |i|
  print &quot;Light #{i + 1} is &quot;
  puts lamps[i] ? &quot;ON&quot; : &quot;OFF&quot;
end
</code></pre></div>
<p>最后，我们会发现编号1，4，9，16，25...100的灯是亮着的，其它都是灭的。即编号值可以开出整数平方根的灯是亮的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何从数组中抽取随机不重复的数字]]></title>
    <link href="http://codemany.com/blog/how-to-extract-random-digit-without-replacement-from-array/"/>
    <updated>2012-12-06T21:49:29+08:00</updated>
    <id>http://codemany.com/blog/how-to-extract-random-digit-without-replacement-from-array</id>
    <content type="html"><![CDATA[<p>今天浏览订阅的博客时发现了一个巧妙的从数组中抽取随机不重复数字的算法。譬如，在100个不重复的数字中选择10个不相同的数字，通过这个算法就不需要修改数组长度和删除数组元素等。具体算法如下：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">int[] numbers = new int[100];
int[] selected = new int[10];

for (int i = 0, n = numbers.length; i &lt; selected.length; i++) {
    int idx = (int)(Math.random() * n);    // 随机产生一个从0 - (n-1)的数字
    selected[i] = numbers[idx];
    numbers[idx] = numbers[n - 1];
    n--;    // 减1，从而在下次循环时产生的随机的numbers数组下标的范围从0 - (n-1)-1，
            // 保证了上一步中已经赋值给数组中其它数的numbers[n-1]不会在下次循环中给
            // 取得，确保了产生的数组selected中的数为不重复的。
}
</code></pre></div>]]></content>
  </entry>
  
</feed>
