<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Translation | 乐者为王]]></title>
  <link href="http://codemany.com/tags/translation/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2015-10-23T22:41:20+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[一开始就编写优质的OO代码]]></title>
    <link href="http://codemany.com/blog/writing-great-oo-code-day-one/"/>
    <updated>2015-10-23T13:50:44+08:00</updated>
    <id>http://codemany.com/blog/writing-great-oo-code-day-one</id>
    <content type="html"><![CDATA[<p>英文原文：<a href="https://weblogs.java.net/blog/2008/10/03/writing-great-oo-code-day-one">https://weblogs.java.net/blog/2008/10/03/writing-great-oo-code-day-one</a></p>

<p>没有获取经验的捷径。编写良好的面向对象代码需要经验。尽管如此，这里有三个实践可以帮助你一开始就有个良好的开端：</p>

<ol>
<li>使用测试驱动开发（TDD）编写你所有的代码</li>
<li>遵循<a href="http://xp.c2.com/XpSimplicityRules.html">简单的规则</a></li>
<li>命令代替询问（Tell Don&#39;t Ask）</li>
</ol>

<h3 id="使用tdd编写你所有的代码">使用TDD编写你所有的代码</h3>

<p><a href="http://ponderingobjectorienteddesign.blogspot.com/2008/09/tdd-is-design-activity.html">测试先行</a>编写的代码和测试后行编写的代码是非常非常不同的代码。测试先行编写的代码是松耦合和高内聚的。测试后行编写的代码往往会破坏封装，当一些属性或私有方法需要被暴露给测试的时候，因为这些类没有被设计成要被测试的。如果你编写的代码测试先行，代码的依赖性会更好，你的代码将是松耦合和高内聚的。稍后详细讨论测试如何帮助你设计更好的代码。</p>

<h3 id="遵循简单的规则">遵循简单的规则</h3>

<p>代码是简洁的，当它：</p>

<ol>
<li>通过所有的测试</li>
<li>不包含重复代码</li>
<li>表达了所有的意图</li>
<li>使用了最少的类和方法</li>
</ol>

<p>重要的是注意到我使用了一个有序列表。顺序很重要。带有单一main()方法的单一GodClass并不简单。它可以通过所有的测试，但在比“Hello, world!”更复杂的任何程序里它一定会包含重复代码和没有表达所有的意图。</p>

<p>我与简单的规则的斗争重点围绕在<a href="http://ponderingobjectorienteddesign.blogspot.com/2008/09/if-bugs.html">If Bug</a> 。我不明白遵循简单的规则如何阻止某人编写大量的if代码。有人会说，我试过了，大量的if代码不会表达意图。但是，当你读到这样的代码</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">if (mobile.getType() == MobileTypes.STANDARD) {
    alert();
}
</code></pre></div>
<p>它实在是太容易看出意图了。无论该代码是在哪个方法的上下文中，如果mobile是STANDARD类型，那么警报。你还需要多少意图？</p>

<p>然后我灵光小闪。如果有那样的代码，那么在代码的其它地方肯定还有更多。可能是这样的代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">if (mobile.getType() == MobileTypes.GAS) {
    registerGasReading();
}
</code></pre></div>
<p>和</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">if (mobile.getType() == MobileTypes.TEXT) {
    sendTextMessage();
}
</code></pre></div>
<p>和</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">if (mobile.getType() == MobileTypes.LOCATION) {
    notifyLocation();
}
</code></pre></div>
<p>你看见了吗？我当然知道。违反规则2。许多许多违反规则2。并且是违反规则2的最糟糕的那种。重复代码在许多不同的代码片段中。重复代码将非常非常难被找到。所以为了帮助防止这个，我列出来了。</p>

<h3 id="命令代替询问">命令代替询问</h3>

<p>命令代替询问意味着不要询问一个对象的状态然后做些什么。应该命令那个对象去做些什么。这意味着所有这些if例子变成了：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">mobile.alert();
</code></pre></div>
<p>和</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">mobile.registerGasReading();
</code></pre></div>
<p>和</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">mobile.sendTextMessage();
</code></pre></div>
<p>和</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">mobile.notifyLocation();
</code></pre></div>
<p>现在假设有一些if子句散落在有重复实现的整个代码中。在那个大量if代码的版本中，它们将非常难被找到，但在命令代替询问版本中，所有的实现都在Mobile类中。所有的都在一个地方寻找和消除。</p>

<p>聆听你的测试也将帮助你保持代码简单。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public interface Alarm {
    void alert(Mobile mobile);
}

public class Siren implements Alarm {
    public void alert(Mobile mobile) {
    if (mobile.getType == MobileTypes.STANDARD) {
        soundSiren();
    }
  }
}

public class TestSiren extends TestCase {
    public void testAlert() {
        LocationMobile mobile = new LocationMobile();
        Siren siren = new Siren();
        siren.alert(mobile);
        assert(sirenSounded());
    }
}
</code></pre></div>
<p>如果你仔细聆听你的测试，它会问你，“你为什么需要LocationMobile去测试Siren？”是呀，为什么呢？似乎Siren甚至不应该知道LocationMobile。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class LocationMobile {
    private Alarm alarm;
    public LocationMobile(Alarm alarm) {
        this.alarm = alarm;
    }
    public void alert() {
        alarm.alert();    // alert on Alarm no longer needs a mobile
    }
}

public class TestLocationMobile extends TestCase {
    public void testAlert() {
        Alarm alarm = EasyMock.createMock(Alarm.class);
        alarm.alert();
        EasyMock.replay(alarm);
        Mobile mobile = new LocationMobile(alarm);
        mobile.alert();
        EasyMock.verify(alarm);
    }
}
</code></pre></div>
<p>看上去我仅仅互换了依赖。作为Alarm依赖Mobile的替换，现在有了Mobile依赖Alarm。如果你仔细看第一个测试，真正的依赖是Siren知道LocationMobile。一个具体类依赖于另一个具体类。这违反了<a href="http://c2.com/cgi/wiki?DependencyInversionPrinciple">依赖倒置原则 （DIP）</a>。第二个例子是LocationMobile依赖接口Alarm。一个具体类依赖一个抽象。这满足了DIP。</p>

<p>如果你使用TDD编写你所有的代码，遵循简单的规则，以及命令代替询问，那么你会在那条成为一个更好的OO程序员的路上。良好的OO代码容易阅读和维护，但是可能难于编写。至少开始是这样。你写得越多，你将会变得更好，你将得到的经验也越多。与此同时，这些实践会让你在你的路上走得更好。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对抗完美]]></title>
    <link href="http://codemany.com/blog/fighting-perfection/"/>
    <updated>2015-10-11T07:43:24+08:00</updated>
    <id>http://codemany.com/blog/fighting-perfection</id>
    <content type="html"><![CDATA[<p>英文原文：<a href="http://usabilitypost.com/2008/10/08/fighting-perfection/">http://usabilitypost.com/2008/10/08/fighting-perfection/</a></p>

<p>如果你像我一样，你可能经常会发现自己从来没有完全满意你的工作——总是做出调整和修改，总是找到你不太喜欢的事情然后改进他们。这适用于很多创造性的努力——或许你正在为你的博客加工一篇文章，整理一份报告或者写一封重要的电子邮件。</p>

<p>问题是，即使在作出修改后，仍然有一些事情你可以调整，事情仍然不是相当完美。</p>

<p>这当然是很好的，你给自己设置了一个高标准。如果你不满意你的工作，那么为什么你的访客或客户就要满意呢？</p>

<h3 id="追求完美是件好事">追求完美是件好事</h3>

<blockquote>
<p>一个建筑师拥有的两个最重要的工具是绘图室的橡皮擦和工地的大铁锤。</p>

<p>Frank Lloyd Wright</p>
</blockquote>

<p>Steve Jobs不满意iPhone的第一个版本。他做了一个艰难的决定去放弃最初的设计，因为他不喜欢它；他觉得这不是Apple能做到的最好的。这引起了很多问题给开发团队，因为他们必须在很短的时间范围内整理出一份全新的设计。</p>

<p>新版本获得了成功，要是他没有做出这个艰难的决定，iPhone将不会成为手机行业的大标志，这在一定程度上要归功于它的标志性设计。</p>

<p>但是……</p>

<h3 id="完美是困难的和费时的">完美是困难的和费时的</h3>

<p>完美可以是危险的和误导的。什么时候足够好？什么时候你可以前进，释放你应用的新版本或发布你的新文章？完美是太高的一个目标，因为它简直太难和太费时去实现。</p>

<p>如果你成了完美的奴隶，你会发现你所有的时间被耗尽。你会不停地做修改调整调整修改——事情却没有按时做完。</p>

<h3 id="如何对抗完美">如何对抗完美?</h3>

<p>考虑优先级——什么是真正要紧的事？对于一个非常大的公司，类似iPhone的东西是一个关键的产品；如果你搞砸了，它能造成严重损失。把产品做正确是至关重要的。设定一个非常高的标准在这里将是一个不错的主意。</p>

<p>那么更小的事情像是博客的设计呢？最终，它通常并不重要，除非这个博客是你的主要业务。在这里简单是你的盟友。简单的东西很难被搞砸，因此创建简单的事情然后把工作做完。</p>

<p>你最宝贵的资源是你的时间。为了对抗完美你必须将时间排出优先次序，并专注于那些要紧的事情。如果你正在做的和改进的事情没有那么重要，那么这些事情就不应该去做。</p>

<h3 id="把事情做完">把事情做完</h3>

<blockquote>
<p>做完。开始把它当作一个咒语。当你去做完它时意味着某些事情已经被完成。决定已经做出，你可以继续前进。做完意味着你正在累积动力。</p>

<p>37signals, <a href="http://gettingreal.37signals.com/ch06_Done.php">Getting Real</a></p>
</blockquote>

<p>执行比想法更重要。把足够好的东西释放出来比做完美但从未完成的东西更好。不要在你做的每件事情上寻求完美——除了那些真正要紧的事情。驯服完美——更快地做完其它的每件事情，把节省下来的时间用在你最重要的项目上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为什么我们不能用估算房屋同样的方法估算软件项目]]></title>
    <link href="http://codemany.com/blog/why-we-cant-estimate-software-project-the-same-way-we-estimate-houses/"/>
    <updated>2015-01-10T09:33:48+08:00</updated>
    <id>http://codemany.com/blog/why-we-cant-estimate-software-project-the-same-way-we-estimate-houses</id>
    <content type="html"><![CDATA[<p>英文原文：<a href="http://www.summa-tech.com/blog/2009/01/28/why-we-cant-estimate-software-project-the-same-way-we-estimate-houses">http://www.summa-tech.com/blog/2009/01/28/why-we-cant-estimate-software-project-the-same-way-we-estimate-houses</a></p>

<p>把构造软件类比成建造房屋是非常有用的，但也有缺陷。</p>

<p>尽管软件建设和住宅建设都是工程实践，但比起软件，我们在估算建造房屋的成本和精力方面更成功。</p>

<h3 id="词汇障碍">词汇障碍</h3>

<p>因为我们大多数人一生都住在房子里，我们开发了一套定义良好的、可以理解的、几乎通用的词汇来描述和讨论关于我们称之为家的地方。当被问及我们的房子是什么样子的，我们可以很容易地回答。当计划一所新房子时，我们可以极其肯定地讨论我们想要什么，并确信建筑师和工程师会明白我们谈论的，反之亦然。我们可能不明白水管设施和电气细节，但我们知道电源插座要放在哪里，知道房间的大小，知道要有多少车库门。</p>

<p>当我们谈论软件时，就不是那么有效了。有太多来自业务和技术方面的新术语，我们需要依赖于现实世界中的类比去解释他们。不仅发生在业务和技术人员之间，甚至还发生在业务人员和业务人员，技术人员和技术人员之间。我们不习惯于去描述软件需求因为所有软件的抽象，在估算时沟通经常受到噪音、误解、缺乏眼界的影响，增加了真正需要构建的不确定性。</p>

<h3 id="物理">物理</h3>

<p>现实世界有非常强大和稳定的规则，比如重力，这些规则会在盖房子的时候施加约束。我们知道我们必须在构建二楼前先完成地下室。我们不能在地基完成后增加层的数量。在水管设施铺设后更改浴室的位置将会是非常非常昂贵的。</p>

<p>在软件项目中，我们生活在一个较少规则的世界里，就像《黑客帝国》。从技术上讲，我们可以在同一时间构造所有的应用层。它可以被设计成使用不同的数据库，运行在不同的服务器，或支持不同的语言。它可以通过浏览器、手机、或其它无线设备访问。选项几乎是无穷无尽的。</p>

<p>正是这种自由和灵活性，在过去的40年里驱动了软件的巨大的进步，但在同时，它也是无数软件项目失败的原因。至关重要的是需求要面对现实，让它们遵守一些基本规则，即使它们不受宇宙物理规律的约束。</p>

<h3 id="程序">程序</h3>

<p>物理和几千年建设的结合已经带来了如何去建造一座房子的一套可靠的程序，虽然总是会有新的材料和改进的技术，核心概念都是相同的。油漆房子的过程几百年来几乎没有变化。</p>

<p>我们仍然处于软件工程的早期阶段。大量的“直觉”仍在估算软件时使用，实际情况是直觉还没有被证明非常有效。</p>

<h3 id="材料和标准">材料和标准</h3>

<p>只有数量有限的材料能被实际地用在建造房屋上。从技术上来讲，可能有成千上百的选项去建造一堵墙：夹板、混凝土、钢铁、沙子、玻璃，但在家具建材零售店里这些选项是非常有限的。涂料的类型，门窗的模型很多但有限。当购买一个水槽时，它很容易兼容已有的水管设施的几率非常高。电器有着相同的电压，灯泡也是兼容的。计划建造一所房子的一切都是兼容的，材料更是普及的，把不确定性降低到了非常小的水平，提高了估算的准确性。</p>

<p>软件行业确实有一些标准，但是它们处于层的最低水平，例如网络协议和文件系统。服务器和产品的集成仍处于布线阶段，XML和Web Service还有很长的路要走，在它们和建筑业达到相同级别的兼容性前，如果这是可能的。</p>

<p>各种各样连接到数据库和构建软件的选项和方法增加了复杂性，提高了每个人参与软件构建工作的学习曲线。我不是说所有这些选项都是不好的，但它确实给估算阶段增加了不确定性，所以产生了复杂性。</p>

<h3 id="角色">角色</h3>

<p>每次我路过建筑工地，都会看到很多帽子，一些在积极工作，一些在等待时机采取行动。但最好的部分是我从来没有见过有人同时戴两顶帽子。角色界定的很明确，工人们专业从事于非常具体的领域。</p>

<p>在大型软件项目中也有一些角色被定义，但还远远没有达到建筑业相同级别的专业化。通常团队成员需要戴上很多帽子，结果是，有时候他们会执行那些他们不是专家的任务，这就增加了他们提供的估算的不确定性。</p>

<p>“很多帽子”现象的一个很好例子是“Webmaster”，该角色用于描述那个做网页设计、创建动画图片、编写HTML和Perl代码、配置数据库、管理网络和邮件服务器的家伙。幸运的是现在Webmaster是个很少使用的术语，因为所有这些活动现在都分配给了不同的角色，像网页设计师、DBA，程序员和系统管理员。我们确实在走向专业化，但还是有很长的路要走。</p>

<p>我并不是建议我们停止使用“让我们像建造房屋那样构造软件”的类比，但我们必须意识到这个比喻的局限性。一旦我们知道局限性我们将能更好地定位讨论这一差异，以及提供建议如何解决它们。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[敏捷开发走下坡路了吗？]]></title>
    <link href="http://codemany.com/blog/agile-development-going-downhill/"/>
    <updated>2013-05-19T12:36:14+08:00</updated>
    <id>http://codemany.com/blog/agile-development-going-downhill</id>
    <content type="html"><![CDATA[<p>英文原文：<a href="http://thatextramile.be/blog/2008/11/agile-development-going-downhill">http://thatextramile.be/blog/2008/11/agile-development-going-downhill</a></p>

<p>James Shore（非常精彩的书《<a href="http://thatextramile.be/blog/2008/05/the-art-of-agile-development/">The Art Of Agile Development</a>》的作者）在他的博客上写了一篇很有趣的帖子：<a href="http://jamesshore.com/Blog/The-Decline-and-Fall-of-Agile.html">The Decline And Fall Of Agile</a>。你绝对应该读读它。</p>

<p>我想我同意James的观点。在过去的几年里，我已经听到了很多的人说他们在做敏捷开发，实际上，他们几乎都不是。引用James的话：</p>

<blockquote>
<p>But guess which part people adopt? That&#39;s right--Sprints and Scrums. Rapid cycles, but none of the good stuff that makes rapid cycles sustainable.</p>
</blockquote>

<p>不幸的是，这是非常真实的。现在许多团队都在进行短迭代工作，很多团队也在做每日例会，或Scrum，或站立会议。但是，有多少人事实上致力于使敏捷开发成功的技术实践和原则呢？老实说，我一个也没见过。</p>

<p>我是一个真正的敏捷开发的铁杆迷，但即使在我现在的工作中，我最近的两个团队也没有完全正确地实现它。我们的研究结果虽然还不错，但我认为我们仍然可以做得更好。我逐渐尝试引入更多的原则和实践，但它确实需要一些时间。但是，所有这些关于敏捷开发的误解，所以很多人（开发人员，项目经理等）有没有真正帮助。在我当前的工作中，这些误解是非常小的，他们并不真正有不良影响。以前在客户那里，我确实注意到这些误解是如何导致异常低效的情况。其实这是非常伤心的，因为迟早经理可能会对敏捷方法持怀疑态度。如果这导致人们放弃一些技术实践和原则，对这个事业来说将会是一个相当大的损失。</p>

<p>我觉得有更多的理由去读James的那本出色的书。如果我可以合法地迫使人们去阅读这本书，我会的:)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[绘制圆角的正确方法]]></title>
    <link href="http://codemany.com/blog/the-proper-way-to-draw-rounded-corners/"/>
    <updated>2013-04-11T14:59:45+08:00</updated>
    <id>http://codemany.com/blog/the-proper-way-to-draw-rounded-corners</id>
    <content type="html"><![CDATA[<p>英文原文：<a href="http://www.usabilitypost.com/2009/01/26/the-proper-way-to-draw-rounded-corners/">http://www.usabilitypost.com/2009/01/26/the-proper-way-to-draw-rounded-corners/</a></p>

<p>在网络上，我已经注意到当人们在他们的设计中实现圆角时犯了很多同样的错误。因为某些原因，当有另外一个圆角在它里面的时候，这个圆角会带来一个问题—无论是有一个围绕周围的边界，还是另一个圆角形状坐落在一个圆角形状内。</p>

<p>这里是我要说的：</p>

<p><img src="/uploads/bad-corner.png" title="bad-corner" ></p>

<p>我看到了很多这种类型的圆角。你可以看到圆角的半径和内圆角的是相同的。这是错误的，因为如果你保持相同半径，两个拐角之间的空间量不会自始至终相等。</p>

<p>下面是相等间距看起来的样子：</p>

<p><img src="/uploads/good-corner.png" title="good-corner" ></p>

<p>这是正确的做法。有什么不同？内角的半径被减小了。好吧，但你怎么知道半径应该有多大？这很简单—如果你把外面的圆角想象成一个圆形，你可以看到它的圆心在哪里。</p>

<p><img src="/uploads/corner-center.png" title="corner-center" ></p>

<p>把这个圆心同样地作为内角的圆心，你就会得到内角的半径。使用这种方法将确保两个形状之间的完美契合。</p>

<p><img src="/uploads/good-corner-ruler.png" title="good-corner-ruler" ></p>

<p>现在你知道了吧？这是做多个圆角彼此包含的正确办法。当然，不需要你使用精确的圆心—有时为了设计良好还需要你移动一点点。但请不要仅仅把相同的圆角向内移动—这是绝对错误的。</p>
]]></content>
  </entry>
  
</feed>
