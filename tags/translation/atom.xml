<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Translation | 乐者为王]]></title>
  <link href="http://codemany.com/tags/translation/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2017-05-25T09:46:38+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[学习新的编程语言的非传统方式]]></title>
    <link href="http://codemany.com/blog/unconventional-way-of-learning-a-new-programming-language/"/>
    <updated>2017-04-08T09:23:59+08:00</updated>
    <id>http://codemany.com/blog/unconventional-way-of-learning-a-new-programming-language</id>
    <content type="html"><![CDATA[<p>英文原文：<a href="https://hackernoon.com/unconventional-way-of-learning-a-new-programming-language-e4d1f600342c">https://hackernoon.com/unconventional-way-of-learning-a-new-programming-language-e4d1f600342c</a></p>

<p>已经有500多种编程语言。因此，今天开始学习新的编程语言对你来说是很正常的。你可能知道C++和Java，但是你的工作需要Python；或者你精通Python，但是需要用Java编写代码；或者也许你想要学习这种很酷的语言只是为了扩展你的编程技能。</p>

<p>如果你想学习新的编程语言，你会选择哪种方式？</p>

<ul>
<li>从若干在线教程中学习</li>
<li>或者从若干在线课程（MOOC）中学习</li>
</ul>

<p>有些人甚至可能认为，学习新语言的最佳方法应该是这样的：</p>

<ul>
<li>学习这门新的编程语言的语法</li>
<li>再用这门语言构建一些个人项目</li>
</ul>

<p>有道理！这样可以确保你能够应用学习语言的语法而获得的知识。</p>

<p>我开发过20多个迷你项目，同时学习不同的语言。相信我，当你为个人项目编写代码的时候，不管这些项目是周末项目还是紧急快速补丁，你编写代码都只是为了完成任务。你只会关注——“我的代码是否工作？”你几乎不关心代码的质量。</p>

<blockquote>
<p>任何傻瓜都能写出计算机可以理解的代码。好的程序员能写出人类可以理解的代码。——Martin Fowler</p>
</blockquote>

<p>那么，你是如何学习你正在尝试学习的新的编程语言的良好实践呢？</p>

<h3 id="向该语言的开源项目贡献代码">向该语言的开源项目贡献代码</h3>

<p>惊讶吗？有些人可能在想——“等等，开源是很难的。只有当我们是该语言的专家时，我们才能为开源项目贡献代码，对吗？”答案是不。</p>

<p>让我给你们讲个故事。</p>

<p>去年，我收到Booking.com全职工作的邀请，而且我知道我将使用Perl（这是他们后端的主要语言）工作。2016年6月，当我完成大学学位后，我开始学习Perl，以便为自己在大学毕业后的首份工作做准备。因为我会在7月的第二周入职，所以我差不多还有1个月的时间。</p>

<p>我开始阅读Perl的语法，并开始理解这门语言的一些常见模式。现在，我真的想用Perl构建一些东西，以便我可以应用我的这门语言的知识和实践这门语言的各种概念。当我在寻找使用Perl构建某些东西的想法时，我在GitHub上看到DuckDuckGo的开源组织。我注意到一些开放项目是用Perl写的。我看看issues发现有很多“新手”问题。我立即开始去解决这些问题，并提交了几个pull request。到今天为止，我已经是他们的几个开放项目的主要贡献者之一，也是DuckDuckGo的20个开源社区领袖之一。</p>

<blockquote>
<p>故事的寓意——通过向用Perl编写的开源项目贡献代码我学会了Perl。</p>
</blockquote>

<h3 id="为什么这种方法奏效呢？">为什么这种方法奏效呢？</h3>

<p>就在我学会Perl的语法之后，我开始向开源项目贡献代码。当这样做的时候，我总是习惯看看现有的模块。我经常留意在Perl中使用的模式。此后，我开始在自己的代码中吸收这些良好的实践，它帮助我学习如何使用Perl编写好的代码。</p>

<p>这并不是偶然。让我给你们讲个另外类似的故事。</p>

<p>最近，当我在Booking.com工作的时候，我挑选了一些任务，包括给用Go语言编写的服务之一添加新功能。以下是我和队友的对话：</p>

<blockquote>
<p>我：我真的喜欢这项任务。我想做它。你怎么看？</p>

<p>他：是的，它的确很有意思。但是，它需要Go的知识。你知道Go吗？</p>

<p>我：不知道。</p>

<p>他：你想学习Go吗？</p>

<p>我：是的！</p>

<p>他：&#x1f60a; 那就去吧！</p>
</blockquote>

<p>我去了，那也是我学习另外一门编程语言——Go的起点！</p>

<p>我开始阅读Go的语法，并在它的官方网站上发现了一个非常棒的初学者语言教程。它足以让我熟悉该语言的所有基本概念。</p>

<p>再一次地，我开始寻找含有“新手”或“易于修复”问题的Go开源项目。我发现了一个Google的项目，它基本上是GitHub的REST API的Go包装器。</p>

<p>在我开始学习Go的2天后，我有了这个项目的第一个PR。</p>

<p><img src="/uploads/contribution-graph.png" title="contribution-graph" ></p>

<h3 id="开源是如何帮助的？">开源是如何帮助的？</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GitHub对软件职业生涯的影响]]></title>
    <link href="http://codemany.com/blog/the-impact-github-is-having-on-your-software-career-right-now/"/>
    <updated>2017-03-20T20:50:30+08:00</updated>
    <id>http://codemany.com/blog/the-impact-github-is-having-on-your-software-career-right-now</id>
    <content type="html"><![CDATA[<p>英文原文：<a href="https://medium.com/@sitapati/the-impact-github-is-having-on-your-software-career-right-now-6ce536ec0b50">https://medium.com/@sitapati/the-impact-github-is-having-on-your-software-career-right-now-6ce536ec0b50</a></p>

<p>在未来的12-24个月里——换句话说，即2018到2019年间——程序员的聘用方式将彻底改变。</p>

<p>2004-2014年间，我任职于Red Hat，世界上最大的开源软件工程公司。2004年7月，在我工作的第一天，我的上司Marty Messer对我说：“你在这里所做的一切工作都是开源的。在将来，你不再需要简历，人们可以直接Google你。”</p>

<p>在那时，它是在Red Hat工作的一个独特之处：我们有机会在开源社区创立自己的个人品牌和声誉。我们通过邮件列表、缺陷追踪器以及提交源代码到Mercurial、Subversion和CVS版本库
来和其他软件工程师进行交流。所有这些都是公开的，并且可以被Google索引。</p>

<p>快进到2017，我们生活的这个世界已经被开源软件所吞噬。</p>

<p>有两个因素可以让你真切地感受到开源时代的到来：</p>

<ol>
<li>微软——曾经是闭源私有软件的典型代表和反对开源的圣战士——已经全心全意地拥抱开源软件，成立.NET基金会（Red Hat是其中的一员）和加入Linux基金会。现在.NET已经作为开源项目进行开发。</li>
<li>GitHub已经成为一个奇特的社交网络，它把问题追踪和分布式代码控制捆绑在一起。</li>
</ol>

<p>对于来自主要是闭源背景的软件开发者来说，刚刚发生了什么还不是很清楚。对他们来说，开源等于“在业余时间免费工作”。</p>

<p>然而，对于我们这些在过去10年里建成一个10亿美元开源软件公司的人来说，为开源工作没有什么免费或业余时间。并且，为开源工作的好处和结果是显而易见的：你的声誉是你的，而且在公司间是可携带的。GitHub是一个社交网络，在那里，你的社会资本，通过你的提交和对你正在工作的任何技术的全球交流的贡献创造的，是你的——不会绑定到你正在临时工作的公司。</p>

<p>聪明人会利用这个优势——他们会向他们日常工作中使用的语言和框架贡献补丁、问题和评论——TypeScript、.NET、Redux。</p>

<p>他们同样会提倡并创造性地安排他们的工作尽可能地以公开的方式完成——即使那只是他们对私有版本库的贡献图。</p>

<p>GitHub是一个很好的均衡器。你可能不能从印度找到一份澳大利亚的工作，但没有什么阻止你在印度利用GitHub与澳大利亚人进行合作。</p>

<p>在过去的十年里，从Red Hat获取一份工作的方式是显而易见的。你只要开始与Red Hat的工程师一起协作开发他们的一些开源项目，然后作出有价值的贡献并且得到他们的认可，你就可以申请一份工作。或者他们会找你。</p>

<p>现在，同样的途径对每个人都开放，不过仅限于技术职位。随着世界被开源所吞噬，同样的求职方式在各个地方开始流行起来。</p>

<p>在<a href="http://www.theregister.co.uk/2017/02/15/think_different_shut_up_and_work_harder_says_linus_torvalds/">最近的访谈</a>中，Linux和Git的发明者Linus Torvalds（在GitHub上有4.9万关注者）这样说道：</p>

<blockquote>
<p>你提交大量的小补丁，直到项目的维护者信任你，到那时你会成为信任网络的一部分，而不仅仅是个发送补丁的家伙。</p>
</blockquote>

<p>你的声誉是你在信任网络中的定位。当你换公司时，它们会减弱并且有所丢失。如果你生活在一个小镇，并且已经在那里很长一段时间，那么小镇里所有的人都了解你。如果你去了其他国家，那么你最终到了一个没人了解你的地方——更糟糕的是，没人知道有谁了解你。</p>

<p>你已经丢失了你的第一度和第二度，甚至可能是第三度连接（译者：不明白什么是“度”的可以搜索六度分隔理论）。除非你已经通过在会议上演讲或者其它一些重要的事情建立品牌，否则你通过与其他人合作以及给企业内部版本库提交代码建立的信任将会不复存在。</p>

<p>但是，如果这些工作一直都在GitHub上完成，它就不会消失。它是可见的。它连接到了一个可见的信任网络。</p>

<p>首先发生的事情之一是弱势群体将开始利用这个优势。学生、新毕业生、移民，他们将利用这个优势搬到澳大利亚。</p>

<p>并且这也将改变整个软件开发的生态环境。以前的特权开发者会突然发现他们的网络被破坏了。开源的原则之一是精英政治——最好的想法胜出，最多的提交胜出，通过测试最多的胜出，最好的实现胜出，等等。</p>

<p>它并不完美（没有什么是完美的）。并且它不会让成为一个好同事的努力废除或打折。在Red Hat，我们解雇过一些摇滚明星工程师，他们只是不能很好地与其他人一起工作——这样的事情不会出现在GitHub，因为大部分开发者都在与其他贡献者互动。</p>

<p>正如有些人用稻草人谬误描述它一样，GitHub不仅仅是代码版本库和原始提交数字的列表。它是一个社交网络。这么说吧：</p>

<blockquote>
<p>它不是你的代码在GitHub上的计数——它是其他人在GitHub上谈及你的代码的计数。</p>
</blockquote>

<p>那是你的可携带声誉。在未来的12-24个月里，由于一些开发者开发这种声誉而其他开发者不，它将成为一个鲜明的区分因素。就像有电子邮箱和没电子邮箱（现在每个人都有电子邮箱）、有蜂窝电话和没蜂窝电话（现在每个人都有蜂窝电话）。最终绝大多数将会以开源的方式工作，它将再次是区别于其它因素的一个公平竞争的领域。</p>

<p>但现在，开发者的职业生涯空间正在被GitHub破坏。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[共享代码的风险]]></title>
    <link href="http://codemany.com/blog/the-perils-of-shared-code/"/>
    <updated>2016-11-25T18:51:10+08:00</updated>
    <id>http://codemany.com/blog/the-perils-of-shared-code</id>
    <content type="html"><![CDATA[<p>英文原文：<a href="https://www.innoq.com/en/blog/the-perils-of-shared-code/">https://www.innoq.com/en/blog/the-perils-of-shared-code/</a></p>

<p>通往地狱的道路往往是由良好的意愿铺就。在各种软件项目中，我看到人们走在这样的道路上，他们在微服务之间借助库共享代码。在几乎每个组织支持微服务架构的项目中，各个团队和开发者都期望以某些核心库为基础构建他们的微服务。显然，即使可能带来的问题已经被知道很长时间了，很多人仍然不知道它们。在这篇博文中，我想研究为什么使用这样的库可能起初听起来有吸引力，为什么可能会出现问题，以及如何能够减轻这些问题。</p>

<h3 id="共享代码的目的">共享代码的目的</h3>

<p>通过库来共享代码有两个主要目的：共享领域逻辑和共享基础设施层中的抽象。</p>

<ol>
<li><p><em>共享的领域模型：</em>领域模型的特定部分在两个或多个有界上下文之间是共同的，因此，作为三番五次实现它的替换，你消除了重复的需要和引入该领域逻辑的不一致实现的可能性。通常，人们想要像那样共享的领域模型的部分是核心领域或一个或多个通用子领域。在领域驱动设计的行话中，这也被称为共享内核。通常，你可以在这里找到像会话和身份验证逻辑这样的概念，但不限于此。一套相关的方法是规范数据模型。</p></li>
<li><p><em>基础设施层抽象：</em>你想避免一次又一次地实现基础设施层的有用抽象，因此你把它们放进一个库里。通常，这些库在数据库访问、消息传递和序列化等方面提供一套统一的方法。</p></li>
</ol>

<p>两者的动机是相同的——避免重复，也就是说，遵循DRY原则（Don’t repeat yourself!）。一旦实现这些逻辑有几个好处：</p>

<blockquote>
<p>你不需要花费宝贵的时间致力于那些已经被解决的问题。</p>

<p>有一套统一的方式做消息传递、数据库访问等。这意味着，当开发者需要去阅读和修改其他开发者最初创建的微服务中的代码时，他们很容易找到他们的方式。</p>

<p>关于彼此行为略有不同的业务逻辑或基础设施关注点，你不想有不同的实现。取而代之的是，有一套做正确事情的规范实现。</p>
</blockquote>

<h3 id="共享代码的问题">共享代码的问题</h3>

<p>在理论上听起来很棒的东西不会没有自己的问题，而且这些问题可能比你试图用你的库解决的问题更令人痛苦。Stefan Tilkov已经详细解释了<a href="https://www.innoq.com/en/blog/thoughts-on-a-canonical-data-model/">为什么你应该避免规范的数据模型</a>。除此之外，让我指出一些其它的问题。</p>

<h4 id="分布式单体">分布式单体</h4>

<p>通常，似乎存在一个隐含的假设，将东西放入库意味着你永远不必担心使用错误或过时的实现构成的服务，因为他们只需要更新其对库的依赖关系到最新版本。</p>

<p>每当你依靠通过将所有的微服务更新到同样的新版本库，来对所有微服务的某些行为作出一致的改变时，你就会在它们之间引入强耦合。你失去了微服务的一个主要优点，即它们彼此独立地演进和部署的能力。</p>

<p>我见过这样的案例，所有的服务必须同时部署，以便服务仍能正常工作。如果你达到这种状态，不可否认，你实际上构建了一个分布式的单体。</p>

<p>一个流行的示例是使用代码生成，例如，基于服务API的Swagger描述，以便为你的服务提供一个客户端库。比你想象的更多，开发者可能会滥用此种方式进行重大变更，因为依赖服务“只”需要使用新版本的客户端库。这不是你如何<a href="http://olivergierke.de/2016/10/evolving-distributed-systems/">演进一个分布式系统</a>。</p>

<h4 id="依赖地狱">依赖地狱</h4>

<p>库，尤其是那些旨在为基础设施关注点提供通用解决方案的库，往往有个额外的问题：它们会附上它们依赖的一整套额外的库。你的库的传递依赖树越大，它导致俗称为依赖地狱的噩梦的可能性就越高。因为你的微服务可能需要自己的额外的依赖，它们同样具有传递依赖性，直到它们中的某些库间接地拉进一些库的冲突版本，这只是个时间问题，只在不同版本之间选择是不可能的，因为它们是二进制不兼容的。</p>

<p>当然，你的解决方案也许只是提供微服务可能需要的所有库作为你的核心库的依赖。那仍然意味着你的微服务不能独立地演进，例如通过升级到它们依赖的唯一的特定库的更高版本——它们都与核心库的发布周期步调一致。除此之外，为什么你要强制每个服务接受一整堆的依赖，当它们实际上可能只需要依赖中的一些时？</p>

<h4 id="自顶而下的库设计">自顶而下的库设计</h4>

<p>通常情况下，我见过的库被一个或多个架构师强加于开发者，采用自顶而下的方法进行库设计。</p>

<p>通常，在这种情况下发生的是，由库暴露的API太受限制和不灵活，或者使用了错误的抽象级别，因为它们是由不够熟悉广泛的不同的真实世界用例的人设计的。这样的库经常导致不得不使用它的开发者遭受挫折，以及导致人们试图绕过库的限制。</p>

<h4 id="单语言解决一切">单语言解决一切</h4>

<p>强制使用库的最明显的缺陷之一是，这使得它更难以切换到不同的编程语言（或者平台，比如JVM或.NET），再次失去了微服务架构的一个优势，即选择最适合给定问题的技术的能力。如果你后来意识到，你终究需要这种语言或者平台的多样性，你必须创造各种奇怪的支持。例如，Netflix提出的<a href="https://github.com/Netflix/Prana">Prana</a>，一个同时运行非JVM服务的附加件，为他们提供到Netflix技术栈的一套HTTP API。</p>

<h3 id="我们能不能做得更好？">我们能不能做得更好？</h3>

<p>由于所有的问题都是通过库共享代码引入的，最极端的解决方案是根本没有这样的库。如果你这样做，你将不得不做一些复制和粘贴或者为新的微服务提供一个模板项目，以便从前面所述的步调一致中释放你的服务。基础设施代码以及领域模型的共享内核中都可以这么做。事实上，Eric Evans在他的关于领域驱动设计的经典蓝皮书中提到，“通常各个团队只是在各自的内核备份上改动，每隔一定时间才会与其他团队集成”[1]。共享内核不一定要是库。</p>

<p>如果你不喜欢复制和粘贴的想法，那也很好。毕竟，如上所述，通过库共享代码有一定的优势。在这种情况下，这里有一些重要的事情需要考虑：</p>

<h4 id="最少依赖的小型库">最少依赖的小型库</h4>

<p>尝试将大的共享库分成一组非常小的、高度集中的库，每个库解决一个特定的问题。试着让这些库成为零依赖库，只依靠语言的标准库。是的，仅仅针对语言的标准库来编程并不总是令人愉快的，但是对于你公司的所有团队的巨大好处（甚至超出你的公司，如果你的馆是开源的）显然大于这个微小的不便。</p>

<p>当然，零依赖并不总是可能的，特别是对于基础设施关注点。对于这些，通过你的每个小型库最小化所需的依赖。另外，有时可以独立于库的核心，提供与别的库的绑定或集成作为单独的工件。</p>

<h4 id="留下选择余地">留下选择余地</h4>

<p>不要指望服务将在特定时间点更新到共享库的最新版本的事实。换句话说，不要强制团队进行库更新，而是让他们可以按照自己的节奏自由更新。这可能需要你以向后和向前兼容的方式修改库，但它会解耦你的服务，不仅给你微服务架构的运营成本，而且还有一些优势。</p>

<p>如果可能，不仅要避免强制库更新，还要使库本身的使用可选。</p>

<h4 id="自底而上的库设计">自底而上的库设计</h4>

<p>最后，如果你想拥有共享库，我见过的获得成功的项目是使用自底而上的方法。让你的团队实现他们的微服务，而不是让象牙塔架构师设计在现实世界中几乎不可用的库，而当在多个服务的生产中已经证明它们自己的一些常见模式出现时，将它们提取到库中。</p>

<p>[1] Evans, Eric: Domain-Driven Design: Tackling Complexity in the Heart of Software, p. 355</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[协议分析器的威力]]></title>
    <link href="http://codemany.com/blog/the-power-of-protocol-analyzers/"/>
    <updated>2016-09-20T18:06:40+08:00</updated>
    <id>http://codemany.com/blog/the-power-of-protocol-analyzers</id>
    <content type="html"><![CDATA[<p>英文原文：<a href="http://arstechnica.com/information-technology/2016/09/the-power-of-protocol-analyzers/">http://arstechnica.com/information-technology/2016/09/the-power-of-protocol-analyzers/</a></p>

<p>问题发生在错综复杂的网络世界里。但要在一时激动之下确定一种新型问题的确切原因变得有些冒险。在这种情况下，当Google-fu耗尽的时候甚至其他能干的工程师也可能会被迫去依赖试错法。</p>

<p>幸运的是，有个秘密武器等待乐意的工程师去部署——协议分析器。该工具允许你明确地确定几乎任何错误的根源，给你提供在底层协议上自我学习的能力。现在唯一的问题是，许多工程师因为（毫无根据的）恐惧而完全回避它。</p>

<h3 id="什么是协议分析器？">什么是协议分析器？</h3>

<p>协议分析器，或者数据包嗅探器，是一个用于拦截通信量，存储它们，并以一个已解码的、人类可读的状态呈现它们的工具。现代协议分析器比如Wireshark甚至可以靠自己发现基本的问题，然后使用捕获的数据执行统计分析。</p>

<p>不理会特性，数据包嗅探器都以基本相同的方式工作。它们把自己插入到网络堆栈中，把所有通信量复制到一个缓冲区或文件。大部分还会将网络驱动置于“混杂模式”，该模式从根本上说允许这些工具取回所有进入网络堆栈的通信量，而不是只采集前往系统本身的通信量。</p>

<h3 id="协议分析仪如何帮助">协议分析仪如何帮助</h3>

<p>在很多情况下，解决一个困难的网络问题的最难部分是找到和理解问题的根源。这种困难的部分源于这样的事实，你对大多数问题使用的工具不是正确的对底层问题的工具。</p>

<p>如果你是一个系统管理员，很有可能你经常用于数据采集的工具是某种日志和错误消息。通常，这些都是解释工具。这些实体试图把原始数据总结为对非开发者或非工程师有意义的东西。因为解释工具是从应用层的视角提供问题的汇总数据，它们往往不能帮助你解决底层的问题。</p>

<p>例如，一条事件日志消息可以告诉你应用程序无法连接到服务器。它甚至可以告诉你根本原因是超时。但这条消息不大可能告诉你超时是由一个黑洞路由器丢弃一个大帧引起。它不能，因为事件日志消息服务不知道错误为何发生。为了使工具知道那个，它需要预测（不解释）这个非常问题，在MTU稳步减少的情况下发送数据包，直到一个通过。如果一个事件日志消息服务早就被编写好要做那件事，从一开始你就不会有这个问题。</p>

<p>当使用错误的工具时，你可能会在某处花上几个小时甚至几周的时间，直到你侥幸得到解决方案。然而，通过使用协议分析器和历久弥新的ping命令，你可以非常容易地在大约5分钟内诊断这个问题。就像早在高中时我的汽车技术辅导员就告诉我的，它全都是关于对任务使用恰当的工具。</p>

<p>除了确定错误，协议分析器提供为数不多的方法之一去证实问题的根源。以前我在微软的时候，棘手问题在团队间来回穿梭是很常见的，因为每个组误解由解释工具提供的数据。首先，问题可能被发送到Exchange团队，接着它可能被穿梭到Active Directory团队，然后最后到Networking团队。</p>

<p>通常，这是因为在其它团队的能力范围之内一个问题好像是合理的。然而，烫手山芋的游戏往往停止在Networking团队。为什么？因为Networking团队的头号工具是证实问题根源的救世主。</p>

<p>网络，像所有的计算，其核心是完全合乎逻辑的。一旦你了解它在幕后是如何工作的，你就有能力在底层确定问题，不论问题是多么独特。作为协议分析的一个伟大副作用，你也将学到很多关于网络的知识，它们将帮助你解决各种各样的网络问题（即使那些不需要协议分析）。</p>

<h3 id="wireshark基础">Wireshark基础</h3>

<p>现在，有各种各样的协议分析器可供选择，从免费的和相当功能的微软消息分析器到特性极其丰富但十分昂贵的Savvius Omnipeek。多年来我已经使用过大量的分析器，但我最喜欢的用于常规故障排除的协议分析器是Wireshark。它是免费的，开源的，多平台的具有很多特性的分析器。有个充满活力的社区站在它背后，而且Wireshark也相当容易习惯。这让它成为一个很好的开始的地方。</p>

<p>你可以从 <a href="https://www.wireshark.org/">https://www.wireshark.org/</a> 下载用于你操作系统的Wireshark。安装它没有什么特别的，但如果你是安装在Windows上，确保也安装了捆绑的WinPCAP驱动程序。这允许Wireshark实际上捕获数据包（没有它，你只能观看存档的数据包）。</p>

<p>Wireshark通常将你的NIC置于混杂模式。正常情况下，你的NIC只会保留前往你的MAC或者广播MAC（FF-FF-FF-FF-FF-FF）的帧。启用混杂模式后，不管怎样，你的NIC保留所有它听到的帧。</p>

<p>从理论上讲，这意味着你应该接收所有的在你Ethernet段上的数据包。不过，实际上如今几乎所有的Ethernet网络都是交换网络。如果你想接收所有的通信量，必须多做些工作。</p>

<p>一旦你已经安装了Wireshark，使用它是相当简单的。把它打开，你将看到如下显示的屏幕：</p>

<p><img src="/uploads/wireshark-network-analyzer.png" title="wireshark-network-analyzer" ></p>

<p>这个屏幕给你展示选择一个在它上面捕获数据包的NIC的选项和输入一个用于只捕获一部分入站数据包的过滤器的选项。如果你选择一个NIC然后点击在文件菜单下面的小鱼翅图标，Wireshark将立即开始捕获数据包。</p>

<p>随着数据包被捕获，Wireshark在主界面中实时地显示它们。当你准备停止时，你只需点击在鱼翅图标旁边的小红方块。</p>

<p><img src="/uploads/wireshark-main-interface.png" title="wireshark-main-interface" ></p>

<p>数据包列表部分显示在这个点捕获的每件事物，按它们被捕获的顺序排序（默认）。（你可以通过点击要作为排序依据的标题任意地排序这些数据包。）</p>

<p>数据包细节部分显示Wireshark解码的在数据包中的每个报头。基本上，Wireshark有几乎今天在用的每个协议的解码器，并且为了显示分成字段的数据，解码器工具自动应用到每个数据包。</p>

<p>举例来说，如下，我已经为一个典型的HTTP数据包增加了Ethernet II报头。</p>

<p><img src="/uploads/wireshark-http-header.png" title="wireshark-http-header" ></p>

<p>你可以清楚地看到Wireshark已经析出了Destination和Source的MAC地址，以及Type字段，它是0x0800。Type字段指出下个报头应该是一个IPv4报头，Wireshark很方便告诉你这个。</p>

<p>这个解码特性使你不必自己计算字节和解码它（不过，如果你愿意，你仍然还可以在原始字节部分做）。如果对原始字节部分有兴趣：Wireshark同时为所有数据提供ASCII转换，它有时提供令人惊讶的数据。在下图，你可以在ASCII视图里的这个数据包中清楚地看到HTTP请求发送的细节。</p>

<p><img src="/uploads/wireshark-ascii-view.png" title="wireshark-ascii-view" ></p>

<p>Wireshark同时也提供一些非常实用的分析和统计特性，包括测量响应时间和往返时间的能力。但到目前为止，最有用的特性是过滤功能。</p>

<p>在数据包列表直接的上方是一个文本框，那里你可以输入显示过滤器。默认不使用过滤器，意味着显示被捕获的所有数据包。然而，你经常最后得到信息过载，而过滤掉噪音是数据包分析的一个非常重要的部分。</p>

<p>Wireshark中的过滤器按照一门简单的语言结合协议字段、比较运算符和逻辑运算符以便过滤掉不匹配条件的数据包。例如，过滤器http将只显示HTTP通信量，而过滤器ip.addr == 192.168.1.10将只显示源或目标的IP地址是192.168.1.10的数据包。</p>

<p>当你是第一次开始的时候，过滤可能会有点令人生畏，但通常在Wireshark中学习过滤器的最简单的方法是使用内建的表达式工具。可以通过点击过滤器文本框右边的Expression按钮访问它。</p>

<p>这个工具允许你寻遍Wireshark本身支持的所有协议，挑选你想过滤的字段而不需要知道过滤器动词或语法。只需选择协议，填写呈现的字段，然后过滤器将会为你而建。这里，我使用表达式工具构建一个仅查找Ethernet广播的过滤器。</p>

<p><img src="/uploads/wireshark-filter-expression.png" title="wireshark-filter-expression" ></p>

<p>注意工具如何在底部的绿框中显示最终的过滤器语法。通过注意这个字段，你将最终变得熟悉你的最常用的过滤器。</p>

<p>然而，你不能用表达式工具做的一件事是把过滤器串起来。因为那个原因，你需要学习一些逻辑运算符。Wireshark的基本逻辑运算符是and（&amp;&amp;）、or（||）和not（!）。</p>

<p>and被用于结合过滤器，只有满足所有条件的数据包会被显示。例如，过滤器http &amp;&amp; ip.addr == 192.168.1.10将只显示在第7层报头中的HTTP协议和在IP报头中的IP地址192.168.1.10两者都包括的数据包。</p>

<p>or被用于查找两者中的任何一个过滤器，因此满足你输入的任何条件的数据包都会被显示。举例来说，过滤器http || ip.addr == 192.168.1.10将显示在第7层报头中的HTTP协议或在IP报头中的IP地址192.168.1.10的数据包。</p>

<p>not被用于从结果中过滤掉一些东西。例如，过滤器ip.addr == 192.168.1.10 ! http将显示有在IP报头中的IP地址192.168.1.10但没有在第7层报头中的HTTP协议的数据包。</p>

<p>关于基本的Wireshark功能最后要注意的事是，除保存你的原始捕获外，你也有多种多样的选项导出捕获。</p>

<p>首先，你导出当前选择的数据包、所有数据包、你标记的数据包或者一段范围的数据包。在这些选项的每一个中，你可以选择导出所有被捕获的数据包或只是被显示的数据包（考虑当前应用的过滤器）。这些选项让你非常具体地知道你想导出哪些数据包。</p>

<p><img src="/uploads/wireshark-export-packets.png" title="wireshark-export-packets" ></p>

<p>此外，你可以把数据包导出成几乎任何常用的格式。在Wireshark中用于文档和电子邮件转出的最好的特性之一是以纯文本或CSV格式导出解剖数据包（完整的数据包解码）的能力。要做到这个，只需从文件菜单里选择“Export Packet Dissections”。</p>

<h3 id="理解你所看到的">理解你所看到的</h3>

<p>尽管所有这些功能都很好，底线是如果你不明白在每个报头中字段的目的它们都是无用的。幸运的是，除了少量专有协议，你遇到的几乎每个协议的规格说明都是免费在线的。</p>

<p>例如：Ethernet，你可以直接到IEEE下载标准；802.3标准可以在 <a href="http://standards.ieee.org/about/get/802/802.3.html">http://standards.ieee.org/about/get/802/802.3.html</a> 获得。它是免费的直接来自权威人士。如果你在查找802.3 Ethernet帧格式，你将发现真的只有3个感兴趣的字段：目标MAC地址、源MAC地址和类型/长度字段。下图中在Wireshark解剖体左边的是来自IEEE 802.3规格说明Section 1中Part 3.1.1的Figure 3-1：</p>

<p><img src="/uploads/wireshark-packet-format.png" title="wireshark-packet-format" ></p>

<p>如果你想知道preamble和SFD发生了什么，它们在帧从NIC到Wireshark向上传递给栈之前被移除。同样地，你通常不会在末尾看到FCS，因为它在向上传递帧之前被剥去。</p>

<p>在第2层上面，所有TPCTCP/IP协议由IETF管理和由RFCs（请求评论）定义。所有这些RFCs可以在站点 <a href="https://www.rfc-editor.org/">https://www.rfc-editor.org/</a> 上即刻地免费地获得。虽然它们有点简洁（并且因为这个原因有时难以理解），它们总是正确的，具体问题的澄清可以使用Google快速搜索获得。</p>

<p>举例来说，通常混淆新手的事情之一是大量TCP重置，或者在TCP报头中数据包有打开的RST标记。浏览RFC 793（TCP），你可能会得到RST总是用信号告知一些坏事情的印象。几乎所有的35个左右提到的RST与某种错误条件有关联。</p>

<p>然而，使用关键词“tcp rst from client”的Google快速搜索将让你得到大量的关于这个现象的很好的讨论。也许最好的是来自Wireshark论坛，在那里他们解释说这很平常，因为客户端应用仅仅被编码去重置链接而不是优雅地关闭它。在这种情况下，服务端已经发送一个FIN。作为回复一个FIN/ACK并等待最终的ACK的替换，客户端只需通过发送一个RST并中止会话来优化过程。在下面的示例中这可以清楚地被看到。</p>

<p><img src="/uploads/wireshark-pcap-example.png" title="wireshark-pcap-example" ></p>

<p>除了规格说明和Google，另一个学习协议通常如何运转的良好来源是示例跟踪的资料库。这些示例跟踪允许你去查看相当典型的既常见又晦涩的协议操作，以及一些十分罕见的平常可能不会碰到的错误。</p>

<p>一个很好的起点是Wireshark Wiki上的样板捕获：<a href="https://wiki.wireshark.org/SampleCaptures">https://wiki.wireshark.org/SampleCaptures</a> 。在这里有大量非常有用的捕获让你去下载以及用过滤和其它Wireshark特性做实验，包括像广播风暴、病毒和攻击套装这样有意思的错误。如果这些还不够，在这个页面上还有一些其它资源的链接去协助你。但是毫无疑问地，变得擅长协议分析的最快方式是仔细观看大量的捕获并试图理解被使用的协议。</p>

<h3 id="如何得到好的捕获">如何得到好的捕获</h3>

<p>如果不能捕获正确的数据，世界上所有的领悟都无济于事。在最基本的层面，目标是只捕获涉及你试图解决的问题的数据包，有效减少你跟踪里的噪音。</p>

<p>为了做到这点，你可以使用一个捕获过滤器去从捕获中排除那些匹配过滤器外的所有数据。如果你确切地知道你在寻找什么这会工作的很好，但往往这种方法会导致你不能觉察一些重要的事情。大多数时候你只有一个问题是什么的粗略想法，或者你忘了一些潜在的找到错误的关键的过程。如果这种情况发生，使用捕获过滤器就没那么幸运，而且你不能返回和没重设置它就不过滤捕获。</p>

<p>例如，在诊断一个网站的性能问题时，你可能决定使用一个捕获过滤器集从Web服务器自身取得捕获，以便只捕获在其与客户端系统和后台SQL服务器之间往返的数据。然而，这个问题实际上可能仅仅是Web服务器使用的身份验证服务器过载，等待身份验证才是引起整个性能问题的原因。使用你选择的捕获过滤器你将永远不会发现这个问题。</p>

<p>这是我倾向于捕获所有数据并且使用显示过滤器去减少跟踪里的噪音的原因。这不是说捕获过滤器完全不必要。捕获过滤器的一个常见用途是当你有一个非常繁忙的你正在捕获的千兆或万兆连接的时候，捕获过滤器变得有用仅仅是因为大量的数据。不过，你始终需要牢记过滤器的限制。</p>

<p>得到一个好的捕获的第二部分是正确识别你需要捕获的系统。举例来说，在前面关于Web服务器性能问题的例子中，我可能首先会从Web服务器和Web客户端两者取得同时发生的捕获。这样你可以看到两边的正常预期行为的任何偏差，这有助于你将问题隔离到服务器或客户端。</p>

<p>一旦查明延迟是一个与身份验证有关的服务端问题，然后我会从Web服务器和身份验证服务器两者取得其它的跟踪。这样，我可以看到是本地到身份验证服务器的问题还是等待像DNS这样其它服务的问题或者Global Catalog是实际上的罪魁祸首。</p>

<p>得到一个好的捕获的第三步是在成功和失败条件中都使用捕获。举例来说，如果你有一个间歇性的Web服务器性能问题，设法在站点正常和不正常工作时都得到跟踪。这能给你一个好的和坏的比较跟踪，可以使用它去隔离问题。</p>

<p>最后，当处理一个间歇性的问题时，你会发现很难得到一个失败捕获。在这种情况下，Wireshark有一个很重要的特性被称为环形缓冲区，它允许你持续地捕获。</p>

<p>通常，特别在一个繁忙的网络上，持续的捕获将冒填满磁盘的风险。但有了环形缓冲区，Wireshark会写入文件直到它达到指定大小或者经过一段时间，然后它会切换到一个新文件。一旦指定数量的文件已经被写入，程序删除最旧的文件。例如，看看下面我已经定义的设置：</p>

<p><img src="/uploads/wireshark-capture-interfaces.png" title="wireshark-capture-interfaces" ></p>

<p>这个配置告诉Wireshark不管文件大小每10分钟创建一个新文件，并且确保程序保留总计3个文件，根据需要删除最旧的。这确保从错误被通知的时间起我有30分钟去停止捕获。这是一个非常有用的技术用于捕获极其间歇性的问题。</p>

<p>这些是你需要的以便用Wireshark开始故障排除的所有基本技术。使用这些技术和资源，你会发现你经常能用比几乎任何其它技术更短的时间找到和验证网络问题的原因。快乐的故障排除。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何创建有效的图标]]></title>
    <link href="http://codemany.com/blog/how-to-create-effective-icons/"/>
    <updated>2016-08-06T12:43:17+08:00</updated>
    <id>http://codemany.com/blog/how-to-create-effective-icons</id>
    <content type="html"><![CDATA[<p>英文原文：<a href="http://www.awwwards.com/how-to-create-effective-icons.html">http://www.awwwards.com/how-to-create-effective-icons.html</a></p>

<p>我可能就是你所说的图标爱好者。我喜欢图标，而且我更加喜欢制作它们！作为一个艺术家，我的背景在很大程度上是绘画——我喜欢绘画，并且我已经画了一辈子（甚至远远早于我知道什么是图形设计）。我想，这是我理解创建图标的一个关键。绘画教你看——然后把你所看到的转化成纸上的线条和图形——而这正是如何创建有效的图标。</p>

<h3 id="几何图形">几何图形</h3>

<p>因此，对初学者而言，基本上任何东西都可以用这四种图形组合而成：</p>

<p><img src="/uploads/effective-icons-1.png" title="effective-icons-1" ></p>

<p>当我想把某事物转换成一个图标时，我观察它然后尽可能地将其拆分为最简单的图形。例如，水滴可以用一个三角形和一个圆形组成。</p>

<p><img src="/uploads/effective-icons-2.png" title="effective-icons-2" ></p>

<p>心形图标可以由两个圆形和一个三角形构成。</p>

<p><img src="/uploads/effective-icons-3.png" title="effective-icons-3" ></p>

<p>我每次都是在Adobe Illustrator中创建这些图形。使用矢量图形可以让我控制线条的粗细，以及图形和其锚点的相互作用。Illustrator也可以让我自由地把线条转换成图形，反之亦然。这一切也许看起来十分基础，但它是我用于创建最复杂图标的同样的方法。下面是我最近在做的一个略微更加复杂些的《权利法案》图标的示例，在这里我应用了同样的原则。</p>

<p><img src="/uploads/effective-icons-4.png" title="effective-icons-4" ></p>

<h3 id="界面图标">界面图标</h3>

<p>我最近有机会为一款超赞的iPhone应用Parker Planner制作一组图标。我很喜欢做这个项目，这个项目其中最重要的一个方面是创建一组易懂的、私有的、实用的和美观的用户界面图标，可以帮助用户浏览操作这款略微复杂的计划应用。</p>

<p><img src="/uploads/effective-icons-5.png" title="effective-icons-5" ></p>

<p>让我们选取这些图标的其中之一分解看看我如何创建它。例如，垃圾桶图标是由三个圆角矩形和三条线构成。</p>

<p>1、选择圆角矩形工具。</p>

<p><img src="/uploads/effective-icons-6.png" title="effective-icons-6" ></p>

<p>2、拖动出一个图形。</p>

<p><img src="/uploads/effective-icons-7.png" title="effective-icons-7" ></p>

<p>3、调整笔划宽度直到你满意。</p>

<p><img src="/uploads/effective-icons-8.png" title="effective-icons-8" ></p>

<p>我通常选择在整组图标中使用一到两种笔划宽度。</p>

<p><img src="/uploads/effective-icons-9.png" title="effective-icons-9" ></p>

<p>这使它们看起来更一致和感觉更有整体性。</p>

<p>4、用另一个圆角矩形创建盖子。</p>

<p><img src="/uploads/effective-icons-10.png" title="effective-icons-10" ></p>

<p>5、再一个圆角矩形创建盖子的把手。</p>

<p><img src="/uploads/effective-icons-11.png" title="effective-icons-11" ></p>

<p>6、擦除圆角矩形的下半部分。</p>

<p><img src="/uploads/effective-icons-12.png" title="effective-icons-12" ></p>

<p>7、现在，通过添加三条竖线到桶身上给桶添加条纹。</p>

<p><img src="/uploads/effective-icons-13.png" title="effective-icons-13" ></p>

<p>8、然后你就获得了它！一个垃圾桶图标……如果你喜欢，你可以用颜色或线条宽度做进一步调整。</p>

<p><img src="/uploads/effective-icons-14.png" title="effective-icons-14" ></p>

<p>我在创建图标时经常使用的一些其它真正有用的工具是Pathfinder，我使用它来剪切、连接和挖空图形。</p>

<p><img src="/uploads/effective-icons-15.png" title="effective-icons-15" ></p>

<p>Stroke/Fill工具，它帮助你将图形在填满和笔划间切换。</p>

<p><img src="/uploads/effective-icons-16.png" title="effective-icons-16" ></p>

<p>以及我非常喜欢的工具Stroke Panel，它帮助你将拐角和线的末端从直角转换到圆角。</p>

<p><img src="/uploads/effective-icons-17.png" title="effective-icons-17" ></p>

<p>当我完成一组图标，我通常将它们全体紧挨着排成一排，看看是否有哪个看起来很奇怪或不到位。然后我会做任何必要的修改。</p>

<p><img src="/uploads/effective-icons-18.png" title="effective-icons-18" ></p>

<p>最后，我总是在应用中测试它们以确保它们感觉正确和功能良好。</p>

<p><img src="/uploads/effective-icons-19.png" title="effective-icons-19" ></p>

<p>最终，我想说创建优秀图标的方法不仅仅是学习Illustrator技巧，尽管它们也是必需的。最好的做法是练习把你周围看到的事物分解成简单图形。你在这点上越是变得更好，你越是能够成为更高超的图像设计师！加油！</p>
]]></content>
  </entry>
  
</feed>
