<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Java | 乐者为王]]></title>
  <link href="http://codemany.com/tags/java/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2014-08-24T18:55:48+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[如何从数组中抽取随机不重复的数字]]></title>
    <link href="http://codemany.com/blog/2012/12/06/how-to-extract-random-digit-without-replacement-from-array/"/>
    <updated>2012-12-06T05:49:29+08:00</updated>
    <id>http://codemany.com/blog/2012/12/06/how-to-extract-random-digit-without-replacement-from-array</id>
    <content type="html"><![CDATA[<p>今天浏览订阅的博客时发现了一个巧妙的从数组中抽取随机不重复数字的算法。譬如，在100个不重复的数字中选择10个不相同的数字，通过这个算法就不需要修改数组长度和删除数组元素等。具体算法如下：</p>

<p>```
int[] numbers = new int[100];
int[] selected = new int[10];</p>

<p>for (int i = 0, n = numbers.length; i &lt; selected.length; i++) {</p>

<pre><code>int idx = (int)(Math.random() * n);    // 随机产生一个从0 - (n-1)的数字
selected[i] = numbers[idx];
numbers[idx] = numbers[n - 1];
n--;    // 减1，从而在下次循环时产生的随机的numbers数组下标的范围从0 - (n-1)-1，
        // 保证了上一步中已经赋值给数组中其它数的numbers[n-1]不会在下次循环中给
        // 取得，确保了产生的数组selected中的数为不重复的。
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[将Nokia 6670的短信导入HTC Hero G3]]></title>
    <link href="http://codemany.com/blog/2011/06/21/transfer-sms-from-nokia6670-to-htc-hero-g3/"/>
    <updated>2011-06-21T08:43:10+08:00</updated>
    <id>http://codemany.com/blog/2011/06/21/transfer-sms-from-nokia6670-to-htc-hero-g3</id>
    <content type="html"><![CDATA[<p>这事本该N久前就该干了（09年末把手机从Nokia 6670换到HTC Hero G3），却一直拖着没有做，今天终于把这事作了一个了结。</p>

<p>Nokia下导出的短信是如Messages_Nokia 6670_20091215.xml这样的一个XML文件，文件内容的编码是unicode，格式就像下面这样：</p>

<p>```
&lt;?xml version="1.0" encoding="unicode"?>
<SMS PhoneModel="Nokia 6670">
  <Message DateTime="2011-06-21 10:10:10"></p>

<pre><code>&lt;Sender&gt;路人甲&lt;/Sender&gt;
&lt;PhoneNumber&gt;+8613988888888&lt;/PhoneNumber&gt;
&lt;Location&gt;Inbox&lt;/Location&gt;
&lt;Text&gt;我是路人甲&lt;/Text&gt;
</code></pre>

<p>  </Message></p>

<p>  <Message DateTime="2011-06-21 11:11:11"></p>

<pre><code>&lt;Sender&gt;路人乙&lt;/Sender&gt;
&lt;PhoneNumber&gt;+8613966666666&lt;/PhoneNumber&gt;
&lt;Location&gt;Outbox&lt;/Location&gt;
&lt;Text&gt;我是路人乙&lt;/Text&gt;
</code></pre>

<p>  </Message>
</SMS>
```</p>

<p>本来是想写个Android应用来直接导入这些备份短信的，不过在实现的过程中发现了SMS Backup&amp;Restore应用导出的备份文件和Nokia的备份文件类似，产生了做个将Nokia备份文件转换成SMS Backup&amp;Restore备份文件的念头，又在网上发现了nicholashan的教程<a href="http://bbs.hiapk.com/thread-140564-1-1.html">《将Nokia的短信导入Hero(可能适用所有Android机型)》</a>，坚定了我的这个想法。</p>

<p>分析了一下SMS Backup&amp;Restore备份文件的格式，文件内容的编码是utf-8的：</p>

<p>```
&lt;?xml version='1.0' encoding='utf-8' standalone='yes' ?>
<smses count="3">
  &lt;sms protocol="0" address="10658658" date="1308629532000"</p>

<pre><code>type="1" subject="null" body="我是内容" toa="null"
sc_toa="null" service_center="null" read="1"
status="-1" locked="0" /&gt;
</code></pre>

<p>  &lt;sms protocol="0" address="13566666666" date="1308633733000"</p>

<pre><code>type="2" subject="null" body="我也是内容" toa="null"
sc_toa="null" service_center="null" read="1"
status="-1" locked="0" /&gt;
</code></pre>

<p>  &lt;sms protocol="0" address="+8613588888888" date="1308641377000"</p>

<pre><code>type="1" subject="null" body="我还是内容" toa="null"
sc_toa="null" service_center="null" read="1"
status="-1" locked="0" /&gt;
</code></pre>

<p></smses>
```</p>

<p>与转换相关的就address、date、type和body四个属性。address是发信人的号码；date是短信发送日期的timestamp。这点nicholashan的确说错了，后面不需要加什么0的（实际上nicholashan自己也怀疑自己的说法）；type等于1表示别人发给你的短信，如果是2的话就是你发给其他人的短信；body就是短信内容了。</p>

<p>将Nokia中的时间转换到SMS Backup&amp;Restore的时间可以使用下面的代码：</p>

<p>```
DateFormat dt = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
long value = 1355296332000L;    // 2012-12-12 12:12:12
Element e = (Element)iter.next();
Attribute attr = e.attribute("DateTime");
try {</p>

<pre><code>value = dt.parse(attr.getValue()).getTime();
</code></pre>

<p>} catch (ParseException ex) {
}
```</p>

<p>完整的代码如下（使用dom4j实现XML解析）：</p>

<p>```
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Iterator;
import java.util.List;</p>

<p>import org.dom4j.Attribute;
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.DocumentHelper;
import org.dom4j.Element;
import org.dom4j.Node;
import org.dom4j.io.SAXReader;
import org.dom4j.io.XMLWriter;</p>

<p>public class Main {</p>

<pre><code>public static void main(String[] args) {
    try {
        SAXReader sr = new SAXReader();
        Document doc = sr.read(new File(args[0]));

        generateDocument(doc);
    } catch (DocumentException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }
}

private static void generateDocument(Document doc) {
    List list = doc.selectNodes("//Message");

    Document document = DocumentHelper.createDocument();
    Element smses = document.addElement("smses");
    smses.addAttribute("count", String.valueOf(list.size()));

    DateFormat dt = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    long value = 1355296332000L;    // 2012-12-12 12:12:12
    Iterator iter = list.iterator();
    while (iter.hasNext()) {
        Element e = (Element)iter.next();
        Attribute attr = e.attribute("DateTime");
        try {
            value = dt.parse(attr.getValue()).getTime();
        } catch (ParseException e) {
            System.out.println(e.getMessage());
        }
        Node phone = e.selectSingleNode("PhoneNumber");
        Node location = e.selectSingleNode("Location");
        Node text = e.selectSingleNode("Text");

        Element sms = smses.addElement("sms");
        sms.addAttribute("protocol", "0");
        sms.addAttribute("address", phone.getText());
        sms.addAttribute("date", String.valueOf(value));
        if ("Inbox".equals(location.getText())) {
            sms.addAttribute("type", "1");
        } else if ("Outbox".equals(location.getText())) {
            sms.addAttribute("type", "2");
        }
        sms.addAttribute("subject", "null");
        sms.addAttribute("body", text.getText());
        sms.addAttribute("toa", "null");
        sms.addAttribute("sc_toa", "null");
        sms.addAttribute("service_center", "null");
        sms.addAttribute("read", "1");
        sms.addAttribute("status", "-1");
        sms.addAttribute("locked", "0");
    }

    File f = new File("output.xml");
    XMLWriter output = new XMLWriter(new FileWriter(f));
    output.write(document);
    output.close();
}
</code></pre>

<p>}
```</p>

<p>代码下载：<a href="https://github.com/dohkoos/N6670Conv">https://github.com/dohkoos/N6670Conv</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[短信分拆算法]]></title>
    <link href="http://codemany.com/blog/2007/11/22/sms-split-algorithm/"/>
    <updated>2007-11-22T21:34:47+08:00</updated>
    <id>http://codemany.com/blog/2007/11/22/sms-split-algorithm</id>
    <content type="html"><![CDATA[<p>今天，突然心血来潮，写了一段分拆短信的代码。代码如下：</p>

<p>```
public class SMSHelper {</p>

<pre><code>private static final int SMS_MAX_LENGTH = 70;

public static List split(String msg) {
    if (msg.length() &lt;= SMS_MAX_LENGTH) {
        throw new IllegalArgumentException("被分拆的短信长度必须大于70个字符");
    }

    List&lt;String&gt; list = new ArrayList&lt;String&gt;();
    int i = 0, start = 0;
    while (true) {
        i++;
        String prompt = "(第" + i + "条)";
        int remain = SMS_MAX_LENGTH - prompt.length();
        if (start + remain &gt; msg.length()) {
            list.add(prompt + msg.substring(start));
            break;
        }
        list.add(prompt + msg.substring(start, start + remain));
        start += remain;
    }
    return list;
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何解决含有中文的页面末尾内容会被SiteMesh截掉的问题]]></title>
    <link href="http://codemany.com/blog/2005/07/22/how-to-solve-sitemesh-truncate-the-page-containing-chinese-character/"/>
    <updated>2005-07-22T14:33:59+08:00</updated>
    <id>http://codemany.com/blog/2005/07/22/how-to-solve-sitemesh-truncate-the-page-containing-chinese-character</id>
    <content type="html"><![CDATA[<p>首先我们先要了解一下ServletResponse.setContentLength(int len)的含义。setContentLength是设置返回内容体长度的方法，len是内容体的长度。由于网络上传输内容是以字节（byte）为单位的，所以len就是指内容体有多少个字节。假设现在有长度为100个字节的数据，在输出数据到客户端前我们用setContentLength(90)设置内容体的长度为90个字节。那么在客户端接收到的数据长度就是90个字节而不是100。下面我们来做个试验：</p>

<p>```
public class PageTruncateFilter implements Filter {</p>

<pre><code>public void init(FilterConfig config) throws ServletException {
}

public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
                    throws IOException, ServletException {
    HttpServletRequest request = (HttpServletRequest)req;
    HttpServletResponse response = (HttpServletResponse)res;

    String content = "&lt;html&gt;&lt;head&gt;&lt;title&gt;Truncated Page&lt;/title&gt;&lt;/head&gt;";
           content += "&lt;body&gt;这个页面的内容will be truncated.&lt;/body&gt;&lt;/html&gt;";
    response.setCharacterEncoding("gbk");
    response.setContentLength(content.length());
    PrintWriter out = response.getWriter();
    out.println(content);
    out.close();
}

public void destroy() {
}
</code></pre>

<p>}
```</p>

<p>由于content字符串含有两个中文字符，每一个中文字符又是由两个字节组成，所以content.length()的值比content的字节数要少2。在客户端显示的内容也会因此少2个字节，即缺少“l>”这两个字符。</p>

<p>现在我们来浏览SiteMesh的源码找出问题的原因。首先从PageFilter.java的doFilter方法开始。由于页面没有在decorators.xml中注册修饰，所以writeOriginal方法会被调用。下面是writeOriginal方法的源代码：</p>

<p>```
/<em>* Write the original page data to the response. </em>/
private void writeOriginal(HttpServletRequest request, HttpServletResponse response,</p>

<pre><code>                      Page page) throws IOException {
response.setContentLength(page.getContentLength());

if (request.getAttribute(USING_STREAM).equals(Boolean.TRUE)) {
    PrintWriter writer = new PrintWriter(response.getOutputStream());
    page.writePage(writer);
    // flush writer to underlying outputStream
    writer.flush();
    response.getOutputStream().flush();
} else {
    page.writePage(response.getWriter());
    response.getWriter().flush();
}
</code></pre>

<p>}
```</p>

<p>首行代码就是设置内容体长度的，让我们追到page.getContentLength()里面去看看（Page接口的getContentLength方法是由AbstractPage.java实现的）：</p>

<p>```
public int getContentLength() {</p>

<pre><code>return pageData.length;
</code></pre>

<p>}
```</p>

<p>它返回pageData数组的长度。但是pageData数组是char类型的，假如pageData中有中文内容时，设置的内容体长度就会小于pageData的字节数。这时就会出现输出到客户端的数据截掉的问题。所以只要修改getContentLength方法返回的值就可以了，下面是修改后的getContentLength方法：</p>

<p>```
public int getContentLength() {</p>

<pre><code>String content = new String(pageData);
return content.getBytes().length;
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Eclipse 3中使用SSH2访问gro.clinux.org的CVS服务器]]></title>
    <link href="http://codemany.com/blog/2005/07/07/using-ssh2-to-access-gro-clinux-org-cvs-server-in-eclipse3/"/>
    <updated>2005-07-07T18:33:00+08:00</updated>
    <id>http://codemany.com/blog/2005/07/07/using-ssh2-to-access-gro-clinux-org-cvs-server-in-eclipse3</id>
    <content type="html"><![CDATA[<p>在Eclipse中生成公钥和私钥</p>

<p>打开Eclipse，进入Window -> Preferences -> Team -> CVS -> SSH2 Connection Method -> Key Management，点击Generate RSA Key...然后填写Passphrase 和Confirm Passphrase，接着点击Save Private Key...保存公钥和私钥（公钥和私钥文件保存在~/.ssh/目录下，id_rsa是私钥文件，id_rsa.pub 是公钥文件）。</p>

<p>将公钥上传至gro.clinux.org服务器</p>

<p>登陆gro服务器，进入[帐号维护]，在页面底部你可以看到如下信息：</p>

<p>```
Shell帐号信息</p>

<p>Shell box：
CVS/SSH 共享认证Key：0 [编辑Keys]
```</p>

<p>点击[编辑Keys]，然后把刚才生成的文件id_rsa.pub中的内容粘贴到文本框中（看看是不是符合它上面的要求，千万要仔细看看），如果没有问题的话，就更新吧。大约6个小时后cron会自动更新，在服务器上你的目录下会自动添加文件夹/.ssh/，里面包含了名为authorized_keys2的文件，你的公钥就保存在这里。</p>

<p>在Eclipse中建立CVS连接</p>

<p>打开CVS Repository Exploring Perspective，进入New -> Repository Location，填入以下内容：</p>

<p><code>
Host：cvs.unixname.gro.clinux.org
Repository Path：/cvsroot/unixname
User：你在gro.clinux.org上注册的帐户
Password：先前保存公钥和私钥时输入的Passphrase
Connection Type：extssh
</code></p>

<p>点击Finish。如果你是第一次登录的话，将会弹出一个对话框，不用看那么仔细，直接点击OK就好了。</p>
]]></content>
  </entry>
  
</feed>
