<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Android | 乐者为王]]></title>
  <link href="http://codemany.com/tags/android/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2014-09-15T15:50:49+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用fastboot给Galaxy Nexus刷官方ROM]]></title>
    <link href="http://codemany.com/blog/2012/05/16/flash-official-rom-to-galaxy-nexus-with-fastboot/"/>
    <updated>2012-05-16T06:59:56+08:00</updated>
    <id>http://codemany.com/blog/2012/05/16/flash-official-rom-to-galaxy-nexus-with-fastboot</id>
    <content type="html"><![CDATA[<p>在刷机前先解释一些基本概念：</p>

<ul>
<li>root - 系统管理员权限</li>
<li>bootloader - 在OS运行前执行的代码，相当于电脑上的BIOS</li>
<li>解锁 - 就是解锁bootloader。解锁之后才可以刷ROM和获取ROOT权限</li>
<li>recovery - 执行底层操作的界面，相当于纯DOS界面</li>
<li>fastboot - 是比recovery更底层的操作界面

<blockquote><p>fastboot is a special diagnostic and engineering protocol that you can boot your Android device into.</p></blockquote></li>
</ul>


<p>分区解释：</p>

<ul>
<li>system：系统分区，我们刷ROM一般就是刷的这个分区</li>
<li>userdata：数据分区</li>
<li>cache：缓存分区</li>
<li>recovery：恢复分区</li>
<li>boot：存放内核和ramdisk的分区</li>
<li>hboot: 这个是SPL所在的分区，很重要。也是fastboot所在的分区，刷错就真的变砖了（所以一般不轻易刷这个）</li>
<li>splash1：这个就是开机第一屏幕了</li>
<li>radio：这个不是什么收音机，而是指无线通信模块，俗称基带（radio最初的意思是无线电通讯）</li>
</ul>


<p>刷机步骤：</p>

<p>1、备份好所有重要信息和数据；</p>

<p>2、安装adb驱动（或者在机器进入fastboot模式后安装也行）</p>

<p>3、下载官方镜像，解压缩。成功解压缩后应该会得到五个文件：</p>

<p><code>
flash-all.sh
flash-base.sh
radio-maguro-i9250xxla02.img
bootloader-maguro-primela03.img
image-yakju-imm76i.zip
</code></p>

<p>4、下载Galaxy-Nexus-fastboot-v2.0.zip，解压缩。将官方固件copy到目录下重命名。规则如下：</p>

<p><code>
刷基带请将radio-xxx.img重命名为radio.img
刷BL请将bootloader-xxx.img重命名为bootloader.img
刷固件请将image-xxx.zip重命名为image.zip
</code></p>

<p>5、关机进入fastboot模式（在关机状态下同时按“音量+”和“音量-”和“电源”三个键，等待机器发出轻微震动即可放开）</p>

<p>6、运行bat文件，选择2进行解锁（音量键选择“YES”开头的，然后按电源键确定）</p>

<p>7、然后开始刷机，基带和BL能不刷就不刷，防止变砖头。不过我在刷的过程中就提示必须刷基带和BL。</p>

<p><img src="/uploads/gn-flash-fail.png" title="gn-flash-fail" ></p>

<p>PS：顺带着把同事的日版机也刷到4.0.4版本。在刷的过程中出现了莫名其妙的事情。刷机一切正常，但是重启之后，就无限在第一屏重启。抠电池重新再刷，还是老样子，但多重启两次后竟然进去了。唉，搞不懂！</p>

<p>刷机工具下载：<a href="https://github.com/dohkoos/galaxy-nexus-flash-tools">https://github.com/dohkoos/galaxy-nexus-flash-tools</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[创建Android自定义键盘]]></title>
    <link href="http://codemany.com/blog/2011/08/30/create-custom-keyboard-for-android/"/>
    <updated>2011-08-30T02:10:05+08:00</updated>
    <id>http://codemany.com/blog/2011/08/30/create-custom-keyboard-for-android</id>
    <content type="html"><![CDATA[<p>在使用股票应用时，我们会发现这些应用使用的是特殊的软键盘，这是如何实现的呢？下面就来做个实例详解。</p>

<p>注意，这篇文章不是教你如何创建输入法，如果你想创建自己的输入法，可以研究文章<a href="http://developer.android.com/resources/articles/creating-input-method.html">Creating an Input Method</a>和Android Sample中的SoftKeyboard项目。</p>

<p><img src="/uploads/android-custom-keyboard.png" title="android-custom-keyboard" ></p>

<p>软键盘实现：在Android中软键盘是很容易实现的，通过android.inputmethodservice.Keyboard类来创建软键盘，该类从XML文件中读取软键盘信息。有多少行，每行有多少按键，每个按键代表什么内容等。下面是软键盘的XML代码：</p>

<p>```
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;Keyboard xmlns:android="<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>"</p>

<pre><code>android:keyWidth="25%p"
android:horizontalGap="0px"
android:verticalGap="0px"
android:keyHeight="@dimen/key_height"&gt;
&lt;Row&gt;
    &lt;Key android:codes="49" android:keyLabel="1" /&gt;
    &lt;Key android:codes="50" android:keyLabel="2" /&gt;
    &lt;Key android:codes="51" android:keyLabel="3" /&gt;
    &lt;Key android:codes="57419"
        android:keyEdgeFlags="right"
        android:keyIcon="@drawable/sym_keyboard_left" /&gt;
&lt;/Row&gt;
&lt;Row&gt;
    &lt;Key android:codes="52" android:keyLabel="4" /&gt;
    &lt;Key android:codes="53" android:keyLabel="5" /&gt;
    &lt;Key android:codes="54" android:keyLabel="6" /&gt;
    &lt;Key android:codes="57421"
        android:keyEdgeFlags="right"
        android:keyIcon="@drawable/sym_keyboard_right" /&gt;
&lt;/Row&gt;
&lt;Row&gt;
    &lt;Key android:codes="55" android:keyLabel="7" /&gt;
    &lt;Key android:codes="56" android:keyLabel="8" /&gt;
    &lt;Key android:codes="57" android:keyLabel="9" /&gt;
    &lt;Key android:codes="-5"
        android:keyHeight="@dimen/key_height_large"
        android:keyEdgeFlags="right"
        android:isRepeatable="true"
        android:keyIcon="@drawable/sym_keyboard_delete" /&gt;
&lt;/Row&gt;
&lt;Row&gt;
    &lt;Key android:codes="-3" android:keyIcon="@drawable/sym_keyboard_done" /&gt;
    &lt;Key android:codes="48" android:keyLabel="0" /&gt;
    &lt;Key android:codes="88" android:keyLabel="X" /&gt;
&lt;/Row&gt;
</code></pre>

<p></Keyboard>
```</p>

<p>在上面的键盘定义中，Row元素说明这是一行按键的定义，Key元素说明这是一个按键的定义。Key元素通过一些属性来定义每个按键，下面是一些常用的属性介绍：</p>

<p>```
codes：代表按键对应的输出值，可以为unicode值或则逗号（,）分割的多个值，也可以为一个字符串。</p>

<pre><code>   在字符串中通过“\”来转义特殊字符，例如“\n”或者“\uxxxx”。Codes通常用来定义该键的键码，
   例如上图中的数字按键1对应的为49。如果提供的是逗号分割的多个值则和普通手机输入键盘一
   样在多个值之间切换。
</code></pre>

<p> keyLabel：代表按键显示的文本内容。
 keyIcon：代表按键显示的图标内容，如果指定了该值则在显示的时候显示为图片不显示文本。
 keyWidth：代表按键的宽度，可以为精确值或则相对值，对于精确值支持多种单位，例如：像素，英</p>

<pre><code>       寸等；相对值为相对于基础取值的百分比，为以%或则%p结尾，其中%p表示相对于父容器。
</code></pre>

<p> keyHeight：代表按键的高度，取值同上。
 horizontalGap：代表按键前的间隙（水平方向），取值同上。
 isSticky：指定按键是否为sticky的。例如Shift大小写切换按键，具有两种状态，按下状态和正常</p>

<pre><code>       状态，取值为true或则false。
</code></pre>

<p> isModifier：指定按键是否为功能键(modifier key)，例如Alt或则Shift，取值为true或则false。
 keyOutputText：指定按键输出的文本内容，取值为字符串。
 isRepeatable：指定按键是否是可重复的，如果长按该键可以触发重复按键事件则为true，否则为false。
 keyEdgeFlags：指定按键的对齐指令，取值为left或则right。
```</p>

<p>然后在main.xml文件末尾加入以下代码：</p>

<p>```
&lt;RelativeLayout</p>

<pre><code>android:layout_width="fill_parent"
android:layout_height="wrap_content"&gt;
&lt;android.inputmethodservice.KeyboardView
    android:id="@+id/keyboard_view"
    android:visibility="gone"
    android:focusable="true"
    android:focusableInTouchMode="true"
    android:layout_width="fill_parent"
    android:layout_height="wrap_content"
    android:layout_alignParentBottom="true" /&gt;
</code></pre>

<p></RelativeLayout>
```</p>

<p>下面是主要的处理代码：</p>

<p>```
public class MainActivity extends Activity {</p>

<pre><code>@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main);

    EditText edit = (EditText)findViewById(R.id.edit);
    edit.setInputType(InputType.TYPE_NULL);
    edit.setOnClickListener(new OnClickListener() {
        @Override
        public void onClick(View v) {
            showKeyboard();
        }
    });

    KeyboardView keyboardView = (KeyboardView)findViewById(R.id.keyboard_view);
    keyboardView.setKeyboard(new Keyboard(this, R.xml.qwerty));
    keyboardView.setEnabled(true);
    keyboardView.setPreviewEnabled(true);
    keyboardView.setOnKeyboardActionListener(new OnKeyboardActionListener() {
        @Override
        public void onKey(int primaryCode, int[] keyCodes) {
            Editable editable = edit.getText();
            int start = edit.getSelectionStart();
            if (primaryCode == Keyboard.KEYCODE_CANCEL) {
                hideKeyboard();
            } else if (primaryCode == Keyboard.KEYCODE_DELETE) {
                if (editable != null &amp;&amp; editable.length() &gt; 0) {
                    editable.delete(start - 1, start);
                }
            } else if (primaryCode == 57419) {    // go left
                if (start &gt; 0) {
                    edit.setSelection(start - 1);
                }
            } else if (primaryCode == 57421) {    // go right
                if (start &lt; edit.length()) {
                    edit.setSelection(start + 1);
                }
            } else {
                editable.insert(start, Character.toString((char)primaryCode));
            }
        }
    });
}

private void showKeyboard() {
    int visibility = keyboardView.getVisibility();
    if (visibility == View.GONE || visibility == View.INVISIBLE) {
        keyboardView.setVisibility(View.VISIBLE);
    }
}

private void hideKeyboard() {
    int visibility = keyboardView.getVisibility();
    if (visibility == View.VISIBLE) {
        keyboardView.setVisibility(View.INVISIBLE);
    }
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何创建Android应用启动界面]]></title>
    <link href="http://codemany.com/blog/2011/08/01/how-to-create-splash-screen-for-android-app/"/>
    <updated>2011-08-01T15:47:50+08:00</updated>
    <id>http://codemany.com/blog/2011/08/01/how-to-create-splash-screen-for-android-app</id>
    <content type="html"><![CDATA[<p>1、制作一张启动图片splash.jpg，放在res/drawable文件夹中。</p>

<p>2、新建布局文件splash.xml：</p>

<p>```
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;LinearLayout xmlns:android="<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>"</p>

<pre><code>android:orientation="vertical"
android:layout_width="fill_parent"
android:layout_height="fill_parent"&gt;
&lt;ImageView
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:scaleType="fitXY"
    android:src="@drawable/splash" /&gt;
</code></pre>

<p></LinearLayout>
```</p>

<p>3、建立SplashActivity，代码如下：</p>

<p>```
package com.codemany.splash;</p>

<p>import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.MotionEvent;</p>

<p>public class SplashActivity extends Activity {</p>

<pre><code>private boolean active = true;
private int splashTime = 5000;    // time to display the splash screen in ms

@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.splash);

    new Thread() {
        @Override
        public void run() {
            try {
                int waited = 0;
                while (active &amp;&amp; (waited &lt; splashTime)) {
                    sleep(100);
                    if (active) {
                        waited += 100;
                    }
                }
            } catch(InterruptedException e) {
            } finally {
                finish();

                // Run next activity
                Intent intent = new Intent(SplashActivity.this, MainActivity.class);
                startActivity(intent);
                //stop();
            }
        }
    }.start();
}

@Override
public boolean onTouchEvent(MotionEvent event) {
    if (event.getAction() == MotionEvent.ACTION_DOWN) {
        active = false;
    }
    return true;
}
</code></pre>

<p>}
```</p>

<p>4、修改AndroidManifest.xml文件，将启动界面Activity改为默认启动，并且设置标题栏不可见。</p>

<p>```
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;manifest xmlns:android="<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>"</p>

<pre><code>package="com.codemany.splash"
android:versionCode="1"
android:versionName="1.0"&gt;

&lt;application android:icon="@drawable/icon" android:label="@string/app_name"&gt;
    &lt;activity android:name=".SplashActivity"
              android:theme="@android:style/Theme.NoTitleBar"&gt;
        &lt;intent-filter&gt;
            &lt;action android:name="android.intent.action.MAIN" /&gt;
            &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;

    &lt;activity android:name=".MainActivity"
              android:label="@string/app_name"&gt;
        &lt;intent-filter&gt;
            &lt;action android:name="android.intent.action.MAIN" /&gt;
            &lt;category android:name="android.intent.category.DEFAULT" /&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;    
&lt;/application&gt;

&lt;uses-sdk android:minSdkVersion="4" /&gt;
</code></pre>

<p></manifest>
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[反编译Android APK文件]]></title>
    <link href="http://codemany.com/blog/2011/07/01/decompile-android-apk-file/"/>
    <updated>2011-07-01T06:07:07+08:00</updated>
    <id>http://codemany.com/blog/2011/07/01/decompile-android-apk-file</id>
    <content type="html"><![CDATA[<p>classes.dex是Java源码编译后生成的字节码文件。由于Android使用的Dalvik虚拟机与标准的Java虚拟机是不兼容的，dex文件与class文件相比，不论是文件结构还是opcode都不一样。</p>

<p>目前有下面这几种反编译的工具:</p>

<ul>
<li>dexdump</li>
<li><a href="http://dedexer.sourceforge.net/">Dedexer</a></li>
<li><a href="http://code.google.com/p/android4me/">AXMLPrinter2</a></li>
<li><a href="http://code.google.com/p/android-apktool/">apktool</a></li>
<li><a href="http://code.google.com/p/dex2jar/">dex2jar</a> + <a href="http://java.decompiler.free.fr/?q=jdgui">JD-GUI</a></li>
<li><a href="http://code.google.com/p/smali/">smali</a></li>
</ul>


<p>dexdump是Android开发包提供的反编译工具。用法为首先启动Android模拟器，把要反编译的dex文件用adb push上传到模拟器中，然后通过adb shell登录，找到该dex文件，执行dexdump xxx.dex。总的来说dexdump功能比较弱，且用起来麻烦，另外反编译的结果的可读性也很差。</p>

<p>另一个反编译工具是Dedexer，反编译的效果比较好。它可以读取dex格式的文件，生成一种类似于汇编语言的输出。这种输出与Jasmin的输出相似，但包含的是Dalvik的字节码。与dexdump相比它至少有3个优点：</p>

<ol>
<li>不需要在Android模拟器中运行；</li>
<li>反编译后的文件目录结构和源代码结构相近，每个class文件对应一个ddx文件。不像dexdump那样把所有的结果都放在一起；</li>
<li>可以作为反编译引擎。目前好多强大的反编译工具都是以Jasmin作为反编译引擎的。</li>
</ol>


<p>可以下载已经编译好的ddx1.11.jar文件（对应Java 1.6版本）。用法：</p>

<p><code>
java -jar ddx1.11.jar -o -D -r -d src classes.dex  # 在src目录下生成ddx文件
</code></p>

<p>APK中的资源是经过压缩的，用文本工具看都是乱码，可以通过AXMLPrinter2将其转换为可读的XML文件。具体命令为：</p>

<p><code>
java -jar AXMLPrinter2.jar xxx.xml output.xml
</code></p>

<p>目前最好的反编译工具是apktool。可以帮助我们把APK文件反编译，输出smali格式的代码、图片和资源等文件，还可以在修改后重新打包。将下载下来的apktool和apktool-install-windows解压到同一目录，有三个文件：aapt.exe，apktool.bat和apktool.jar。使用方法：</p>

<p><code>
apktool d xxx.apk zzz  # 反编译xxx.apk到zzz目录，得到APK的图片和配置资源文件等
apktool b zzz  # 从文件夹zzz重建APK，输出到zzz/dist/out.apk
</code></p>

<p>dex2jar是一个将Dalvik虚拟机的dex文件转换回标准Java的class文件的工具：</p>

<p><code>
dex2jar xxx.apk  # 生成jar文件，可以用JD GUI工具直接打开查看
</code></p>

<p>smali可以反编译dex文件，也可以把你修改过的代码重新编译成dex：</p>

<p><code>
java -jar baksmali.jar classes.dex -o classes
java -jar smali.jar classes -o classes.dex
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何获得已安装应用的安装时间和占用空间]]></title>
    <link href="http://codemany.com/blog/2011/06/18/how-to-obtain-install-time-and-space-of-installed-apps/"/>
    <updated>2011-06-18T09:59:11+08:00</updated>
    <id>http://codemany.com/blog/2011/06/18/how-to-obtain-install-time-and-space-of-installed-apps</id>
    <content type="html"><![CDATA[<p>可以通过ApplicationInfo类中sourceDir取得应用的文件路径，再使用File类读取文件的相关属性实现。不过这可能导致:</p>

<ol>
<li>无法获取原始的创建时间，可能很早就被创建了，之后被替换了；</li>
<li>如果这个应用在一个私有的位置，比如app-private目录（使用Market付费购买的应用在这个位置），没有ROOT权限的手机会导致读取失败。</li>
</ol>


<p>```
List<PackageInfo> pkgs = getPackageManager().getInstalledPackages(0);
for (int i = 0; i &lt; pkgs.size(); i++) {</p>

<pre><code>PackageInfo pkg = pkgs.get(i);

File file = new File(pkg.applicationInfo.sourceDir);
System.out.println("file size: " + file.length());
System.out.println("file last modified: " + file.lastModified());
</code></pre>

<p>}
```</p>

<p>不过File类中文件大小和文件最后修改时间的值是long型，不是用户友好的，在显示前需要格式化一下：</p>

<p>```
String size = Formatter.formatFileSize(context, file.length())</p>

<p>Date date = new Date(file.lastModified())
String lastModified = new SimpleDateFormat("yyyy-MM-dd").format(date)</p>

<p>System.out.println("file size: " + size);
System.out.println("file last modified: " + lastModified);
```</p>

<p>从Android 2.3 API Level为9开始，ApplicationInfo类新增了firstInstallTime和lastUpdateTime两个字段，可以直接获取应用的创建和最后修改时间，即使是付费软件也能正常获取。</p>

<p>参考资料：<br />
<a href="http://www.android123.com.cn/androidkaifa/719.html">http://www.android123.com.cn/androidkaifa/719.html</a></p>
]]></content>
  </entry>
  
</feed>
