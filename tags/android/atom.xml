<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Android | 乐者为王]]></title>
  <link href="http://codemany.com/tags/android/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2014-09-15T16:48:04+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[扫描ISBN条码实现藏书管理]]></title>
    <link href="http://codemany.com/blog/2013/04/25/library-management-by-scanning-isbn-barcode/"/>
    <updated>2013-04-25T12:17:14+08:00</updated>
    <id>http://codemany.com/blog/2013/04/25/library-management-by-scanning-isbn-barcode</id>
    <content type="html"><![CDATA[<p>每个程序猿家里都有一堆技术书籍，偶也不例外，因此想写个Android应用来管理自己的藏书以及想买的书籍。在网上找到marshal的<a href="http://marshal.easymorse.com/archives/2745">识别图书ISBN号并输出查询结果的示例</a>和<a href="http://marshal.easymorse.com/archives/2756">完善图书查询原型，增加收藏夹功能</a>两篇文章，写的非常不错，还提供源代码。下载代码研究后发现已基本具备了想要的功能，决定在它的基础上做些修改供自己使用。</p>

<p>把原来uses-sdk的minSdkVersion改成了9，增加android:targetSdkVersion="17"。然后使用手机测试程序时发现，在连接网络时后台会抛出了android.os.NetworkOnMainThreadException异常，并且应用崩溃打不开。通过查阅相关资料了解到，自从Android 2.3之后，系统增加了一个类StrictMode。这个类对网络的访问方式进行了一定的改变。官方文档给出了这个类设置的目的：</p>

<blockquote><p>StrictMode is a developer tool which detects things you might be doing by accident and brings them to your attention so you can fix them.</p>

<p>StrictMode is most commonly used to catch accidental disk or network access on the application's main thread, where UI operations are received and animations take place. Keeping disk and network operations off the main thread makes for much smoother, more responsive applications. By keeping your application's main thread responsive, you also prevent ANR dialogs from being shown to users.</p>

<p>Note that even though an Android device's disk is often on flash memory, many devices run a filesystem on top of that memory with very limited concurrency. It's often the case that almost all disk accesses are fast, but may in individual cases be dramatically slower when certain I/O is happening in the background from other processes. If possible, it's best to assume that such things are not fast.</p></blockquote>

<p>因为marshal把访问网络的代码直接放到UI线程中，造成和主线程的首要工作UI交互相矛盾。解决这类问题很容易，把访问网络的代码放到AsyncTask中就行了。官方有个<a href="http://developer.android.com/training/basics/network-ops/index.html">NetworkUsage</a>例子是个不错的参考。</p>

<p>接着发现豆瓣API查询返回的是500错误，在浏览器上访问却又正常，后来给HttpClient加上Agent头就没问题了，不知道是不是期间豆瓣的API在实现上作了改变。</p>

<p><code>
HttpClient client = new DefaultHttpClient();
String agent = System.getProperty("http.agent");
client.getParams().setParameter(CoreProtocolPNames.USER_AGENT, agent);
</code></p>

<p>解析豆瓣XML查询结果的代码：</p>

<p>```
XmlPullParserFactory factory = XmlPullParserFactory.newInstance();
factory.setNamespaceAware(true);
XmlPullParser parser = factory.newPullParser();
parser.setInput(inputStream, "utf-8");
Book book = new Book();</p>

<p>int eventType = parser.getEventType();
while (eventType != XmlPullParser.END_DOCUMENT) {</p>

<pre><code>switch (eventType) {
case XmlPullParser.START_TAG:
    if ("link".equals(parser.getName())
            &amp;&amp; "image".equals(parser.getAttributeValue(null, "rel"))) {
        book.setImageUrl(parser.getAttributeValue(null, "href"));
        eventType = parser.next();
    } else if ("summary".equals(parser.getName())) {
        book.setSummary(parser.nextText());
    } else if ("attribute".equals(parser.getName())) {
        String name = parser.getAttributeValue(null, "name");
        if ("title".equals(name)) {
            book.setTitle(parser.nextText());
        } else if ("author".equals(name)) {
            book.setAuthor(parser.nextText());
        } else if ("isbn10".equals(name)) {
            book.setIsbn10(parser.nextText());
        } else if ("isbn13".equals(name)) {
            book.setIsbn13(parser.nextText());
        } else if ("publisher".equals(name)) {  
            book.setPublisher(parser.getText());
        }                   
    }
    break;
case XmlPullParser.END_TAG:
    break;
}
eventType = parser.next();
</code></pre>

<p>}
```</p>

<p>然后，然后就是结果页面不显示图书信息。想要找到原因，肿么办？看来要调试WebView了！<a href="http://developer.android.com/guide/webapps/debugging.html">http://developer.android.com/guide/webapps/debugging.html</a> 告诉了我们如何调试。</p>

<p>首先在WebView上设置setWebChromeClient方法：</p>

<p>```
webView.setWebChromeClient(new WebChromeClient() {</p>

<pre><code>public void onConsoleMessage(String message,
        int lineNumber, String sourceID) {
    Log.d(TAG, message + " -- From line "
            + lineNumber + " of " + sourceID);
}
</code></pre>

<p>});
```</p>

<p>然后在JavaScript脚本中使用以下方法就可以在logcat中看到调试信息了。</p>

<p><code>
console.log(String)
console.info(String)
console.warn(String)
console.error(String)
</code></p>

<p>重新运行程序，果然在logcat中看到报如下错误：</p>

<p><code>
Uncaught TypeError: Object [object Object] has no method...
</code></p>

<p>搜索后在Stack Overflow找到了<a href="http://stackoverflow.com/questions/14031635/android-4-2-1-webview-and-javascript-interface-breaks">问题的答案</a>（Stack Overflow真的非常不错，问题的回答都非常详尽）。<a href="http://developer.android.com/guide/webapps/webview.html#BindingJavaScript">http://developer.android.com/guide/webapps/webview.html#BindingJavaScript</a> 是官方文档的解释。</p>

<p>解决方法就是在要被JavaScript调用的方法上加@JavascriptInterface注解：</p>

<p>```
public class Book {</p>

<pre><code>@JavascriptInterface
public String getAuthor() {
    return author;
}

public void setAuthor(String author) {
    if (this.author != null) {
        this.author += ", " + author;
    } else {
        this.author = author;
    }
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用fastboot给Galaxy Nexus刷官方ROM]]></title>
    <link href="http://codemany.com/blog/2012/05/16/flash-official-rom-to-galaxy-nexus-with-fastboot/"/>
    <updated>2012-05-16T06:59:56+08:00</updated>
    <id>http://codemany.com/blog/2012/05/16/flash-official-rom-to-galaxy-nexus-with-fastboot</id>
    <content type="html"><![CDATA[<p>在刷机前先解释一些基本概念：</p>

<ul>
<li>root - 系统管理员权限</li>
<li>bootloader - 在OS运行前执行的代码，相当于电脑上的BIOS</li>
<li>解锁 - 就是解锁bootloader。解锁之后才可以刷ROM和获取ROOT权限</li>
<li>recovery - 执行底层操作的界面，相当于纯DOS界面</li>
<li>fastboot - 是比recovery更底层的操作界面

<blockquote><p>fastboot is a special diagnostic and engineering protocol that you can boot your Android device into.</p></blockquote></li>
</ul>


<p>分区解释：</p>

<ul>
<li>system：系统分区，我们刷ROM一般就是刷的这个分区</li>
<li>userdata：数据分区</li>
<li>cache：缓存分区</li>
<li>recovery：恢复分区</li>
<li>boot：存放内核和ramdisk的分区</li>
<li>hboot: 这个是SPL所在的分区，很重要。也是fastboot所在的分区，刷错就真的变砖了（所以一般不轻易刷这个）</li>
<li>splash1：这个就是开机第一屏幕了</li>
<li>radio：这个不是什么收音机，而是指无线通信模块，俗称基带（radio最初的意思是无线电通讯）</li>
</ul>


<p>刷机步骤：</p>

<p>1、备份好所有重要信息和数据；</p>

<p>2、安装adb驱动（或者在机器进入fastboot模式后安装也行）</p>

<p>3、下载官方镜像，解压缩。成功解压缩后应该会得到五个文件：</p>

<p><code>
flash-all.sh
flash-base.sh
radio-maguro-i9250xxla02.img
bootloader-maguro-primela03.img
image-yakju-imm76i.zip
</code></p>

<p>4、下载Galaxy-Nexus-fastboot-v2.0.zip，解压缩。将官方固件copy到目录下重命名。规则如下：</p>

<p><code>
刷基带请将radio-xxx.img重命名为radio.img
刷BL请将bootloader-xxx.img重命名为bootloader.img
刷固件请将image-xxx.zip重命名为image.zip
</code></p>

<p>5、关机进入fastboot模式（在关机状态下同时按“音量+”和“音量-”和“电源”三个键，等待机器发出轻微震动即可放开）</p>

<p>6、运行bat文件，选择2进行解锁（音量键选择“YES”开头的，然后按电源键确定）</p>

<p>7、然后开始刷机，基带和BL能不刷就不刷，防止变砖头。不过我在刷的过程中就提示必须刷基带和BL。</p>

<p>{% img /uploads/gn-flash-fail.png gn-flash-fail %}</p>

<p>PS：顺带着把同事的日版机也刷到4.0.4版本。在刷的过程中出现了莫名其妙的事情。刷机一切正常，但是重启之后，就无限在第一屏重启。抠电池重新再刷，还是老样子，但多重启两次后竟然进去了。唉，搞不懂！</p>

<p>刷机工具下载：<a href="https://github.com/dohkoos/galaxy-nexus-flash-tools">https://github.com/dohkoos/galaxy-nexus-flash-tools</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实现Android底部工具栏]]></title>
    <link href="http://codemany.com/blog/2011/11/16/make-bottom-toolbar-in-android/"/>
    <updated>2011-11-16T01:08:52+08:00</updated>
    <id>http://codemany.com/blog/2011/11/16/make-bottom-toolbar-in-android</id>
    <content type="html"><![CDATA[<p>在网上大部分教程中，底部工具栏通常由TabHost和RadioGroup结合完成，每个工具栏项对应一个独立的Activity。不过，我们要实现的是多个工具栏项在单独的一个Activity上起作用。</p>

<p><a href="http://www.cnblogs.com/figoyu/archive/2010/11/20/1882691.html">http://www.cnblogs.com/figoyu/archive/2010/11/20/1882691.html</a> 就是这个。不过该教程对每个工具栏项设置了固定宽度80dip，导致工具栏项或屏幕大小不定时代码布局会有问题。</p>

<p>这里对该教程做了些改进，使之能做到适应不定的工具栏项或屏幕大小。改进后的布局代码如下：</p>

<p>```
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;LinearLayout xmlns:android="<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>"</p>

<pre><code>android:orientation="vertical"
android:layout_width="fill_parent"
android:layout_height="fill_parent"&gt;
&lt;LinearLayout
    android:layout_width="fill_parent"
    android:layout_height="0dip"
    android:layout_weight="1.0"&gt;
    &lt;ScrollView
        android:layout_width="fill_parent"
        android:layout_height="fill_parent"
        android:scrollbars="vertical"
        android:fadingEdge="vertical"&gt;
        &lt;TextView
            android:id="@+id/content"
            android:layout_width="fill_parent"
            android:layout_height="wrap_content"
            android:textSize="17dip" /&gt;
    &lt;/ScrollView&gt;
&lt;/LinearLayout&gt;

&lt;include layout="@layout/toolbar" /&gt;
</code></pre>

<p></LinearLayout>
```</p>

<p>以下是工具栏toolbar.xml的布局代码：</p>

<p>```
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;LinearLayout xmlns:android="<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>"</p>

<pre><code>android:orientation="horizontal"
android:layout_width="fill_parent"
android:layout_height="wrap_content"
android:background="@drawable/toolbar_bg"&gt;
&lt;ImageButton
    android:id="@+id/btn_index"
    android:src="@drawable/index"
    android:text="@string/index"
    style="@style/toolbar" /&gt;
&lt;ImageButton
    android:id="@+id/btn_prev"
    android:src="@drawable/btn_prev_bg"
    android:text="@string/prev"
    style="@style/toolbar" /&gt;
&lt;ImageButton
    android:id="@+id/btn_next"
    android:src="@drawable/btn_next_bg"
    android:text="@string/next"
    style="@style/toolbar" /&gt;
&lt;ImageButton
    android:id="@+id/btn_zoomin"
    android:src="@drawable/zoomin"
    android:text="@string/zoomin"
    style="@style/toolbar" /&gt;
&lt;ImageButton
    android:id="@+id/btn_zoomout"
    android:src="@drawable/zoomout"
    android:text="@string/zoomout"
    style="@style/toolbar" /&gt;
</code></pre>

<p></LinearLayout>
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[创建Android自定义键盘]]></title>
    <link href="http://codemany.com/blog/2011/08/30/create-custom-keyboard-for-android/"/>
    <updated>2011-08-30T02:10:05+08:00</updated>
    <id>http://codemany.com/blog/2011/08/30/create-custom-keyboard-for-android</id>
    <content type="html"><![CDATA[<p>在使用股票应用时，我们会发现这些应用使用的是特殊的软键盘，这是如何实现的呢？下面就来做个实例详解。</p>

<p>注意，这篇文章不是教你如何创建输入法，如果你想创建自己的输入法，可以研究文章<a href="http://developer.android.com/resources/articles/creating-input-method.html">Creating an Input Method</a>和Android Sample中的SoftKeyboard项目。</p>

<p>{% img /uploads/android-custom-keyboard.png android-custom-keyboard %}</p>

<p>软键盘实现：在Android中软键盘是很容易实现的，通过android.inputmethodservice.Keyboard类来创建软键盘，该类从XML文件中读取软键盘信息。有多少行，每行有多少按键，每个按键代表什么内容等。下面是软键盘的XML代码：</p>

<p>```
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;Keyboard xmlns:android="<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>"</p>

<pre><code>android:keyWidth="25%p"
android:horizontalGap="0px"
android:verticalGap="0px"
android:keyHeight="@dimen/key_height"&gt;
&lt;Row&gt;
    &lt;Key android:codes="49" android:keyLabel="1" /&gt;
    &lt;Key android:codes="50" android:keyLabel="2" /&gt;
    &lt;Key android:codes="51" android:keyLabel="3" /&gt;
    &lt;Key android:codes="57419"
        android:keyEdgeFlags="right"
        android:keyIcon="@drawable/sym_keyboard_left" /&gt;
&lt;/Row&gt;
&lt;Row&gt;
    &lt;Key android:codes="52" android:keyLabel="4" /&gt;
    &lt;Key android:codes="53" android:keyLabel="5" /&gt;
    &lt;Key android:codes="54" android:keyLabel="6" /&gt;
    &lt;Key android:codes="57421"
        android:keyEdgeFlags="right"
        android:keyIcon="@drawable/sym_keyboard_right" /&gt;
&lt;/Row&gt;
&lt;Row&gt;
    &lt;Key android:codes="55" android:keyLabel="7" /&gt;
    &lt;Key android:codes="56" android:keyLabel="8" /&gt;
    &lt;Key android:codes="57" android:keyLabel="9" /&gt;
    &lt;Key android:codes="-5"
        android:keyHeight="@dimen/key_height_large"
        android:keyEdgeFlags="right"
        android:isRepeatable="true"
        android:keyIcon="@drawable/sym_keyboard_delete" /&gt;
&lt;/Row&gt;
&lt;Row&gt;
    &lt;Key android:codes="-3" android:keyIcon="@drawable/sym_keyboard_done" /&gt;
    &lt;Key android:codes="48" android:keyLabel="0" /&gt;
    &lt;Key android:codes="88" android:keyLabel="X" /&gt;
&lt;/Row&gt;
</code></pre>

<p></Keyboard>
```</p>

<p>在上面的键盘定义中，Row元素说明这是一行按键的定义，Key元素说明这是一个按键的定义。Key元素通过一些属性来定义每个按键，下面是一些常用的属性介绍：</p>

<p>```
codes：代表按键对应的输出值，可以为unicode值或则逗号（,）分割的多个值，也可以为一个字符串。</p>

<pre><code>   在字符串中通过“\”来转义特殊字符，例如“\n”或者“\uxxxx”。Codes通常用来定义该键的键码，
   例如上图中的数字按键1对应的为49。如果提供的是逗号分割的多个值则和普通手机输入键盘一
   样在多个值之间切换。
</code></pre>

<p> keyLabel：代表按键显示的文本内容。
 keyIcon：代表按键显示的图标内容，如果指定了该值则在显示的时候显示为图片不显示文本。
 keyWidth：代表按键的宽度，可以为精确值或则相对值，对于精确值支持多种单位，例如：像素，英</p>

<pre><code>       寸等；相对值为相对于基础取值的百分比，为以%或则%p结尾，其中%p表示相对于父容器。
</code></pre>

<p> keyHeight：代表按键的高度，取值同上。
 horizontalGap：代表按键前的间隙（水平方向），取值同上。
 isSticky：指定按键是否为sticky的。例如Shift大小写切换按键，具有两种状态，按下状态和正常</p>

<pre><code>       状态，取值为true或则false。
</code></pre>

<p> isModifier：指定按键是否为功能键(modifier key)，例如Alt或则Shift，取值为true或则false。
 keyOutputText：指定按键输出的文本内容，取值为字符串。
 isRepeatable：指定按键是否是可重复的，如果长按该键可以触发重复按键事件则为true，否则为false。
 keyEdgeFlags：指定按键的对齐指令，取值为left或则right。
```</p>

<p>然后在main.xml文件末尾加入以下代码：</p>

<p>```
&lt;RelativeLayout</p>

<pre><code>android:layout_width="fill_parent"
android:layout_height="wrap_content"&gt;
&lt;android.inputmethodservice.KeyboardView
    android:id="@+id/keyboard_view"
    android:visibility="gone"
    android:focusable="true"
    android:focusableInTouchMode="true"
    android:layout_width="fill_parent"
    android:layout_height="wrap_content"
    android:layout_alignParentBottom="true" /&gt;
</code></pre>

<p></RelativeLayout>
```</p>

<p>下面是主要的处理代码：</p>

<p>```
public class MainActivity extends Activity {</p>

<pre><code>@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main);

    EditText edit = (EditText)findViewById(R.id.edit);
    edit.setInputType(InputType.TYPE_NULL);
    edit.setOnClickListener(new OnClickListener() {
        @Override
        public void onClick(View v) {
            showKeyboard();
        }
    });

    KeyboardView keyboardView = (KeyboardView)findViewById(R.id.keyboard_view);
    keyboardView.setKeyboard(new Keyboard(this, R.xml.qwerty));
    keyboardView.setEnabled(true);
    keyboardView.setPreviewEnabled(true);
    keyboardView.setOnKeyboardActionListener(new OnKeyboardActionListener() {
        @Override
        public void onKey(int primaryCode, int[] keyCodes) {
            Editable editable = edit.getText();
            int start = edit.getSelectionStart();
            if (primaryCode == Keyboard.KEYCODE_CANCEL) {
                hideKeyboard();
            } else if (primaryCode == Keyboard.KEYCODE_DELETE) {
                if (editable != null &amp;&amp; editable.length() &gt; 0) {
                    editable.delete(start - 1, start);
                }
            } else if (primaryCode == 57419) {    // go left
                if (start &gt; 0) {
                    edit.setSelection(start - 1);
                }
            } else if (primaryCode == 57421) {    // go right
                if (start &lt; edit.length()) {
                    edit.setSelection(start + 1);
                }
            } else {
                editable.insert(start, Character.toString((char)primaryCode));
            }
        }
    });
}

private void showKeyboard() {
    int visibility = keyboardView.getVisibility();
    if (visibility == View.GONE || visibility == View.INVISIBLE) {
        keyboardView.setVisibility(View.VISIBLE);
    }
}

private void hideKeyboard() {
    int visibility = keyboardView.getVisibility();
    if (visibility == View.VISIBLE) {
        keyboardView.setVisibility(View.INVISIBLE);
    }
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何创建Android应用启动界面]]></title>
    <link href="http://codemany.com/blog/2011/08/01/how-to-create-splash-screen-for-android-app/"/>
    <updated>2011-08-01T15:47:50+08:00</updated>
    <id>http://codemany.com/blog/2011/08/01/how-to-create-splash-screen-for-android-app</id>
    <content type="html"><![CDATA[<p>1、制作一张启动图片splash.jpg，放在res/drawable文件夹中。</p>

<p>2、新建布局文件splash.xml：</p>

<p>```
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;LinearLayout xmlns:android="<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>"</p>

<pre><code>android:orientation="vertical"
android:layout_width="fill_parent"
android:layout_height="fill_parent"&gt;
&lt;ImageView
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:scaleType="fitXY"
    android:src="@drawable/splash" /&gt;
</code></pre>

<p></LinearLayout>
```</p>

<p>3、建立SplashActivity，代码如下：</p>

<p>```
package com.codemany.splash;</p>

<p>import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.MotionEvent;</p>

<p>public class SplashActivity extends Activity {</p>

<pre><code>private boolean active = true;
private int splashTime = 5000;    // time to display the splash screen in ms

@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.splash);

    new Thread() {
        @Override
        public void run() {
            try {
                int waited = 0;
                while (active &amp;&amp; (waited &lt; splashTime)) {
                    sleep(100);
                    if (active) {
                        waited += 100;
                    }
                }
            } catch(InterruptedException e) {
            } finally {
                finish();

                // Run next activity
                Intent intent = new Intent(SplashActivity.this, MainActivity.class);
                startActivity(intent);
                //stop();
            }
        }
    }.start();
}

@Override
public boolean onTouchEvent(MotionEvent event) {
    if (event.getAction() == MotionEvent.ACTION_DOWN) {
        active = false;
    }
    return true;
}
</code></pre>

<p>}
```</p>

<p>4、修改AndroidManifest.xml文件，将启动界面Activity改为默认启动，并且设置标题栏不可见。</p>

<p>```
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;manifest xmlns:android="<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>"</p>

<pre><code>package="com.codemany.splash"
android:versionCode="1"
android:versionName="1.0"&gt;

&lt;application android:icon="@drawable/icon" android:label="@string/app_name"&gt;
    &lt;activity android:name=".SplashActivity"
              android:theme="@android:style/Theme.NoTitleBar"&gt;
        &lt;intent-filter&gt;
            &lt;action android:name="android.intent.action.MAIN" /&gt;
            &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;

    &lt;activity android:name=".MainActivity"
              android:label="@string/app_name"&gt;
        &lt;intent-filter&gt;
            &lt;action android:name="android.intent.action.MAIN" /&gt;
            &lt;category android:name="android.intent.category.DEFAULT" /&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;    
&lt;/application&gt;

&lt;uses-sdk android:minSdkVersion="4" /&gt;
</code></pre>

<p></manifest>
```</p>
]]></content>
  </entry>
  
</feed>
