<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Android | 乐者为王]]></title>
  <link href="http://codemany.com/tags/android/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2014-08-03T22:17:08+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[扫描ISBN条码实现藏书管理]]></title>
    <link href="http://codemany.com/blog/2013/04/25/manage-library-by-scanning-isbn-barcode/"/>
    <updated>2013-04-25T12:17:14+08:00</updated>
    <id>http://codemany.com/blog/2013/04/25/manage-library-by-scanning-isbn-barcode</id>
    <content type="html"><![CDATA[<p>每个程序猿家里都有一堆技术书籍，偶也不例外，因此想写个Android应用来管理自己的藏书以及想买的书籍。在网上找到marshal的<a href="http://marshal.easymorse.com/archives/2745">识别图书ISBN号并输出查询结果的示例</a>和<a href="http://marshal.easymorse.com/archives/2756">完善图书查询原型，增加收藏夹功能</a>两篇文章，写的非常不错，还提供源代码。下载代码研究后发现已基本具备了想要的功能，决定在它的基础上做些修改供自己使用。</p>

<p>把原来uses-sdk的minSdkVersion改成了9，增加android:targetSdkVersion=&ldquo;17"。然后使用手机测试程序时发现，在连接网络时后台会抛出了android.os.NetworkOnMainThreadException异常，并且应用崩溃打不开。通过查阅相关资料了解到，自从Android 2.3之后，系统增加了一个类StrictMode。这个类对网络的访问方式进行了一定的改变。官方文档给出了这个类设置的目的：</p>

<blockquote><p>StrictMode is a developer tool which detects things you might be doing by accident and brings them to your attention so you can fix them.</p>

<p>StrictMode is most commonly used to catch accidental disk or network access on the application&rsquo;s main thread, where UI operations are received and animations take place. Keeping disk and network operations off the main thread makes for much smoother, more responsive applications. By keeping your application&rsquo;s main thread responsive, you also prevent ANR dialogs from being shown to users.</p>

<p>Note that even though an Android device&rsquo;s disk is often on flash memory, many devices run a filesystem on top of that memory with very limited concurrency. It&rsquo;s often the case that almost all disk accesses are fast, but may in individual cases be dramatically slower when certain I/O is happening in the background from other processes. If possible, it&rsquo;s best to assume that such things are not fast.</p></blockquote>

<p>因为marshal把访问网络的代码直接放到UI线程中，造成和主线程的首要工作UI交互相矛盾。解决这类问题很容易，把访问网络的代码放到AsyncTask中就行了。官方有个<a href="http://developer.android.com/training/basics/network-ops/index.html">NetworkUsage</a>例子是个不错的参考。</p>

<p>接着发现豆瓣API查询返回的是500错误，在浏览器上访问却又正常，后来给HttpClient加上Agent头就没问题了，不知道是不是期间豆瓣的API在实现上作了改变。
<code>
HttpClient client = new DefaultHttpClient();
String agent = System.getProperty("http.agent");
client.getParams().setParameter(CoreProtocolPNames.USER_AGENT, agent);
</code></p>

<p>解析豆瓣XML查询结果的代码：
```
XmlPullParserFactory factory = XmlPullParserFactory.newInstance();
factory.setNamespaceAware(true);
XmlPullParser parser = factory.newPullParser();
parser.setInput(inputStream, &ldquo;utf-8&rdquo;);
Book book = new Book();</p>

<p><p>int eventType = parser.getEventType();
while (eventType != XmlPullParser.END_DOCUMENT) {</p>

<pre><code>switch (eventType) {
case XmlPullParser.START_TAG:
    if ("link".equals(parser.getName())
            &amp;&amp; "image".equals(parser.getAttributeValue(null, "rel"))) {
        book.setImageUrl(parser.getAttributeValue(null, "href"));
        eventType = parser.next();
    } else if ("summary".equals(parser.getName())) {
        book.setSummary(parser.nextText());
    } else if ("attribute".equals(parser.getName())) {
        String name = parser.getAttributeValue(null, "name");
        if ("title".equals(name)) {
            book.setTitle(parser.nextText());
        } else if ("author".equals(name)) {
            book.setAuthor(parser.nextText());
        } else if ("isbn10".equals(name)) {
            book.setIsbn10(parser.nextText());
        } else if ("isbn13".equals(name)) {
            book.setIsbn13(parser.nextText());
        } else if ("publisher".equals(name)) {  
            book.setPublisher(parser.getText());
        }                   
    }
    break;
case XmlPullParser.END_TAG:
    break;
}
eventType = parser.next();
</code></pre>

<p>}
```</p>

<p>然后，然后就是结果页面不显示图书信息。想要找到原因，肿么办？看来要调试WebView了！<a href="http://developer.android.com/guide/webapps/debugging.html">http://developer.android.com/guide/webapps/debugging.html</a> 告诉了我们如何调试。</p>

<p>首先在WebView上设置setWebChromeClient方法：
```
webView.setWebChromeClient(new WebChromeClient() {</p>

<pre><code>public void onConsoleMessage(String message,
        int lineNumber, String sourceID) {
    Log.d(TAG, message + " -- From line "
            + lineNumber + " of " + sourceID);
}
</code></pre>

<p>});
```</p>

<p>然后在JavaScript脚本中使用以下方法就可以在logcat中看到调试信息了。
<code>
console.log(String)
console.info(String)
console.warn(String)
console.error(String)
</code></p>

<p>重新运行程序，果然在logcat中看到报如下错误：
<code>
Uncaught TypeError: Object [object Object] has no method...
</code></p>

<p>搜索后在Stack Overflow找到了<a href="http://stackoverflow.com/questions/14031635/android-4-2-1-webview-and-javascript-interface-breaks">问题的答案</a>（Stack Overflow真的非常不错，问题的回答都非常详尽）。<a href="http://developer.android.com/guide/webapps/webview.html#BindingJavaScript">这里</a>是Android官方文档的解释。</p>

<p>解决方法就是在要被JavaScript调用的方法上加@JavascriptInterface注解：
```
public class Book {</p>

<pre><code>@JavascriptInterface
public String getAuthor() {
    return author;
}

public void setAuthor(String author) {
    if (this.author != null) {
        this.author += ", " + author;
    } else {
        this.author = author;
    }
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用fastboot刷Galaxy Nexus官方系统]]></title>
    <link href="http://codemany.com/blog/2012/05/16/using-to-to-fastboot-brush-galaxy-nexus-official-system/"/>
    <updated>2012-05-16T06:59:56+08:00</updated>
    <id>http://codemany.com/blog/2012/05/16/using-to-to-fastboot-brush-galaxy-nexus-official-system</id>
    <content type="html"><![CDATA[<p><p>root &ndash; 系统管理员权限<br />
bootloader &ndash; 相当于电脑上的BIOS
<blockquote>bootloader is code that is executed before any Operating System starts to run.</blockquote>
recovery &ndash; 执行底层操作的界面，相当于纯DOS界面<br />
fastboot &ndash; 是比recovery更底层的操作界面
<blockquote>fastboot is a special diagnostic and engineering protocol that you can boot your Android device into.</blockquote>
解锁 &ndash; 就是解锁bootloader。解锁之后才可以刷ROM</p>

<p><p>分区解释：<br />
system：系统分区，我们刷ROM一般就是刷的这个分区<br />
userdata：数据分区<br />
cache：缓存分区<br />
recovery：恢复分区<br />
boot：存放内核和ramdisk的分区<br />
hboot: 这个是SPL所在的分区，很重要。也是fastboot所在的分区.刷错就真的变砖了.（所以一般不轻易刷这个）<br />
splash1：这个就是开机第一屏幕了<br />
radio：这个不是什么收音机，而是指无线通信模块，俗称基带（radio最初的意思是无线电通讯）</p>

<p><p>刷机步骤：  <br />
1. 安装adb驱动（或者在机器进入fastboot模式后安装也行）</p>

<p><p>2. 下载官方镜像，解压缩。成功解压缩后得到五个文件：<br />
flash-all.sh<br />
flash-base.sh<br />
radio-maguro-i9250xxla02.img<br />
bootloader-maguro-primela03.img<br />
image-yakju-imm76i.zip</p>

<p><p>3. 下载Galaxy-Nexus-fastboot-v2.0.zip，解压缩。将官方固件copy到目录下重命名。规则如下：<br />
刷基带请将radio-xxx.img重命名为radio.img<br />
刷BL请将bootloader-xxx.img重命名为bootloader.img<br />
刷固件请将image-xxx.zip重命名为image.zip</p>

<p><p>4. 关机进入fastboot模式（在关机状态下同时按“音量+”和“音量-”和“电源”三个键，等待机器发出轻微震动即可放开）</p>

<p><p>5. 运行bat文件，选择2进行解锁（解锁是root和刷机的前提，音量键选择“YES”开头的，然后按电源键确定）</p>

<p><p>6. 高兴么就root一下。然后开始刷机，基带和BL能不刷就不刷，防止变砖头。不过我在刷的过程中就提示必须刷基带和BL。
<img src="/uploads/gn-update-fail.png" title="gn-update-fail" ></p>

<p><p>注意事项：<br />
刷机有风险，操作需谨慎<br />
刷机前请备份好数据<br />
刷机前请确保手机电量在50%以上</p>

<p><p>PS：顺带着把同事的日版机也刷到4.0.4版本。在刷的过程中出现了莫名其妙的事情。刷机一切正常，但是重启之后，就无限在第一屏重启。抠电池重新再刷，还是老样子，但多启两次后竟然进去了，到现在也搞不清是怎么回事。</p>

<p><p><a href="https://github.com/dohkoos/galaxy-nexus-update-tools">刷机工具下载</a>
</p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用showDialog()创建的ProgressDialog再次打开时进度条不变化的问题解析]]></title>
    <link href="http://codemany.com/blog/2012/04/15/the-using-showdialog-to-create-progressdialog-open-again-the-progress-bar-does-not-change-the-problem-resolution/"/>
    <updated>2012-04-15T13:15:24+08:00</updated>
    <id>http://codemany.com/blog/2012/04/15/the-using-showdialog-to-create-progressdialog-open-again-the-progress-bar-does-not-change-the-problem-resolution</id>
    <content type="html"><![CDATA[<p><p>先来看段代码：<br />
[code lang=&ldquo;xml&rdquo;]
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"<br /></p>

<pre><code>android:layout_width="fill_parent"&lt;br /&gt;
android:layout_height="fill_parent"&lt;br /&gt;
android:orientation="vertical"&gt;
&lt;Button&lt;br /&gt;
    android:layout_width="fill_parent"&lt;br /&gt;
    android:layout_height="wrap_content"&lt;br /&gt;
    android:text="Copy Contacts"&lt;br /&gt;
    android:onClick="copyContacts" /&gt;
</code></pre>

<p></LinearLayout>
```</p>

<p>```
import android.app.Activity;<br />
import android.app.Dialog;<br />
import android.app.ProgressDialog;<br />
import android.os.AsyncTask;<br />
import android.os.Bundle;<br />
import android.view.View;</p>

<p><p>public class DialogTestActivity extends Activity {<br /></p>

<pre><code>private static final int COPY_CONTACTS = 0;
</code></pre>

<p><p>    private ProgressDialog mProgressDialog;</p>

<p><p>    @Override<br /></p>

<pre><code>public void onCreate(Bundle savedInstanceState) {&lt;br /&gt;
    super.onCreate(savedInstanceState);&lt;br /&gt;
    setContentView(R.layout.main);&lt;br /&gt;
}
</code></pre>

<p><p>    public void copyContacts(View target) {<br /></p>

<pre><code>    showDialog(COPY_CONTACTS);&lt;br /&gt;
}
</code></pre>

<p><p>    @Override<br /></p>

<pre><code>protected Dialog onCreateDialog(int id) {&lt;br /&gt;
    switch (id) {&lt;br /&gt;
    case COPY_CONTACTS:&lt;br /&gt;
        mProgressDialog = new ProgressDialog(this);&lt;br /&gt;
        mProgressDialog.setTitle("Copy contacts");&lt;br /&gt;
        mProgressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);&lt;br /&gt;
        mProgressDialog.setMax(100);&lt;br /&gt;
        new AsyncCopyContactsTask().execute();&lt;br /&gt;
        break;&lt;br /&gt;
    }&lt;br /&gt;
    return mProgressDialog;&lt;br /&gt;
}
</code></pre>

<p><p>    private class AsyncCopyContactsTask extends AsyncTask&lt;Void, Void, Integer> {<br /></p>

<pre><code>    @Override&lt;br /&gt;
    protected Integer doInBackground(Void... params) {&lt;br /&gt;
        for (int i = 0; i &lt; 100; i++) {&lt;br /&gt;
            try {&lt;br /&gt;
                Thread.sleep(100);&lt;br /&gt;
            } catch (InterruptedException e) {&lt;br /&gt;
            }&lt;br /&gt;
            publishProgress();&lt;br /&gt;
        }&lt;br /&gt;
        return 0;&lt;br /&gt;
    }
</code></pre>

<p><p>        protected void onProgressUpdate(Void&hellip; progress) {<br /></p>

<pre><code>        mProgressDialog.incrementProgressBy(1);&lt;br /&gt;
    }
</code></pre>

<p><p>        protected void onPostExecute(Integer result) {<br /></p>

<pre><code>        mProgressDialog.dismiss();&lt;br /&gt;
    }&lt;br /&gt;
}&lt;br /&gt;
</code></pre>

<p>}
```</p>

<p><p>第一次点击按钮会显示一个进度条，上面的数字处于变动当中，到达最大值后进度条会消失不见；再次点击按钮后，就会发现进度条上的数值和消失前相同，并且不再变化，而且进度条也不会消失。这是为什么呢？如果想每次打开对话框时进度条显示的内容都有所不同，该怎么做？</p>

<p><p>Activity中有三个和对话框显示有关的方法：showDialog()，dismissDialog()和removeDialog()。其中showDialog()用于显示一个对话框；dismissDialog()使对话框消失，但仍然处于内存中，只是不显示而已，如果再次调用showDialog()方法，则缓存在内存中的对话框会重新显示，而不需要重新创建。removeDialog()使对话框消失，并从内存中将对话框清除，如果再次调用showDialog()来显示它，则在显示之前需要重新创建对话框。</p>

<p><p>在一个对话框的声明周期内，onCreateDialog()仅被调用一次，但onPrepareDialog()方法会每次被调用。比如，第一次调用 showDialog()方法显示某个对话框时，会先触发onCreateDialog()的执行，然后再触发onPrepareDialog()方法；如果将某个对话框 removeDialog()后再showDialog()，也会先触发onCreateDialog()，接着触发onPrepareDialog()方法；如果某个对话框是被dismiss()掉的，再调用 showDialog()方法来显示它时就不会触发onCreateDialog()方法的执行，只会触发onPrepareDialog()方法。</p>

<p><p>这是因为第一次调用showDialog()时，Android从你的Activity中调用onCreateDialog()方法，得到返回的Dialog对象。把当前Activity设置为该对话框的所有者，从而把对话框挂靠到Activity上，让Activity自动管理该对话框的状态。这样，下次调用showDialog()时就不用重新创建Dialog对象，而是复用旧的。</p>

<p><p>注意：如果你决定在onCreateDialog()方法之外创建一个对话框，它将不会被附着到活动上。不过，你可以通过setOwnerActivity()把它附着到一个Activity上。</p>

<p><p>所以，解决再次打开ProgressDialog时进度条不变化的最好方法就是将mProgressDialog.dismiss()改成removeDialog(COPY_CONTACTS)。
</p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[简单实现Android底部工具栏]]></title>
    <link href="http://codemany.com/blog/2011/11/16/simple-to-make-android-the-bottom-toolbar/"/>
    <updated>2011-11-16T01:08:52+08:00</updated>
    <id>http://codemany.com/blog/2011/11/16/simple-to-make-android-the-bottom-toolbar</id>
    <content type="html"><![CDATA[<p><p>在网上大部分教程中，底部工具栏通常由TabHost和RadioGroup结合完成，每个工具栏项对应一个独立的Activity。不过，我们要实现的是多个工具栏项在单独的一个Activity上起作用。</p>

<p><p><a href="http://www.cnblogs.com/figoyu/archive/2010/11/20/1882691.html"><a href="http://www.cnblogs.com/figoyu/archive/2010/11/20/1882691.html">http://www.cnblogs.com/figoyu/archive/2010/11/20/1882691.html</a></a>就是这个。不过该教程对每个工具栏项设置了固定宽度80dip，导致工具栏项或屏幕大小不定时代码布局会有问题。</p>

<p><p>这里对该教程做了些改进，使之能做到适应不定的工具栏项或屏幕大小。改进后的布局代码如下：<br />
```
// main.xml<br />
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?><br />
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"<br /></p>

<pre><code>android:orientation="vertical"&lt;br /&gt;
android:layout_width="fill_parent"&lt;br /&gt;
android:layout_height="fill_parent"&gt;&lt;br /&gt;
&lt;LinearLayout&lt;br /&gt;
    android:layout_width="fill_parent"&lt;br /&gt;
    android:layout_height="0dip"&lt;br /&gt;
    android:layout_weight="1.0"&gt;&lt;br /&gt;
    &lt;ScrollView&lt;br /&gt;
        android:layout_width="fill_parent"&lt;br /&gt;
        android:layout_height="fill_parent"&lt;br /&gt;
        android:scrollbars="vertical"&lt;br /&gt;
        android:fadingEdge="vertical"&gt;&lt;br /&gt;
        &lt;TextView&lt;br /&gt;
            android:id="@+id/content"&lt;br /&gt;
            android:layout_width="fill_parent"&lt;br /&gt;
            android:layout_height="wrap_content"&lt;br /&gt;
            android:textSize="17dip" /&gt;&lt;br /&gt;
    &lt;/ScrollView&gt;&lt;br /&gt;
&lt;/LinearLayout&gt;
</code></pre>

<p><p>    <include layout="@layout/toolbar" /><br />
</LinearLayout><br />
```</p>

<p><p>以下是工具栏的布局代码：<br />
```
// toolbar.xml<br />
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?><br />
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"<br /></p>

<pre><code>android:orientation="horizontal"&lt;br /&gt;
android:layout_width="fill_parent"&lt;br /&gt;
android:layout_height="wrap_content"&lt;br /&gt;
android:background="@drawable/toolbar_bg"&gt;&lt;br /&gt;
&lt;ImageButton&lt;br /&gt;
    android:id="@+id/btn_index"&lt;br /&gt;
    android:src="@drawable/index"&lt;br /&gt;
    android:text="@string/index"&lt;br /&gt;
    style="@style/toolbar" /&gt;&lt;br /&gt;
&lt;ImageButton&lt;br /&gt;
    android:id="@+id/btn_prev"&lt;br /&gt;
    android:src="@drawable/btn_prev_bg"&lt;br /&gt;
    android:text="@string/prev"&lt;br /&gt;
    style="@style/toolbar" /&gt;&lt;br /&gt;
&lt;ImageButton&lt;br /&gt;
    android:id="@+id/btn_next"&lt;br /&gt;
    android:src="@drawable/btn_next_bg"&lt;br /&gt;
    android:text="@string/next"&lt;br /&gt;
    style="@style/toolbar" /&gt;&lt;br /&gt;
&lt;ImageButton&lt;br /&gt;
    android:id="@+id/btn_zoomin"&lt;br /&gt;
    android:src="@drawable/zoomin"&lt;br /&gt;
    android:text="@string/zoomin"&lt;br /&gt;
    style="@style/toolbar" /&gt;&lt;br /&gt;
&lt;ImageButton&lt;br /&gt;
    android:id="@+id/btn_zoomout"&lt;br /&gt;
    android:src="@drawable/zoomout"&lt;br /&gt;
    android:text="@string/zoomout"&lt;br /&gt;
    style="@style/toolbar" /&gt;&lt;br /&gt;
</code></pre>

<p></LinearLayout><br />
[/code]
</p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用Spinner + SQLite实现省市县三级联动]]></title>
    <link href="http://codemany.com/blog/2011/09/16/spinner-sqlite-implementation-with-provincial-and-county-levels-linkage/"/>
    <updated>2011-09-16T05:48:32+08:00</updated>
    <id>http://codemany.com/blog/2011/09/16/spinner-sqlite-implementation-with-provincial-and-county-levels-linkage</id>
    <content type="html"><![CDATA[<p><p><strong>1. 建立省市县<a href="http://www.stats.gov.cn/tjbz/xzqhdm/index.htm">行政区划代码</a>（截止2010年12月31日）数据表</strong></p>

<p><code>
CREATE TABLE xzqhdm (&lt;br /&gt;
  _id INTEGER PRIMARY KEY,&lt;br /&gt;
  code NUMERIC,&lt;br /&gt;
  region TEXT,&lt;br /&gt;
  parent_code NUMERIC&lt;br /&gt;
);&lt;br /&gt;
</code></p>

<p><p>parent_code指上一级的行政区划代码，省属于最上级的行政单位，设置它的区划代码为999999。</p>

<p><code>
insert into xzqhdm values(NULL, 110000, "北京市", 999999);&lt;br /&gt;
insert into xzqhdm values(NULL, 110100, "市辖区", 110000);&lt;br /&gt;
insert into xzqhdm values(NULL, 110101, "东城区", 110100);&lt;br /&gt;
insert into xzqhdm values(NULL, 110102, "西城区", 110100);&lt;br /&gt;
insert into xzqhdm values(NULL, 110103, "崇文区", 110100);&lt;br /&gt;
insert into xzqhdm values(NULL, 110104, "宣武区", 110100);&lt;br /&gt;
insert into xzqhdm values(NULL, 110105, "朝阳区", 110100);&lt;br /&gt;
insert into xzqhdm values(NULL, 110106, "丰台区", 110100);&lt;br /&gt;
...&lt;br /&gt;
insert into xzqhdm values(NULL, 659001, "石河子市", 659000);&lt;br /&gt;
insert into xzqhdm values(NULL, 659002, "阿拉尔市", 659000);&lt;br /&gt;
insert into xzqhdm values(NULL, 659003, "图木舒克市", 659000);&lt;br /&gt;
insert into xzqhdm values(NULL, 659004, "五家渠市", 659000);&lt;br /&gt;
</code></p>

<p><p><strong>2. SQLite数据库的操作</strong>
如果应用使用到了SQLite数据库，在用户初次使用应用时，需要创建应用使用到的数据库表结构及添加一些初始化记录，另外在软件升级的时候，也需要对数据表结构进行更新。Android系统为我们提供了一个名为SQLiteOpenHelper的类，这是一个抽象类，该类用于对数据库版本进行管理，有两个重要的方法，分别是onCreate()和onUpgrade()。</p>

<p><p>当调用SQLiteOpenHelper的getWritableDatabase()或getReadableDatabase()方法获取数据库实例时，如果数据库不存在，Android系统会自动生成一个数据库文件，接着调用onCreate()方法，onCreate()方法在初次生成数据库时才会被调用，在onCreate()方法里可以生成数据库表结构及添加一些应用使用到的初始化数据。onUpgrade()方法在数据库的版本发生变化时会被调用，数据库的版本是由程序员控制的，假设数据库现在的版本是1，由于业务的需要，修改了数据库表的结构，这时候就需要升级软件，升级软件时希望更新用户手机里的数据库表结构，为了实现这一目的，可以把原来的数据库版本设置为2（或其他数值），并且在onUpgrade()方法里面实现表结构的更新。当软件的版本升级次数比较多，这时在onUpgrade()方法里面可以根据原版号和目标版本号进行判断，然后作出相应的表结构及数据更新。</p>

<p><p>SQLiteDatabase类则封装了一些操作数据库的常用API，使用该类可以完成对数据进行CRUD操作。主要是execSQL()和rawQuery()方法。execSQL()方法可以执行insert、delete、update和CREATE TABLE之类有更改行为的SQL语句； rawQuery()方法可以执行select语句。SQLiteDatabase还专门提供了对应于CRUD的操作方法： insert()、delete()、update()和query()。</p>

<p><p>问题：<br />
如何将SQLite数据库与apk文件一起发布？<br />
可以将数据库文件复制到res\raw目录中，所有在res\raw目录中的文件不会被压缩，这样可以直接提取该目录中的文件。</p>

<p><p>如何打开res\raw目录中的数据库文件？<br />
不能直接打开res\raw目录中的数据库文件，需要在程序第一次启动时将该文件复制到手机内存或SD卡中，然后再打开。</p>

<p>```
public class DBHelper extends SQLiteOpenHelper {<br /></p>

<pre><code>private static String DB_PATH = "/data/data/com.codemany.linkage/databases/";&lt;br /&gt;
private static String DB_NAME = "xzqh.db";&lt;br /&gt;
private static DBHelper databaseHelper;&lt;br /&gt;
private static SQLiteDatabase db;
</code></pre>

<p><p>    private Context context;</p>

<p><p>    private DBHelper(Context context) {<br /></p>

<pre><code>    super(context, DB_NAME, null, 1);&lt;br /&gt;
    this.context = context;&lt;br /&gt;
}
</code></pre>

<p><p>    public static DBHelper getInstance(Context context) {<br /></p>

<pre><code>    if (databaseHelper == null) {&lt;br /&gt;
        databaseHelper = new DBHelper(context);&lt;br /&gt;
        databaseHelper.openDataBase();
</code></pre>

<p><p>            if (db == null) {<br /></p>

<pre><code>            try {&lt;br /&gt;
                db = databaseHelper.getWritableDatabase();&lt;br /&gt;
                databaseHelper.copyDatabase();&lt;br /&gt;
            }&lt;br /&gt;
            catch (Exception e) {&lt;br /&gt;
                Log.d("DBHelper", "Error in database creation");&lt;br /&gt;
            }
</code></pre>

<p><p>                databaseHelper.openDataBase();<br /></p>

<pre><code>        }&lt;br /&gt;
    }&lt;br /&gt;
    return databaseHelper;&lt;br /&gt;
}
</code></pre>

<p><p>    private void copyDatabase() throws IOException {<br /></p>

<pre><code>    InputStream is = context.getResources().openRawResource(R.raw.xzqh);&lt;br /&gt;
    OutputStream os = new FileOutputStream(DB_PATH + DB_NAME);&lt;br /&gt;
    byte[] buffer = new byte[1024];&lt;br /&gt;
    int length;&lt;br /&gt;
    while ((length = is.read(buffer)) &gt; 0) {&lt;br /&gt;
        os.write(buffer, 0, length);&lt;br /&gt;
    }
</code></pre>

<p><p>        os.flush();<br /></p>

<pre><code>    os.close();&lt;br /&gt;
    is.close();&lt;br /&gt;
}
</code></pre>

<p><p>    private void openDataBase() {<br /></p>

<pre><code>    try {&lt;br /&gt;
        db = SQLiteDatabase.openDatabase(&lt;br /&gt;
                DB_PATH + DB_NAME,&lt;br /&gt;
                null,&lt;br /&gt;
                SQLiteDatabase.OPEN_READONLY | SQLiteDatabase.NO_LOCALIZED_COLLATORS);&lt;br /&gt;
    } catch (SQLiteException e) {&lt;br /&gt;
        // database does't exist yet&lt;br /&gt;
    }&lt;br /&gt;
}
</code></pre>

<p><p>    public SimpleCursorAdapter getListByParentCode(Context context, String parentCode) {<br /></p>

<pre><code>    SimpleCursorAdapter list = null;&lt;br /&gt;
    DBHelper dHelper = new DBHelper(context);&lt;br /&gt;
    SQLiteDatabase db = dHelper.getReadableDatabase();&lt;br /&gt;
    Cursor cursor = db.rawQuery(&lt;br /&gt;
            "select code as _id, region from xzqhdm where parent_code = ?",&lt;br /&gt;
            new String[] {parentCode});&lt;br /&gt;
    if (cursor.getCount() != 0) {&lt;br /&gt;
        list = new SimpleCursorAdapter(context,&lt;br /&gt;
                android.R.layout.simple_spinner_item,&lt;br /&gt;
                cursor,&lt;br /&gt;
                new String[] {"region"},&lt;br /&gt;
                new int[] {android.R.id.text1});&lt;br /&gt;
        list.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);&lt;br /&gt;
    }&lt;br /&gt;
    return list;&lt;br /&gt;
}
</code></pre>

<p><p>    @Override<br /></p>

<pre><code>public synchronized void close() {&lt;br /&gt;
    if (db != null) {&lt;br /&gt;
        db.close();&lt;br /&gt;
    }&lt;br /&gt;
    super.close();&lt;br /&gt;
}
</code></pre>

<p><p>    @Override<br /></p>

<pre><code>public void onCreate(SQLiteDatabase db) {&lt;br /&gt;
}
</code></pre>

<p><p>    @Override<br /></p>

<pre><code>public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {&lt;br /&gt;
}&lt;br /&gt;
</code></pre>

<p>}
```</p>

<p><p>在代码实现时遇到的难题是如何在选中region的同时得到对应的code。网上有教程说定制自己的adapter，重写bingView，不过有多个spinner就需要声明多个全局变量；还有教程指出可以直接往adapter中传递对象（实现一个类，将code和region作为字段），然后重写对象的toString()方法。后来受到这个帖子的启发，修改了rawQuery中的select语句得以实现Spinner控件中的键值绑定。<br />
原来的select语句是：</p>

<p><code>
select _id, code, region from xzqhdm where parent_code = ?&lt;br /&gt;
</code></p>

<p><p>因为传入到CursorAdapter中的Cursor结果集必须包含有列名为<em>id的列，否则CursorAdapter将不会起作用。而code可以被看作是整数，那么只需要将选出的code当作</em>id就行了，根据这个想法写出的select语句如下：</p>

<p><code>
select code as _id, region from xzqhdm where parent_code = ?&lt;br /&gt;
</code></p>

<p><p>这样，但触发Spinner上的ItemSelected事件时就可以通过最后一个参数id得到当前的code了。</p>

<p><p><span style="color: #ff0000;">写这篇文章的时候同时也在调试着代码，突然发现其实不需要改写select语句也是可以实现键值绑定的。只要在onItemSelected()方法中使用如下代码就可以取得相应的值了：</span></p>

<p>```
Cursor cursor = (Cursor)parent.getSelectedItem();<br />
if (cursor != null) {<br /></p>

<pre><code>int code = cursor.getString(cursor.getColumnIndex("code"));&lt;br /&gt;
String country = cursor.getString(cursor.getColumnIndex("region"));&lt;br /&gt;
</code></pre>

<p>}
```</p>

<p><a href="/uploads/linkage.zip" title="linkage.zip">代码下载</a></p>

<p><p>参考文章：
<a href="http://lxmgfd.iteye.com/blog/970637"><a href="http://lxmgfd.iteye.com/blog/970637">http://lxmgfd.iteye.com/blog/970637</a></a>
<a href="http://www.eoeandroid.com/thread-98254-1-1.html"><a href="http://www.eoeandroid.com/thread-98254-1-1.html">http://www.eoeandroid.com/thread-98254-1-1.html</a></a>
<a href="http://www.cmd100.com/bbs/thread-5454-1-1.html"><a href="http://www.cmd100.com/bbs/thread-5454-1-1.html">http://www.cmd100.com/bbs/thread-5454-1-1.html</a></a></p></p>
]]></content>
  </entry>
  
</feed>
