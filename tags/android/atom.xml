<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Android | 乐者为王]]></title>
  <link href="http://codemany.com/tags/android/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2017-01-19T21:28:27+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[象棋残局大师开发实录（2）]]></title>
    <link href="http://codemany.com/blog/chess-mess-master-development-record-part2/"/>
    <updated>2017-01-17T18:21:40+08:00</updated>
    <id>http://codemany.com/blog/chess-mess-master-development-record-part2</id>
    <content type="html"><![CDATA[<p>界面的实现主要是绘制棋盘和棋子，有纯代码绘制和使用图片两种方式。因为担心图片缩放引起图片质量问题，以及害怕根据缩放计算棋子落点的麻烦，打算采取纯代码绘制方式。不过在编写了部分代码后发觉这不是个好主意。</p>

<p>纯代码绘制棋盘需要画纵横线、斜线、炮兵座线、文字“楚河汉界”以及中文数字两套坐标，部分线条需要加粗，河界区的竖线不需要画，文字绘制时是以baseline为Y坐标的。这些因素导致文字和棋子在视图中的坐标位置都需要经过细细地计算。如果再考虑让“楚河汉界”这几个字躺着显示，那就更是麻烦。即便这样，绘制完的棋盘背景也只是白色，素素的不是很好看。就这还是没有考虑绘制棋子的结果。当然，好处也是有的，棋子所在的交点坐标很容易计算得到（这个其实不算优点，只是我没深入思考的结果，图片的方式也很容易计算棋子的落点坐标），棋盘也不需要考虑缩放问题，总是适配当前运行的机器的。</p>

<p>既然纯代码绘制的方式问题多多且只有无需屏幕适配这个优势，那采用图片的方式就是必然。</p>

<p>图片方式的实现也有两种，一种是使用View或者SurfaceView显示图片；还有一种是把棋盘和棋子当作ImageView控件处理。使用Layout.addView(View)和Layout.deleteView(View)就可以很容易地放置和消除棋子。经过简单的比较我选用SurfaceView作为绘制的视图。SurfaceView的内容这里不做介绍，因为这不是我们要考虑的重点。以下是SurfaceView的代码骨架：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class GameView extends SurfaceView implements SurfaceHolder.Callback {
    private DrawThread drawThread;
    private SurfaceHolder surfaceHolder;

    public GameView(Context context, AttributeSet attrs) {
        super(context, attrs);

        surfaceHolder = getHolder();
        surfaceHolder.addCallback(this);

        // TODO: 加载棋盘棋子图片资源
    }

    // 自定义的绘制方法
    private void doDraw(Canvas canvas) {
        // TODO: 绘制棋盘和棋子
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        if (event.getAction() == MotionEvent.ACTION_DOWN) {
            // TODO: 游戏交互
        }
        return super.onTouchEvent(event);
    }

    @Override
    public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
    }

    @Override
    public void surfaceCreated(SurfaceHolder holder) {
        if (drawThread == null) {
            drawThread = new DrawThread();
            drawThread.start();
        }
    }

    @Override
    public void surfaceDestroyed(SurfaceHolder holder) {
        if (drawThread != null) {
            drawThread.stopThread();
        }
    }

    private class DrawThread extends Thread {
        private boolean isRunning = false;

        public DrawThread() {
            isRunning = true;
        }

        public void stopThread() {
            isRunning = false;
            boolean retry = true;
            while (retry) {
                try {
                    this.join();    // 保证run方法执行完毕
                    retry = false;
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }

        @Override
        public void run() {
            while (isRunning) {
                Canvas canvas = null;
                try {
                    canvas = surfaceHolder.lockCanvas();
                    synchronized (surfaceHolder) {
                        if (canvas != null) {
                            doDraw(canvas);
                        }
                    }
                } finally {
                    if (canvas != null) {
                        surfaceHolder.unlockCanvasAndPost(canvas);
                    }
                }
            }
        }
    }
}
</code></pre></div>
<p>用图片在视图上绘制棋盘需要考虑不同屏幕尺寸的适配问题，官方推荐的做法是单图片多分辨率，即将不同分辨率的同个图片放在特定的资源目录下。这种做法的缺点是需要维护多套图片，且绘制的棋盘也不可能正好完全匹配屏幕。使用单分辨率图片的话，如果图片尺寸过小，那么在绘制时就必须放大，容易变得模糊；如果图片尺寸太大的话，又会导致资源太大进而引起应用安装包过大的问题。这里使用的是558 * 620像素的图片，既不是太大，又不是太小，恰到好处。其中，棋盘格子是57 * 57像素的正方形，河界的高度和棋盘格子的边长相等，所以两条边线的距离是57 * 8 = 456像素，底线距离是57 * 9 = 513像素。</p>

<p><img src="/uploads/marked-chess-board.png" title="marked-chess-board" ></p>

<p>棋子图片的原始大小是55 * 55像素。连同上面棋盘的那些值可以设置成以下的常量供以后使用：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class ChessBoard {
    public static final int RAW_IMAGE_WIDTH = 558;
    public static final int RAW_IMAGE_HEIGHT = 620;
    public static final int RAW_TILES_WIDTH = 456;
    public static final int RAW_TILES_HEIGHT = 513;
    public static final int RAW_TILE_SIZE = 57;
    public static final int RAW_CHESS_SIZE = 55;

</code></pre></div>
<p>因为使用的是单张图片，所以在绘制之前还需要知道屏幕的大小，以便在绘制时对图片做等比例的缩放，使图片在填满屏幕的前提下，最大程度地保证图片的缩放效果，确保图片不变形。缩放代码如下：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">// 计算屏幕的最佳缩放比例
private float calcBestScale() {
    DisplayMetrics dm = getResources().getDisplayMetrics();
    int screenWidth  = dm.widthPixels;
    int screenHeight = dm.heightPixels;

    float scaleX = (float)screenWidth / RAW_IMAGE_WIDTH;
    float scaleY = (float)screenHeight / RAW_IMAGE_HEIGHT;
    return Math.min(scaleX, scaleY);
}

private Bitmap resizeBitmap(Bitmap bitmap, float bestScale) {
    Matrix matrix = new Matrix();
    matrix.postScale(bestScale, bestScale);
    return Bitmap.createBitmap(bitmap, 0, 0,
            bitmap.getWidth(), bitmap.getHeight(), matrix, true);
}
</code></pre></div>
<p>在保证能得到最佳效果的缩放图片后，就可以加载棋盘和棋子的图片资源了。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">private void initResources() {
    board = resizeBitmap(BitmapFactory.decodeStream(
            getResources().openRawResource(+R.drawable.board)), bestScale);

    chesses[0] = resizeBitmap(BitmapFactory.decodeStream(
            getResources().openRawResource(+R.drawable.black_jiang)), bestScale);
    chesses[1] = resizeBitmap(BitmapFactory.decodeStream(
            getResources().openRawResource(+R.drawable.black_shi)), bestScale);
    chesses[2] = resizeBitmap(BitmapFactory.decodeStream(
            getResources().openRawResource(+R.drawable.black_xiang)), bestScale);
    chesses[3] = resizeBitmap(BitmapFactory.decodeStream(
            getResources().openRawResource(+R.drawable.black_ma)), bestScale);
    chesses[4] = resizeBitmap(BitmapFactory.decodeStream(
            getResources().openRawResource(+R.drawable.black_ju)), bestScale);
    chesses[5] = resizeBitmap(BitmapFactory.decodeStream(
            getResources().openRawResource(+R.drawable.black_pao)), bestScale);
    chesses[6] = resizeBitmap(BitmapFactory.decodeStream(
            getResources().openRawResource(+R.drawable.black_zu)), bestScale);
    chesses[7] = resizeBitmap(BitmapFactory.decodeStream(
            getResources().openRawResource(+R.drawable.red_shuai)), bestScale);
    chesses[8] = resizeBitmap(BitmapFactory.decodeStream(
            getResources().openRawResource(+R.drawable.red_shi)), bestScale);
    chesses[9] = resizeBitmap(BitmapFactory.decodeStream(
            getResources().openRawResource(+R.drawable.red_xiang)), bestScale);
    chesses[10] = resizeBitmap(BitmapFactory.decodeStream(
            getResources().openRawResource(+R.drawable.red_ma)), bestScale);
    chesses[11] = resizeBitmap(BitmapFactory.decodeStream(
            getResources().openRawResource(+R.drawable.red_ju)), bestScale);
    chesses[12] = resizeBitmap(BitmapFactory.decodeStream(
            getResources().openRawResource(+R.drawable.red_pao)), bestScale);
    chesses[13] = resizeBitmap(BitmapFactory.decodeStream(
            getResources().openRawResource(+R.drawable.red_bing)), bestScale);
}
</code></pre></div>
<p>注意，加载图片资源要用openRawResource()配合decodeStream()才能得到原始大小的图片，如果使用decodeResource()的话，得到的图片大小则是<code>原始大小 * 手机密度 / 160</code>。至于R前面的+号则是因为图片在drawable目录下时Android Studio会提示警告，不想加的话就必须要把图片放到raw目录中。</p>

<p>有了棋盘和棋子的图片资源后，我们就可以绘制象棋界面了。当然，在这之前还要先确定表示棋局状态的数据结构，我们用一个10行9列的二维数组来描述。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class ChessBoard {
    /*
     * 无子(0)
     * 黑将(1) 黑士(2) 黑象(3)  黑马(4)  黑车(5)  黑砲(6)  黑卒(7)
     * 红帅(8) 红仕(9) 红相(10) 红馬(11) 红車(12) 红炮(13) 红兵(14)
     */
    private int[][] chessPoints = {
        /*   1 2 3 4 5 6 7 8 9   */
        {5, 4, 3, 2, 1, 2, 3, 4, 5},
        {0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 6, 0, 0, 0, 0, 0, 6, 0},
        {7, 0, 7, 0, 7, 0, 7, 0, 7},
        {0, 0, 0, 0, 0, 0, 0, 0, 0},
        /*       楚河 汉界       */
        {0, 0, 0, 0, 0, 0, 0, 0, 0},
        {14, 0, 14, 0, 14, 0, 14, 0, 14},
        {0, 13, 0, 0, 0, 0, 0, 13, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0},
        {12, 11, 10, 9, 8, 9, 10, 11, 12}
        /* 九 八 七 六 五 四 三 二 一 */
    };

    public int[][] getChessPoints() {
        return chessPoints;
    }

    public int getChess(int row, int col) {
        return chessPoints[row][col];
    }

    public boolean hasChess(int row, int col) {
        return chessPoints[row][col] != 0;
    }
</code></pre></div>
<p>接着，我们需要根据适配时图片缩放的比例计算各个棋子绘制时的偏移坐标（假设棋盘的偏移坐标是[0, 0]）。先看下图：</p>

<p><img src="/uploads/chess-piece-offset.png" title="chess-piece-offset" ></p>

<p>通过观察可以知道，两个棋子左边框之间的距离等于棋盘格子的边长。如果把左上角棋子相对棋盘图片边界偏移的变量分为称为chessBaseLeft和chessBaseTop的话，那么它们的值可以通过以下的公式计算得到：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">tileSize = ChessBoard.RAW_TILE_SIZE * bestScale;    // 棋盘格子缩放后的大小
chessBaseLeft = (ChessBoard.RAW_IMAGE_WIDTH - ChessBoard.RAW_TILES_WIDTH
        - ChessBoard.RAW_CHESS_SIZE) / 2 * bestScale;
chessBaseTop = (ChessBoard.RAW_IMAGE_HEIGHT - ChessBoard.RAW_TILES_HEIGHT
        - ChessBoard.RAW_CHESS_SIZE) / 2 * bestScale;
</code></pre></div>
<p>得到棋子相对棋盘的偏移坐标后，我们就可以开始真正的绘制棋盘和棋子了。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">canvas.drawColor(Color.WHITE);

// 绘制棋盘
canvas.drawBitmap(board, 0, 0, paint);

// 根据points数组绘制棋子
for (int row = 0; row &lt; chessBoard.getChessPoints().length; row++) {
    for (int col = 0; col &lt; chessBoard.getChessPoints()[row].length; col++) {
        if (chessBoard.hasChess(row, col)) {
            float left = chessBaseLeft + col * tileSize;
            float top = chessBaseTop + row * tileSize;
            int index = chessBoard.getChess(row, col) - 1;
            canvas.drawBitmap(chesses[index], left, top, paint);
        }
    }
}
</code></pre></div>
<p>至此，象棋界面的绘制就算是完成了，接下来要处理的是与玩家的交互。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[象棋残局大师开发实录（1）]]></title>
    <link href="http://codemany.com/blog/chess-mess-master-development-record-part1/"/>
    <updated>2017-01-01T21:43:06+08:00</updated>
    <id>http://codemany.com/blog/chess-mess-master-development-record-part1</id>
    <content type="html"><![CDATA[<p>小时候经常在街头看到有人摆象棋残局，红方无论赢棋还是和棋都算破解成功，否则就是失败。作为象棋低手，也曾尝试过好多次，但从来没有真正破解过哪个残局。有次甚至默记住某个残局的走法去破解，结果在解完所有圈套后还是在接下来的走棋中输掉。</p>

<p>一晃许多年过去了，象棋也很长时间没有再玩过。最近偶尔在网上接触到象棋残局，又再次把思绪给挑动起来。同时也了解到那些街头残局的最终结果通常都是和棋，并且由于残局往往会包含多个圈套，所以破解成功的可能性非常非常之低。因为在解套阶段，你必须步步走对才能把所有的圈套解除，否则只要有一步走错便是输。解完套之后，你仍然得小心翼翼地走棋，要是误走一着也很可能会输掉。正所谓：一着不慎，满盘皆输。</p>

<p>残局棋谱通常会有参考走法，按照这些走法逐步执行就可以破解成功。但目前我在网上碰到的有些残局的参考走法明显有错误。比如，红方在某个关键步骤时有不遵循参考走法的走法会让红方对黑方形成必杀，又或者黑方在某一步时换个走法就会使和棋的结局变成黑方必胜。当然，这些错误或正确的走法也可能是我想当然，因此我也不能确定我的想法是否真的正确。为解决这个问题，我决定开发一款结合人工智能的象棋残局软件。毕竟现在的人工智已经非常强大了，上半年的AlphoGo都已经把围棋这个难题给攻克，所以用人工智能来探索象棋残局还是非常合适的。</p>

<p>象棋游戏属于完全信息博弈游戏，所以它至少应具备如下几个部分：</p>

<ol>
<li>某种在机器中表示棋局的方法，能够让程序知道博弈的状态。</li>
<li>产生合法走法的规则，以使博弈公正地进行，并可判断棋手是否乱走。</li>
<li>从所有合法的走法中选择最佳走法的技术。</li>
<li>一种评估局面优劣的方法，用以同上面的技术配合作出智能的选择。</li>
<li>用户界面。有了它，程序才可以用。</li>
</ol>

<p>但我要开发的程序主要是用于研究象棋残局的，所以它还需要一些特殊的辅助功能。在最理想的情况下，残局的人机博弈走法应该和参考走法相同。但有时候我们会发现黑方会走出不在参考走法上的步骤。因为参考走法是经过多年的演变而来，通常是最优的，所以我们需要能对黑方的走棋进行纠错。当然，最好的做法是提高博弈算法的能力，但智能的改进不是一蹴而就的，纠错功能的提供只是作为这种无奈的补充。假如黑方的走法确实比参考走法更优，并且我们发现黑方这样走以后红方似乎找不到可以赢棋或者和棋的走法，这时就需要机器帮助我们计算出最佳走法。此外，轮到红方走棋时可能会发现有貌似比参考走法上更优的走法需要验证，这时我们需要在验证失败后能够回退到不同走法的分叉点上。</p>

<p>带有这些特殊需求的游戏原型界面如下图所示：</p>

<p><img src="/uploads/chess-mess-master.png" title="chess-mess-master" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Application对象里存储数据的陷阱]]></title>
    <link href="http://codemany.com/blog/trap-for-storing-data-in-the-application-object/"/>
    <updated>2015-10-27T20:57:41+08:00</updated>
    <id>http://codemany.com/blog/trap-for-storing-data-in-the-application-object</id>
    <content type="html"><![CDATA[<p>看到<a href="http://www.developerphil.com/dont-store-data-in-the-application-object/">Don&#39;t Store Data in the Application Object</a>讲，在Application对象中存储共享数据会引起NullPointerException。顿时心里就咯噔了一下，用了四分之三秒，想起自己有个业余项目就干了这样的事。赶紧地测试看看。</p>

<p>打开应用，从MainActivity进入TxtViewerActivity界面（这里MainActivity主要是读取目录数据，然后保存在继承自Application的MainApp中，供TxtViewerActivity调用）。按手机Home键退出应用，这时你按菜单键可以看到该应用的缩图。然后在Eclipse中打开Window -&gt; Show View -&gt; Other -&gt; Android -&gt; Devices视图，双击窗口内的设备，然后点击设备下对应的进程，点击右上方红色的“Stop Process”图标。</p>

<p><img src="/uploads/android-devices.png" title="android-devices" ></p>

<p>重新按菜单键打开应用，然后……然后果然在LogCat中看到了有NullPointerException的大段红色警告文字。</p>

<h3 id="为什么会crash的？">为什么会Crash的？</h3>

<p>根本原因在于：当应用被kill掉后，通过菜单键重新打开时，应用不会开始重新启动。Android系统会新建一个Application对象，然后启动上次离开时的TxtViewerActivity以造成这个应用从来没有被kill掉的假象。因为没有经过MainActivity的数据读取，所以在TxtViewerActivity中读取数据当然要抛出异常了。</p>

<h3 id="有没有替代方法呢？">有没有替代方法呢？</h3>

<ul>
<li>直接将数据通过Intent传递给TxtViewerActivity？当然也会碰到上述同样的问题。</li>
<li>使用SharedPreferences？可惜只能存储boolean、int、long、float和String五种数据类型，不支持List的存储；</li>
<li>使用持久化存储？也不支持List的存储，而且太笨重了；</li>
<li>使用Singleton对象保存共享数据，然后通过Intent传递呢？这个想法不错，还可以将读取assets资源等操作移到该对象中，做到单一职责原则，改善设计。不过这样一来Singleton对象会对MainActivity的context有长期引用，容易造成内存泄露。如果不把读取操作放进去……那根本就不可能，你能让一个追求完美的程序猿忍受糟糕的代码设计吗！</li>
</ul>

<p>幸好早就有人总结出来经验了：使用Application的context代替Activity的context。</p>

<p>创建Singleton对象，在Application对该对象保持引用，把原来存储在Application中共享的数据全部移到Singleton对象中，将Activity中读取assets资源等操作也放入该对象，Activity中原来对Application对象的访问改成通过Application对象对Singleton对象的访问。</p>

<p>这样修改后，不光解决了应用的崩溃，还预防了内存泄漏，更改进代码的设计。</p>

<p>代码下载：<a href="https://github.com/dohkoos/txtReader">https://github.com/dohkoos/txtReader</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TabActivity is deprecated]]></title>
    <link href="http://codemany.com/blog/tabactivity-is-deprecated/"/>
    <updated>2014-12-05T19:29:10+08:00</updated>
    <id>http://codemany.com/blog/tabactivity-is-deprecated</id>
    <content type="html"><![CDATA[<p>最近在整理<a href="http://codemany.com/blog/summary-of-android-tab-navigation/">Android Tab导航总结</a>的代码时发现
TabActivity在API 13中被标记为过期了，所以就去寻找它的替换类，能尽量满足最小修改的要求。发现可以使用FragmentActivity来替代，Fragment组件作为标签页添加。</p>

<p>Fragment是Android 3.0引入的一个新概念，主要是为了适应各种不同的屏幕大小，它非常类似于Activity，可以像Activity一样包含布局，但是不能单独存在，只能存在于Activity中。下图是Fragment在不同屏幕上的显示以及Fragment与所在Activity的关系：</p>

<p><img src="/uploads/android-fragments.png" title="android-fragments" ></p>

<p>重构前的布局：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">MainActivity extends TabActivity
    TabHost - tabhost
        LinearLayout
            TabWidget - tabs
            FrameLayout - tabcontent
                TabSpec (Activity)
                ...
                TabSpec (Activity)
</code></pre></div>
<p>重构后的布局：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">MainActivity extends FragmentActivity
    TabHost - tabhost
        LinearLayout
            TabWidget - tabs
            FrameLayout - tabcontent
                TabSpec (Fragment)
                ...
                TabSpec (Fragment)
</code></pre></div>
<p>把TabLeftActivity和TabRightActivity分别改成LeftFragment和RightFragment：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class LeftFragment extends Fragment {

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        rootView = inflater.inflate(R.layout.tab_left, container, false);

        // do something
        // 不能直接使用findViewById()方法，必须加上rootView前缀
        // 如果要引用当前绑定的Activity实例，使用getActivity()方法

        return rootView;
    }
}
</code></pre></div>
<p>然后在main.xml中的FrameLayout里添加两个Fragment组件：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&lt;fragment android:name=&quot;com.example.fragments.LeftFragment&quot;
    android:id=&quot;@+id/fragment_left&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot; /&gt;

&lt;fragment android:name=&quot;com.example.fragments.RightFragment&quot;
    android:id=&quot;@+id/fragment_right&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot; /&gt;
</code></pre></div>
<p>把MainActivity改成从FragmentActivity继承。这里不能像TabActivity一样直接用getTabHost()，需要改成如下代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">TabHost tabHost = (TabHost)findViewById(android.R.id.tabhost);
tabHost.setup();
</code></pre></div>
<p>到这边就已经完成了，其它tabHost.addTab的使用方式一模一样。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[扫描ISBN条码实现藏书管理]]></title>
    <link href="http://codemany.com/blog/manage-books-by-scanning-isbn-barcode/"/>
    <updated>2013-04-25T12:17:14+08:00</updated>
    <id>http://codemany.com/blog/manage-books-by-scanning-isbn-barcode</id>
    <content type="html"><![CDATA[<p>每个程序猿家里都有一堆技术书籍，偶也不例外，因此想写个Android应用来管理自己的藏书以及想买的书籍。在网上找到marshal的<a href="http://marshal.easymorse.com/archives/2745">识别图书ISBN号并输出查询结果的示例</a>和<a href="http://marshal.easymorse.com/archives/2756">完善图书查询原型，增加收藏夹功能</a>两篇文章，写的非常不错，还提供源代码。下载代码研究后发现已基本具备了想要的功能，决定在它的基础上做些修改供自己使用。</p>

<p>把原来uses-sdk的minSdkVersion改成了9，增加android:targetSdkVersion=&quot;17&quot;。然后使用手机测试程序时发现，在连接网络时后台会抛出android.os.NetworkOnMainThreadException，并且应用崩溃打不开。通过查阅相关资料了解到，自从Android 2.3之后，系统增加了一个类StrictMode。这个类对网络的访问方式进行了一定的改变。官方文档给出了这个类设置的目的：</p>

<blockquote>
<p>StrictMode is a developer tool which detects things you might be doing by accident and brings them to your attention so you can fix them.</p>

<p>StrictMode is most commonly used to catch accidental disk or network access on the application&#39;s main thread, where UI operations are received and animations take place. Keeping disk and network operations off the main thread makes for much smoother, more responsive applications. By keeping your application&#39;s main thread responsive, you also prevent ANR dialogs from being shown to users.</p>

<p>Note that even though an Android device&#39;s disk is often on flash memory, many devices run a filesystem on top of that memory with very limited concurrency. It&#39;s often the case that almost all disk accesses are fast, but may in individual cases be dramatically slower when certain I/O is happening in the background from other processes. If possible, it&#39;s best to assume that such things are not fast.</p>
</blockquote>

<p>因为marshal把访问网络的代码直接放到UI线程中，造成和主线程的首要工作——UI交互——相矛盾。解决这类问题很容易，把访问网络的代码放到AsyncTask中就行了。</p>

<p>接着发现豆瓣API查询返回的是500错误，在浏览器上访问却又正常，后来给HttpClient加上Agent头就没问题了，不知道是不是期间豆瓣的API在实现上作了改变。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">HttpClient client = new DefaultHttpClient();
String agent = System.getProperty(&quot;http.agent&quot;);
client.getParams().setParameter(CoreProtocolPNames.USER_AGENT, agent);
</code></pre></div>
<p>解析豆瓣XML查询结果的代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">XmlPullParserFactory factory = XmlPullParserFactory.newInstance();
factory.setNamespaceAware(true);
XmlPullParser parser = factory.newPullParser();
parser.setInput(inputStream, &quot;utf-8&quot;);

Book book = new Book();
book.setIsbn(getIntent().getExtras().getString(&quot;ISBN&quot;));

int eventType = parser.getEventType();
while (eventType != XmlPullParser.END_DOCUMENT) {
    switch (eventType) {
    case XmlPullParser.START_TAG:
        if (&quot;link&quot;.equals(parser.getName())
                &amp;&amp; &quot;image&quot;.equals(parser.getAttributeValue(null, &quot;rel&quot;))) {
            book.setImageUrl(parser.getAttributeValue(null, &quot;href&quot;));
            eventType = parser.next();
        } else if (&quot;summary&quot;.equals(parser.getName())) {
            book.setSummary(parser.nextText());
        } else if (&quot;attribute&quot;.equals(parser.getName())) {
            String name = parser.getAttributeValue(null, &quot;name&quot;);
            if (&quot;title&quot;.equals(name)) {
                book.setTitle(parser.nextText());
            } else if (&quot;author&quot;.equals(name)) {
                book.setAuthor(parser.nextText());
            } else if (&quot;publisher&quot;.equals(name)) {
                book.setPublisher(parser.nextText());
            }
        }
        break;
    case XmlPullParser.END_TAG:
        break;
    }
    eventType = parser.next();
}
</code></pre></div>
<p>然后，然后就是结果页面不显示图书信息。想要找到原因，肿么办？看来要调试WebView了！<a href="http://developer.android.com/guide/webapps/debugging.html">http://developer.android.com/guide/webapps/debugging.html</a> 告诉了我们如何调试。</p>

<p>首先在WebView上设置setWebChromeClient方法：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">webView.setWebChromeClient(new WebChromeClient() {
    public void onConsoleMessage(String message,
            int lineNumber, String sourceID) {
        Log.d(TAG, message + &quot; -- From line &quot;
                + lineNumber + &quot; of &quot; + sourceID);
    }
});
</code></pre></div>
<p>然后在JavaScript脚本中使用以下方法就可以在logcat中看到调试信息了。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">console.log(String)
console.info(String)
console.warn(String)
console.error(String)
</code></pre></div>
<p>重新运行程序，果然在logcat中看到报如下错误：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Uncaught TypeError: Object [object Object] has no method &#39;xxx&#39;
</code></pre></div>
<p>搜索后在Stack Overflow找到了<a href="http://stackoverflow.com/questions/14031635/android-4-2-1-webview-and-javascript-interface-breaks">问题的答案</a>（Stack Overflow真的非常不错，问题的回答都非常详尽）。<a href="http://developer.android.com/guide/webapps/webview.html#BindingJavaScript">http://developer.android.com/guide/webapps/webview.html#BindingJavaScript</a> 是官方文档的解释。</p>

<p>解决方法就是在要被JavaScript调用的方法上加@JavascriptInterface注解：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class Book {

    @JavascriptInterface
    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        if (this.author != null) {
            this.author += &quot;, &quot; + author;
        } else {
            this.author = author;
        }
    }
</code></pre></div>
<p>代码下载：<a href="https://github.com/dohkoos/Bookly">https://github.com/dohkoos/Bookly</a></p>
]]></content>
  </entry>
  
</feed>
