<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Software Engineering | 乐者为王]]></title>
  <link href="http://codemany.com/tags/software-engineering/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2017-02-18T12:13:25+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[共享代码的风险]]></title>
    <link href="http://codemany.com/blog/the-perils-of-shared-code/"/>
    <updated>2016-11-25T18:51:10+08:00</updated>
    <id>http://codemany.com/blog/the-perils-of-shared-code</id>
    <content type="html"><![CDATA[<p>英文原文：<a href="https://www.innoq.com/en/blog/the-perils-of-shared-code/">https://www.innoq.com/en/blog/the-perils-of-shared-code/</a></p>

<p>通往地狱的道路往往是由良好的意愿铺就。在各种软件项目中，我看到人们走在这样的道路上，他们在微服务间借助于库共享代码。在几乎每个组织支持微服务架构的项目中，各个团队和开发者都期望以某些核心库为基础构建他们的微服务。显然，即使可能带来的问题已经被知道很长时间了，很多人仍然不知道它们。在这篇博文中，我想研究为什么使用这样的库可能起初听起来有吸引力，为什么可能会出现问题，以及如何能够减轻这些问题。</p>

<h3 id="共享代码的目的">共享代码的目的</h3>

<p>通过库来共享代码有两个主要目的：共享领域逻辑和共享基础设施层中的抽象。</p>

<ol>
<li><p><em>共享的领域模型：</em>领域模型的特定部分在两个或多个有界上下文之间是共同的，因此，作为三番五次实现它的替换，你消除了重复的需要和引入该领域逻辑的不一致实现的可能性。通常，人们想要像那样共享的领域模型的部分是核心领域或一个或多个通用子领域。在领域驱动设计的行话中，这也被称为共享内核。通常，你可以在这里找到像会话和身份验证逻辑这样的概念，但不限于此。一套相关的方法是规范数据模型。</p></li>
<li><p><em>基础设施层抽象：</em>你想避免一次又一次地实现基础设施层的有用抽象，因此你把它们放进一个库里。通常，这些库在数据库访问、消息传递和序列化等方面提供一套统一的方法。</p></li>
</ol>

<p>两者的动机是相同的——避免重复，也就是说，遵循DRY原则（Don’t repeat yourself!）。一旦实现这些逻辑有几个好处：</p>

<blockquote>
<p>你不需要花费宝贵的时间致力于那些已经被解决的问题。</p>

<p>有一套统一的方式做消息传递、数据库访问等。这意味着，当开发者需要去阅读和修改其他开发者最初创建的微服务中的代码时，他们很容易找到他们的方式。</p>

<p>关于彼此行为略有不同的业务逻辑或基础设施关注点，你不想有不同的实现。取而代之的是，有一套做正确事情的规范实现。</p>
</blockquote>

<h3 id="共享代码的问题">共享代码的问题</h3>

<p>在理论上听起来很棒的东西不会没有自己的问题，而且这些问题可能比你试图用你的库解决的问题更令人痛苦。Stefan Tilkov已经详细解释了<a href="https://www.innoq.com/en/blog/thoughts-on-a-canonical-data-model/">为什么你应该避免规范的数据模型</a>。除此之外，让我指出一些其它的问题。</p>

<h4 id="分布式单体">分布式单体</h4>

<p>Often, there seems to be an implicit assumption that putting things into a library means that you never have to worry about services using a wrong or outdated implementation, because they simply need to update their dependency on the library to the latest version.</p>

<p>Whenever you rely on being able to change some behaviour consistently across all your microservices by updating them all to the same new version of your library, you introduce a strong coupling between them. You lose one major benefit of microservices, the ability to have them evolve and to deploy them independently from each other.</p>

<p>I have seen cases where all the services had to be deployed together in order for things to still work properly. If you reach this state, there is no denying that you have actually built a distributed monolith.</p>

<p>A popular example is to use code generation based, for instance, on a Swagger description of your service API, in order to provide a client library for your service. More often than you may think, developers are tempted to abuse this for making breaking changes, because dependent services “just” need to use a new version of their client library. This is not how you <a href="http://olivergierke.de/2016/10/evolving-distributed-systems/">evolve a distributed system</a>.</p>

<h4 id="依赖地狱">依赖地狱</h4>

<p>Libraries, especially those that are designed to provide a common solution to infrastructure concerns, often have an additional problem: They come with a whole bag of additional libraries they depend on. The bigger the transitive dependency tree of your library, the higher the probability that it will lead to the nightmare commonly known as dependency hell. Since your microservices will likely need their own additional dependencies, which again have transitive dependencies, it is only a matter of time until some of them transitively pull in conflicting versions of some library, and simply choosing between the different versions will be impossible, because they are binary incompatible.</p>

<p>Of course, your solution might be to simply provide all the libraries your microservices could possibly need as dependencies of your core library. That still means that your microservices cannot evolve independently, for example by upgrading to a later version of only a specific library they depend on – they are all in lockstep with the release cycle of your core library. Apart from that, why would you force a whole bunch of dependencies on every service when in fact they probably only need a few of them?</p>

<h4 id="自上而下的库设计">自上而下的库设计</h4>

<p>More often than not, the libraries I have seen were forced upon the developers by one or more architects, taking a top-down approach to library design.</p>

<p>Usually, what happens in this case is that the APIs that are exposed by the library are too restrictive and inflexible, or use the wrong level of abstraction, because they are designed by people who are not familiar enough with the wide spectrum of different real-world use cases. Such a library often leads to frustration among the developers that have to live with it, and to people trying to work around the limitations of the library.</p>

<h4 id="单语言解决一切">单语言解决一切</h4>

<p>One of the most obvious drawbacks that come with enforcing libraries is that this makes it even harder to switch to a different programming language (or platform, like the JVM or .NET), again losing one advantage of a microservices architecture, the ability to choose the technology that fits best for a given problem. If you later on realise that you need this kind of language or platform diversity after all, you have to do invent all kinds of weird crutches. For instance, Netflix came up with <a href="https://github.com/Netflix/Prana">Prana</a>, a sidecar that runs along side non-JVM services, providing them an HTTP API to the Netflix technology stack.</p>

<h3 id="我们能不能做得更好？">我们能不能做得更好？</h3>

<p>With all the problems introduced by sharing code via libraries, the most extreme solution is to simply have no such library at all. If you do that, you will have to do some copy-and-paste or provide a template project for new microservices in order to liberate your services from the lockstep described above. This can be done both for infrastructure code as well as for the shared kernel of your domain model. In fact, in his classic blue book on domain-driven design, Eric Evans mentioned that usually, “teams make changes on separate copies of the KERNEL, integrating with the other team at intervals”[1]. The shared kernel does not necessarily have to be a library.</p>

<p>If you don’t like the idea of copy and paste, that’s fine as well. After all, as mentioned above, there are definite advantages to sharing code through libraries. Here are some important things to consider in this case:</p>

<h4 id="最少依赖的小型库">最少依赖的小型库</h4>

<p>Try to split up your big shared library into a set of very small, highly focussed libraries, each of them solving one specific problem. Try to make these libraries zero-dependency libraries, only relying on the language’s standard library. Yes, it’s not always enjoyable to program only against your languge’s standard library, but the tremendous benefits for all the teams in your company (or even beyond your company, if your library is open source) clearly outweigh this minor inconvenience.</p>

<p>Of course, zero dependencies is not always possible, especially for infrastructure concerns. For these, minimize the dependencies required by each of your small libraries. Also, sometimes it can make sense to provide a binding or integration with another library as a separate artifact, independently from the core of your library.</p>

<h4 id="留下选择余地">留下选择余地</h4>

<p>Never rely on the fact that services will update to the latest version of your shared library at a specific point in time. In other words, don’t force library updates on teams, but give them the freedom to update at their own pace. This may require you to change your library in backward and forward compatible ways, but it decouples your services, giving you not only the operational costs of a microservices architecture, but also some of the benefits.</p>

<p>If possible, avoid not only forced library upates, but make the usage of your library itself optional.</p>

<h4 id="自下而上的库设计">自下而上的库设计</h4>

<p>Finally, if you want to have shared libraries, successful projects I have seen were using a bottom-up approach. Instead of having ivory tower architects design libraries that are hardly usable in the real-world, have your teams implement their microservices, and when some common patterns emerge that have proven themselves in production in multiple services, extract them into a library.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为什么我们不能用估算房屋同样的方法估算软件项目]]></title>
    <link href="http://codemany.com/blog/why-we-cant-estimate-software-project-the-same-way-we-estimate-houses/"/>
    <updated>2015-01-10T09:33:48+08:00</updated>
    <id>http://codemany.com/blog/why-we-cant-estimate-software-project-the-same-way-we-estimate-houses</id>
    <content type="html"><![CDATA[<p>英文原文：<a href="http://www.summa-tech.com/blog/2009/01/28/why-we-cant-estimate-software-project-the-same-way-we-estimate-houses">http://www.summa-tech.com/blog/2009/01/28/why-we-cant-estimate-software-project-the-same-way-we-estimate-houses</a></p>

<p>把构造软件类比成建造房屋是非常有用的，但也有缺陷。</p>

<p>尽管软件建设和住宅建设都是工程实践，但比起软件，我们在估算建造房屋的成本和精力方面更成功。</p>

<h3 id="词汇障碍">词汇障碍</h3>

<p>因为我们大多数人一生都住在房子里，我们开发了一套定义良好的、可以理解的、几乎通用的词汇来描述和讨论关于我们称之为家的地方。当被问及我们的房子是什么样子的，我们可以很容易地回答。当计划一所新房子时，我们可以极其肯定地讨论我们想要什么，并确信建筑师和工程师会明白我们谈论的，反之亦然。我们可能不明白水管设施和电气细节，但我们知道电源插座要放在哪里，知道房间的大小，知道要有多少车库门。</p>

<p>当我们谈论软件时，就不是那么有效了。有太多来自业务和技术方面的新术语，我们需要依赖于现实世界中的类比去解释他们。不仅发生在业务和技术人员之间，甚至还发生在业务人员和业务人员，技术人员和技术人员之间。我们不习惯于去描述软件需求因为所有软件的抽象，在估算时沟通经常受到噪音、误解、缺乏眼界的影响，增加了真正需要构建的不确定性。</p>

<h3 id="物理">物理</h3>

<p>现实世界有非常强大和稳定的规则，比如重力，这些规则会在盖房子的时候施加约束。我们知道我们必须在构建二楼前先完成地下室。我们不能在地基完成后增加层的数量。在水管设施铺设后更改浴室的位置将会是非常非常昂贵的。</p>

<p>在软件项目中，我们生活在一个较少规则的世界里，就像《黑客帝国》。从技术上讲，我们可以在同一时间构造所有的应用层。它可以被设计成使用不同的数据库，运行在不同的服务器，或支持不同的语言。它可以通过浏览器、手机、或其它无线设备访问。选项几乎是无穷无尽的。</p>

<p>正是这种自由和灵活性，在过去的40年里驱动了软件的巨大的进步，但在同时，它也是无数软件项目失败的原因。至关重要的是需求要面对现实，让它们遵守一些基本规则，即使它们不受宇宙物理规律的约束。</p>

<h3 id="程序">程序</h3>

<p>物理和几千年建设的结合已经带来了如何去建造一座房子的一套可靠的程序，虽然总是会有新的材料和改进的技术，核心概念都是相同的。油漆房子的过程几百年来几乎没有变化。</p>

<p>我们仍然处于软件工程的早期阶段。大量的“直觉”仍在估算软件时使用，实际情况是直觉还没有被证明非常有效。</p>

<h3 id="材料和标准">材料和标准</h3>

<p>只有数量有限的材料能被实际地用在建造房屋上。从技术上来讲，可能有成千上百的选项去建造一堵墙：夹板、混凝土、钢铁、沙子、玻璃，但在家具建材零售店里这些选项是非常有限的。涂料的类型，门窗的模型很多但有限。当购买一个水槽时，它很容易兼容已有的水管设施的几率非常高。电器有着相同的电压，灯泡也是兼容的。计划建造一所房子的一切都是兼容的，材料更是普及的，把不确定性降低到了非常小的水平，提高了估算的准确性。</p>

<p>软件行业确实有一些标准，但是它们处于层的最低水平，例如网络协议和文件系统。服务器和产品的集成仍处于布线阶段，XML和Web Service还有很长的路要走，在它们和建筑业达到相同级别的兼容性前，如果这是可能的。</p>

<p>各种各样连接到数据库和构建软件的选项和方法增加了复杂性，提高了每个人参与软件构建工作的学习曲线。我不是说所有这些选项都是不好的，但它确实给估算阶段增加了不确定性，所以产生了复杂性。</p>

<h3 id="角色">角色</h3>

<p>每次我路过建筑工地，都会看到很多帽子，一些在积极工作，一些在等待时机采取行动。但最好的部分是我从来没有见过有人同时戴两顶帽子。角色界定的很明确，工人们专业从事于非常具体的领域。</p>

<p>在大型软件项目中也有一些角色被定义，但还远远没有达到建筑业相同级别的专业化。通常团队成员需要戴上很多帽子，结果是，有时候他们会执行那些他们不是专家的任务，这就增加了他们提供的估算的不确定性。</p>

<p>“很多帽子”现象的一个很好例子是“Webmaster”，该角色用于描述那个做网页设计、创建动画图片、编写HTML和Perl代码、配置数据库、管理网络和邮件服务器的家伙。幸运的是现在Webmaster是个很少使用的术语，因为所有这些活动现在都分配给了不同的角色，像网页设计师、DBA，程序员和系统管理员。我们确实在走向专业化，但还是有很长的路要走。</p>

<p>我并不是建议我们停止使用“让我们像建造房屋那样构造软件”的类比，但我们必须意识到这个比喻的局限性。一旦我们知道局限性我们将能更好地定位讨论这一差异，以及提供建议如何解决它们。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何避免项目总是完成90%]]></title>
    <link href="http://codemany.com/blog/how-to-avoid-the-project-is-always-90-percent-done/"/>
    <updated>2012-05-19T14:23:25+08:00</updated>
    <id>http://codemany.com/blog/how-to-avoid-the-project-is-always-90-percent-done</id>
    <content type="html"><![CDATA[<p>程序员经常会说“功能已经基本完成，接下来只需要花点时间进行扫尾工作即可，但这些基本都是些小事情，我已经完成了90%。”但实际情况是项目进度总是延迟。这里最最根本的问题是什么？这个程序员并没有一个清单，把自己要做的所有事情都列出来。这就意味着，即使他坚信自己已经完成90%的工作，他还是不知道这个项目什么时候可以做完，他的时间表是没有真实依据的。</p>

<p>一个好的软件项目经理的任务就是，鼓励并且强制要求程序员创建一张他们所要做的全部事情的列表。然后再为其中的每一项列出子项，并且尽可能把所有的子项都加进来。一旦你拥有了这么一个包含所有事项的列表，你就可以开始估算这个任务需要花费多少时间了。</p>

<p>以下是避免“总是完成90%”问题的发生的几点建议：</p>

<ol>
<li>把项目中所有要做的事情全部罗列出来做成列表。</li>
<li>估算这个列表中每一项所需要花费的时间。这种最初的估算可以帮助你知道整个项目大致要花费多少时间。</li>
<li>如果列表中有一项的时间花费超过1天，则把这项拆分成若干小项。这种将大任务拆分成小任务的方式是解决“总是完成90%”问题的关键步骤。</li>
<li>使用一种呈现任务状态的方式，以便那些感兴趣的人可以了解项目进度。</li>
<li>既然你已经拥有很多小的任务，并且这些任务所消耗的时间都在1天以内，你就可以每天追踪自己的任务完成情况。</li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为什么要软件建模]]></title>
    <link href="http://codemany.com/blog/why-should-software-modeling/"/>
    <updated>2005-05-16T06:23:07+08:00</updated>
    <id>http://codemany.com/blog/why-should-software-modeling</id>
    <content type="html"><![CDATA[<p>模型是对现实的简化。需要进行建模的原因有以下几点：</p>

<ol>
<li>人们对复杂问题的理解能力是有限的；</li>
<li>我们要开发的软件系统是复杂的；</li>
<li>对系统的完整的理解有助于正确地实施工作（但不一定能使开发工作进展的更快）；</li>
<li>我们不能完整的理解一个复杂的系统，为了能够更好地理解正在开发的系统，因此要对它进行建模。</li>
</ol>

<p>那么，是不是任何情况下都要建模呢？未必尽然。是否要进行软件建模是由系统的复杂程度决定的。如果系统的复杂性在我们的控制范围之内，那么就不需要建模。不过，有一个自然趋势：随着时间的推移，几乎所有的应用系统变得越来越复杂。因此要记住的是：狗窝总有一天会膨胀成大厦，并且因为不堪承受其自身的重量而倒塌。</p>
]]></content>
  </entry>
  
</feed>
