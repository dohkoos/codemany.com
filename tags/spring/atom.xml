<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Spring | 乐者为王]]></title>
  <link href="http://codemany.com/tags/spring/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2014-12-23T20:21:35+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Struts 2 + Spring 3 + Hibernate 4登录实例]]></title>
    <link href="http://codemany.com/blog/struts2-spring3-hibernate4-login-sample/"/>
    <updated>2012-09-04T06:54:27+08:00</updated>
    <id>http://codemany.com/blog/struts2-spring3-hibernate4-login-sample</id>
    <content type="html"><![CDATA[<p>在pom.xml中添加Spring的依赖包：</p>

<p>&#8220;`
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-orm</artifactId>
    <version>3.1.2.RELEASE</version>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-web</artifactId>
    <version>3.1.2.RELEASE</version>
</dependency></p>

<!-- 注意：没有这个plugin包会导致Spring无法注入bean到Struts 2的Action中 -->


<p><dependency>
    <groupId>org.apache.struts</groupId>
    <artifactId>struts2-spring-plugin</artifactId>
    <version>2.3.4.1</version>
</dependency>
&#8220;`</p>

<p>配置web.xml文件，加上Spring的监听器：</p>

<pre><code>&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
&lt;/context-param&gt;

&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>

<p>删除hibernate.cfg.xml，添加applicationContext.xml，内容为：</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;!-- DriverManagerDataSource在每个连接请求时都新建一个connection。
         与DBCP的BasicDataSource不同，DriverManagerDataSource提供的连接没有进行池管理 --&gt;
    &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;
        &lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt;
        &lt;property name="url" value="jdbc:mysql://localhost:3306/jbookshelf" /&gt;
        &lt;property name="username" value="root" /&gt;
        &lt;property name="password" value="123456" /&gt;
    &lt;/bean&gt;

    &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate4.LocalSessionFactoryBean"&gt;
        &lt;property name="dataSource" ref="dataSource" /&gt;
        &lt;property name="hibernateProperties"&gt;
            &lt;props&gt;
                &lt;prop key="hibernate.connection.pool_size"&gt;1&lt;/prop&gt;
                &lt;prop key="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/prop&gt;
                &lt;prop key="hibernate.cache.provider_class"&gt;org.hibernate.cache.internal.NoCacheProvider&lt;/prop&gt;
                &lt;prop key="show_sql"&gt;true&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
        &lt;property name="mappingResources"&gt;
            &lt;list&gt;
                &lt;value&gt;com/codemany/account/model/User.hbm.xml&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="userDao" class="com.codemany.account.dao.UserDao"&gt;
        &lt;property name="sessionFactory" ref="sessionFactory" /&gt;
    &lt;/bean&gt;

    &lt;!-- Struts 2的action是有状态的，必须显式设置scope为prototype，这样每次请求过来都会创建新的action --&gt;
    &lt;bean id="loginAction" class="com.codemany.account.action.LoginAction" scope="prototype"&gt;
        &lt;property name="userDao" ref="userDao" /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>

<p>删除HibernateUtil.java，修改UserDao.java为以下内容：</p>

<pre><code>package com.codemany.account.dao;

import org.hibernate.Query;
import org.hibernate.Session;
import org.hibernate.SessionFactory;

import com.codemany.account.model.User;

public class UserDao {
    // Spring 3集成Hibernate 4不再需要HibernateDaoSupport或HibernateTemplate了，
    // 直接使用原生API即可。
    private SessionFactory sessionFactory;

    public void setSessionFactory(SessionFactory sessionFactory) {
        this.sessionFactory = sessionFactory;
    }

    public User getUser(String username) {
        Session session = sessionFactory.openSession();
        try {
            Query query = session.createQuery("from User u where u.username = ?");
            query.setString(0, username);
            query.setMaxResults(1);
            return (User)query.uniqueResult();
        } finally {
            session.close();
        }
    }
}
</code></pre>

<p>在struts.xml中将action元素中login的class属性改为applicationContext.xml配置文件中的loginAction：</p>

<pre><code>&lt;action name="login" class="loginAction"&gt;
    &lt;result name="success"&gt;/index.jsp&lt;/result&gt;
    &lt;result name="input"&gt;/index.jsp&lt;/result&gt;
&lt;/action&gt;
</code></pre>

<p>修改LoginAction.java的代码：</p>

<pre><code>package com.codemany.account.action;

import com.codemany.account.dao.UserDao;
import com.codemany.account.model.User;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionSupport;

public class LoginAction extends ActionSupport {
    private static final long serialVersionUID = -389833745243649130L;

    private String username;
    private String password;

    private UserDao userDao;

    public String execute() throws Exception {
        if (username == null || username.length() == 0
                || password == null || password.length() == 0) {
            return INPUT;
        }

        User u = userDao.getUser(username);
        if (u == null || !password.equals(u.getPassword())) {
            return INPUT;
        }

        ActionContext.getContext().getSession().put("logined", true);
        return SUCCESS;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
}
</code></pre>

<p>代码下载：<a href="https://github.com/dohkoos/JBookShelf">https://github.com/dohkoos/JBookShelf</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JPA + Spring 2入门]]></title>
    <link href="http://codemany.com/blog/getting-started-jpa-with-spring2/"/>
    <updated>2007-08-10T18:33:42+08:00</updated>
    <id>http://codemany.com/blog/getting-started-jpa-with-spring2</id>
    <content type="html"><![CDATA[<p>一、配置JPA</p>

<p>Spring提供了两种方法创建JPA的EntityManagerFactory对象。</p>

<p>方法1：</p>

<pre><code>&lt;beans&gt;
    &lt;bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalEntityManagerFactoryBean"&gt;
        &lt;property name="persistenceUnitName" value="persistenceUnit" /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>

<p>FactoryBean创建的EntityManagerFactory适用于仅通过JPA进行数据访问的环境。由于使用了PersistenceProvider自动侦测机制，所以只能从默认路径classpath:META-INF/persistence.xml中读取配置信息。</p>

<p>方法2：</p>

<pre><code>&lt;beans&gt;
    &lt;bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
        &lt;property name="dataSource" ref="someDataSource" /&gt;
        &lt;property name="loadTimeWeaver"&gt;
            &lt;bean class="org.springframework.instrument.classloading.SimpleLoadTimeWeaver" /&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>

<p>FactoryBean提供了对JPA EntityManagerFactory的完整控制，非常适合那种有简单定制需要的环境。你可以处理多个persistence.xml配置文件；覆盖persistence.xml文件的默认路径；可以传递Spring托管的JDBC DataSource给JPA PersistenceProvider，用来替代persistence.xml中的JDBC配置（这个Spring托管的DataSource通常被作为nonJtaDataSource传送给PersistenceProvider，并且覆盖persistence.xml中相同的nonJtaDataSource）。</p>

<p>二、数据访问</p>

<p>基于JPA的DAO可以通过三种方式进行数据访问JpaDaoSupport，JpaTemplate和plain JPA。其中JpaTemplate是plain JPA的封装，而JpaDaoSupport又是JpaTemplate的封装。无疑，使用不对Spring产生任何依赖的Plain JPA的API进行编程是最好选择。</p>

<pre><code>public class ProductDaoImpl implements ProductDao {
    private EntityManager entityManager = null;

    @PersistenceContext
    public void setEntityManager(EntityManager entityManager) {
        this.entityManager = entityManager;
    }

    public Collection loadProductsByCategory(String category) {
         Query query = em.createQuery("from Product as p where p.category = :category");
         query.setParameter("category", category);
         return query.getResultList();
    }
}
</code></pre>

<p>注意，必须激活PersistenceAnnotationBeanPostProcessor功能才能让Spring识别@PersistenceContext注解。</p>

<pre><code>&lt;beans&gt;
    &lt;!-- JPA annotations bean post processor --&gt;
    &lt;bean class="org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor" /&gt;

    &lt;bean id="productDao" class="com.codemany.netlink.dao.impl.ProductDaoImpl" /&gt;
&lt;/beans&gt;
</code></pre>

<p>三、异常转化</p>

<p>Spring提供了一个允许通过使用@Repository注解进行透明的异常转化的解决方案。</p>

<pre><code>@Repository
public class ProductDaoImpl implements ProductDao {
</code></pre>

<pre><code>&lt;beans&gt;
    &lt;!-- Exception translation bean post processor --&gt;
    &lt;bean class="org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor" /&gt;
</code></pre>

<p>后置处理器将自动的寻找所有的异常转化器（PersistenceExceptionTranslator这个接口的实现类）并通知所有打上@Repository注解的bean，从而能够使得被找到的异常转化器能够在抛出异常时做相应的异常转化工作。</p>

<p>总结来说：DAO能够基于普通的Java持久层API和注解来实现，但同样也能享受到由Spring管理事务、IoC和透明的异常转化（转化成为Spring的异常体系）等好处。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[集成P6Spy到Spring后没有产生log文件的问题]]></title>
    <link href="http://codemany.com/blog/problem-does-not-generate-log-file-when-integrate-p6spy-into-spring/"/>
    <updated>2007-01-22T17:41:32+08:00</updated>
    <id>http://codemany.com/blog/problem-does-not-generate-log-file-when-integrate-p6spy-into-spring</id>
    <content type="html"><![CDATA[<p>网上关于集成P6Spy到Spring的帖子说：在Spring的配置文件中添加：</p>

<pre><code>&lt;bean id="dataSource" class="com.p6spy.engine.spy.P6DataSource" destroy-method="close"&gt;
    &lt;constructor-arg ref="dataSourceTarget" /&gt;
&lt;/bean&gt;
</code></pre>

<p>然后将原来dataSource定义的id值改为dataSourceTarget：</p>

<pre><code>&lt;bean id="dataSourceTarget" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="${driver}" /&gt;
    &lt;property name="url" value="${url}" /&gt;
    &lt;property name="username" value="${username}" /&gt;
    &lt;property name="password" value="${password}" /&gt;
&lt;/bean&gt;
</code></pre>

<p>但是照着这样做了以后却发现没有生成log文件。</p>

<p>下载P6Spy的源代码进行阅读后找到了问题所在。打开P6Util.java文件，在classPathFile()方法中有这样一条语句：</p>

<pre><code>fp = classLoadPropertyFile(Thread.currentThread().getContextClassLoader().getResource(file))
</code></pre>

<p>getResource(file)用来读取spy.properties配置文件，file的值就是spy.properties的文件路径。我的syp.properties放在了C:\Tomcat 5.5\webapps\netlink\WEB-INF\classes目录下，所以它返回的值是C:/Tomcat%205.5/webapps/netlink/WEB-INF/classes/spy.properties，Tomcat 5.5中的空格被编码成了%20。然后在classLoadPropertyFile()方法中就直接使用该值来创建File对象。可想而知，肯定创建失败。</p>

<pre><code>public static File classLoadPropertyFile(java.net.URL purl) {
    try {
        if (purl != null) {
            // modified by jayakumar for JDK 1.2 support
            //return new File(purl.getPath());
            return new File(getPath(purl));
            // end of modification
        }
    } catch (Exception e) {
        // we ignore this, since JDK 1.2 does not suppport this method
    }
    return null;
}
</code></pre>

<p>在classPathFile()方法中通过判断fp.exists()来决定是否返回log文件的路径，既然上面创建File对象失败了，那fp.exists()肯定不可能为true了，log文件也就不可能被创建了。</p>

<p>解决问题的方法超简单，把Tomcat 5.5中的空格去掉就行了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DbUnit结合Spring进行SqlMap的单元测试]]></title>
    <link href="http://codemany.com/blog/sqlmap-unit-testing-with-spring-and-dbunit/"/>
    <updated>2006-04-11T20:39:04+08:00</updated>
    <id>http://codemany.com/blog/sqlmap-unit-testing-with-spring-and-dbunit</id>
    <content type="html"><![CDATA[<p>使用DbUnit，开发人员可以控制测试数据库的状态。进行一个DAO单元测试之前，DbUnit为数据库准备好初始化数据；而在测试结束时，DbUnit会把数据库状态恢复到测试前的状态。下面的例子使用DbUnit为SqlMap编写单元测试。</p>

<p>SqlMap映射文件User.xml的内容如下：</p>

<pre><code>&lt;select id="getUser" parameterClass="String" resultClass="User"&gt;
    SELECT username, password, first_name, last_name
    FROM user WHERE username = #username#
&lt;/select&gt;

&lt;delete id="removeUser" parameterClass="String"&gt;
    DELETE FROM user WHERE username = #username#
&lt;/delete&gt;

&lt;update id="updateUser" parameterClass="User"&gt;
    UPDATE user SET
        password = #password#,
        first_name = #firstName#,
        last_name = #lastName#
    WHERE username =#username#
&lt;/update&gt;

&lt;insert id="insertUser" parameterClass="User"&gt;
    INSERT INTO user (username, password, first_name, last_name)
    VALUES (#username#, #password#, #firstName#, #lastName#)
&lt;/insert&gt;
</code></pre>

<p>配置文件sql-map-config.xml中的内容如下：</p>

<pre><code>&lt;sqlMapConfig&gt;
    &lt;settings lazyLoadingEnabled="true"
              cacheModelsEnabled="true"
              enhancementEnabled="true"
              maxSessions="64"
              maxTransactions="8"
              maxRequests="128" /&gt;

    &lt;sqlMap resource="com/codemany/netlink/dao/impl/User.xml" /&gt;
&lt;/sqlMapConfig&gt;
</code></pre>

<p>首先，要为单元测试准备测试数据。我们可以用DbUnit的Flat XML格式来准备测试数据集。下面的XML文件称为目标数据库的Seed File，它为测试准备了两条数据。其中元素名user对应数据库的表名，属性username，password，first_name和last_name是表user的列名，属性值就是记录值。</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;dataset&gt;
    &lt;user username="ford"
        password="ford"
        first_name="Henry"
        last_name="Ford" /&gt;

    &lt;user username="twain"
        password="twain"
        first_name="Mark"
        last_name="twain" /&gt;
&lt;/dataset&gt;
</code></pre>

<p>缺省情况下，DbUnit在单元测试开始之前执行CLEAN_INSERT操作，删除Seed File中所有表的数据，并导入Seed File的测试数据。我们可以通过覆盖getSetUpOperation()和getTearDownOperation()方法来控制单元测试前和测试后的数据库状态。一种高效的实施方案就是让getSetUpOperation()方法执行REFRESH操作，通过执行这个操作，我们可以用Seed File中的数据去更新目标数据库里的数据。接下来，就是getTearDownOperation()，让他执行一个NONE操作，也就是什么也不执行。</p>

<pre><code>protected DatabaseOperation getSetUpOperation() throws Exception {
    return DatabaseOperation.REFRESH;
}

protected DatabaseOperation getTearDownOperation() throws Exception {
    return DatabaseOperation.NONE;
}
</code></pre>

<p>为了方便测试，我们为SqlMap的单元测试编写一个抽象的测试基类，代码如下：</p>

<pre><code>public abstract class SqlMapTestCase extends DatabaseTestCase {
    protected SqlMapClient sqlMapClient = null;
    protected Properties props = new Properties();

    protected IDatabaseConnection getConnection() throws Exception {
        props.load(Resources.getResourceAsStream("properties/database.properties"));

        Class.forName(props.getProperty("driver"));
        Connection conn = DriverManager.getConnection(props.getProperty("url"),
                props.getProperty("username"), props.getProperty("password"));
        return new DatabaseConnection(conn);
    }

    protected IDataSet getDataSet() throws Exception {
        String resource = "com/codemany/netlink/dao/impl/dataset.xml";
        return new FlatXmlDataSet(Resources.getResourceAsStream(resource));
    }

    protected void setUp() throws Exception {
        super.setUp();

        // Build the SqlMapClient
        Reader reader = Resources.getResourceAsReader("sql-map-config.xml");
        sqlMapClient = SqlMapClientBuilder.buildSqlMapClient(reader);

        // Tell the SqlMapClient to use the given DataSource
        DataSource dataSource = getDataSource();
        TransactionConfig transactionConfig = getTransactionConfig(dataSource);
        // Apply the given TransactionConfig to the SqlMapClient
        applyTransactionConfig(sqlMapClient, transactionConfig);
    }

    protected void tearDown() throws Exception {
        super.tearDown();

        if (sqlMapClient != null) {
            DataSource ds = sqlMapClient.getDataSource();
            Connection conn = ds.getConnection();
            conn.close();
        }
    }

    private DataSource getDataSource() throws Exception {
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName(props.getProperty("driver"));
        dataSource.setUrl(props.getProperty("url"));
        dataSource.setUsername(props.getProperty("username"));
        dataSource.setPassword(props.getProperty("password"));
        return dataSource;
    }

    private TransactionConfig getTransactionConfig(DataSource dataSource) throws Exception {
        Properties transactionConfigProperties = new Properties();
        transactionConfigProperties.setProperty("SetAutoCommitAllowed", "false");

        TransactionConfig transactionConfig = (TransactionConfig)ExternalTransactionConfig.class.newInstance();
        transactionConfig.setDataSource(dataSource);
        transactionConfig.initialize(transactionConfigProperties);
        return transactionConfig;
    }

    private void applyTransactionConfig(SqlMapClient sqlMapClient, TransactionConfig transactionConfig) {
        if (!(sqlMapClient instanceof ExtendedSqlMapClient)) {
            throw new IllegalArgumentException("Cannot set TransactionConfig with DataSource"
                    + "for SqlMapClient if not of type ExtendedSqlMapClient: " + sqlMapClient);
        }
        ExtendedSqlMapClient extendedClient = (ExtendedSqlMapClient)sqlMapClient;
        transactionConfig.setMaximumConcurrentTransactions(extendedClient.getDelegate().getMaxTransactions());
        extendedClient.getDelegate().setTxManager(new TransactionManager(transactionConfig));
    }
}
</code></pre>

<p>然后为每个SqlMap映射文件编写一个测试类，继承上面的抽象类：</p>

<pre><code>public class UserSqlMapTest extends SqlMapTestCase {

    public void testGetUser() throws Exception {
        User user = (User)sqlMapClient.queryForObject("getUser", "ford");
        assertNotNull(user);
        assertEquals("ford", user.getName());
    }
}
</code></pre>

<p>如此就可以进行单元测试了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一步一步整合WebWork和Spring]]></title>
    <link href="http://codemany.com/blog/webwork-and-spring-integration-step-by-step/"/>
    <updated>2005-09-26T10:50:27+08:00</updated>
    <id>http://codemany.com/blog/webwork-and-spring-integration-step-by-step</id>
    <content type="html"><![CDATA[<p>拷贝webwork-2.1.7.jar、spring-1.2.1.jar以及webwork2-srping.jar到WEB-INF/lib目录下。</p>

<p>添加以下内容到web.xml文件中：</p>

<pre><code>&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;

&lt;listener&gt;
    &lt;listener-class&gt;com.atlassian.xwork.ext.ResolverSetupServletContextListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>

<p>applicationContext.xml中的内容如下：</p>

<pre><code>&lt;beans&gt;
    &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.SingleConnectionDataSource"&gt;
        &lt;property name="driverClassName" value="${driver}" /&gt;
        &lt;property name="url" value="${url}" /&gt;
        &lt;property name="username" value="${username}" /&gt;
        &lt;property name="password" value="${password}" /&gt;
    &lt;/bean&gt;

    &lt;bean id="sqlMapClient" class="org.springframework.orm.ibatis.SqlMapClientFactoryBean"&gt;
        &lt;property name="configLocation" value="/WEB-INF/sql-map-config.xml" /&gt;
        &lt;property name="dataSource" ref="dataSource" /&gt;
    &lt;/bean&gt;

    &lt;bean id="userManager" class="com.codemany.netlink.service.impl.UserManagerImpl" singleton="true"&gt;
        &lt;property name="sqlMapClient" ref="sqlMapClient" /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>

<p>配置文件sql-map-config.xml中的内容如下：</p>

<pre><code>&lt;sqlMapConfig&gt;
    &lt;sqlMap resource="com/codemany/netlink/dao/impl/User.xml" /&gt;
&lt;/sqlMapConfig&gt;
</code></pre>

<p>在xwork.xml中添加以下内容：</p>

<pre><code>&lt;package name="default" extends="webwork-default"
        externalReferenceResolver="com.atlassian.xwork.ext.SpringServletContextReferenceResolver"&gt;

    &lt;interceptors&gt;
        &lt;interceptor name="reference-resolver"
                class="com.opensymphony.xwork.interceptor.ExternalReferencesInterceptor" /&gt;

        &lt;interceptor-stack name="interceptors"&gt;
            &lt;interceptor-ref name="params" /&gt;
            &lt;interceptor-ref name="reference-resolver" /&gt;
        &lt;/interceptor-stack&gt;
    &lt;/interceptors&gt;

    &lt;default-interceptor-ref name="default-interceptor" /&gt;

    &lt;action name="login" class="com.codemany.netlink.action.LoginAction"&gt;
        &lt;external-ref name="userManager"&gt;userManager&lt;/external-ref&gt;
        &lt;result name="success" type="dispatcher"&gt;/success.jsp&lt;/result&gt;
        &lt;result name="error" type="dispatcher"&gt;/error.jsp&lt;/result&gt;
    &lt;/action&gt;
&lt;/package&gt;
</code></pre>

<p>在LoginAction.java中添加代码：</p>

<pre><code>private UserManager userManager = null;

public void setUserManager(UserManager userManager) {
    this.userManager = userManager;
</code></pre>

<p>建立UserManager.java接口文件：</p>

<pre><code>public interface UserManager {
    public User login(String username, String password) throws UserLoginException;
}
</code></pre>

<p>UserManagerImpl.java实现代码：</p>

<pre><code>public class UserManagerImpl extends SqlMapClientDaoSupport implements UserManager {

    public User login(String username, String password) throws UserLoginException {
        // do something
    }
}
</code></pre>
]]></content>
  </entry>
  
</feed>
