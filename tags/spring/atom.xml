<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Spring | 乐者为王]]></title>
  <link href="http://codemany.com/tags/spring/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2014-09-15T15:50:49+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Struts 2 + Spring 3 + Hibernate 4登录实例]]></title>
    <link href="http://codemany.com/blog/2012/09/04/struts2-spring3-hibernate4-login-sample/"/>
    <updated>2012-09-04T06:54:27+08:00</updated>
    <id>http://codemany.com/blog/2012/09/04/struts2-spring3-hibernate4-login-sample</id>
    <content type="html"><![CDATA[<p>在pom.xml中添加Spring的依赖包：</p>

<p>```
<dependency></p>

<pre><code>&lt;groupId&gt;org.springframework&lt;/groupId&gt;
&lt;artifactId&gt;spring-orm&lt;/artifactId&gt;
&lt;version&gt;3.1.2.RELEASE&lt;/version&gt;
</code></pre>

<p></dependency>
<dependency></p>

<pre><code>&lt;groupId&gt;org.springframework&lt;/groupId&gt;
&lt;artifactId&gt;spring-web&lt;/artifactId&gt;
&lt;version&gt;3.1.2.RELEASE&lt;/version&gt;
</code></pre>

<p></dependency></p>

<!-- 注意：没有这个plugin包会导致Spring无法注入bean到Struts 2的Action中 -->


<p><dependency></p>

<pre><code>&lt;groupId&gt;org.apache.struts&lt;/groupId&gt;
&lt;artifactId&gt;struts2-spring-plugin&lt;/artifactId&gt;
&lt;version&gt;2.3.4.1&lt;/version&gt;
</code></pre>

<p></dependency>
```</p>

<p>配置web.xml文件，加上Spring的监听器：</p>

<p>```
&lt;context-param></p>

<pre><code>&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
&lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
</code></pre>

<p>&lt;/context-param></p>

<p><listener></p>

<pre><code>&lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
</code></pre>

<p></listener>
```</p>

<p>删除hibernate.cfg.xml，添加applicationContext.xml，内容为：</p>

<p>```
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;beans xmlns="<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a>"</p>

<pre><code>xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

&lt;!-- DriverManagerDataSource在每个连接请求时都新建一个connection。
     与DBCP的BasicDataSource不同，DriverManagerDataSource提供的连接没有进行池管理 --&gt;
&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;
    &lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt;
    &lt;property name="url" value="jdbc:mysql://localhost:3306/jbookshelf" /&gt;
    &lt;property name="username" value="root" /&gt;
    &lt;property name="password" value="123456" /&gt;
&lt;/bean&gt;

&lt;bean id="sessionFactory" class="org.springframework.orm.hibernate4.LocalSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="dataSource" /&gt;
    &lt;property name="hibernateProperties"&gt;
        &lt;props&gt;
            &lt;prop key="hibernate.connection.pool_size"&gt;1&lt;/prop&gt;
            &lt;prop key="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/prop&gt;
            &lt;prop key="hibernate.cache.provider_class"&gt;org.hibernate.cache.internal.NoCacheProvider&lt;/prop&gt;
            &lt;prop key="show_sql"&gt;true&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
    &lt;property name="mappingResources"&gt;
        &lt;list&gt;
            &lt;value&gt;com/codemany/account/model/User.hbm.xml&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="userDao" class="com.codemany.account.dao.UserDao"&gt;
    &lt;property name="sessionFactory" ref="sessionFactory" /&gt;
&lt;/bean&gt;

&lt;!-- Struts 2的action是有状态的，必须显式设置scope为prototype，这样每次请求过来都会创建新的action --&gt;
&lt;bean id="loginAction" class="com.codemany.account.action.LoginAction" scope="prototype"&gt;
    &lt;property name="userDao" ref="userDao" /&gt;
&lt;/bean&gt;
</code></pre>

<p></beans>
```</p>

<p>删除HibernateUtil.java，修改UserDao.java为以下内容：</p>

<p>```
package com.codemany.account.dao;</p>

<p>import org.hibernate.Query;
import org.hibernate.Session;
import org.hibernate.SessionFactory;</p>

<p>import com.codemany.account.model.User;</p>

<p>public class UserDao {</p>

<pre><code>// Spring 3集成Hibernate 4不再需要HibernateDaoSupport或HibernateTemplate了，
// 直接使用原生API即可。
private SessionFactory sessionFactory;

public void setSessionFactory(SessionFactory sessionFactory) {
    this.sessionFactory = sessionFactory;
}

public User getUser(String username) {
    Session session = sessionFactory.openSession();
    try {
        Query query = session.createQuery("from User u where u.username = ?");
        query.setString(0, username);
        query.setMaxResults(1);
        return (User)query.uniqueResult();
    } finally {
        session.close();
    }
}
</code></pre>

<p>}
```</p>

<p>在struts.xml中将action元素中login的class属性改为applicationContext.xml配置文件中的loginAction：</p>

<p>```
<action name="login" class="loginAction"></p>

<pre><code>&lt;result name="success"&gt;/index.jsp&lt;/result&gt;
&lt;result name="input"&gt;/index.jsp&lt;/result&gt;
</code></pre>

<p></action>
```</p>

<p>修改LoginAction.java的代码：</p>

<p>```
package com.codemany.account.action;</p>

<p>import com.codemany.account.dao.UserDao;
import com.codemany.account.model.User;</p>

<p>import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionSupport;</p>

<p>public class LoginAction extends ActionSupport {</p>

<pre><code>private static final long serialVersionUID = -389833745243649130L;

private String username;
private String password;

private UserDao userDao;

public String execute() throws Exception {
    if (username == null || username.length() == 0
            || password == null || password.length() == 0) {
        return INPUT;
    }

    User u = userDao.getUser(username);
    if (u == null || !password.equals(u.getPassword())) {
        return INPUT;
    }

    ActionContext.getContext().getSession().put("logined", true);
    return SUCCESS;
}

public void setUsername(String username) {
    this.username = username;
}

public void setPassword(String password) {
    this.password = password;
}

public void setUserDao(UserDao userDao) {
    this.userDao = userDao;
}
</code></pre>

<p>}
```</p>

<p>代码下载：<a href="https://github.com/dohkoos/JBookShelf">https://github.com/dohkoos/JBookShelf</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JPA + Spring 2入门]]></title>
    <link href="http://codemany.com/blog/2007/08/10/getting-started-jpa-with-spring2/"/>
    <updated>2007-08-10T18:33:42+08:00</updated>
    <id>http://codemany.com/blog/2007/08/10/getting-started-jpa-with-spring2</id>
    <content type="html"><![CDATA[<p>一、配置JPA</p>

<p>Spring提供了两种方法创建JPA的EntityManagerFactory对象。</p>

<p>方法一：</p>

<p>```
<beans></p>

<pre><code>&lt;bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalEntityManagerFactoryBean"&gt;
    &lt;property name="persistenceUnitName" value="myPersistenceUnit" /&gt;
&lt;/bean&gt;
</code></pre>

<p></beans>
```</p>

<p>FactoryBean创建的EntityManagerFactory适用于仅通过JPA进行数据访问的环境。由于使用了PersistenceProvider自动侦测机制，所以只能从默认路径classpath:META-INF/persistence.xml中读取配置信息。</p>

<p>方法二：</p>

<p>```
<beans></p>

<pre><code>&lt;bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
    &lt;property name="dataSource" ref="someDataSource" /&gt;
    &lt;property name="loadTimeWeaver"&gt;
        &lt;bean class="org.springframework.instrument.classloading.SimpleLoadTimeWeaver" /&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>

<p></beans>
```</p>

<p>FactoryBean提供了对JPA EntityManagerFactory的完整控制，非常适合那种有简单定制需要的环境。你可以处理多个persistence.xml配置文件；覆盖persistence.xml文件的默认路径；可以传递Spring托管的JDBC DataSource给JPA PersistenceProvider，用来替代persistence.xml中的JDBC配置（这个Spring托管的DataSource通常被作为nonJtaDataSource传送给PersistenceProvider，并且覆盖persistence.xml中相同的nonJtaDataSource）。</p>

<p>二、数据访问</p>

<p>基于JPA的DAO可以通过三种方式进行数据访问JpaDaoSupport，JpaTemplate和plain JPA。其中JpaTemplate是plain JPA的封装，而JpaDaoSupport又是JpaTemplate的封装。无疑，使用不对Spring产生任何依赖的Plain JPA的API进行编程是最好选择。</p>

<p>```
public class ProductDaoImpl implements ProductDao {</p>

<pre><code>private EntityManager entityManager = null;

@PersistenceContext
public void setEntityManager(EntityManager entityManager) {
    this.entityManager = entityManager;
}

public Collection loadProductsByCategory(String category) {
     Query query = em.createQuery("from Product as p where p.category = :category");
     query.setParameter("category", category);
     return query.getResultList();
}
</code></pre>

<p>}
```</p>

<p>注意，必须激活PersistenceAnnotationBeanPostProcessor功能才能让Spring识别@PersistenceContext注解。</p>

<p>```
<beans></p>

<pre><code>&lt;!-- JPA annotations bean post processor --&gt;
&lt;bean class="org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor" /&gt;

&lt;bean id="myProductDao" class="product.ProductDaoImpl" /&gt;
</code></pre>

<p></beans>
```</p>

<p>三、异常转化</p>

<p>Spring提供了一个允许通过使用@Repository注解进行透明的异常转化的解决方案。</p>

<p>```
@Repository
public class ProductDaoImpl implements ProductDao {</p>

<pre><code>...
</code></pre>

<p>}</p>

<p><beans></p>

<pre><code>&lt;!-- Exception translation bean post processor --&gt;
&lt;bean class="org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor" /&gt;

&lt;bean id="myProductDao" class="product.ProductDaoImpl" /&gt;
</code></pre>

<p></beans>
```</p>

<p>后置处理器将自动的寻找所有的异常转化器（PersistenceExceptionTranslator这个接口的实现类）并通知所有打上@Repository注解的bean，从而能够使得被找到的异常转化器能够在抛出异常时做相应的异常转化工作。</p>

<p>总结来说：DAO能够基于普通的Java持久层API和注解来实现，但同样也能享受到由Spring管理事务、IoC和透明的异常转化（转化成为Spring的异常体系）等好处。</p>
]]></content>
  </entry>
  
</feed>
