<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Architecture | 乐者为王]]></title>
  <link href="http://codemany.com/tags/architecture/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2016-05-15T09:22:37+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[贫血领域模型]]></title>
    <link href="http://codemany.com/blog/anemic-domain-model/"/>
    <updated>2005-05-12T08:33:42+08:00</updated>
    <id>http://codemany.com/blog/anemic-domain-model</id>
    <content type="html"><![CDATA[<p>英文原文：<a href="http://martinfowler.com/bliki/AnemicDomainModel.html">http://martinfowler.com/bliki/AnemicDomainModel.html</a></p>

<p>贫血领域模型是那些已近存在了相当长时间的反模式中的一份子，而且看起来现在势头正旺。我和Eric Evans聊过这个，并且我们都注意到它们似乎越来越流行。作为真正的<a href="http://martinfowler.com/eaaCatalog/domainModel.html">领域模型</a>支持者，这不是一件好事。</p>

<p>贫血领域模型的基本症状是乍一看它就像真的领域模型一样。这些对象大多以领域空间中的名词命名，并且这些对象被真正的领域模型拥有的丰富的关系和结构连接。当你观察行为时问题就来了，你意识到这些对象几乎没有任何行为，仅仅只是封装了getter和setter方法。确实，这些模型规则经常说不要把任何领域逻辑放到领域对象里。取而代之的是一组服务对象捕获了所有的领域逻辑。这些在领域对象上层的服务把领域对象当数据使用。</p>

<p>这种反模式最根本的恐怖在于它和面向对象设计的基本理念完全相反，它只是把数据和处理合在一起。贫血领域模型其实只是一种过程式风格的设计，正是那种像我（和Eric）自Smalltalk早期以来一直在与之作斗争的顽固者。更糟糕的是，许多人认为贫血对象是真正的对象，因此完全抓不住面向对象设计是怎么回事的要点。</p>

<p>Now object-oriented purism is all very well, but I realize that I need more fundamental arguments against this anemia. In essence the problem with anemic domain models is that they incur all of the costs of a domain model, without yielding any of the benefits. The primary cost is the awkwardness of mapping to a database, which typically results in a whole layer of O/R mapping. This is worthwhile iff you use the powerful OO techniques to organize complex logic. By pulling all the behavior out into services, however, you essentially end up with <a href="http://martinfowler.com/eaaCatalog/transactionScript.html">Transaction Scripts</a>, and thus lose the advantages that the domain model can bring. As I discussed in <a href="http://martinfowler.com/books/eaa.html">P of EAA</a>, Domain Models aren&#39;t always the best tool.</p>

<p>It&#39;s also worth emphasizing that putting behavior into the domain objects should not contradict the solid approach of using layering to separate domain logic from such things as persistence and presentation responsibilities. The logic that should be in a domain object is domain logic - validations, calculations, business rules - whatever you like to call it. (There are cases when you make an argument for putting data source or presentation logic in a domain object, but that&#39;s orthogonal to my view of anemia.)</p>

<p>One source of confusion in all this is that many OO experts do recommend putting a layer of procedural services on top of a domain model, to form a <a href="http://martinfowler.com/eaaCatalog/serviceLayer.html">Service Layer</a>. But this isn&#39;t an argument to make the domain model void of behavior, indeed service layer advocates use a service layer in conjunction with a behaviorally rich domain model.</p>

<p>Eric Evans&#39;s excellent book <a href="http://domaindrivendesign.org/books/">Domain Driven Design</a> has the following to say about these layers.</p>

<blockquote>
<p>Application Layer [his name for Service Layer]: Defines the jobs the software is supposed to do and directs the expressive domain objects to work out problems. The tasks this layer is responsible for are meaningful to the business or necessary for interaction with the application layers of other systems. This layer is kept thin. It does not contain business rules or knowledge, but only coordinates tasks and delegates work to collaborations of domain objects in the next layer down. It does not have state reflecting the business situation, but it can have state that reflects the progress of a task for the user or the program.</p>

<p>Domain Layer (or Model Layer): Responsible for representing concepts of the business, information about the business situation, and business rules. State that reflects the business situation is controlled and used here, even though the technical details of storing it are delegated to the infrastructure. This layer is the heart of business software.</p>
</blockquote>

<p>The key point here is that the Service Layer is thin - all the key logic lies in the domain layer. He reiterates this point in his service pattern:</p>

<blockquote>
<p>Now, the more common mistake is to give up too easily on fitting the behavior into an appropriate object, gradually slipping toward procedural programming.</p>
</blockquote>

<p>I don&#39;t know why this anti-pattern is so common. I suspect it&#39;s due to many people who haven&#39;t really worked with a proper domain model, particularly if they come from a data background. Some technologies encourage it; such as J2EE&#39;s Entity Beans which is one of the reasons I prefer <a href="http://martinfowler.com/bliki/POJO.html">POJO</a> domain models.</p>

<p>In general, the more behavior you find in the services, the more likely you are to be robbing yourself of the benefits of a domain model. If all your logic is in services, you&#39;ve robbed yourself blind.</p>
]]></content>
  </entry>
  
</feed>
