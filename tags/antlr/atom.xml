<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: ANTLR | 乐者为王]]></title>
  <link href="http://codemany.com/tags/antlr/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2016-06-20T16:02:45+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（11）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part11/"/>
    <updated>2016-04-18T18:13:27+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part11</id>
    <content type="html"><![CDATA[]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（10）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part10/"/>
    <updated>2016-04-08T22:11:39+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part10</id>
    <content type="html"><![CDATA[]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（9）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part9/"/>
    <updated>2016-03-27T07:10:05+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part9</id>
    <content type="html"><![CDATA[]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（8）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part8/"/>
    <updated>2016-03-20T09:57:45+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part8</id>
    <content type="html"><![CDATA[<ul>
<li>syntax analyzer 语法分析器</li>
<li>syntax tree 语法树</li>
</ul>

<p>一门语言由有效的句子组成，一个句子由短语组成，一个短语由子短语和词汇符号组成。要实现一门语言，我们必须构建一个能读取句子以及对发现的短语和输入符号作出适当反应的应用。</p>

<p>这样的应用必须能识别特定语言的所有有效的句子、短语和子短语。识别一个短语意味着我们能确定短语的各种组件并能指出它与其它短语的区别。例如，我们把输入a=5识别为赋值语句，这就意味着我们知道a是赋值目标以及5是要存储的值。识别赋值语句a=5也意味着应用认为它是明显不同于，比如说，a+b语句的。在识别后，应用将执行适当的操作，例如performAssignment(&quot;a&quot;, 5)或者translateAssignment(&quot;a&quot;, 5)。</p>

<p>识别语言的程序被称为语法分析器。语法指代控制语言成员的规则，每条规则都表示一个短语的结构。为了更容易地实现识别语言的程序，通常我们会把识别语言的语法分析拆解成两个相似但不同的任务或阶段。</p>

<p>把字符组成单词或符号（记号）的过程被称为词法分析或简单标记化。我们把标记输入的程序称为词法分析器。词法分析器能把相关的记号组成记号类型，例如INT（整数）、ID（标志符）、FLOAT（浮点数）等。当语法分析器只关心类型的时候，词法分析器会把词汇符号组成类型，而不是单独的符号。记号至少包含两块信息：记号类型（确定词法结构）和匹配记号的文本。</p>

<p>第二阶段是真正的语法分析器，它使用这些记号去识别句子结构，在本例中是赋值语句。默认情况下，ANTLR生成的语法分析器会构建一个称为语法分析树或语法树的数据结构，它记录语法分析器如何识别输入句子的结构和它的组件短语。下图阐明了语言识别器的基本数据流：</p>

<p><img src="/uploads/basic-data-flow.png" title="basic-data-flow" ></p>

<p>语法分析树的内部节点是分组和确认它们子节点的短语名字。根节点是最抽象的短语名字，在本例中是prog（“program”的缩写）。语法分析树的叶子节点永远是输入记号。</p>

<p>通过生成语法分析树，语法分析器给应用的其余部分提供了方便的数据结构，它们含有关于语法分析器如何把符号组成短语的完整信息。树是非常容易处理的，并且也能被程序员很好的理解。更好的是，语法分析器能自动地生成语法分析树。</p>

<p>通过操作语法分析树，需要识别相同语言的多个应用能重用同一个语法分析器。当然，你也可以选择直接在语法中嵌入特定应用的代码片段，这是语法分析器生成器传统的做法。ANTLR v4仍然允许这样做，但是语法分析树有助于更简洁更解耦的设计。</p>

<p>语法分析树对于需要多次树遍历的转换也是非常有用的，因为在计算依赖关系的阶段通常会需要前一个阶段的信息。相比于在每个阶段都要准备输入字符，我们只需要遍历语法分析树多次，更具有效率。</p>

<p>因为我们用一套规则指定短语，语法分析树子树根节点对应于语法规则名。这里的语法规则对应于上图中assign子树的第一层：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">assign : ID &#39;=&#39; expr ;    // 匹配赋值语句像&quot;a=5&quot;
</code></pre></div>
<p>明白ANTLR如何把这些规则转换为人类可读的语法分析代码是使用和调试语法的基础，因此让我们深入地挖掘语法分析是如何工作的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（7）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part7/"/>
    <updated>2016-03-11T16:42:08+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part7</id>
    <content type="html"><![CDATA[<ul>
<li>sequence 序列</li>
</ul>

<p>在<a href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part6/">ANTLR 4权威参考读书笔记（6）</a>中的这些操作仅仅是提取和打印被语法分析器匹配的值，它们并没有改变语法分析器本身。</p>

<p>实际上，操作还可以影响语法分析器如何识别输入短语。这类特殊的操作被称为语义谓词。下面我们会用一个简单的例子来展示语义谓词的强大能力：动态地打开和关闭语法的某个部分。</p>

<h3 id="使用语义谓词改变语法分析">使用语义谓词改变语法分析</h3>

<p>有一个读入整数序列的语法，它的玄机是由输入的部分指定有多少个整数组合在一起，所以我们必须等到运行时才能知道有多少整数被匹配。这里是示例输入文件idata.txt的内容：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">2 9 10 3 1 2 3
</code></pre></div>
<p>第1个数字表示匹配后续两个数字9和10；紧跟10的数字3表示匹配接下来的三个数字。我们的目的是设计一个语法IData.g，把9和10组合在一起，把1、2和3组合在一起。在语法上执行以下命令后显示的语法分析树能够清楚地标识出整数的分组，就像下图显示的那样：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr -no-listener IData.g
compile *.java
grun IData file -gui idata.txt
</code></pre></div>
<p><img src="/uploads/idata-parse-tree.png" title="idata-parse-tree" ></p>

<p>要达成这个目标，以下语法中的关键是一个被称为语义谓词的布尔值操作：{$i &lt; $n}?。当谓词计算结果为true时，语法分析器匹配整数直到超过序列规则参数n要求的数量；当计算结果为false时，谓词让相关的选项从生成的语法分析器中“消失”。
在这个案例中，值为false的谓词让(...)*循环从规则序列里终止并返回。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grammar IData;

file : group+ ;

group: INT sequence[$INT.int] ;

sequence[int n]
locals [int i = 1;]
     : ( {$i&lt;=$n}? INT {$i++;} )*  // match n integers
     ;

INT  : [0-9]+ ;  // match integers
WS   : [ \t\n\r]+ -&gt; skip ;  // toss out all whitespace
</code></pre></div>
<p>被语法分析器使用的规则序列的内部语法表示看起来就像下图这样：</p>

<p><img src="/uploads/idata-rule-sequence.png" title="idata-rule-sequence" ></p>

<p>虚线表明谓词可以剪断那条路径，只给语法分析器留下一个选择：退出的路径。</p>

<p>虽然大部分时间我们不需要这样的微管理，但它至少让我们知道我们有这样的武器可以处理病理分析问题。</p>
]]></content>
  </entry>
  
</feed>
