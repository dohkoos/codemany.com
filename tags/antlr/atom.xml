<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: ANTLR | 乐者为王]]></title>
  <link href="http://codemany.com/tags/antlr/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2017-01-05T17:47:44+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（23）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part23/"/>
    <updated>2016-08-16T18:09:05+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part23</id>
    <content type="html"><![CDATA[<p>默认情况下，ANTLR为每个规则生成一个单一的事件类型，而不管语法分析器匹配了哪个选项。这很不方便，因为监听器和访问者方法必须确定哪个选项被语法分析器匹配。在本节中，我们将看到如何得到更细粒度的事件。</p>

<h3 id="为规则选项贴标签以得到精确的事件方法">为规则选项贴标签以得到精确的事件方法</h3>

<p>为阐明事件粒度问题，让我们为以下的表达式语法构建一个带有监听器的简单计算器：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grammar Expr;
s : e ;
e : e op=MULT e    // MULT is &#39;*&#39;
  | e op=ADD e     // ADD is &#39;+&#39;
  | INT
  ;
</code></pre></div>
<p>按照上面的语法，规则e会产生一个相当无用的监听器，因为规则e的所有选项导致树遍历器触发相同的enterE()和exitE()方法。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public interface ExprListener extends ParseTreeListener {
    void enterE(ExprParser.EContext ctx);
    void exitE(ExprParser.EContext ctx);
</code></pre></div>
<p>监听器方法必须使用op记号标签和ctx的方法进行测试以查看语法分析器为每个e子树匹配了哪个选项。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitE(ExprParser.EContext ctx) {
    if (ctx.getChildCount() == 3) {    // operations have 3 children
        int left = values.get(ctx.e(0));
        int right = values.get(ctx.e(1));
        if (ctx.op.getType() == ExprParser.MULT) {
            values.put(ctx, left * right);
        } else {
            values.put(ctx, left + right);
        }
    } else {
        values.put(ctx, values.get(ctx.getChild(0)));    // an INT
    }
}
</code></pre></div>
<p>在exitE()中引用的MULT字段是在ExprParser中由ANTLR自动生成的：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class ExprParser extends Parser {
    public static final int MULT=1, ADD=2, INT=3, WS=4;
</code></pre></div>
<p>如果我们查看在类ExprParser中的类EContext，我们可以看到ANTLR把来自3个选项的所有元素都塞进了相同的上下文对象。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public static class EContext extends ParserRuleContext {
    public Token op;                     // derived from label op
    public List&lt;EContext&gt; e() { ... }    // get all e subtrees
    public EContext e(int i) { ... }     // get ith e subtree
    public TerminalNode INT() { ... }    // get INT node if alt 3 of e
</code></pre></div>
<p>为得到更精确的监听器事件，ANTLR让我们使用#运算符给任何规则最外层的选项打标签。让我们从Expr派生语法LExpr，并给e的选项打上标签，以下是修改后的e规则：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">e : e MULT e  # Mult
  | e ADD e   # Add
  | INT       # Int
  ;
</code></pre></div>
<p>现在，ANTLR为e的每个选项生成了单独的监听器方法，因此，我们不再需要op记号标签。对于选项标签X，ANTLR生成方法enterX()和exitX()。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public interface LExprListener extends ParseTreeListener {
    void enterMult(LExprParser.MultContext ctx);
    void exitMult(LExprParser.MultContext ctx);
    void enterAdd(LExprParser.AddContext ctx);
    void exitAdd(LExprParser.AddContext ctx);
    void enterInt(LExprParser.IntContext ctx);
    void exitInt(LExprParser.IntContext ctx);
    ...
}
</code></pre></div>
<p>注意，ANTLR也为选项生成特定的以标签命名的上下文对象（EContext的子类）。专门的上下文对象的getter方法只限于应用在那些相关的选项。例如，IntContext只有一个INT()方法，我们可以在enterInt()中调用ctx.INT()，但在enterAdd()中就不能。</p>

<p>监听器和访问者是极好的。我们只需要通过充实事件方法就可以得到可复用和可重定目标的语法以及封装的语言应用。ANTLR甚至会为我们自动生成骨架代码。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（22）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part22/"/>
    <updated>2016-07-24T21:40:28+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part22</id>
    <content type="html"><![CDATA[<p>基于监听器的方法是极好的，因为所有树遍历和方法触发被自动完成。尽管有时候自动树遍历也是一个缺点，因为我们不能控制遍历本身。例如，我们可能想遍历一段C程序的语法分析树，通过跳过函数体子树忽略函数中的一切。监听器事件方法也不能使用方法返回值去传递数据。当我们需要控制遍历或返回带有事件方法返回值的值时，我们使用访问者模式。现在，让我们构建一个基于访问者版本的属性文件加载器去比较这两种方法。</p>

<h3 id="使用访问者实现应用">使用访问者实现应用</h3>

<p>使用访问者代替监听器，我们只需要让ANTLR生成访问者接口和实现接口，然后创建一段测试代码在语法分析树上调用visit()，根本不需要触及到语法。</p>

<p>在命令行使用-visitor参数时，ANTLR生成接口PropertyFileVisitor和类PropertyFileBaseVisitor，后者有如下的默认实现：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class PropertyFileBaseVisitor&lt;T&gt; extends AbstractParseTreeVisitor&lt;T&gt;
                                        implements PropertyFileVisitor&lt;T&gt; {
    @Override
    public T visitFile(PropertyFileParser.FileContext ctx) { ... }
    @Override
    public T visitProp(PropertyFileParser.PropContext ctx) { ... }
}
</code></pre></div>
<p>我们可以从监听器的exitProp()中拷贝映射功能，然后把它粘贴到与规则prop相关的访问者方法中。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class TestPropertyFileVisitor {
    public static class PropertyFileVisitor extends PropertyFileBaseVisitor&lt;Void&gt; {
        Map&lt;String,String&gt; props = new OrderedHashMap&lt;String, String&gt;();
        public Void visitProp(PropertyFileParser.PropContext ctx) {
            String id = ctx.ID().getText();    // prop : ID &#39;=&#39; STRING &#39;\n&#39; ;
            String value = ctx.STRING().getText();
            props.put(id, value);
            return null;    // Java says must return something even when Void
        }
    }
</code></pre></div>
<p>这里是访问者接口和类之间的继承关系：</p>

<p><img src="/uploads/propertyfile-visitor-hierachy.png" title="propertyfile-visitor-hierachy" ></p>

<p>访问者在子节点上通过显式地调用接口ParseTreeVisitor的visit()方法遍历语法分析树。那些方法在AbstractParseTreeVisitor中实现。在这里，为prop调用创建的节点没有子树，因此visitProp()不需要调用visit()。</p>

<p>在监听器和访问者的测试代码（例如TestPropertyFileVisitor）之间最大的不同是访问者的测试代码不需要ParseTreeWalker，它只需要让访问者去访问由语法分析器创建的树。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">PropertyFileVisitor loader = new PropertyFileVisitor();
loader.visit(tree);
System.out.println(loader.props);    // print results
</code></pre></div>
<p>以下是构建和测试序列：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr -visitor PropertyFile.g  # create visitor as well this time
compile *.java
run TestPropertyFileVisitor t.properties
</code></pre></div>
<p>这里是输出的内容：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">{user=&quot;parrt&quot;, machine=&quot;maniac&quot;}
</code></pre></div>
<p>我们可以使用监听器和访问者构建几乎任何我们想要的。一旦我们处于Java空间，就不再需要学习更多的ANTLR知识。我们只要知道语法、语法分析树、监听器和访问者事件方法之间的关系。除此之外，就是代码。在对识别中的输入短语的回答中，我们可以生成输出、收集信息、以某种方式验证短语，或者执行计算。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（21）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part21/"/>
    <updated>2016-07-14T18:38:42+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part21</id>
    <content type="html"><![CDATA[<p>前文的语法仍然存在问题，因为它限制我们只能使用Java生成语法分析器。为使语法可复用和语言无关，我们需要完全避免嵌入动作。接下来就将展示如何用监听器做到这点。</p>

<h3 id="使用语法分析树监听器实现应用">使用语法分析树监听器实现应用</h3>

<p>在构建语言应用时要避免应用和语法纠缠在一起，关键是让语法分析器生成语法分析树，然后遍历该树去触发特定的应用代码。我们可以使用我们最喜欢的技术遍历树，也可以使用ANTLR生成的树遍历机制中的一个。在本节中，我们将使用ANTLR内建的ParseTreeWalker构建一个基于监听器版本的属性文件应用。</p>

<p>让我们从属性文件语法的原始版本开始：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">file : prop+ ;
prop : ID &#39;=&#39; STRING &#39;\n&#39; ;
</code></pre></div>
<p>下面是属性示例文件t.properties的内容：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">user=&quot;parrt&quot;
machine=&quot;maniac&quot;
</code></pre></div>
<p>通过上述语法，ANTLR生成PropertyFileParser，该语法分析器会自动构建如下图所示的语法分析树：</p>

<p><img src="/uploads/propertyfile-parse-tree.png" title="propertyfile-parse-tree" ></p>

<p>有了语法分析树，我们就可以使用ParseTreeWalker去访问所有的节点，触发进入和退出方法。</p>

<p>现在来看一下ANTLR通过语法PropertyFile生成的监听器接口PropertyFileListener，当ANTLR的ParseTreeWalker发现和完成节点时，它会为每个规则子树分别触发进入和退出方法。因为在语法PropertyFile中只有两条语法规则，所以在接口中有4个方法：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public interface PropertyFileListener extends ParseTreeListener {
    void enterFile(PropertyFileParser.FileContext ctx);
    void exitFile(PropertyFileParser.FileContext ctx);
    void enterProp(PropertyFileParser.PropContext ctx);
    void exitProp(PropertyFileParser.PropContext ctx);
}
</code></pre></div>
<p>FileContext和PropContext对象是针对每条语法规则的语法分析树节点的实现，它们包含一些有用的方法。</p>

<p>为方便起见，ANTLR也会生成带有默认实现的类PropertyFileBaseListener，这些默认实现模仿在前文语法中@member区域我们手写的空白方法。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class PropertyFileBaseVisitor&lt;T&gt; extends AbstractParseTreeVisitor&lt;T&gt;
                                        implements PropertyFileVisitor&lt;T&gt; {
    @Override
    public T visitFile(PropertyFileParser.FileContext ctx) { }
    @Override
    public T visitProp(PropertyFileParser.PropContext ctx) { }
}
</code></pre></div>
<p>默认实现让我们只需要覆盖和实现那些我们关心的方法。例如，以下是属性文件加载器的一个重新实现，像前面那样它只有一个方法，但使用监听器机制：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public static class PropertyFileLoader extends PropertyFileBaseListener {
    Map&lt;String,String&gt; props = new OrderedHashMap&lt;String, String&gt;();
    public void exitProp(PropertyFileParser.PropContext ctx) {
        String id = ctx.ID().getText();    // prop : ID &#39;=&#39; STRING &#39;\n&#39; ;
        String value = ctx.STRING().getText();
        props.put(id, value);
    }
}
</code></pre></div>
<p>主要的不同是这个版本扩展了基类监听器，而不是语法分析器，监听器方法在语法分析器完成后被触发。</p>

<p>这里面有很多的接口和类，让我们看一下在这些关键元素间的继承关系。</p>

<p><img src="/uploads/propertyfile-listener-hierachy.png" title="propertyfile-listener-hierachy" ></p>

<p>处于ANTLR运行库中的接口ParseTreeListener要求每个监听器对事件visitTerminal()、enterEveryRule()和exitEveryRule()作出反应，如果有语法错误的还要加上visitErrorNode()。ANTLR从语法文件PropertyFile生成接口PropertyFileListener，并且为类PropertyFileBaseListener的所有方法生成默认实现。我们仅需要构建PropertyFileLoader，它继承了PropertyFileBaseListener中的所有空方法。</p>

<p>方法exitProp()可以访问与规则prop相关的规则上下文对象PropContext，该上下文对象持有在规则prop中提到的每个元素（ID和STRING）的对应方法。因为这些元素是语法中的记号引用，所以方法返回语法分析树节点TerminalNode。我们既可以通过getText()直接访问记号的文本，也可以通过getSymbol()首先获取Token。</p>

<p>现在让我们创建测试文件TestPropertyFile.java遍历树，倾听来自PropertyFileLoader的声音：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">// create a standard ANTLR parse tree walker
ParseTreeWalker walker = new ParseTreeWalker();
// create listener then feed to walker
PropertyFileLoader loader = new PropertyFileLoader();
walker.walk(loader, tree);    // walk parse tree
System.out.println(loader.props);    // print results
</code></pre></div>
<p>然后就是编译和生成代码，运行测试程序去处理输入文件：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr PropertyFile.g
compile *.java
run TestPropertyFile t.properties
</code></pre></div>
<p>这里是输出的内容：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">{user=&quot;parrt&quot;, machine=&quot;maniac&quot;}
</code></pre></div>
<p>测试程序成功地把文件中的属性赋值重组成内存中的映射数据结构。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（20）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part20/"/>
    <updated>2016-07-03T18:37:26+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part20</id>
    <content type="html"><![CDATA[<p>单独的语法不是很有用，因为相关的语法分析器只能告诉我们某个输入句子是否遵守语言规格。为构建语言应用，我们需要语法分析器在看到特定的输入句子、短语或者记号时触发特定的动作。这些短语-动作对的集合表示语言应用或者至少是在语法和一个更大的周边应用之间的接口。</p>

<p>我们可以使用语法分析树监听器和访问者构建语言应用。监听器是一个响应规则进入和退出事件的对象，这些短语识别事件在语法分析树遍历器发现和完成节点时触发。为了支持应用必须控制树是如何被遍历的这种情况，ANTLR生成的语法分析树也支持著名的树访问者模式。</p>

<p>监听器和访问者之间最大的不同是，监听器方法不对显式地调用方法去遍历它们的子树负责，而访问者必须显式地触发访问子节点以保持树的遍历继续。通过这些显式的访问子树的调用，访问者控制遍历的顺序以及多少树被访问。为方便起见，我们使用术语“事件方法”来指代监听器回调或者访问者方法。</p>

<p>为了确切地知道ANTLR为我们构建了什么样的树遍历设施以及为什么，让我们首先看看监听器机制的起源以及如何使用监听器和访问者把特定应用的代码和语法分离。</p>

<h3 id="从嵌入动作演化到监听器">从嵌入动作演化到监听器</h3>

<p>监听器和访问者机制将语法从应用代码中解耦，提供了一些令人信服的好处。这种解耦很好地封装了应用程序，而不是把它切割成碎片分散到语法中的各个地方。没有嵌入动作，我们可以在不同的应用中复用相同的语法，甚至不需要重新编译生成的语法分析器。如果没有嵌入动作，ANTLR还可以用相同的语法生成不同编程语言的语法分析器。集成语法缺陷修复或更新也更容易，因为我们不必担心嵌入动作导致的合并冲突。</p>

<p>接下来，我们将探讨从带有嵌入动作的语法到完全解耦的语法和应用的演化。以下含有用«...»描述的嵌入动作的属性文件语法读取属性文件，每行一个属性赋值。像«start file»这样的动作只是Java代码适当的替代。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grammar PropertyFile;
file : {«start file»} prop+ {«finish file»} ;
prop : ID &#39;=&#39; STRING &#39;\n&#39; {«process property»} ;
ID   : [a-z]+ ;
STRING : &#39;&quot;&#39; .*? &#39;&quot;&#39; ;
</code></pre></div>
<p>这样的紧密耦合把语法束缚到一个特定的应用上。一个更好的方法是创建由ANTLR生成的语法分析器PropertyFileParser的子类，然后把嵌入动作转换成方法。重构仅留下不重要的方法调用在语法中触发新创建方法的动作，然后，通过子类化语法分析器，我们可以实现任意数量的不同应用而无需修改语法。这样的重构看起来像：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grammar PropertyFile;
@members {
    void startFile() { }    // blank implementations
    void finishFile() { }
    void defineProperty(Token name, Token value) { }
}

file : {startFile();} prop+ {finishFile();} ;
prop : ID &#39;=&#39; STRING &#39;\n&#39; {defineProperty($ID, $STRING)} ;
ID   : [a-z]+ ;
STRING : &#39;&quot;&#39; .*? &#39;&quot;&#39; ;
</code></pre></div>
<p>解耦可以让语法被不同的应用复用，但语法因为方法调用的关系仍然被绑定在Java上。</p>

<p>为演示已重构语法的复用性，让我们构建两个不同的应用。首先从遇到属性后只是打印它们的那个开始。这个过程只是去扩展由ANTLR生成的语法分析器类和覆盖一个或多个由语法触发的方法。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class PropertyFilePrinter extends PropertyFileParser {
    void defineProperty(Token name, Token value) {
        System.out.println(name.getText() + &quot;=&quot; + value.getText());
    }
}
</code></pre></div>
<p>由于ANTLR生成的PropertyFileParser类中的默认实现，我们不需要覆盖startFile()或finishFile()。</p>

<p>为了启动这个应用，我们需要创建一个特定的PropertyFilePrinter语法分析器子类的实例，而不是常规的PropertyFileParser的。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">PropertyFileLexer lexer = new PropertyFileLexer(input);
CommonTokenStream tokens = new CommonTokenStream(lexer);
PropertyFilePrinter parser = new PropertyFilePrinter(tokens);
parser.file();    // launch our special version of the parser
</code></pre></div>
<p>作为第二个应用，我们把属性加载到一个map中而不是打印它们。我们需要做的就是创建一个新的子类并把不同的功能放到defineProperty()中。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class PropertyFileLoader extends PropertyFileParser {
    Map&lt;String,String&gt; props = new OrderedHashMap&lt;String, String&gt;();
    void defineProperty(Token name, Token value) {
        props.put(name.getText(), value.getText());
    }
}
</code></pre></div>
<p>在语法分析器执行完毕后，字段props将会包含名-值对。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（19）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part19/"/>
    <updated>2016-06-21T21:12:40+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part19</id>
    <content type="html"><![CDATA[<ul>
<li>component 构件</li>
</ul>

<p>因为词法规则可以使用递归，所以词法解析器在技术上和语法解析器一样强大。那意味着我们甚至可以在词法分析器中匹配语法结构。或者，在另一个极端，我们可以把字符当作记号，使用语法分析器去把语法结构应用到字符流（这种被称为无扫描语法分析器）。这导致什么在词法分析器中匹配和什么在语法分析器中匹配的界线在哪里并不是很明显。幸运的是，有几条经验法则可以让我们做出判断：</p>

<ul>
<li>在词法分析器中匹配和丢弃任何语法分析器根本不需要见到的东西。例如，在词法分析器中识别和扔掉像注释和空格这些东西。否则，语法分析器必须经常查看是否有注释或空格在记号间。</li>
<li>在词法分析器中匹配诸如标志符、关键字、字符串和数字这样的常用记号。语法分析器比词法分析器有更多的开销，因此，我们不必让语法分析器承受把数字放在一起识别成整数的负担。</li>
<li>把那些语法分析器不需要去辨别的词法结构合并成一个单独的记号类型。例如，如果我们的应用把整数和浮点数当作同一事物对待，然后把它们合并成记号类型NUMBER，那么就没必要向语法分析器发送单独的记号类型。</li>
<li>合并能被语法分析器视为一个单独实体的任何东西。例如，如果语法分析器不在乎XML标签里的内容，词法分析器可以把尖括号中的任何东西合并成一个单独的被称为TAG的记号类型。</li>
<li>如果语法分析器需要先拆开一小块文本后才能去处理它，那么词法分析器应该传递独立的构件作为记号给语法分析器。例如，如果语法分析器需要处理一个IP地址的元素，词法分析器应该发送IP构件（整数和点）的独立的记号。</li>
</ul>

<p>想象下现在需要处理Web服务器上的日志文件，每一行表示一条记录。让我们假设每条记录都有一个请求IP地址、HTTP协议命令和结果代码。这里是一个日志条目的示例：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">192.168.209.85 &quot;GET /download/foo.html HTTP/1.0&quot; 200
</code></pre></div>
<p>如果想要统计文件中有多少行，那么我们可以忽略掉任何东西除了换行字符的序列：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">file  : NL+ ;               // 匹配换行符（NL）序列的语法规则
STUFF : ~&#39;\n&#39;+ -&gt; skip ;    // 匹配和丢弃除&#39;\n&#39;外的任何东西
NL    : &#39;\n&#39; ;              // 返回NL给语法分析器或调用代码
</code></pre></div>
<p>词法分析器不必识别太多的结构，语法分析器会匹配换行记号的序列。</p>

<p>接下来，我们需要从日志文件中收集一系列的IP地址。这意味着我们需要一条规则去识别IP地址的词法结构。并且我们也可以提供其它记录元素的词法规则：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">IP    : INT &#39;.&#39; INT &#39;.&#39; INT &#39;.&#39; INT ;    // 192.168.209.85
INT   : [0-9]+ ;                         // 匹配IP八位组或者HTTP结果代码
STRING: &#39;&quot;&#39; .*? &#39;&quot;&#39; ;                    // 匹配HTTP协议命令
NL    : &#39;\n&#39; ;                           // 匹配日志文件记录终结符
WS    : &#39; &#39; -&gt; skip ;                    // 忽略空格
</code></pre></div>
<p>拥有一套完整的记号后，我们可以让语法规则匹配日志文件中的记录：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">file : row+ ;                // 匹配日志文件中行的语法规则
row  : IP STRING INT NL ;    // 匹配日志文件记录
</code></pre></div>
<p>更进一步，我们需要把文本IP地址转换成32位的数字。使用便利的库函数split(&#39;.&#39;)，我们可以把IP地址切割成字符串传递给语法分析器让它去处理。但是，更好的做法是让词法分析器匹配IP地址的词法结构，然后把匹配出的构件作为记号传递给语法分析器。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">file  : row+ ;                           // 匹配日志文件中行的语法规则
row   : ip STRING INT NL ;               // 匹配日志文件记录
ip    : INT &#39;.&#39; INT &#39;.&#39; INT &#39;.&#39; INT ;    // 在语法分析器中匹配IP地址
INT   : [0-9]+ ;                         // 匹配IP八位组或者HTTP结果代码
STRING: &#39;&quot;&#39; .*? &#39;&quot;&#39; ;                    // 匹配HTTP协议命令
NL    : &#39;\n&#39; ;                           // 匹配日志文件记录终结符
WS    : &#39; &#39; -&gt; skip ;                    // 忽略空格
</code></pre></div>
<p>把词法规则IP切换成语法规则ip显示了我们可以多么轻易地移动这条分界线。</p>

<p>如果要求处理HTTP协议命令字符串的内容，我们可以遵循相同的思考过程。如果不需要检查字符串的部分，那么词法分析器可以把整个字符串作为一个单独的记号传递给语法分析器。如果我们需要抽出各种不同的部分，最好就是让词法分析器去识别那些部分后再把这些匹配出的构件传递给语法分析器。</p>
]]></content>
  </entry>
  
</feed>
