<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: ANTLR | 乐者为王]]></title>
  <link href="http://codemany.com/tags/antlr/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2016-05-10T10:16:40+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（7）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part7/"/>
    <updated>2016-03-11T16:42:08+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part7</id>
    <content type="html"><![CDATA[<ul>
<li>sequence 序列</li>
</ul>

<p>在<a href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part6/">ANTLR 4权威参考读书笔记（6）</a>中的这些操作仅仅是提取和打印被语法分析器匹配的值，它们并没有改变语法分析器本身。</p>

<p>实际上，操作还可以影响语法分析器如何识别输入短语。这类特殊的操作被称为语义谓词。下面我们会用一个简单的例子来展示语义谓词的强大能力：动态地打开和关闭语法的某个部分。</p>

<h3 id="使用语义谓词改变语法分析">使用语义谓词改变语法分析</h3>

<p>有一个读入整数序列的语法，它的玄机是由输入的部分指定有多少个整数组合在一起，所以我们必须等到运行时才能知道有多少整数被匹配。这里是示例输入文件idata.txt的内容：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">2 9 10 3 1 2 3
</code></pre></div>
<p>第1个数字表示匹配后续两个数字9和10；紧跟10的数字3表示匹配接下来的三个数字。我们的目的是设计一个语法IData.g，把9和10组合在一起，把1、2和3组合在一起。在语法上执行以下命令后显示的语法分析树能够清楚地标识出整数的分组，就像下图显示的那样：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr -no-listener IData.g
compile *.java
grun IData file -gui idata.txt
</code></pre></div>
<p><img src="/uploads/idata-parse-tree.png" title="idata-parse-tree" ></p>

<p>要达成这个目标，以下语法中的关键是一个被称为语义谓词的布尔值操作：{$i &lt; $n}?。当谓词计算结果为true时，语法分析器匹配整数直到超过序列规则参数n要求的数量；当计算结果为false时，谓词让相关的选项从生成的语法分析器中“消失”。
在这个案例中，值为false的谓词让(...)*循环从规则序列里终止并返回。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grammar IData;

file : group+ ;

group: INT sequence[$INT.int] ;

sequence[int n]
locals [int i = 1;]
     : ( {$i&lt;=$n}? INT {$i++;} )*  // match n integers
     ;

INT  : [0-9]+ ;  // match integers
WS   : [ \t\n\r]+ -&gt; skip ;  // toss out all whitespace
</code></pre></div>
<p>被语法分析器使用的规则序列的内部语法表示看起来就像下图这样：</p>

<p><img src="/uploads/idata-rule-sequence.png" title="idata-rule-sequence" ></p>

<p>虚线表明谓词可以剪断那条路径，只给语法分析器留下一个选择：退出的路径。</p>

<p>虽然大部分时间我们不需要这样的微管理，但它至少让我们知道我们有这样的武器可以处理病理分析问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（6）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part6/"/>
    <updated>2016-02-14T16:16:37+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part6</id>
    <content type="html"><![CDATA[<ul>
<li>action 操作</li>
<li>clause 子句</li>
</ul>

<p>Listener和Visitor机制是极好的。大多数时候，我们可以用Listener或Visitor构建语言应用，它们让特定应用的代码置身于语法之外，使语法容易被阅读。</p>

<p>但有时候我们需要额外的控制权和灵活性。为了达到这个目的，我们可以直接在语法中嵌入代码片段（这些嵌入的代码片段被称为操作）。这些操作会被注入到由ANTLR工具生成的分析器代码中。这些被注入的代码在分析期间执行，并且能像其它任意代码片段一样收集信息或生成输出。结合语义谓词，我们甚至可以在运行时让我们语法的某部分消失！例如，我们可能想打开或关闭Java语法中的enum关键词，分析语言的不同版本。没有语义谓词，我们就需要两个不同版本的语法。</p>

<p>下面我们将实现一个简单的程序，读入数据行，然后打印出在特定列中找到的值。</p>

<h3 id="在语法中嵌入任意的操作">在语法中嵌入任意的操作</h3>

<p>如果我们不想付出构建语法分析树的开销，或者想要在分析期间动态地计算值或把东西打印出来，那么可以通过在语法中嵌入任意代码实现。它的比较困难的，因为我们必须明白在语法分析器上的操作的影响，以及在哪里放置这些操作。</p>

<p>为了解释嵌入在语法中的操作，让我们先来看下文件rows.txt中的数据：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">parrt   Terence Parr    101
tombu   Tom Burns       020
bke     Kevin Edgar     008
</code></pre></div>
<p>这些列是由TAB分隔的，每一行用一个换行结束。匹配这种类型的输入在语法上还是相当简单的。下面是此语法文件Rows.g的内容：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">file : (row NL)+ ;  // NL is newline token: &#39;\r&#39;? &#39;\n&#39;
row  : STUFF+ ;
</code></pre></div>
<p>我们需要创建一个构造器以便我们能传递我们想要的列号（从1开始计数），所以我们需要在规则中添加一些操作来做这些事情：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grammar Rows;

@parser::members {  // add members to generated RowsParser
    int col;
    public RowsParser(TokenStream input, int col) { // custom constructor
        this(input);
        this.col = col;
    }
}

file: (row NL)+ ;

row
locals [int i=0]
    : ( STUFF
        {
        $i++;
        if ( $i == col ) System.out.println($STUFF.text);
        }
      )+
    ;

TAB  :  &#39;\t&#39; -&gt; skip ;  // match but don&#39;t pass to the parser
NL   :  &#39;\r&#39;? &#39;\n&#39; ;    // match and pass to the parser
STUFF:  ~[\t\r\n]+ ;    // match any chars except tab, newline
</code></pre></div>
<p>在上述语法中，操作是被花括号括起来的代码片段；members操作的代码将会被注入到生成的语法分析器类中的成员区；在规则row中的操作访问的$i是由locals子句定义的局部变量，该操作也用$STUFF.text获取最近匹配的STUFF记号的文本内容。STUFF词法规则匹配任何非TAB或换行的字符，这意味着在列中可以有空格字符。</p>

<p>现在，是时候去思考如何使用定制的构造器传递一个列号给语法分析器，并且告诉语法分析器不要构建语法分析树了：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class Rows {

    public static void main(String[] args) throws Exception {
        ANTLRInputStream input = new ANTLRInputStream(System.in);
        RowsLexer lexer = new RowsLexer(input);
        CommonTokenStream tokens = new CommonTokenStream(lexer);
        int col = Integer.valueOf(args[0]);
        RowsParser parser = new RowsParser(tokens, col);    // pass column number!
        parser.setBuildParseTree(false);    // don&#39;t waste time bulding a tree
        parser.file();
    }
}
</code></pre></div>
<p>现在，让我们核实下我们的语法分析器能否正确匹配一些示例输入：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr -no-listener Rows.g  # don&#39;t need the listener
compile *.java
run Rows 1 &lt; rows.txt
</code></pre></div>
<p>这时你会看到rows.txt文件的第1列内容被输出：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">parrt
tombu
bke
</code></pre></div>
<p>如果将上面命令中的1换成2，你会看到rows.txt文件的第2列内容被输出；如果换成3，那么rows.txt文件的第3列内容将会被输出。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（5）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part5/"/>
    <updated>2016-01-22T21:18:51+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part5</id>
    <content type="html"><![CDATA[<p>在<a href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part3/">ANTLR 4权威参考读书笔记（3）</a>以及<a href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part4/">ANTLR 4权威参考读书笔记（4）</a>中我们分别用Visitor和Listener机制实现了计算器的解释执行和编译执行。但并没有给出这两种机制的太多细节，这次就来详细地讲讲。</p>

<p>ANTLR在它的运行库中为两种树遍历机制提供支持。默认情况下，ANTLR生成一个语法分析树Listener接口，在其中定义了回调方法，用于响应被内建的树遍历器触发的事件。</p>

<p>在Listener和Visitor机制之间最大的不同是：Listener方法被ANTLR提供的遍历器对象调用；而Visitor方法必须显式的调用visit方法遍历它们的子节点，在一个节点的子节点上如果忘记调用visit方法就意味着那些子树没有得到访问。</p>

<p>让我们首先从Listener开始。在我们了解Listener之后，我们也将看到ANTLR如何生成遵循Visitor设计模式的树遍历器。</p>

<h3 id="语法分析树listener">语法分析树Listener</h3>

<p>在Calc.java中有这样两行代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">ParseTreeWalker walker = new ParseTreeWalker();
walker.walk(new DirectiveListener(), tree);
</code></pre></div>
<p>类ParseTreeWalker是ANTLR运行时提供的用于遍历语法分析树和触发Listener中回调方法的树遍历器。ANTLR工具根据Calc.g中的语法自动生成ParseTreeListener接口的子接口CalcListener和默认实现CalcBaseListener，其中含有针对语法中每个规则的enter和exit方法。DirectiveListener是我们编写的继承自CalcBaseListener的包含特定应用代码的实现，把它传递给树遍历器后，树遍历器在遍历语法分析树时就会触发DirectiveListener中的回调方法。</p>

<p><img src="/uploads/calc-listener-hierachy.png" title="calc-listener-hierachy" ></p>

<p>下图左边的语法分析树显示ParseTreeWalker执行了一次深度优先遍历，由粗虚线表示，箭头方向代表遍历方向。右边显示的是语法分析树的完整调用序列，它们由ParseTreeWalker触发调用。当树遍历器遇到规则assign的节点时，它触发enterAssign()并且给它传递AssignContext语法分析树节点。在树遍历器访问完assign节点的所有子节点后，它触发exitAssign()。</p>

<p><img src="/uploads/listener-call-sequence.png" title="listener-call-sequence" ></p>

<p>Listener机制的强大之处在于所有都是自动的。我们不必要写语法分析树遍历器，而且我们的Listener方法也不必要显式地访问它们的子节点。</p>

<h3 id="语法分析树visitor">语法分析树Visitor</h3>

<p>有些情况下，我们实际想要控制的是遍历本身，在那里我们可以显式地调用visit方法去访问子树节点。选项-visitor告诉ANTLR工具从相应语法生成Visitor接口和默认实现，其中含有针对语法中每个规则的visit方法。</p>

<p>下图是我们熟悉的Visitor模式操作在语法分析树上。左边部分的粗虚线表示语法分析树的深度优先遍历，箭头方向代表遍历方向。右边部分指明Visitor中的方法调用序列。</p>

<p><img src="/uploads/visitor-call-sequence.png" title="visitor-call-sequence" ></p>

<p>下面是Calc.java中的两行代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">EvalVisitor eval = new EvalVisitor();
// To start walking the parse tree
eval.visit(tree);
</code></pre></div>
<p>我们首先初始化自制的树遍历器EvalVisitor，然后调用visit()去访问整棵语法分析树。ANTLR运行时提供的Visitor支持代码会在看到根节点时调用visitProg()。在那里，visitProg()会把子树作为参数调用visit方法继续遍历，如此等等。</p>

<p><img src="/uploads/calc-visitor-hierachy.png" title="calc-visitor-hierachy" ></p>

<p>ANTLR自动生成的Visitor接口和默认实现可以让我们为Visitor方法编写自己的实现，让我们避免必须覆写接口中的每个方法，让我们仅仅聚焦在我们感兴趣的方法上。这种方法减少了我们学习ANTLR必须要花费的时间，让我们回到我们所熟悉的编程语言领域。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（4）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part4/"/>
    <updated>2016-01-18T15:06:54+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part4</id>
    <content type="html"><![CDATA[<p>在<a href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part3/">ANTLR 4权威参考读书笔记（3）</a>中的计算器是以解释的方式执行的，现在我们想要把它转换成以编译的方式执行。编译执行和解释执行相比，需要依赖于特定的目标机器。在这里我们假设有一台这样的机器，它用堆栈进行运算，支持如下表所示的几种指令：</p>

<table><thead>
<tr>
<th>指令</th>
<th>说明</th>
<th>操作数个数</th>
<th>用途</th>
</tr>
</thead><tbody>
<tr>
<td>LDV</td>
<td>Load Variable</td>
<td>1</td>
<td>变量入栈</td>
</tr>
<tr>
<td>LDC</td>
<td>Load Constant</td>
<td>1</td>
<td>常量入栈</td>
</tr>
<tr>
<td>STR</td>
<td>Store Value</td>
<td>1</td>
<td>栈顶一个元素存入指定变量</td>
</tr>
<tr>
<td>ADD</td>
<td>Add</td>
<td>0</td>
<td>栈顶两个元素出栈，求和后入栈</td>
</tr>
<tr>
<td>SUB</td>
<td>Subtract</td>
<td>0</td>
<td>栈顶两个元素出栈，求差后入栈</td>
</tr>
<tr>
<td>MUL</td>
<td>Multiply</td>
<td>0</td>
<td>栈顶两个元素出栈，求积后入栈</td>
</tr>
<tr>
<td>DIV</td>
<td>Divide</td>
<td>0</td>
<td>栈顶两个元素出栈，求商后入栈</td>
</tr>
<tr>
<td>RET</td>
<td>Return</td>
<td>0</td>
<td>栈顶一个元素出栈，计算结束</td>
</tr>
</tbody></table>

<p>做这个最简单的方法是使用ANTLR的语法分析树Listener机制实现DirectiveListener类，然后它通过监听来自树遍历器触发的事件，输出对应的机器指令。</p>

<p>Listener机制的优势是我们不必要自己去做任何树遍历，甚至我们不必要知道遍历语法分析树的运行时如何调用我们的方法，我们只要知道我们的DirectiveListener类得到通知，在与语法规则匹配的短语开始和结束时。这种方法减少了我们学习ANTLR必须要花费的时间，让我们回到我们所熟悉的编程语言领域。</p>

<p>这里不需要创建新的语法规则，还是继续沿用前文Calc.g所包含的语法，标签也要保留：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grammar Calc;

prog
    : stat+
    ;

stat
    : expr                   # printExpr
    | ID &#39;=&#39; expr            # assign
    ;

expr
    : expr op=(MUL|DIV) expr # MulDiv
    | expr op=(ADD|SUB) expr # AddSub
    | INT                    # int
    | ID                     # id
    | &#39;(&#39; expr &#39;)&#39;           # parens
    ;

MUL : &#39;*&#39; ;

DIV : &#39;/&#39; ;

ADD : &#39;+&#39; ;

SUB : &#39;-&#39; ;

ID  : [a-zA-Z]+ ;

INT : [0-9]+ ;

WS  : [ \t\r\n]+ -&gt; skip ;    // toss out whitespace
</code></pre></div>
<p>然后，我们可以运行ANTLR工具：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr Calc.g
</code></pre></div>
<p>它会生成后缀名为tokens和java的六个文件：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Calc.tokens         CaclLexer.java          CalcParser.java
CalcLexer.tokens    CalcBaseListener.java   CalcListener.java
</code></pre></div>
<p>正如这里我们看到的，ANTLR会为我们自动生成Listener基础设施。其中CalcListener是语法和Listener对象之间的关键接口，描述我们可以实现的回调方法：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public interface CalcListener extends ParseTreeListener {
    void enterProg(CalcParser.ProgContext ctx);
    void exitProg(CalcParser.ProgContext ctx);
    void enterPrintExpr(CalcParser.PrintExprContext ctx);
    ...
}
</code></pre></div>
<p>CalcBaseListener则是ANTLR生成的一组空的默认实现。ANTLR内建的树遍历器会去触发在Listener中像enterProg()和exitProg()这样的一串回调方法，如同它对语法分析树执行了一次深度优先遍历。为响应树遍历器触发的事件，我们的DirectiveListener需要继承CalcBaseListener并实现一些方法。我们不需要实现全部的接口方法，我们也不需要去覆写每个enter和exit方法，我们只需要去覆写那些我们感兴趣的回调方法。</p>

<p>在本例中，我们需要通过覆写6个方法对6个事件——当树遍历器exit那些有标签的选项时触发——作出响应。我们的基本策略是当这些事件发生时打印出已转换的指令。以下是完整的实现代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class DirectiveListener extends CalcBaseListener {

    @Override
    public void exitPrintExpr(CalcParser.PrintExprContext ctx) {
        System.out.println(&quot;RET\n&quot;);
    }

    @Override
    public void exitAssign(CalcParser.AssignContext ctx) {
        String id = ctx.ID().getText();
        System.out.println(&quot;STR &quot; + id);
    }

    @Override
    public void exitMulDiv(CalcParser.MulDivContext ctx) {
        if (ctx.op.getType() == CalcParser.MUL) {
            System.out.println(&quot;MUL&quot;);
        } else {
            System.out.println(&quot;DIV&quot;);
        }
    }

    @Override
    public void exitAddSub(CalcParser.AddSubContext ctx) {
        if (ctx.op.getType() == CalcParser.ADD) {
            System.out.println(&quot;ADD&quot;);
        } else {
            System.out.println(&quot;SUB&quot;);
        }
    }

    @Override
    public void exitId(CalcParser.IdContext ctx) {
        System.out.println(&quot;LDV &quot; + ctx.ID().getText());
    }

    @Override
    public void exitInt(CalcParser.IntContext ctx) {
        System.out.println(&quot;LDC &quot; + ctx.INT().getText());
    }
}
</code></pre></div>
<p>为了让它运行起来，余下我们唯一需要做的事是创建一个主程序去调用它：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class Calc {

    public static void main(String[] args) throws Exception {
        InputStream is = args.length &gt; 0 ? new FileInputStream(args[0]) : System.in;

        ANTLRInputStream input = new ANTLRInputStream(is);
        CalcLexer lexer = new CalcLexer(input);
        CommonTokenStream tokens = new CommonTokenStream(lexer);
        CalcParser parser = new CalcParser(tokens);
        ParseTree tree = parser.prog();

        ParseTreeWalker walker = new ParseTreeWalker();
        walker.walk(new DirectiveListener(), tree);

        // print LISP-style tree
        System.out.println(tree.toStringTree(parser));
    }
}
</code></pre></div>
<p>这个程序和前文Calc.java中的代码极度相似，区别只在12-13行。这两行代码负责创建树遍历器，然后让树遍历器去遍历那颗从语法分析器返回的语法分析树，当树遍历器遍历时，它就会触发调用到我们的DirectiveListener中实现的方法。此外，通过传入一个不同的Listener实现我们能简单地生成完全不同的输出。Listener机制有效地隔离了语法和语言应用，使语法可以被其它应用再次使用。</p>

<p>现在一切完备，让我们尝试着去编译和运行它吧！下面是完整的命令序列：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">compile *.java
run Calc calc.txt
</code></pre></div>
<p>编译的输出结果如下所示：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">LDC 19
RET

LDC 5
STR a
LDC 6
STR b
LDV a
LDV b
LDC 2
MUL
ADD
RET

LDC 1
LDC 2
ADD
LDC 3
MUL
RET
</code></pre></div>
<p>代码下载：<a href="https://github.com/dohkoos/antlr4-calculator">https://github.com/dohkoos/antlr4-calculator</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（3）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part3/"/>
    <updated>2016-01-05T16:48:16+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part3</id>
    <content type="html"><![CDATA[<ul>
<li>lexical 词法的</li>
<li>alternative 选项</li>
<li>notation 表示法</li>
<li>directive 指令</li>
<li>label 标签</li>
</ul>

<p>了解ANTLR最好的方法就是实例。构建一个简单的计算器是个不错的主意。为了使它容易理解且保持简单，我们将只允许基本的算术运算符（加、减、乘、除）、括号表达式、整数和变量。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grammar Calc;

prog
    : stat+
    ;

stat
    : expr
    | ID &#39;=&#39; expr
    ;

expr
    : expr (&#39;*&#39;|&#39;/&#39;) expr
    | expr (&#39;+&#39;|&#39;-&#39;) expr
    | INT
    | ID
    | &#39;(&#39; expr &#39;)&#39;
    ;

ID  : [a-zA-Z]+ ;

INT : [0-9]+ ;

WS  : [ \t\r\n]+ -&gt; skip ;    // toss out whitespace
</code></pre></div>
<p>在上述的语法中，程序是由空格（换行符也被当作空格）终止的语句序列，语句可以是表达式或者赋值。那些以小写字母开头的像stat和expr是语法规则；由大写字母开头的诸如ID和INT为词法规则，用于识别标志符和整数这样的记号。我们用“|”分隔规则的选项，我们也可以用“()”把符号分组成子规则。例如，子规则<code>(&#39;*&#39;|&#39;/&#39;)</code>匹配乘法符号或者除法符号。</p>

<p>ANTLR v4最重要的新特性是它有能力处理（大多数类型的）左递归规则。例如，规则expr前两个选项就在左边缘递归地调用了expr自身。这种指定算术表达式表示法的方法比那些典型的自顶向下语法分析器策略更容易。当然，在这种策略下，我们需要定义多个规则，每个运算符优先级一个规则。</p>

<p>记号定义的表示法对那些有正则表达式经验的应该很熟悉。唯一不寻常的是在WS规则上的<code>-&gt; skip</code>指令，它告诉词法分析器去匹配但丢弃空格，不要把它们放到记号流中，这样在语法分析树上空格就不会有对应的记号。（每个可能的输入字符都必须被至少一个词法规则匹配。）我们通过使用形式化的ANTLR表示法避免捆绑语法到某个特定的目标语言，而不是在语法中插入任意代码片段来告诉词法分析器去忽略。</p>

<p>这里是一些用来评估所有语法特性的测试序列：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">193
a = 5
b = 6
a+b*2
(1+2)*3
</code></pre></div>
<p>把它们放入文件calc.txt中，然后执行以下命令：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr Calc.g
compile *.java
grun Calc prog -gui calc.txt
</code></pre></div>
<p>TestRig会弹出一个显示语法分析树的窗口：</p>

<p><img src="/uploads/calc-parse-tree.png" title="calc-parse-tree" ></p>

<h3 id="使用visitor模式计算结果">使用Visitor模式计算结果</h3>

<p>为了给前面的算术表达式语法分析器计算出结果，我们还需要做些其它的事情。</p>

<p>ANTLR v4鼓励我们保持语法的整洁，使用语法分析树Visitor和其它遍历器来实现语言应用。不过在接触这些之前，我们需要对语法做些修改。</p>

<p>首先，我们需要用标签标明规则的选项，标签可以是和规则名没有冲突的任意标志符。如果选项上没有标签，ANTLR只会为每个规则生成一个visit方法。</p>

<p>在本例中，我们希望为每个选项生成一个不同的visit方法，以便每种输入短语都能得到不同的事件。在新的语法中，标签出现在选项的右边缘，且以“#”符号开头：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">stat
    : expr                   # printExpr
    | ID &#39;=&#39; expr            # assign
    ;

expr
    : expr op=(MUL|DIV) expr # MulDiv
    | expr op=(ADD|SUB) expr # AddSub
    | INT                    # int
    | ID                     # id
    | &#39;(&#39; expr &#39;)&#39;           # parens
    ;
</code></pre></div>
<p>接下来，让我们为运算符字面量定义一些记号名字，以便以后可以在visit方法中引用作为Java常量的它们：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">MUL : &#39;*&#39; ;

DIV : &#39;/&#39; ;

ADD : &#39;+&#39; ;

SUB : &#39;-&#39; ;
</code></pre></div>
<p>现在，我们有了一个增强型的语法。接下来要做的事情是实现一个EvalVisitor类，它通过遍历表达式语法分析树计算和返回值。</p>

<p>执行下面的命令，让ANTLR生成Visitor接口和它的默认实现，其中-no-listener参数是告诉ANTLR不再生成Listener相关的代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr -no-listener -visitor Calc.g
</code></pre></div>
<p>所有被标签标明的选项在生成的Visitor接口中都定义了一个visit方法：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public interface CalcVisitor&lt;T&gt; extends ParseTreeVisitor&lt;T&gt; {
    T visitProg(CalcParser.ProgContext ctx);
    T visitPrintExpr(CalcParser.PrintExprContext ctx);
    T visitAssign(CalcParser.AssignContext ctx);
    ...
}
</code></pre></div>
<p>接口定义使用的是Java泛型，visit方法的返回值为参数化类型，这允许我们根据表达式计算返回值的类型去设定实现的泛型参数。因为表达式的计算结果是整型，所以我们的EvalVisitor应该继承<code>CalcBaseVisitor&lt;Integer&gt;</code>类。为计算语法分析树的每个节点，我们需要覆写与语句和表达式选项相关的方法。这里是全部的代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class EvalVisitor extends CalcBaseVisitor&lt;Integer&gt; {
    /** &quot;memory&quot; for our calculator; variable/value pairs go here */
    Map&lt;String, Integer&gt; memory = new HashMap&lt;String, Integer&gt;();

    /** ID &#39;=&#39; expr */
    @Override
    public Integer visitAssign(CalcParser.AssignContext ctx) {
        String id = ctx.ID().getText();  // id is left-hand side of &#39;=&#39;
        int value = visit(ctx.expr());   // compute value of expression on right
        memory.put(id, value);           // store it in our memory
        return value;
    }

    /** expr */
    @Override
    public Integer visitPrintExpr(CalcParser.PrintExprContext ctx) {
        Integer value = visit(ctx.expr()); // evaluate the expr child
        System.out.println(value);         // print the result
        return 0;                          // return dummy value
    }

    /** INT */
    @Override
    public Integer visitInt(CalcParser.IntContext ctx) {
        return Integer.valueOf(ctx.INT().getText());
    }

    /** ID */
    @Override
    public Integer visitId(CalcParser.IdContext ctx) {
        String id = ctx.ID().getText();
        if ( memory.containsKey(id) ) return memory.get(id);
        return 0;
    }

    /** expr op=(&#39;*&#39;|&#39;/&#39;) expr */
    @Override
    public Integer visitMulDiv(CalcParser.MulDivContext ctx) {
        int left = visit(ctx.expr(0));  // get value of left subexpression
        int right = visit(ctx.expr(1)); // get value of right subexpression
        if ( ctx.op.getType() == CalcParser.MUL ) return left * right;
        return left / right; // must be DIV
    }

    /** expr op=(&#39;+&#39;|&#39;-&#39;) expr */
    @Override
    public Integer visitAddSub(CalcParser.AddSubContext ctx) {
        int left = visit(ctx.expr(0));  // get value of left subexpression
        int right = visit(ctx.expr(1)); // get value of right subexpression
        if ( ctx.op.getType() == CalcParser.ADD ) return left + right;
        return left - right; // must be SUB
    }

    /** &#39;(&#39; expr &#39;)&#39; */
    @Override
    public Integer visitParens(CalcParser.ParensContext ctx) {
        return visit(ctx.expr()); // return child expr&#39;s value
    }
}
</code></pre></div>
<p>以前开发和测试语法都是使用的TestRig，这次我们试着编写计算器的主程序来启动代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class Calc {

    public static void main(String[] args) throws Exception {
        InputStream is = args.length &gt; 0 ? new FileInputStream(args[0]) : System.in;

        ANTLRInputStream input = new ANTLRInputStream(is);
        CalcLexer lexer = new CalcLexer(input);
        CommonTokenStream tokens = new CommonTokenStream(lexer);
        CalcParser parser = new CalcParser(tokens);
        ParseTree tree = parser.prog();

        EvalVisitor eval = new EvalVisitor();
        // 开始遍历语法分析树
        eval.visit(tree);

        System.out.println(tree.toStringTree(parser));
    }
}
</code></pre></div>
<p>创建一个运行主程序的脚本：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">#!/bin/sh
java -cp .:./antlr-4.5.1-complete.jar:$CLASSPATH $*
</code></pre></div>
<p>把它保存为run.sh后，执行以下命令：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">compile *.java
run Calc calc.txt
</code></pre></div>
<p>然后你就会看到文本形式的语法分析树以及计算结果：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">193
17
9
(prog (stat (expr 193)) (stat a = (expr 5)) (stat b = (expr 6))
 (stat (expr (expr a) + (expr (expr b) * (expr 2)))) (stat (expr
 (expr ( (expr (expr 1) + (expr 2)) )) * (expr 3))))
</code></pre></div>
<p>代码下载：<a href="https://github.com/dohkoos/antlr4-calculator">https://github.com/dohkoos/antlr4-calculator</a></p>
]]></content>
  </entry>
  
</feed>
