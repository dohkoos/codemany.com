<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: ANTLR | 乐者为王]]></title>
  <link href="http://codemany.com/tags/antlr/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2016-08-12T16:28:06+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（14）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part14/"/>
    <updated>2016-05-16T20:26:22+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part14</id>
    <content type="html"><![CDATA[<p>对于大多数语法，注释和空格都是语法分析器可以忽略的东西。如果我们不想让注释和空格在语法中到处都是，那么就需要让词法分析器把它们扔掉。不幸的是，这意味着任何后续处理步骤都不能再访问注释和空格。安全地忽略掉注释和空格的方法是把这些发送给语法分析器的记号放到一个“隐藏通道”中，语法分析器仅需要调协到单个通道即可。我们可以把任何我们想要的东西传递到其它通道中。这里是如何实现的语法：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">COMMENT
    : &#39;/*&#39; .*? &#39;*/&#39; -&gt; channel(HIDDEN)    // match anything between /* and */
    ;

WS  : [ \r\t\n]+    -&gt; channel(HIDDEN)
    ;
</code></pre></div>
<p>就像我们前面讨论过的<code>-&gt; skip</code>那样，<code>-&gt; channel(HIDDEN)</code>也是一个的词法分析器指令。在这里，它设置那些记号的通道号码以便这些记号可以被语法分析器忽略。记号流仍然维护着原始的记号序列，但在喂食给语法分析器时则略过离线通道中的记号。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（12）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part12/"/>
    <updated>2016-04-26T10:20:44+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part12</id>
    <content type="html"><![CDATA[<ul>
<li>sentinel 哨兵</li>
<li>tag 标签</li>
</ul>

<p>目前我们看到的输入文件都只包含一种语言，但在实际应用中我们会遇到有些包含多种语言的常用文件格式。例如，Java的文档注释，XML文件等。这些环绕着模板表达式的文本需要不同的处理方式，它们被称为孤岛语言。</p>

<p>ANTLR有提供一个称之为“词法模型”的词法分析器特性，它让我们可以很容易地处理包含混合格式的文件。基本思路是：当词法分析器看到特殊的哨兵字符序列时，让它在模式之间来回切换。</p>

<p>XML是一个很好例子，它通常会在同一个文件中包含不同的词法结构。一个XML语法分析器会把除标签和实体引用（例如&hearts;）之外的任何东西当作文本块。当词法分析器看到<code>&lt;</code>时，它切换到“inside”模式；当它看到<code>&gt;</code>或<code>/&gt;</code>时，就切换回默认模式。以下语法展示了该特性是如何工作的：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">lexer grammar XMLLexer;

// Default &quot;mode&quot;: Everything OUTSIDE of a tag
OPEN        :   &#39;&lt;&#39;                 -&gt; pushMode(INSIDE) ;
COMMENT     :   &#39;&lt;!--&#39; .*? &#39;--&gt;&#39;    -&gt; skip ;
EntityRef   :   &#39;&amp;&#39; [a-z]+ &#39;;&#39; ;
TEXT        :   ~(&#39;&lt;&#39;|&#39;&amp;&#39;)+ ;    // match any 16 bit char minus &lt; and &amp;

// ----------------- Everything INSIDE of a tag ---------------------
mode INSIDE;

CLOSE       :   &#39;&gt;&#39;                 -&gt; popMode ;    // back to default mode
SLASH_CLOSE :   &#39;/&gt;&#39;                -&gt; popMode ;
EQUALS      :   &#39;=&#39; ;
STRING      :   &#39;&quot;&#39; .*? &#39;&quot;&#39; ;
SlashName   :   &#39;/&#39; Name ;
Name        :   ALPHA (ALPHA|DIGIT)* ;
S           :   [ \t\r\n]           -&gt; skip ;

fragment
ALPHA       :   [a-zA-Z] ;

fragment
DIGIT       :   [0-9] ;
</code></pre></div>
<p>把上述语法保存为XMLLexer.g文件，然后使用包含以下内容的t.xml文件作为输入来测试它：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&lt;tools&gt;
  &lt;tool name=&quot;ANTLR&quot;&gt;A parser generator&lt;/tool&gt;
&lt;/tools&gt;
</code></pre></div>
<p>以下是构建和运行测试的命令：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr XMLLexer.g
compile *.java
grun XML tokens -tokens t.xml
</code></pre></div>
<p>这里是输出的内容：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">[@0,0:0=&#39;&lt;&#39;,&lt;1&gt;,1:0]
[@1,1:5=&#39;tools&#39;,&lt;10&gt;,1:1]
[@2,6:6=&#39;&gt;&#39;,&lt;5&gt;,1:6]
[@3,7:10=&#39;\r\n  &#39;,&lt;4&gt;,1:7]
[@4,11:11=&#39;&lt;&#39;,&lt;1&gt;,2:2]
[@5,12:15=&#39;tool&#39;,&lt;10&gt;,2:3]
[@6,17:20=&#39;name&#39;,&lt;10&gt;,2:8]
[@7,21:21=&#39;=&#39;,&lt;7&gt;,2:12]
[@8,22:28=&#39;&quot;ANTLR&quot;&#39;,&lt;8&gt;,2:13]
[@9,29:29=&#39;&gt;&#39;,&lt;5&gt;,2:20]
[@10,30:47=&#39;A parser generator&#39;,&lt;4&gt;,2:21]
[@11,48:48=&#39;&lt;&#39;,&lt;1&gt;,2:39]
[@12,49:53=&#39;/tool&#39;,&lt;9&gt;,2:40]
[@13,54:54=&#39;&gt;&#39;,&lt;5&gt;,2:45]
[@14,55:56=&#39;\r\n&#39;,&lt;4&gt;,2:46]
[@15,57:57=&#39;&lt;&#39;,&lt;1&gt;,3:0]
[@16,58:63=&#39;/tools&#39;,&lt;9&gt;,3:1]
[@17,64:64=&#39;&gt;&#39;,&lt;5&gt;,3:7]
[@18,65:66=&#39;\r\n&#39;,&lt;4&gt;,3:8]
[@19,67:66=&#39;&lt;EOF&gt;&#39;,&lt;-1&gt;,4:0]
</code></pre></div>
<p>上面输出的每一行代表一个记号，包含记号索引、开始和结束字符、记号文本、记号类型，最后的行和字符位置则告诉我们词法分析器如何标记化输入。</p>

<p>在命令行中，XML tokens序列处通常是一个语法名字后面跟着开始规则，但在这里，我们使用语法名字后面跟着特殊的规则名字tokens来告诉TestRig应该运行词法分析器而不是语法分析器。接着使用选项-tokens打印出匹配的记号列表。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（11）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part11/"/>
    <updated>2016-04-18T18:13:27+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part11</id>
    <content type="html"><![CDATA[<p>为制作语言应用，我们必须为每个输入短语或子短语执行一些适当的代码，那样做最简单的方法是操作由语法分析器自动创建的语法分析树。</p>

<p>早些时候我们已经学习了词法分析器处理字符和把记号传递给语法分析器，然后语法分析器分析语法和创建语法分析树的相关知识。对应的ANTLR类分别是CharStream、Lexer、Token、Parser和ParseTree。连接词法分析器和语法分析器的管道被称为TokenStream。下图说明了这些类型的对象如何连接到内存中其它的对象。</p>

<p>{% img /uploads/basic-data-structure.png basic-data-structure %}</p>

<p>这些ANTLR数据结构分享尽可能多的数据以便节省内存的需要。上图显示在语法分析树中的叶子（记号）节点含有在记号流中记号的点。记号记录开始和结束字符在CharStream中的索引，而不是复制子串。这里没有与空格字符有关的记号，因为我们假设我们的词法分析器扔掉了空格。</p>

<p>下图显示的是ParseTree的子类RuleNode和TerminalNode以及它们所对应的子树根节点和叶子节点。RuleNode包含有方法如getChild()和getParent()等，但RuleNode并不专属于特定语法所有。为支持更好地访问在特定节点中的元素，ANTLR为每个规则生成一个RuleNode子类。下图为我们显示了赋值语句例子的子树根节点的特定类，它们是StatContext、AssignContext和ExprContext：</p>

<p>{% img /uploads/parse-tree-node.png parse-tree-node %}</p>

<p>因为它们记录了我们知道的通过规则对短语识别的每件事，所以这些被称为上下文对象。每个上下文对象知道被识别短语的开始和结束记号以及提供对所有短语的元素的访问。例如，AssignContext提供方法ID()和expr()去访问标志符节点和表达式子树。</p>

<p>给出了具体类型的描述，我们可以手工写代码去执行树的深度优先遍历。当我们发现和完成节点时我们可以执行任何我们想要的动作。典型的操作是诸如计算结果，更新数据结构，或者生成输出。相比每次为每个应用写同样的树遍历样板代码，我们可以使用ANTLR自动生成的树遍历机制。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（10）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part10/"/>
    <updated>2016-04-08T22:11:39+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part10</id>
    <content type="html"><![CDATA[<p>一个模棱两可的短语或句子通常是指它有不止一种解释。换句话说，短语或句子能适配不止一种语法结构。要解释或转换一个短语，程序必须要能唯一地确认它的含义，这意味着我们必须提供无歧义的语法，以便生成的语法分析器能用明确的一个方法匹配每个输入短语。</p>

<p>在这里，让我们展示一些有歧义的语法以便让二义性的概念更具体。如果你以后在构建语法时陷入二义性，你可以参考本节的内容。</p>

<p>一些明显有歧义的语法：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">assign
    : ID &#39;=&#39; expr    // 匹配一个赋值语句，例如f()
    | ID &#39;=&#39; expr    // 前面选项的精确复制
    ;

expr
    : INT ;
</code></pre></div>
<p>大多数时候二义性是不明显的，如同以下的语法，它能通过规则stat的两个选项匹配函数调用：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">stat
    : expr          // 表达式语句
    | ID &#39;(&#39; &#39;)&#39;    // 函数调用语句
    ;

expr
    : ID &#39;(&#39; &#39;)&#39;
    | INT
    ;
</code></pre></div>
<p>这里是两个输入f()的解释，从规则stat开始：</p>

<p>{% img /uploads/fn-parse-tree.png fn-parse-tree %}</p>

<p>左边的语法分析树显示f()匹配规则expr。右边的语法分析树显示f()匹配规则stat的第二个选项。</p>

<p>因为大部分语言它们的语法都被设计成无歧义的，有歧义的语法类似于编程缺陷。我们需要识别语法以便为每个输入短语提交单一选择给语法分析器。如果语法分析器发现一个有歧义的短语，它必须选一个可行的选项。ANTLR通过选择涉及决定的第一个选项解决二义性。在本例中，语法分析器将选择与左边的语法分析树有关的f()的解释。</p>

<p>二义性可以发生在词法分析器中也能发生在语法分析器中，但ANTLR可以自动地解决它们。ANTLR通过使输入字符串和语法中第一个指定的规则匹配来解决词法二义性。为了明白这是如何工作的，让我们看看对大部分编程语言都很普遍的二义性：在关键字和标志符规则中的二义性。关键字begin（后面有个非字母）也是标志符，至少词法上，因此词法分析器可以匹配b-e-g-i-n到两者中的任何一个规则。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">BEGIN : &#39;begin&#39; ;    // 匹配b-e-g-i-n序列，即把二义性解析为BEGIN
ID    : [a-z]+ ;     // 匹配一个或多个任意小写字母
</code></pre></div>
<p>注意，词法分析器会试着为每个记号尽可能匹配最长的字符串，这意味着输入beginner将仅匹配规则ID。词法分析器不会把beginner匹配成BEGIN随后ID匹配输入ner。</p>

<p>有时候语言的语法就明显有歧义，没有任何的语法重组能改变这个事实。例如，算术表达式的自然语法可以用两种方式解释输入像1+2*3这样，要么执行运算符从左到右，要么像大部分语言那样按优先级顺序。</p>

<p>C语言展示了另一种二义性，但我们可以使用上下文信息比如标志符如何被定义来解决它。考虑代码片段i*j;。在语法上，它看起来像是一个表达式，但它的含义或者语义依赖i是类型名还是变量。如果i是类型名，那么这个片段不是表达式，而是一个声明为指向类型i的指针变量j。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（9）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part9/"/>
    <updated>2016-03-27T07:10:05+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part9</id>
    <content type="html"><![CDATA[<ul>
<li>predication 预测</li>
<li>predict 预判</li>
<li>lookahead 预读</li>
</ul>

<p>ANTLR工具根据语法规则，例如我们刚才看到的assign，生成递归下降语法分析器。递归下降语法分析器只是递归方法的一个集合，每个规则一个方法。下降这个术语指的是分析从语法分析树的根开始向着叶子进行（记号）。我们首先调用的规则，即stat符号，成为语法分析树的根。那也就意味着对<a href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part8/">ANTLR 4权威参考读书笔记（8）</a>中的语法分析树来说需要调用方法stat()。这类分析更通用的术语是自顶向下分析：递归下降语法分析器仅仅是自顶向下语法分析器实现的一种。</p>

<p>要了解递归下降语法分析器是什么样子，这里是ANTLR为规则assign生成的方法（稍微整理）：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">// assign : ID &#39;=&#39; expr ;
void assign() {    // 根据规则assign生成的方法
    match(ID);     // 比较ID和当前输入符号然后消费
    match(&#39;=&#39;);
    expr();        // 通过调用expr()匹配表达式
}
</code></pre></div>
<p>递归下降语法分析器最酷的部分是通过调用方法stat()、assign()和expr()跟踪出的调用关系图反映了内部的语法分析树节点。match()的调用对应语法分析树叶子。为了在一个手工构建的语法分析器中手动构建一颗语法分析树，我们需要在每个规则方法的开始处插入“添加新子树根”操作，以及给match()一个“添加新叶子节点”操作。</p>

<p>方法assign()只是检查确保所有必要的记号存在且以正确的顺序。当语法分析器进入assign()时，它不必在多个选项之间进行选择。选项是规则定义右边的选择之一。例如，调用assign的stat规则可能有其它类型的语句。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">/** 匹配起始于当前输入位置的任何语句 */
stat
    : assign    // 第一个选项（&#39;|&#39;是选项分隔符）
    | ifstat    // 第二个选项
    | whilestat
    ...
    ;
</code></pre></div>
<p>stat的分析规则看起来像一条switch语句：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">void stat() {
    switch ( «current input token» ) {
        CASE ID : assign(); break;
        CASE IF : ifstat(); break;    // IF是关键字&#39;if&#39;的记号类型
        CASE WHILE : whilestat(); break;
        ...
        default : «raise no viable alternative exception»
    }
}
</code></pre></div>
<p>方法stat()必须通过检查下一个输入记号作出分析决定或预测。分析决定预判哪一个选项将会成功。在本例中，当看到WHILE关键字时会预判是规则stat的第三个选项。规则方法stat()然后就会调用whilestat()。你以前可能听说过术语预读记号，那只是下一个输入记号。预读记号可以是语法分析器在匹配和消费它之前嗅探的任何记号。</p>

<p>有时候，语法分析器需要一些预读记号去预判哪个选项会成功。它甚至必须考虑从当前位置直到文件结尾的所有的记号。ANTLR默默地为你处理所有的这些事情，但是对决策过程有个基本的了解是有帮助的，可以让调试生成的语法分析器更容易。</p>

<p>为更好地理解分析决定，想象有个单一入口和单一出口的迷宫，有单词写在地板上。每个沿着从入口到出口路径的单词序列表示一个句子。迷宫的结构与定义一门语言的语法规则类似。为测试一个句子在一门语言中的成员身份，我们在穿越迷宫时把句子的单词和沿着地板的单词作比较。如果通过句子的单词我们能到达出口，那么句子是有效的。</p>

<p>为了通过迷宫，我们必须在每个岔口选择一条有效路径，正如我们必须在语法分析器中选择选项。我们必须决定该走哪条路，通过把我们句子中下一个单词（们）和沿着来自每个岔口的每条路径上可见的单词比较。我们能从岔口看到的单词与预读记号类似。当每条路径以唯一的单词开始时决定是相当容易的。在规则stat中，每个选项从唯一的记号开始，因此stat()可以通过查看第一个预读记号识别选项。</p>

<p>当单词从一个岔口重叠部分开始每条路径时，语法分析器需要继续往前看，扫描可以识别选项的单词。ANTLR根据需要为每个决定自动上下调节预读数量。如果预读的结果是多条同样的到出口的路径，即当前的输入短语有多种解释。解决这样的二义性将是我们的下一个主题。</p>
]]></content>
  </entry>
  
</feed>
