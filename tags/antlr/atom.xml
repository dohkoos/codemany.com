<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: ANTLR | 乐者为王]]></title>
  <link href="http://codemany.com/tags/antlr/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2016-08-25T09:11:03+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（16）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part16/"/>
    <updated>2016-06-02T10:16:21+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part16</id>
    <content type="html"><![CDATA[<ul>
<li>initializer 初始值设定项</li>
</ul>

<p>现在，我们已经有了一个自顶向下的草拟出语法的通用策略，下面我们要专注于一些常用的语言模式。尽管在过去几十年里有大量的语言被发明，但仍然只有较少的基本语言模式需要被处理。这是因为人们趋向于设计遵循自然语言约束的语言，语言也会因为设计者遵循数学上的常用表示法而趋向于相似。甚至在词法级别，语言趋向于重用一些相同的结构，例如标志符、整数、字符串等。这些单词顺序和依赖的约束来源于自然语言，并逐渐演化成为四种抽象的语言模式：</p>

<h4 id="模式：序列">模式：序列</h4>

<p>这是像数组初始值设定项中的值那样的一系列元素，也是在计算机语言中最常见的结构。例如，下面是登录到POP服务器时的序列：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">USER parrt
PASS secret
RETR 1
</code></pre></div>
<p>这些命令本身也是序列。大部分命令是一个关键词（保留标志符，例如USER和RETR）跟随一个运算元再跟随一个换行符。为了在语法中指定此类序列，我们可以按照顺序简单地列出各个元素。以下是检索命令的序列（其中INT表示整数记号类型）：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">retr : &#39;RETR&#39; INT &#39;\n&#39; ;
</code></pre></div>
<p>我们可以给RETR序列打上retr规则的标签，这样在语法的其它地方，我们就能使用规则名字作为简写来引用RETR序列。</p>

<p>对于任意长度的序列像矢量[1 2 3]这样的简单整数列表，虽然它是一个有限序列，但我们不可能通过像INT INT INT ...这样的规则片段来列出所有可能的整数列表。为了编码这样的一个或者多个元素，我们使用“+”子规则运算符。例如，{INT}+表示任意长度的整数序列，或者使用简写INT+也可以。至于可以为空的列表，我们则使用零个或者多个运算符“*”。</p>

<p>这种模式的变体有带终结符的序列和带分隔符的序列，CSV文件就很好地示范了这两者。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">file : (row &#39;\n&#39;)* ;           // 带一个“\n”终结符的序列
row  : field (&#39;,&#39; field)* ;    // 带一个“,”分隔符的序列
field: INT ;                   // 假设字段只是整数
</code></pre></div>
<p>规则file使用带终结符模式的列表去匹配零个或者多个row &#39;\n&#39;序列，记号“\n”终结序列的每个元素。规则row使用带分隔符模式的列表去匹配一个field后面有零个或者多个&#39;,&#39; field序列，记号“,”分隔各个字段。</p>

<p>最后，还有个特殊类型的零个或者一个序列，用“?”指定。可以使用它去表达可选的构造体。</p>

<h4 id="模式：选择">模式：选择</h4>

<p>这是一个在多个可供替代的短语之间的选择，比如在编程语言中不同种类的语句。为了在语言中表示选择的这个概念，我们使用“|”作为ANTLR中的“or”运算符去分隔被称为“选项”的语法选择。</p>

<p>回到CVS语法，我们可以通过整数或者字符串的选择让规则field变得更灵活。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">field: INT | STRING ;
</code></pre></div>
<p>任何时候，如果你发现正在说“语言结构x可以是这个或者那个”，那么你就可以确定应该使用选择模式，在规则x中使用“|”。</p>

<h4 id="模式：记号依赖">模式：记号依赖</h4>

<p>记号依赖表示一个记号的存在需要在短语的其它地方有它的对等物的存在，比如匹配的左右括号。前面我们曾经使用INT+去表达在矢量[1 2 3]中的整数非空序列。为指定周围有方括号的矢量，我们需要一种方法去表达记号中的依赖。如果我们在句子中看到一个符号，那么我们必须在句子的其它地方找到它的对等物。为表达这种语法，我们必须使用同时指定对等符号的序列，它们通常包围或分组着其它元素。在这个案例中，我们这样指定矢量：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">vector : &#39;[&#39; INT+ &#39;]&#39; ;    // [1], [1 2], [1 2 3], ...
</code></pre></div>
<p>扫视任何有效的代码，你会看到必须成对出现的各种分组符号：(...)，[...]，{...}。但是要牢记，依赖符号并不是必须配对的，类C语言都有的a ? b : c三元运算符就指定了当看到“?”符号时需要在接下来的短语中看到“:”符号。</p>

<h4 id="模式：嵌套短语">模式：嵌套短语</h4>

<p>嵌套短语有一个自相似的语言结构，它的子短语也遵循相同的结构。表达式是典型的自相似语言结构，由被运算符分隔的嵌套子表达式组成。类似地，while的代码块是嵌套在外部代码块内的一个代码块。我们在语法中使用递归规则表达自相似的语言结构。因此，如果规则的伪代码引用它自身，我们将需要一个递归的自引用规则。</p>

<p>让我们来看下代码块的嵌套是如何工作的。while语句是关键词while跟随一个在括号中的条件表达式再跟随一个语句。我们也可以把多条语句包裹在花括号里当作一个单块语句。表达语法如下所示：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">stat: &#39;while&#39; &#39;(&#39; expr &#39;)&#39; stat    // 匹配WHILE语句
    | &#39;{&#39; stat* &#39;}&#39;                // 匹配在括号中的语句块
    ;
</code></pre></div>
<p>这里的stat可以是单条语句或者被花括号括起来的一组语句。规则stat是直接递归的，因为它在两个选项中直接引用它自身。如果我们把第二个选项移到它自己的规则中，规则stat和block将是双向间接递归的。语法如下所示：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">stat: &#39;while&#39; &#39;(&#39; expr &#39;)&#39; stat    // 匹配WHILE语句
    | &#39;{&#39; stat* &#39;}&#39;                // 匹配语句块
    ;
block: &#39;{&#39; stat* &#39;}&#39; ;             // 匹配在括号中的语句块
</code></pre></div>
<p>看下面仅有3类表达式（索引数组引用、括号表达式和整数）的简单语言的语法：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">expr: ID &#39;[&#39; expr &#39;]&#39;    // a[1], a[b[1]], a[(2*b[1])]
    | &#39;(&#39; expr &#39;)&#39;       // (1), (a[1]), (((1))), (2*a[1])
    | INT                // 1, 94117
    ;
</code></pre></div>
<p>注意递归是如何自然地发生的。数组索引表达式的索引组件是表达式本身，因此我们只需要在选项中引用expr即可。</p>

<p>下图是关于两个例子输入的语法分析树：</p>

<p><img src="/uploads/expr-parse-tree.png" title="expr-parse-tree" ></p>

<p>分析树中的内部树节点是规则引用，叶子是记号引用。从树根到任何节点的路径表示元素的规则调用栈（或者ANTLR生成的递归下降语法分析器调用栈）。路径代表递归嵌套的子树有多个相同规则的引用。规则节点是其下方子树的标签。根节点是expr，所以整棵树是一个表达式。在1之前的那棵expr子树会把整数当作一个表达式。</p>

<p>为实现这些模式，我们只需要由选项、记号引用、规则引用组成的语法规则即可。我们还可以把这些元素组成子规则，子规则是裹在括号内的行内规则。我们也可以将子规则标记为“?”或“*”或“+”循环去识别被包围的语法片段多次。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（15）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part15/"/>
    <updated>2016-05-22T17:51:36+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part15</id>
    <content type="html"><![CDATA[<p>在聚焦到具体的语法规则内部结构之前，我们要先讨论下语法的整体剖析以及如何形成一套初始的语法骨架。</p>

<p>文法文件通常是由一个命名文法的头和一系列可以彼此调用的规则组成。就像下面的那样：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grammar MyG;
rule1 : «stuff» ;
rule2 : «more stuff» ;
...
</code></pre></div>
<p>设计语法就是要搞清楚«stuff»是什么？哪个规则是开始规则。这要求我们需要知道给定语言的一系列代表性的输入例子。当然，从语言参考手册或者其它语法分析器生成器格式而来的语法也是有帮助的。</p>

<p>正确设计语法的方法是借鉴功能分解或者自顶向下的设计，从粗粒度级别到细粒度级别逐步定义语言结构并把它们编码为语法规则。所以，我们的第一个任务就是找到粗粒度语言结构的名字，同时它也是开始规则。在英语中我们使用sentence，对于XML文件来说它则是document。</p>

<p>设计开始规则的内容是用英语伪代码描述整个输入格式的问题。例如，“a comma-separated-value (CSV) file is a sequence of rows terminated by newlines.”这段文字，在is a左边的至关重要的单词file是规则名字，在is a右边的所有内容则成为在规则定义右则的«stuff»的内容：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">file : «sequence of rows that are terminated by newlines» ;
</code></pre></div>
<p>然后我们通过描述在开始规则右侧被确定的元素来进行下一个粒度级别的设计。在规则右侧的名词通常是对记号或尚未定义的规则的引用，这些记号是那些我们在正常情况下视为单词、标点符号、运算符的元素。就像单词是英语句子中的原子成分那样，记号在语法规则中也是如此。规则引用则涉及到像row那样需要被分解为更详细部分的其它语言结构。</p>

<p>进入细节的另外一层，我们可以说row是一系列被逗号分隔的field，而field则是一个数字或字符串。就像以下所示：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">row   : «sequence of fields separated by commas» ;
field : «number or string» ;
</code></pre></div>
<p>当没有规则需要再定义时，我们就得到了语法的一个粗略的草图。</p>

<p>如果有其它格式的语法作为参考的话设计语法会容易的多，但小心不要盲目地遵循它，否则你会误入歧途的。非ANTLR格式的语法只是让你知道别人是如何决定分解语言中的短语的，它最大的作用就是可以给我们一份规则名称的列表用作参考。</p>

<p>不推荐从参考手册上复制粘贴语法到ANTLR，然后再通过细微的调整让它工作。把它当作一套指南而不是一段代码是更好的办法。为了清晰地描述语法，参考手册通常是相当松散的。这意味着语法能识别大量不在语言中的句子，或者语法可能不够明确，可以用多种方法匹配相同的输入序列。例如，语法可能会说表达式可以调用一个构建器或者访问一个函数，问题是像T(i)这样的输入可以同时匹配两者。理想情况下，在语法中是不能有这样的二义性的，每个输入句子我们只需要一种解释。</p>

<p>在另一个极端，参考手册中的语法有时过于明确地说明了规则。有些约束是需要在分析完输入后实施的，而不是试图对语法结构实施约束。例如，W3C XML语法就显式地指定标签中什么地方必须要有空格以及什么地方的空格可以省略。但事实是我们可以简单地让词法分析器在把记号发送给语法分析器之前去除空格，不需要在语法中到处测试它。</p>

<p>规格还说&lt;?xml ...&gt;标签可以有两个附加属性encoding和standalone。我们需要知道约束，但它是很容易去允许任何属性名字，然后在语法分析后检查语法分析树，以确保所有这些限制都满足的。
归根结底，XML只是嵌在文本中的一对标签，因此它的语法结构是相当直白的。唯一的挑战是如何分别对待什么在标签内以及什么在标签外。</p>

<p>识别语法规则并用伪代码表示它们的右侧部分最初是个挑战，但当你为更多的语言构建语法后它会变得越来越容易。一旦我们有了伪代码，我们就需要把它转换成ANTLR表示法，以便能得到一个可工作的语法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（14）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part14/"/>
    <updated>2016-05-16T20:26:22+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part14</id>
    <content type="html"><![CDATA[<p>对于大多数语法，注释和空格都是语法分析器可以忽略的东西。如果我们不想让注释和空格在语法中到处都是，那么就需要让词法分析器把它们扔掉。不幸的是，这意味着任何后续处理步骤都不能再访问注释和空格。安全地忽略掉注释和空格的方法是把这些发送给语法分析器的记号放到一个“隐藏通道”中，语法分析器仅需要调协到单个通道即可。我们可以把任何我们想要的东西传递到其它通道中。这里是如何实现的语法：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">COMMENT
    : &#39;/*&#39; .*? &#39;*/&#39; -&gt; channel(HIDDEN)    // match anything between /* and */
    ;

WS  : [ \r\t\n]+    -&gt; channel(HIDDEN)
    ;
</code></pre></div>
<p>就像我们前面讨论过的<code>-&gt; skip</code>那样，<code>-&gt; channel(HIDDEN)</code>也是一个的词法分析器指令。在这里，它设置那些记号的通道号码以便这些记号可以被语法分析器忽略。记号流仍然维护着原始的记号序列，但在喂食给语法分析器时则略过离线通道中的记号。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（13）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part13/"/>
    <updated>2016-05-06T18:24:18+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part13</id>
    <content type="html"><![CDATA[<p>现在准备要构建一个工具，用来把<a href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part7/">ANTLR 4权威参考读书笔记（7）</a>中idata.txt里的数据按group分行显示，就像这样：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">2 9 10
3 1 2 3
</code></pre></div>
<p>我们可以借助语法分析树的Listener机制来对词法分析结束后生成的记号流进行改写，我们不需要实现每一个Listener接口方法，只需要在捕获到group的时候把换行符插到它末尾就行。实现改写的代码如下所示：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">import org.antlr.v4.runtime.TokenStream;
import org.antlr.v4.runtime.TokenStreamRewriter;

public class RewriteListener extends IDataBaseListener {
    TokenStreamRewriter rewriter;

    public RewriteListener(TokenStream tokens) {
        rewriter = new TokenStreamRewriter(tokens);
    }

    @Override
    public void enterGroup(IDataParser.GroupContext ctx) {
        rewriter.insertAfter(ctx.stop, &#39;\n&#39;);
    }
}
</code></pre></div>
<p>接着就是写一个小程序来调用我们上面的改写类：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.tree.*;
import java.io.FileInputStream;
import java.io.InputStream;

public class IData {

    public static void main(String[] args) throws Exception {
        InputStream is = args.length &gt; 0 ? new FileInputStream(args[0]) : System.in;

        ANTLRInputStream input = new ANTLRInputStream(is);
        IDataLexer lexer = new IDataLexer(input);
        CommonTokenStream tokens = new CommonTokenStream(lexer);
        IDataParser parser = new IDataParser(tokens);
        ParseTree tree = parser.file();

        RewriteListener listener = new RewriteListener(tokens);

        System.out.println(&quot;Before Rewriting&quot;);
        System.out.println(listener.rewriter.getText());

        ParseTreeWalker walker = new ParseTreeWalker();
        walker.walk(listener, tree);

        System.out.println(&quot;After Rewriting&quot;);
        System.out.println(listener.rewriter.getText());
    }
}
</code></pre></div>
<p>这里的关键是TokenStreamRewriter对象知道如何在不修改流的情况下提供一个记号流的修改过的视图。它把所有的操作方法当作指令并把它们排进队列，等到在遍历记号流把它作为文本渲染回去的时候延迟执行。每次我们调用getText()时rewriter就会执行那些指令。</p>

<p>最后就是构建和测试应用：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr IData.g
compile *.java
run IData idata.txt
</code></pre></div>
<p>以下是输出结果：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Before Rewriting
29103123
After Rewriting
2910
3123
</code></pre></div>
<p>仅用几行代码，我们就能够没有任何烦恼地对某些内容做轻微的调整。这种策略对于源代码检测或重构这类一般性的问题是非常有效的。TokenStreamRewriter是一个非常强大且有效的操作记号流的方法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（12）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part12/"/>
    <updated>2016-04-26T10:20:44+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part12</id>
    <content type="html"><![CDATA[<ul>
<li>sentinel 哨兵</li>
<li>tag 标签</li>
</ul>

<p>目前我们看到的输入文件都只包含一种语言，但在实际应用中我们会遇到有些包含多种语言的常用文件格式。例如，Java的文档注释，XML文件等。这些环绕着模板表达式的文本需要不同的处理方式，它们被称为孤岛语言。</p>

<p>ANTLR有提供一个称之为“词法模型”的词法分析器特性，它让我们可以很容易地处理包含混合格式的文件。基本思路是：当词法分析器看到特殊的哨兵字符序列时，让它在模式之间来回切换。</p>

<p>XML是一个很好例子，它通常会在同一个文件中包含不同的词法结构。一个XML语法分析器会把除标签和实体引用（例如&hearts;）之外的任何东西当作文本块。当词法分析器看到<code>&lt;</code>时，它切换到“inside”模式；当它看到<code>&gt;</code>或<code>/&gt;</code>时，就切换回默认模式。以下语法展示了该特性是如何工作的：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">lexer grammar XMLLexer;

// Default &quot;mode&quot;: Everything OUTSIDE of a tag
OPEN        :   &#39;&lt;&#39;                 -&gt; pushMode(INSIDE) ;
COMMENT     :   &#39;&lt;!--&#39; .*? &#39;--&gt;&#39;    -&gt; skip ;
EntityRef   :   &#39;&amp;&#39; [a-z]+ &#39;;&#39; ;
TEXT        :   ~(&#39;&lt;&#39;|&#39;&amp;&#39;)+ ;    // match any 16 bit char minus &lt; and &amp;

// ----------------- Everything INSIDE of a tag ---------------------
mode INSIDE;

CLOSE       :   &#39;&gt;&#39;                 -&gt; popMode ;    // back to default mode
SLASH_CLOSE :   &#39;/&gt;&#39;                -&gt; popMode ;
EQUALS      :   &#39;=&#39; ;
STRING      :   &#39;&quot;&#39; .*? &#39;&quot;&#39; ;
SlashName   :   &#39;/&#39; Name ;
Name        :   ALPHA (ALPHA|DIGIT)* ;
S           :   [ \t\r\n]           -&gt; skip ;

fragment
ALPHA       :   [a-zA-Z] ;

fragment
DIGIT       :   [0-9] ;
</code></pre></div>
<p>把上述语法保存为XMLLexer.g文件，然后使用包含以下内容的t.xml文件作为输入来测试它：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&lt;tools&gt;
  &lt;tool name=&quot;ANTLR&quot;&gt;A parser generator&lt;/tool&gt;
&lt;/tools&gt;
</code></pre></div>
<p>以下是构建和运行测试的命令：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr XMLLexer.g
compile *.java
grun XML tokens -tokens t.xml
</code></pre></div>
<p>这里是输出的内容：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">[@0,0:0=&#39;&lt;&#39;,&lt;1&gt;,1:0]
[@1,1:5=&#39;tools&#39;,&lt;10&gt;,1:1]
[@2,6:6=&#39;&gt;&#39;,&lt;5&gt;,1:6]
[@3,7:10=&#39;\r\n  &#39;,&lt;4&gt;,1:7]
[@4,11:11=&#39;&lt;&#39;,&lt;1&gt;,2:2]
[@5,12:15=&#39;tool&#39;,&lt;10&gt;,2:3]
[@6,17:20=&#39;name&#39;,&lt;10&gt;,2:8]
[@7,21:21=&#39;=&#39;,&lt;7&gt;,2:12]
[@8,22:28=&#39;&quot;ANTLR&quot;&#39;,&lt;8&gt;,2:13]
[@9,29:29=&#39;&gt;&#39;,&lt;5&gt;,2:20]
[@10,30:47=&#39;A parser generator&#39;,&lt;4&gt;,2:21]
[@11,48:48=&#39;&lt;&#39;,&lt;1&gt;,2:39]
[@12,49:53=&#39;/tool&#39;,&lt;9&gt;,2:40]
[@13,54:54=&#39;&gt;&#39;,&lt;5&gt;,2:45]
[@14,55:56=&#39;\r\n&#39;,&lt;4&gt;,2:46]
[@15,57:57=&#39;&lt;&#39;,&lt;1&gt;,3:0]
[@16,58:63=&#39;/tools&#39;,&lt;9&gt;,3:1]
[@17,64:64=&#39;&gt;&#39;,&lt;5&gt;,3:7]
[@18,65:66=&#39;\r\n&#39;,&lt;4&gt;,3:8]
[@19,67:66=&#39;&lt;EOF&gt;&#39;,&lt;-1&gt;,4:0]
</code></pre></div>
<p>上面输出的每一行代表一个记号，包含记号索引、开始和结束字符、记号文本、记号类型，最后的行和字符位置则告诉我们词法分析器如何标记化输入。</p>

<p>在命令行中，XML tokens序列处通常是一个语法名字后面跟着开始规则，但在这里，我们使用语法名字后面跟着特殊的规则名字tokens来告诉TestRig应该运行词法分析器而不是语法分析器。接着使用选项-tokens打印出匹配的记号列表。</p>
]]></content>
  </entry>
  
</feed>
