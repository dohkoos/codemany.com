<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: ANTLR | 乐者为王]]></title>
  <link href="http://codemany.com/tags/antlr/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2017-01-18T20:24:55+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（28）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part28/"/>
    <updated>2016-10-06T18:42:25+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part28</id>
    <content type="html"><![CDATA[<ul>
<li>scope 作用域</li>
</ul>

<p>为了阐明Cymbol语法是可复用的，本节中我们将在不做修改的基础上再次使用它，用于构建一个完全不同的应用。不仅如此，我们还会在同样的树上使用两个不同的监听器做两次遍历。</p>

<h3 id="验证程序符号的使用情况">验证程序符号的使用情况</h3>

<p>为Cymbol这样的编程语言构建解释器、编译器或者转换器，我们需要验证Cymbol程序是否正确地使用符号（标志符）。接下来，我们将构建一个Cymbol验证器用于检查以下的条件：</p>

<ul>
<li>可见的变量引用有相应的定义（在作用域内）。</li>
<li>函数引用有相应的定义（函数可以以任何顺序出现）。</li>
<li>变量不作为函数使用。</li>
<li>函数不作为变量使用。</li>
</ul>

<p>让我们看一下有许多不同引用的Cymbol示例代码，其中有些是无效的。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">int f(int x, float y) {
    g();      // forward reference is ok
    i = 3;    // no declaration for i (error)
    g = 4;    // g is not variable (error)
    return x + y;    // x, y are defined, so no problem
}
void g() {
    int x = 0;
    float y;
    y = 9;    // y is defined
    f();      // backward reference is ok
    z();      // no such function (error)
    y();      // y is not function (error)
    x = f;    // f is not a variable (error)
}
</code></pre></div>
<p>为验证程序中的一切都没问题，根据前面的条件，我们应该打印出函数列表和本地变量以及全局符号列表（函数和全局变量）。更进一步，当我们发现问题时应该给出一个错误。例如，使用上述输入，让我们构建一个称为CheckSymbols的应用。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">java CheckSymbols vars.cymbol
</code></pre></div>
<p>在执行以上命令后会生成如下输出：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">locals:[]
function&lt;f:tINT&gt;:[&lt;x:tINT&gt;, &lt;y:tFLOAT&gt;]
locals:[x, y]
function&lt;g:tVOID&gt;:[]
globals:[f, g]
line 3:4 no such variable: i
line 4:4 g is not a variable
line 13:4 no such function: z
line 14:4 y is not a function
line 15:8 f is not a variable
</code></pre></div>
<p>实现这类问题的关键是一个被称为符号表的相应的数据结构。我们的应用会把符号存在符号表中，然后通过在符号表中查找符号引用检查它们的正确性。在接下来的部分，我们将大概看一看数据结构看起来像什么，并且使用它去解决手头的验证问题。</p>

<h3 id="符号表中的速成课">符号表中的速成课</h3>

<p>语言实现者通常称持有符号的数据结构为符号表。语言的实现决定符号表的结构和复杂性，如果一门语言允许相同的标志符在不同的上下文中指向不同的东西，符号表会将那些符号分组到不同的作用域中。作用域只是一组符号，例如函数的参数列表或变量列表以及在全局作用域内的函数。</p>

<p>符号表自身只是一个符号定义的存储库——它不作任何检查。为了验证代码，我们需要检查表达式中违反我们之前设置的规则的变量和函数引用。符号验证有两个基本操作：定义符号和解决符号。定义一个符号意味着把它添加到一个作用域中。解决一个符号意味着计算出符号指向哪个定义。在某种程度上，解决一个符号意味着找到最近的匹配定义。最近的作用域是最近的封闭作用域。例如，让我们看看另一个Cymbol例子，它在不同的作用域有符号定义。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">int x;
int y;
void a()
{
    int x;
    x = 1;
    // x resolves to current scope, not x in global scope
    y = 2;
    // y is not found in current scope, but resolves in global
    { int y = x; }
}
void b(int z)
{ }
</code></pre></div>
<p>全局作用域包含变量x和y以及函数a()和b()。函数处于全局作用域，但它们也构成新的作用域用于持有函数的参数，如果有的话。同样嵌套在函数作用域内的是函数本地代码块，它们构成另一个新的作用域。本地变量被约束在嵌套在函数作用域内的本地作用域内。</p>

<p>因为符号x被定义了两次，所以做不到仅把所有标识符都填充进单个集合而没有冲突。这也是作用域出现的原因。我们保留一组作用域，并且一个作用域中的每个标志符只允许有单个定义。我们还保留一个指向父作用域的指针，以便在外层作用域中找到符号定义。这些作用域形成了一棵树。</p>

<p><img src="/uploads/cymbol-scope-tree.png" title="cymbol-scope-tree" ></p>

<p>沿着从任何作用域到根（全局作用域）的路径的所有节点形成一堆作用域。为了找到一个符号的定义，我们从围绕着引用的作用域开始，并沿着作用域树向上遍历，直到找到它的定义。</p>

<h3 id="验证器架构">验证器架构</h3>

<p>开始构建验证器前，先让我们思考下大方向和总体策略。我们可以根据关键操作——定义和解决——把问题分解。对于定义，我们需要侦听变量和函数定义事件，然后把符号对象插入围绕着定义的作用域。在函数定义的开始处，我们需要压栈一个新的作用域，然后在函数定义的结尾处把它出栈。</p>

<p>为解决和检查符号引用，我们需要侦听在表达式中的变量和函数名字引用。针对每个引用，我们将验证是否有匹配的定义，以及引用是否正确使用符号。</p>

<p>这似乎很直截了当，但有个并发症：在源码文件中，Cymbol程序可以调用在它之后定义的一个函数。我们称它为前向引用。为支持这个特性，我们需要在语法分析树上执行两次遍历。第一遍，或者阶段，定义包含函数的符号，然后第二遍进行解决。用这种方法，第二遍可以看到文件中的所有函数。以下是用于触发在语法分析树上两次遍历的代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">ParseTreeWalker walker = new ParseTreeWalker();
DefPhase def = new DefPhase();
walker.walk(def, tree);
// create next phase and feed symbol table info from def to ref phase
RefPhase ref = new RefPhase(def.globals, def.scopes);
walker.walk(ref, tree);
</code></pre></div>
<p>在定义阶段，我们将创建许多作用域。除非我们保持对它们的引用，否则垃圾收集器会回收它们。为了符号表能够度过从定义到解决阶段的转变，我们需要追踪这些作用域。储存它们最合乎逻辑的地方是在语法分析树本身（或者，从技术上讲，使用关联值与树节点的注解映射）。然后引用阶段就可以在它下行语法分析树时很简单地获得当前作用域的指针。与函数和本地块关联的树节点将可以获得它们的作用域的指针。</p>

<h3 id="定义和解决符号">定义和解决符号</h3>

<p>考虑到我们的基本策略，让我们从DefPhase开始构建我们的验证器。这个阶段类需要3个字段：一个全局作用域的引用、一个用于追踪我们创建的作用域的语法分析树注解器，以及一个当前作用域的指针。enterFile()的监听器代码在活动开始时创建全局变量。当活动结束时，exitFile()负责打印结果。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class DefPhase extends CymbolBaseListener {
    ParseTreeProperty&lt;Scope&gt; scopes = new ParseTreeProperty&lt;Scope&gt;();
    GlobalScope globals;
    Scope currentScope;    // define symbols in this scope
    public void enterFile(CymbolParser.FileContext ctx) {
        globals = new GlobalScope(null);
        currentScope = globals;
    }
    public void exitFile(CymbolParser.FileContext ctx) {
        System.out.println(globals);
    }
</code></pre></div>
<p>当语法分析器找到函数声明时，应用需要创建一个FunctionSymbol对象。作为一个符号和作为一个包含参数的作用域，FunctionSymbol对象负有双重责任。为把函数作用域嵌套在全局作用域内，我们需要把函数作用域压栈。我们通过设置函数的封闭作用域为当前作用域并重置当前作用域来做到这点。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void enterFunctionDecl(CymbolParser.FunctionDeclContext ctx) {
    String name = ctx.ID().getText();
    int typeTokenType = ctx.type().start.getType();
    Symbol.Type type = CheckSymbols.getType(typeTokenType);

    // push new scope by making new one that points to enclosing scope
    FunctionSymbol function = new FunctionSymbol(name, type, currentScope);
    currentScope.define(function);    // Define function in current scope
    saveScope(ctx, function);         // Push: set function&#39;s parent to current
    currentScope = function;          // Current scope is now function scope
}

void saveScope(ParserRuleContext ctx, Scope s) {
    scopes.put(ctx, s);
}
</code></pre></div>
<p>方法saveScope()使用函数作用域注解functionDecl规则节点，以便在随后的引用阶段可以获得它。当我们离开函数时就出栈函数作用域，因此当前作用域仍然是全局作用域。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitFunctionDecl(CymbolParser.FunctionDeclContext ctx) {
    System.out.println(currentScope);
    currentScope = currentScope.getEnclosingScope();    // pop scope
}
</code></pre></div>
<p>本地作用域以类似的方式工作。我们在监听器方法enterBlock()中压栈一个作用域，然后在exitBlock()中出栈它。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（27）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part27/"/>
    <updated>2016-09-28T09:32:41+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part27</id>
    <content type="html"><![CDATA[<p>前面我们主要处理的是数据，今天我们就来做些编程语言方面的事情。</p>

<h3 id="生成调用关系图">生成调用关系图</h3>

<p>软件很难编写和维护，这就是为什么我们试图构建工具去提高我们的生产力和工作效率。例如，在过去的十年里，我们已经看到测试框架、代码覆盖工具和代码分析器的激增，也很高心看到类层次结构的可视化树，以及大部分开发环境支持这个功能。其中有种可视化被称为调用图，它由函数作为节点，并且函数调用作为节点间的有向边。</p>

<p>这本节中，我们将使用Cymbol语法构建一个调用图生成器。考虑以下函数和函数调用集：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">int main() { fact(); a(); }
float fact(int n) {
    print(n);
    if (n == 0) then return 1;
    return n * fact(n - 1);
}
void a() { int x = b(); if false then {c(); d();} }
void b() { c(); }
void c() { b(); }
void d() { }
void e() { }
</code></pre></div>
<p>我们将会把它可视化成如下的调用图：</p>

<p><img src="/uploads/cymbol-call-graph.png" title="cymbol-call-graph" ></p>

<p>可视化的好处是人眼可以很容易地挑出偏差。例如，e()节点是个孤立节点，它意味着没有函数调用它，因此它是一段死代码。一目了然，我们找到一个可以被丢弃的函数。我们还可以通过在图中寻找像fact() -&gt; fact()和b() -&gt; c() -&gt; d()这样的循环非常容易地检测递归。</p>

<p>为了可视化调用图，我们需要读入一段Cymol程序和创建一个DOT文件。例如，以下是我们需要为t.cymbol生成的DOT文件。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">digraph G {
    ranksep=.25;
    edge [arrowsize=.5]
    node [shape=circle, fontname=&quot;ArialNarrow&quot;,
    fontsize=12, fixedsize=true, height=.45];
    main; fact; a; b; c; d; e;
    main -&gt; fact;
    main -&gt; a;
    fact -&gt; print;
    fact -&gt; fact;
    a -&gt; b;
    a -&gt; c;
    a -&gt; d;
    b -&gt; c;
    c -&gt; b;
}
</code></pre></div>
<p>上面的输出包括样本设置描述，例如ranksep=.25;和一列节点和边。为抓住孤立节点，我们需要确保为每个函数名生成节点定义，即使它没有出边和入边。否则它将不会出现在图中。注意在节点定义行末尾的e节点。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">main; fact; a; b; c; d; e;
</code></pre></div>
<p>我们的策略很简单，当语法分析器找到一个函数声明时，应用会把当前函数名添加到一个列表，并且设置一个字段称为currentFunctionName。当语法分析器看到一个函数调用，应用会记录从currentFunctionName到被调用函数名的一条边。</p>

<p>开始之前，让我们给Cymbol.g中的一些规则选项打上标签，以便获得更精确的监听器方法。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">expr: ID &#39;(&#39; exprList? &#39;)&#39;    # Call
    | expr &#39;[&#39; expr &#39;]&#39;       # Index
    | &#39;-&#39; expr                # Negate
    | &#39;!&#39; expr                # Not
    | expr &#39;*&#39; expr           # Mult
    | expr (&#39;+&#39;|&#39;-&#39;) expr     # AddSub
    | expr &#39;==&#39; expr          # Equal
    | ID                      # Var
    | INT                     # Int
    | &#39;(&#39; expr &#39;)&#39;            # Parens
    ;
</code></pre></div>
<p>然后，作为语言应用的基础，把所有图相关的东西封装进一个类。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">static class Graph {
    // I&#39;m using org.antlr.v4.runtime.misc: OrderedHashSet, MultiMap
    Set&lt;String&gt; nodes = new OrderedHashSet&lt;String&gt;();    // list of functions
    MultiMap&lt;String, String&gt; edges = new MultiMap&lt;String, String&gt;();    // caller-&gt;callee
    public void edge(String source, String target) {
        edges.map(source, target);
    }
</code></pre></div>
<p>从节点和边的集合中，我们可以在类Graph的toDOT()中使用一些Java代码转储出适当的DOT代码。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public String toDOT() {
    StringBuilder buf = new StringBuilder();
    buf.append(&quot;digraph G {\n&quot;);
    buf.append(&quot;    ranksep=.25;\n&quot;);
    buf.append(&quot;    edge [arrowsize=.5]\n&quot;);
    buf.append(&quot;    node [shape=circle, fontname=\&quot;ArialNarrow\&quot;,\n&quot;);
    buf.append(&quot;    fontsize=12, fixedsize=true, height=.45];\n&quot;);
    buf.append(&quot;    &quot;);
    for (String node : nodes) {    // print all nodes first
        buf.append(node);
        buf.append(&quot;; &quot;);
    }
    buf.append(&quot;\n&quot;);
    for (String src : edges.keySet()) {
        for (String trg : edges.get(src)) {
            buf.append(&quot;    &quot;);
            buf.append(src);
            buf.append(&quot; -&gt; &quot;);
            buf.append(trg);
            buf.append(&quot;;\n&quot;);
        }
    }
    buf.append(&quot;}\n&quot;);
    return buf.toString();
}
</code></pre></div>
<p>现在我们要做的是使用监听器填满这些数据结构，监听器需要两个字段用于记录。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">static class FunctionListener extends CymbolBaseListener {
    Graph graph = new Graph();
    String currentFunctionName = null;
</code></pre></div>
<p>然后应用只需要监听两个事件。首先，在语法分析器发现函数声明时记录当前的函数名。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void enterFunctionDecl(CymbolParser.FunctionDeclContext ctx) {
    currentFunctionName = ctx.ID().getText();
    graph.nodes.add(currentFunctionName);
}
</code></pre></div>
<p>其次，当语法分析器侦测到函数调用时，应用需要记录从当前函数到被调用函数的一条边。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitCall(CymbolParser.CallContext ctx) {
    String funcName = ctx.ID().getText();
    // map current function to the callee
    graph.edge(currentFunctionName, funcName);
}
</code></pre></div>
<p>注意，函数调用不能隐藏在嵌套代码块或诸如a()这样的声明中。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">void a() { int x = b(); if false then {c(); d();} }
</code></pre></div>
<p>无论什么时候，只要树遍历器发现函数调用就触发监听器方法exitCall()。</p>

<p>通过语法分析树和类FunctionListener，我们可以启动带有监听器的一个遍历器去产生输出。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">ParseTreeWalker walker = new ParseTreeWalker();
FunctionListener collector = new FunctionListener();
walker.walk(collector, tree);
System.out.println(collector.graph.toString())
</code></pre></div>
<p>在转储DOT字符串前，该代码会打印出函数和边的列表。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr Cymbol.g
compile *.java
run CallGraph t.cymbol
</code></pre></div>
<p>以下是部分输出结果：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">edges: {main=[fact, a], fact=[print, fact], a=[b, c, d], b=[c], c=[b]},
functions: [main, fact, a, b, c, d, e]
digraph G {
ranksep=.25;
edge [arrowsize=.5]
...
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（26）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part26/"/>
    <updated>2016-09-09T22:22:47+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part26</id>
    <content type="html"><![CDATA[<p>今天准备做的是把JSON文本文件转换成XML文本文件。</p>

<h3 id="把json转换成xml">把JSON转换成XML</h3>

<p>许多Web服务返回的是JSON数据，但是我们可能会遇到一种情况，需要把JSON数据送给那些只接受XML数据的代码。这就需要我们构建一个JSON到XML的转换器。我们的目标是读入像下面这样的JSON数据：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">{
&quot;description&quot; : &quot;An imaginary server config file&quot;,
&quot;logs&quot; : {&quot;level&quot;:&quot;verbose&quot;, &quot;dir&quot;:&quot;/var/log&quot;},
&quot;host&quot; : &quot;antlr.org&quot;,
&quot;admin&quot;: [&quot;parrt&quot;, &quot;tombu&quot;],
&quot;aliases&quot;: []
}
</code></pre></div>
<p>放出等价的XML数据，就像下面这样的：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&lt;description&gt;An imaginary server config file&lt;/description&gt;
&lt;logs&gt;
  &lt;level&gt;verbose&lt;/level&gt;
  &lt;dir&gt;/var/log&lt;/dir&gt;
&lt;/logs&gt;
&lt;host&gt;antlr.org&lt;/host&gt;
&lt;admin&gt;
  &lt;element&gt;parrt&lt;/element&gt;
  &lt;element&gt;tombu&lt;/element&gt;
&lt;/admin&gt;
&lt;aliases&gt;&lt;/aliases&gt;
</code></pre></div>
<p>正如我们对CSV做的那样，让我们给JSON语法中的一些选项打上标签，以便让ANTLR生成更精确的监听器方法。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">object
    : &#39;{&#39; pair (&#39;,&#39; pair)* &#39;}&#39;    # AnObject
    | &#39;{&#39; &#39;}&#39;                     # EmptyObject
    ;
array
    : &#39;[&#39; value (&#39;,&#39; value)* &#39;]&#39;  # ArrayOfValues
    | &#39;[&#39; &#39;]&#39;                     # EmptyArray
    ;
</code></pre></div>
<p>我们将对规则value做同样的事，但是稍有不同。除3个选项外的其它所有选项只需要返回被匹配的值的文本，所以我们可以为其它所有选项使用相同的标签，使语法分析树遍历器为那些选项触发相同的监听器方法。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">value
    : STRING    # String
    | NUMBER    # Atom
    | object    # ObjectValue
    | array     # ArrayValue
    | &#39;true&#39;    # Atom
    | &#39;false&#39;   # Atom
    | &#39;null&#39;    # Atom
    ;
</code></pre></div>
<p>为构建这样的转换器，明智的做法是让每个规则返回被它匹配的输入短语的XML等价物。为追踪部分结构，我们使用字段xml和两个帮助方法来注解语法分析树。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public static class XMLEmitter extends JSONBaseListener {
    ParseTreeProperty&lt;String&gt; xml = new ParseTreeProperty&lt;String&gt;();
    String getXML(ParseTree ctx) { return xml.get(ctx); }
    void setXML(ParseTree ctx, String s) { xml.put(ctx, s); }
</code></pre></div>
<p>我们把每棵子树转换后的字符串挂载到该子树的根节点。在语法分析树更高节点上工作的方法可以捕获这些值以便计算更大的字符串。然后挂载在根节点上的字符串完成计算。</p>

<p>让我们从最简单的转换开始。value的Atom选项返回匹配记号的文本。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitAtom(JSONParser.AtomContext ctx) {
    setXML(ctx, ctx.getText());
}
</code></pre></div>
<p>字符串基本上是相同的，只是我们必须去除双引号。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitString(JSONParser.StringContext ctx) {
    setXML(ctx, stripQuotes(ctx.getText()));
}
</code></pre></div>
<p>如果value()规则方法找到一个对象或数组，它可以把组合元素的部分转换拷贝到它自己的语法分析树节点。以下代码是找到对象时的处理：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitObjectValue(JSONParser.ObjectValueContext ctx) {
    // analogous to String value() {return object();}
    setXML(ctx, getXML(ctx.object()));
}
</code></pre></div>
<p>一旦我们可以转换所有的值，我们需要担心名-值对以及把它们转换成标签和文本。生成的XML的标签名字来源于STRING &#39;:&#39; value选项中的STRING。在左右尖括号之间的文本来源于挂载在value子节点上的文本。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitPair(JSONParser.PairContext ctx) {
    String tag = stripQuotes(ctx.STRING().getText());
    JSONParser.ValueContext vctx = ctx.value();
    String x = String.format(&quot;&lt;%s&gt;%s&lt;/%s&gt;\n&quot;, tag, getXML(vctx), tag);
    setXML(ctx, x);
}
</code></pre></div>
<p>JSON对象由名-值对组成。因此，对于被选项中标记为AnObject的object找到的每个对，我们把计算后的结果追加在语法分析树。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitAnObject(JSONParser.AnObjectContext ctx) {
    StringBuilder buf = new StringBuilder();
    buf.append(&quot;\n&quot;);
    for (JSONParser.PairContext pctx : ctx.pair()) {
        buf.append(getXML(pctx));
    }
    setXML(ctx, buf.toString());
}
public void exitEmptyObject(JSONParser.EmptyObjectContext ctx) {
    setXML(ctx, &quot;&quot;);
}
</code></pre></div>
<p>处理数组遵循相似的模式，只是简单地连接来自子节点的结果列表，然后把它们包裹在<code>&lt;element&gt;</code>标签中。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitArrayOfValues(JSONParser.ArrayOfValuesContext ctx) {
    StringBuilder buf = new StringBuilder();
    buf.append(&quot;\n&quot;);
    for (JSONParser.ValueContext vctx : ctx.value()) {
        buf.append(&quot;&lt;element&gt;&quot;); // conjure up element for valid XML
        buf.append(getXML(vctx));
        buf.append(&quot;&lt;/element&gt;&quot;);
        buf.append(&quot;\n&quot;);
    }
    setXML(ctx, buf.toString());
}
public void exitEmptyArray(JSONParser.EmptyArrayContext ctx) {
    setXML(ctx, &quot;&quot;);
}
</code></pre></div>
<p>最后，我们需要使用从一个对象或数组收集来的全部转换注解语法分析树的根节点。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">json: object
    | array
    ;
</code></pre></div>
<p>我们可以在监听器里用一个集合运算做到这点。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitJson(JSONParser.JsonContext ctx) {
    setXML(ctx, getXML(ctx.getChild(0)));
}
</code></pre></div>
<p>以下是构建和测试序列：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr JSON.g
compile *.java
run JSON2XML t.json
</code></pre></div>
<p>下面的是部分的输出结果：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&lt;description&gt;An imaginary server config file&lt;/description&gt;
&lt;logs&gt;
&lt;level&gt;verbose&lt;/level&gt;
...
</code></pre></div>
<p>有些转换不总是像JSON到XML那样直白的。但是，这个例子向我们表明如何通过拼凑部分翻译短语处理句子转换问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（25）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part25/"/>
    <updated>2016-09-03T16:16:56+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part25</id>
    <content type="html"><![CDATA[<p>这次我们要做的是通过监听器实现CSV文件的加载器，用于建立一个二维列表数据结构。</p>

<h3 id="加载csv数据">加载CSV数据</h3>

<p>我们的目标是构建一个监听器去加载CSV数据到一个映射列表数据结构中，这是任何数据格式阅读器或配置文件阅读器都会做的事。我们会收集每行的字段并放到一个映射中，构成头名-值组合。以下是示例文件t.csv的内容：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Details,Month,Amount
Mid Bonus,June,&quot;$2,000&quot;
,January,&quot;&quot;&quot;zippo&quot;&quot;&quot;
Total Bonuses,&quot;&quot;,&quot;$5,000&quot;
</code></pre></div>
<p>我们想要看到如下的映射列表被打印出：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">[{Details=Mid Bonus, Month=June, Amount=&quot;$2,000&quot;},
 {Details=, Month=January, Amount=&quot;&quot;&quot;zippo&quot;&quot;&quot;},
 {Details=Total Bonuses, Month=&quot;&quot;, Amount=&quot;$5,000&quot;}]
</code></pre></div>
<p>为了在监听器中得到精确的方法，我们给CSV语法中field规则的每个选项打上标签：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grammar CSV;

file : hdr row+ ;
hdr : row ;
row : field (&#39;,&#39; field)* &#39;\r&#39;? &#39;\n&#39; ;
field
    : TEXT    # text
    | STRING  # string
    |         # empty
    ;

TEXT : ~[,\n\r&quot;]+ ;
STRING : &#39;&quot;&#39; (&#39;&quot;&quot;&#39;|~&#39;&quot;&#39;)* &#39;&quot;&#39; ;     // quote-quote is an escaped quote
</code></pre></div>
<p>我们可以从定义我们需要的数据结构开始监听器的实现。首先，我们需要的数据结构是称为rows的映射列表。我们也需要在头行中找到的列名列表header。为处理数据行，我们需要把字段值读到一个临时列表currentRowFieldValues中，然后把列名映射到那些值上。以下是监听器LoadCSV.java的实现代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public static class Loader extends CSVBaseListener {
    public static final String EMPTY = &quot;&quot;;
    /** Load a list of row maps that map field name to value */
    List&lt;Map&lt;String,String&gt;&gt; rows = new ArrayList&lt;Map&lt;String, String&gt;&gt;();
    /** List of column names */
    List&lt;String&gt; header;
    /** Build up a list of fields in current row */
    List&lt;String&gt; currentRowFieldValues;
</code></pre></div>
<p>下面的3个规则方法通过计算适当的字符串处理字段值，并把它添加到currentRowFieldValues中。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitString(CSVParser.StringContext ctx) {
    currentRowFieldValues.add(ctx.STRING().getText());
}
public void exitText(CSVParser.TextContext ctx) {
    currentRowFieldValues.add(ctx.TEXT().getText());
}
public void exitEmpty(CSVParser.EmptyContext ctx) {
    currentRowFieldValues.add(EMPTY);
}
</code></pre></div>
<p>在我们能处理数据行之前，我们需要从第一行取得列名列表。头行在语法上仅仅是另外的行，但我们在对待它时要不同于常规的数据行，那意味着我们需要检查上下文。暂时让我们假设在exitRow()执行后，currentRowFieldValues包含列名列表。要填充header，我们只需要捕获第一行的字段值。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitHdr(CSVParser.HdrContext ctx) {
    header = new ArrayList&lt;String&gt;();
    header.addAll(currentRowFieldValues);
}
</code></pre></div>
<p>谈到行时，我们需要两个操作：一个是当我们开始一行时，另一个是当我们结束一行时。当我们开始一行时，我们需要分配或清除currentRowFieldValues，准备获取一组新的数据。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void enterRow(CSVParser.RowContext ctx) {
    currentRowFieldValues = new ArrayList&lt;String&gt;();
}
</code></pre></div>
<p>在行结束的时候，我们必须考虑上下文。如果我们仅仅加载头行，那我们不能改变rows字段，因为列名不是数据。在exitRow()中，我们可以通过查看在语法分析树中的父节点的getRuleIndex()值（或者询问父节点是否是HdrContext类型）测试上下文。如果当前行是数据行，我们将通过同时遍历header中的列名和currentRowFieldValues中的值获取的内容创建映射。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitRow(CSVParser.RowContext ctx) {
    // If this is the header row, do nothing
    // if ( ctx.parent instanceof CSVParser.HdrContext ) return; OR:
    if ( ctx.getParent().getRuleIndex() == CSVParser.RULE_hdr ) {
        return;
    }
    // It&#39;s a data row
    Map&lt;String, String&gt; m = new LinkedHashMap&lt;String, String&gt;();
    int i = 0;
    for (String v : currentRowFieldValues) {
        m.put(header.get(i), v);
        i++;
    }
    rows.add(m);
}
</code></pre></div>
<p>到这里，加载CSV数据到数据结构中的任务就算已经完成。在使用ParseTreeWalker遍历树后，我们就可以紧接着打印出rows字段：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">ParseTreeWalker walker = new ParseTreeWalker();
Loader loader = new Loader();
walker.walk(loader, tree);
System.out.println(loader.rows);
</code></pre></div>
<p>以下是构建和测试序列：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr CSV.g
compile *.java
run LoadCSV t.csv
</code></pre></div>
<p>下面显示的是输出结果：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">[{Details=Mid Bonus, Month=June, Amount=&quot;$2,000&quot;}, {Details=, Month=January,
Amount=&quot;&quot;&quot;zippo&quot;&quot;&quot;}, {Details=Total Bonuses, Month=&quot;&quot;, Amount=&quot;$5,000&quot;}]
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（24）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part24/"/>
    <updated>2016-08-26T18:46:37+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part24</id>
    <content type="html"><![CDATA[<p>在本节中，我们准备讲讲有时候事件方法需要传递部分结果或其它信息的问题。</p>

<h3 id="在事件方法间共享信息">在事件方法间共享信息</h3>

<p>无论收集信息还是计算值，传递参数和返回值都是比使用字段和全局变量更方便良好的编程实践。问题是ANTLR自动生成的监听器方法的签名不需要特定应用的返回值或参数，ANTLR也自动生成访问者方法而不需要特定应用的参数。</p>

<p>接下来，我们将探讨让事件方法无需修改事件方法签名就能传递数据的机制。我们将构建同样的简单计算器的3个不同实现，基于前面章节的LExpr表达式语法。第一个实现使用访问者方法返回值，第二个定义了一个在事件方法间共享的字段，第三个则注解语法分析树节点以便储存感兴趣的值。</p>

<h4 id="使用访问者遍历语法分析树">使用访问者遍历语法分析树</h4>

<p>构建基于访问者的计算器，最简单的方法是让和规则expr相关的事件方法返回子表达式的值。例如，visitAdd()将返回两个子表达式相加的值，visitInt()将返回整型的值。传统的访问者不指定visit方法的返回值。当我们为特定应用需求实现一个类时添加返回类型是容易的，扩展LExprBaseVisitor<T>并提供Integer作为<T>类型参数。访问者代码看起来如下所示：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public static class EvalVisitor extends LExprBaseVisitor&lt;Integer&gt; {
    public Integer visitMult(LExprParser.MultContext ctx) {
        return visit(ctx.e(0)) * visit(ctx.e(1));
    }
    public Integer visitAdd(LExprParser.AddContext ctx) {
        return visit(ctx.e(0)) + visit(ctx.e(1));
    }
    public Integer visitInt(LExprParser.IntContext ctx) {
        return Integer.valueOf(ctx.INT().getText());
    }
}
</code></pre></div>
<p>EvalVisitor从ANTLR生成的AbstractParseTreeVisitor类继承通用的visit()方法，我们的访问者使用它去准确地触发子树访问。</p>

<p>注意，EvalVisitor没有针对规则s的访问者方法。在LExprBaseVisitor中的visitS()的默认实现调用预定义的方法ParseTreeVisitor.visitChildren(). visitChildren()返回从最后的子节点访问返回的值。在这里，visitS()返回访问它唯一的子节点（节点e）时返回的表达式的值。我们可以使用这种默认的行为。</p>

<p>在测试文件TestLEvalVisitor.java中，我们有常用代码去启动LExprParser和打印语法分析树，然后我们需要编码去启动EvalVisitor和打印出当访问树时计算出的表达式的值。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">EvalVisitor evalVisitor = new EvalVisitor();
int result = evalVisitor.visit(tree);
System.out.println(&quot;visitor result = &quot; + result);
</code></pre></div>
<p>要构建计算器，需要告诉ANTLR使用-visitor参数去生成访问者。（如果我们不再需要生成监听器，可以使用-no-listener参数）以下是完整的构建和测试序列：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr -visitor LExpr.g
compile *.java
run TestLEvalVisitor
</code></pre></div>
<p>接着输入以下内容：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">1+2*3
EOF
</code></pre></div>
<p>你就会看到如下结果：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(s (e (e 1) + (e (e 2) * (e 3))))
visitor result = 7
</code></pre></div>
<p>如果我们需要特定应用的返回值，访问者工作的相当好，因为我们使用了内建的Java返回值机制。如果我们不希望显式地调用访问者方法去访问子节点，我们可以切换到监听器机制，不幸的是，这意味着我们要放弃使用Java方法返回值的整洁。</p>

<h4 id="使用栈模拟返回值">使用栈模拟返回值</h4>

<p>ANTLR生成的监听器事件方法没有返回值。为了给在语法分析树更高节点上执行的监听器方法返回值，我们可以把部分的值存储在监听器的一个字段中。我们会想到用栈来存储值，方法就是把计算一个子表达式的结果推送到栈中，在语法分析树上用于子表达式的方法则把运算元从栈中弹出。以下是完整的Evaluator计算器监听器（代码在TestLEvaluator.java文件中）：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public static class Evaluator extends LExprBaseListener {
    Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
    public void exitMult(LExprParser.MultContext ctx) {
        int right = stack.pop();
        int left = stack.pop();
        stack.push(left * right);
    }
    public void exitAdd(LExprParser.AddContext ctx) {
        int right = stack.pop();
        int left = stack.pop();
        stack.push(left + right);
    }
    public void exitInt(LExprParser.IntContext ctx) {
        stack.push(Integer.valueOf(ctx.INT().getText()));
    }
}
</code></pre></div>
<p>要测试上面的这段代码，我们可以创建和使用在代码TestLEvaluator中的ParseTreeWalker，以下是完整的构建和测试序列：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr LExpr.g
compile *.java
run TestLEvaluator
</code></pre></div>
<p>接着输入以下内容：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">1+2*3
EOF
</code></pre></div>
<p>你就会看到如下结果：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(s (e (e 1) + (e (e 2) * (e 3))))
stack result = 7
</code></pre></div>
<p>使用栈字段有点别扭但工作得很好。我们必须确保事件方法以正确的顺序压入和弹出跨越监听器事件的值。带有返回值的访问者没有栈的这种笨拙但却需要手工访问树的节点。第三种实现是通过把部分值隐藏在树节点中来捕获它们。</p>

<h4 id="注解语法分析树">注解语法分析树</h4>

<p>作为使用临时存储在事件方法间共享数据的替代，我们可以把这些值存储在语法分析树本身中。使用树注解方法时我们可以带有监听器或访问者，但在这里我们使用监听器来阐明如何使用它。让我们首先看一下用部分结果注解的1+2*3的LExpr语法分析树。</p>

<p><img src="/uploads/lexpr-parse-tree.png" title="lexpr-parse-tree" ></p>

<p>每个子表达式对应一个子树根（和对应一个e规则调用）。从e节点发出的水平线指向的数字是我们想要返回的部分结果。</p>

<p>让我们看看节点注解策略将如何工作在来自LExpr语法的规则e上。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">e : e MULT e    # Mult
  | e ADD e     # Add
  | INT         # Int
  ;
</code></pre></div>
<p>e选项的监听器方法每个都会存储一个结果在相对应的e语法分析树节点中。任何随后的在语法分析树更高节点上的add或multiply事件将通过查看存储在它们对应的子节点中的值来抓取子表达式的值。</p>

<p>现在，让我们假设每个语法分析树节点（每个规则上下文对象）都有一个字段value，那么exitAdd()看起来将是这样；</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitAdd(LExprParser.AddContext ctx) {
    // e(0).value is the subexpression value of the first e in the alternative
    ctx.value = ctx.e(0).value + ctx.e(1).value;    // e &#39;+&#39; e # Add
}
</code></pre></div>
<p>这看起来相当合理，但不幸的是，在Java中我们不能扩展类ExprContext去动态地添加字段。为了让语法分析树注解生效，我们需要一种方法去注解各式各样的节点而不需要手工修改由ANTLR生成的关联节点类。</p>

<p>注解语法分析树节点最简单的方式是使用与节点任意值相关联的一个Map。因此，ANTLR提供了一个简单的帮助类ParseTreeProperty。让我们在文件TestLEvaluatorWithProps.java中构建称作EvaluatorWithProps的另一个计算器版本，它使用ParseTreeProperty关联了LExpr语法分析树节点和部分结果。以下是在监听器开始处的适当的定义：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public static class EvaluatorWithProps extends LExprBaseListener {
    /** maps nodes to integers with Map&lt;ParseTree,Integer&gt; */
    ParseTreeProperty&lt;Integer&gt; values = new ParseTreeProperty&lt;Integer&gt;();
</code></pre></div>
<p>注意：如果你想使用自己的Map类型字段代替ParseTreeProperty，确保它继承自IdentityHashMap，而不是通常的HashMap。我们需要去注解特殊的节点，进行同一性测试而不是equals()。两个e节点可能是equals()，但在内存中不是同一个物理节点。</p>

<p>为注解一个节点，我们使用values.put(node, value)。为得到和一个节点有关联的值，我们使用values.get(node)。这很好，但是让我们创建一些有直白名字的帮助方法以便让代码更容易阅读。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void setValue(ParseTree node, int value) { values.put(node, value); }
public int getValue(ParseTree node) { return values.get(node); }
</code></pre></div>
<p>让我们从最简单的表达式选项Int开始监听器方法。我们想使用它匹配的INT记号的整型值去注解它的语法分析树e节点。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitInt(LExprParser.IntContext ctx) {
    String intText = ctx.INT().getText();    // INT    # Int
    setValue(ctx, Integer.valueOf(intText));
}
</code></pre></div>
<p>对于加法树，我们得到两个子表达式子节点的值（运算元）和带有和的注释的子树跟。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitAdd(LExprParser.AddContext ctx) {
    int left = getValue(ctx.e(0));    // e &#39;+&#39; e    # Add
    int right = getValue(ctx.e(1));
    setValue(ctx, left + right);
}
</code></pre></div>
<p>方法exitMult()是相同的，只是运算的时候用multiply代替了add。</p>

<p>我们的测试代码从分析规则s开始。因此我们必须确保语法分析树根有e子树的值。为把值从e节点冒泡到根s节点，我们实现了exitS()。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">/** Need to pass e&#39;s value out of rule s : e ; */
public void exitS(LExprParser.SContext ctx) {
    setValue(ctx, getValue(ctx.e()));    // like: int s() { return e(); }
}
</code></pre></div>
<p>以下是如何启动监听器以及打印出来自语法分析树根节点的表达式的值：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">ParseTreeWalker walker = new ParseTreeWalker();
EvaluatorWithProps evalProp = new EvaluatorWithProps();
walker.walk(evalProp, tree);
System.out.println(&quot;properties result = &quot; + evalProp.getValue(tree));
</code></pre></div>
<p>以下是构建和测试序列：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr LExpr.g
compile *.java
run TestLEvaluatorWithProps
</code></pre></div>
<p>接着输入以下内容：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">1+2*3
EOF
</code></pre></div>
<p>你就会看到如下结果：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(s (e (e 1) + (e (e 2) * (e 3))))
stack result = 7
</code></pre></div>
<p>现在我们已经看到了相同计算器的3个实现，并且我们也已经准备好把我们的知识用于构建真实案例。因为每个方法都有它的优势和劣势，下面就让我们来比较下不同的技术。</p>

<h3 id="比较信息共享方法">比较信息共享方法</h3>

<p>为得到可复用和可重定目标的语法，我们需要让它们完全清除用户定义的动作。这意味着要把所有特定应用的代码放到语法外的某些监听器和访问者中。监听器和访问者操作语法分析树，ANTLR自动生成合适的树遍历接口和默认实现。因为事件方法签名是固定的和不特定于应用的，所以事件方法可以共享信息的方式有3种：</p>

<ul>
<li>本地Java调用栈：访问者返回用户定义类型的一个值。如果访问者需要传递参数，它也必须使用下面两种技术的一种。</li>
<li>基于栈：一个栈字段模仿参数和返回值，像Java调用栈那样。</li>
<li>注解者：一个Map字段使用有用的值注解节点。</li>
</ul>

<p>所有这3种方法是和语法本身完全解耦的，并且很好地封装在专门的对象中。除此之外，它们也都有各自的优点和缺点。我们可以根据问题的需要和个人的喜好决定采取哪种方法。你甚至可以在同一个应用中使用多种方法。</p>

<p>访问者方法很好懂，因为它们直接调用其它访问者方法去获取部分结果，并且能像其它任何方法那样返回值。这也是它们的缺点，访问者方法必须显式地访问它们的子节点。而监听器就不需要。因为访问者有个通用的接口，所以它不能定义参数。访问者必须使用其它解决方案的一种去传递参数给它在子节点上调用的访问者方法。访问者的空间效率很好，因为它在任何时间仅需保留少数的部分结果。在树遍历后没有部分结果保留。当访问者方法可以返回值时，每个值必须是同种类型，不想其它的解决方案。</p>

<p>基于栈的解决方案可以模仿参数和返回带有一个栈的值，但在手动管理栈时有个断开的机会。这可能会发生，因为监听器方法不能直接调用彼此。作为程序员，我们必须确定推入栈中的在将来事件方法调用能适当地弹出。栈可以传递多个值和多个返回值。基于栈的解决方案也是空间有效的，因为它不会把任何东西固定到树上。在树遍历后所有的部分结果存储消失。</p>

<p>注解者通常可以作为默认解决方案采用，因为它允许你任意地提供信息给事件方法操作语法分析树中上上下下的节点。你也可以传递多个值，它们可以是任意类型。在许多情况下注解胜于使用带有短暂值的栈。在各种方法的数据传递准备间很少有断开的机会。比起在编程语言中说返回值，使用setValue(ctx, value)注解树不太直观，但是更通用。超过其它两种的这种方法的唯一缺点是在树遍历期间部分结果是保留的，因此它有较大的内存占用。</p>

<p>从另一方面来说，在某些应用中能够注解树正是我们需要的。应用需要在树上通过多遍，第一遍是很方便在树上计算和储存数据的。当语法分析树遍历器重新遍历树的时候第二遍然后就很容易访问数据。总的来说，树注解非常灵活，有一个可接受的内存负担。</p>
]]></content>
  </entry>
  
</feed>
