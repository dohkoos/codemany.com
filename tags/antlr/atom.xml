<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: ANTLR | 乐者为王]]></title>
  <link href="http://codemany.com/tags/antlr/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2017-11-15T09:56:15+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（31）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part31/"/>
    <updated>2016-11-12T14:21:50+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part31</id>
    <content type="html"><![CDATA[<ul>
<li>lookahead 前导符</li>
</ul>

<p>现在我们已经对ANTLR语法分析器生成的消息种类以及如何调整和重定向它们有很好的了解，让我们来探讨错误恢复。</p>

<h3 id="自动错误恢复策略">自动错误恢复策略</h3>

<p>错误恢复是允许语法分析器找到语法错误后还能继续的东西。ANTLR的错误恢复机制是：如果可能的话，语法分析器在不匹配的记号错误上执行单次记号插入和单次记号删除。如果不能，语法分析器会吞掉记号直到它找到可以合理遵循当前规则的记号然后返回它，继续下去，就好像什么事都没发生。在本节中，我们将探讨ANTLR如何在各种情况下从错误中恢复。让我们从ANTLR使用的基本恢复策略开始。</p>

<h4 id="通过扫描后续记号恢复">通过扫描后续记号恢复</h4>

<p>当真正面对残缺的输入时，当前规则不能继续，因此语法分析器通过吞掉记号来恢复，直到它认为它已经重新同步然后返回到调用规则。我们可以称之为“同步和返回策略”。有些人称它是“恐慌模式”，但它工作的非常好。语法分析器知道它不能用当前规则匹配当前输入。它只能抛出记号直到前导符与语法分析器退出规则后应该匹配的内容一致。例如，如果在赋值语句中有个语法错误，在语法分析器看到分号或其它语句终结符之前抛出记号是非常有意义的。激烈但有效。正如我们将看到的，ANTLR试图在规则中恢复，然后在撤回到这个基本策略。</p>

<p>每个ANTLR生成的规则方法都被包裹在try-catch中，通过报告错误并在返回之前尝试恢复来响应语法错误。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">try {
    ...
} catch (RecognitionException re) {
    _errHandler.reportError(this, re);
    _errHandler.recover(this, re);
}
</code></pre></div>
<p>在这里，recover()会消费记号直到它在重新同步集合中找到记号。重新同步集合是所有调用栈上的规则的规则引用跟随集合的并集。规则引用的跟随集合是可以立即匹配引用而无需离开当前规则的跟随引用的记号集合。例如，选项<code>assign &#39;;&#39;</code>，规则引用assign的跟随集合是{&#39;;&#39;}。如果选项仅仅是assign，它的跟随集合就为空。</p>

<p>让我们通过示例来看看重新同步集合中包含什么。考虑以下语法，并设想在每个规则调用中，语法分析器跟踪每个规则调用的跟随集合。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">// Filename: F.g

grammar F;

group
    : &#39;[&#39; expr &#39;]&#39;      // Tokens following ref to expr: {&#39;]&#39;}
    | &#39;(&#39; expr &#39;)&#39;      // Tokens following ref to expr: {&#39;)&#39;}
    ;
expr: atom &#39;^&#39; INT ;    // Tokens following ref to atom: {&#39;^&#39;}
atom: ID
    | INT
    ;

INT : [0-9]+ ;
ID  : [a-zA-Z]+ ;
WS  : [ \t\r\n]+ -&gt; skip ;
</code></pre></div>
<p>对于输入<code>[1^2]</code>，考虑下图中左边的语法分析树：</p>

<p><img src="/uploads/syntax-parse-tree.png" alt="syntax-parse-tree"></p>

<p>当在规则atom中匹配记号1时，调用栈是[group, expr, atom]（group调用expr，expr调用atom）。通过查看调用栈，我们可以准确地知道记号集合可以跟随语法分析器调用的任何规则，以便把我们带到当前位置。在当前规则中跟随集合只考虑记号，以至在运行时，我们可以只组合与当前调用栈有关系的集合。换句话说，我们不能同时从group的所有选项到达规则expr。</p>

<p>结合从语法F中的注释里提取的跟随集合，我们得到一个重新同步集合<code>{&#39;^&#39;, &#39;]&#39;}</code>。为什么这是我们想要的，让我们观察当语法分析器遇到错误的输入<code>[]</code>时会发生什么。我们得到上图中显示在右边的语法分析树。在规则atom中，语法分析器发现当前记号<code>]</code>不符合atom的任何选项。要想重新同步，语法分析器需要消费记号直到它在重新同步集合找到记号。在这种情况下，当前记号<code>]</code>作为重新同步集合的成员开始，所以语法分析器不会消费任何记号以便在atom中重新同步。</p>

<p>在规则atom中完成恢复过程之后，语法分析器回到规则expr但是立刻发现它没有<code>^</code>记号。重复同样的过程，语法分析器消费记号直到它在重新同步集合找到记号。expr的重新同步集合是在group的第一个选项中的expr引用的跟随集合：<code>{ &#39;]&#39; }</code>。再次，语法分析器不消费任何东西并退出expr，回到规则group的第一个选项。现在，跟随着expr的引用，语法分析器明确知道它在寻找什么。它成功地匹配规则group中的<code>&#39;]&#39;</code>。语法分析器现在已经正确地同步。</p>

<p>在恢复期间，ANTLR语法分析器避免发出级联错误消息。也就是说，语法分析器为每个语法错误发出单独的错误消息，直到它们从该错误成功地恢复。通过使用一个简单的布尔变量，设置语法错误，语法分析器避免发出更多的错误，直到语法分析器成功匹配令牌和重置变量。</p>

<p>在许多情况下，ANTLR可以比单纯消费更智能地恢复，直到重新同步集合并从当前规则返回。尝试“修复”输入并在相同的规则内继续是值得的。在接下来的几个部分，我们将看看语法分析器如何从不匹配的记号以及子规则里的错误中恢复。</p>

<h4 id="从不匹配记号中恢复">从不匹配记号中恢复</h4>

<p>在语法分析过程中最常见的操作之一是“匹配记号”。对于语法中的每个记号引用T，语法分析器调用match(T)。如果当前的记号不是T，match()通知错误监听器并尝试重新同步。要重新同步，它有3个选择。它可以删除一个记号，它可以想象出一个，或者可以放弃并抛出异常以便从事基本的同步和返回机制。</p>

<p>如果这样做有意义的话，删除当前记号是最容易去重新同步的方法。让我们再次讨论来自在语法Simple中的简单类定义语言的规则classDef。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">classDef
    : &#39;class&#39; ID &#39;{&#39; member+ &#39;}&#39;    // a class has one or more members
      { System.out.println(&quot;class &quot; + $ID.text); }
    ;
</code></pre></div>
<p>给定输入<code>class 9 T {int i; }</code>，语法分析器将删除9并继续在规则中进行来匹配类体。下图说明了语法分析器消耗class后的输入状态：</p>

<p><img src="/uploads/input-state-1.png" alt="input-state-1"></p>

<p>LA(1)和LA(2)标记前导符号的第一个记号（当前记号）和第二个标记。match(ID)期望LA(1)是一个ID，但它不是。实际上，下一个记号LA(2)才是一个ID。为了恢复分析，我们只需要删除当前记号，消费我们期望的ID并退出match()。</p>

<p>如果语法分析器无法通过删除记号重新同步，则会尝试插入一个记号作为代替。假设我们忘记了ID，以致classDef看到输入<code>class { int i; }</code>。匹配class后，输入状态如下所示：</p>

<p><img src="/uploads/input-state-2.png" alt="input-state-2"></p>

<p>语法分析器调用match(ID)后发现是{。在这种情况下，语法分析器知道{是下一步需要的记号，因为它在classDef中跟随ID引用。要重新同步，match()可以假装看到标识符并返回，从而允许下一个match(&#39;{&#39;)调用成功。</p>

<p>如果我们忽略嵌入动作（如引用类名标识符的print语句），那么这很有用。print语句通过$ID.text引用缺失的记号，如果记号为空，将导致异常。而不是简单地假装记号存在，由错误处理程序想象出一个。这个想象出的记号有语法分析器期望的记号类型以及从当前输入记号LA(1)中获得的行和字符的位置信息。这个想象出的记号也用于阻止在监听器和访问者中引用缺失记号的异常。</p>

<p>看看发生了什么的最简单的方法是查看语法分析树，它显示语法分析器如何识别所有记号。在出现错误的情况下，
语法分析树用红色突出显示在重新同步期间语法分析器删除或想象出的记号。对于输入<code>class { int i; }</code>和语法Simple，我们得到以下的语法分析树：</p>

<p><img src="/uploads/error-parse-tree.png" alt="error-parse-tree"></p>

<p>语法分析器也会执行嵌入print动作而不抛出异常，因为错误恢复会为$ID想象出一个有效的Token对象。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ grun Simple prog -gui
class { int i; }
EOF
line 1:6 missing ID at &#39;{&#39;
var i
class &lt;missing ID&gt;
</code></pre></div>
<p>当然，带有文本<code>&lt;missing ID&gt;</code>的标识符对于任何我们试图完成的目标都不是很有用，但至少错误恢复不会导致一堆空指针异常。现在我们知道ANTLR如何对简单的记号引用进行规则内恢复，下面让我们来探讨如何从以前和子规则识别期间的错误中恢复。</p>

<h4 id="从子规则的错误中恢复">从子规则的错误中恢复</h4>

<p>为避免刚碰到错误就从子规则循环中抽身，对周围规则强制同步和返回恢复，ANTLR v4会在开始和循环继续测试处自动插入同步检查。机制看起来是这样：</p>

<p><em>子规则开始</em> 在任何子规则的开头，语法分析器尝试单个记号删除。但是，与记号匹配不同，语法分析器不会尝试单个记号插入。ANTLR很难想象出一个记号，因为它将不得不猜测几个选项中的哪个最终会成功。</p>

<p><em>循环子规则继续测试</em> 如果子规则是循环结构，<code>(...)*</code>或者<code>(...)+</code>，语法分析器在错误出现时积极尝试恢复以停留在循环中。在成功匹配循环的某个选项后，语法分析器消费直到它找到符合以下这些集合之一的记号：</p>

<ol>
<li>循环的另个迭代</li>
<li>循环后面的</li>
<li>当前的重新同步集合</li>
</ol>

<p>让我们先来看下子规则前的单个符号删除。考虑规则classDef中的<code>member+</code>循环结构。如果我们不小心输入一个额外的<code>{</code>，<code>member+</code>子规则在跳进member前将会删除这个额外的记号，就像下面语法分析树显示的那样：</p>

<p><img src="/uploads/member-parse-tree.png" alt="member-parse-tree"></p>

<p>以下的会话可以证实恢复是妥当的，因为它能正确地识别变量i：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ grun Simple prog
class T { { int i; }
EOF
line 1:9 extraneous input &#39;{&#39; expecting &#39;int&#39;
var i
class T
</code></pre></div>
<p>现在让我们尝试一些真正混乱的输入，看看<code>member+</code>循环能否恢复并继续寻找member。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ grun Simple prog
class T { {
  int x;
  y;;;
  int z;
}
EOF
line 1:9 extraneous input &#39;{&#39; expecting &#39;int&#39;
var x
line 3:2 extraneous input &#39;y&#39; expecting {&#39;int&#39;, &#39;}&#39;}
var z
class T
</code></pre></div>
<p>语法分析器重新同步并停留在循环中是因为它确定了变量z。语法分析器消费<code>y;;;</code>直到看到另一个成员的开始（就如前面所说的集合3），然后循环回到member。如果输入不包含<code>int z</code>，语法分析器会一直消费下去直到看到<code>}</code>（前面的集合2）并退出循环。语法分析树突出显示已被删除的记号并说明语法分析器仍然把<code>int z;</code>解释为有效的成员。</p>

<p><img src="/uploads/parse-tree-10.png" alt="parse-tree-10"></p>

<p>如果提供的规则member有语法错误并且没有<code>}</code>，在语法分析器找到<code>}</code>之前我们不希望它进行扫描。语法分析器重新同步可以为查找<code>}</code>抛出整个下面的类定义。相反，语法分析器如果看到集合3中的记号会停止消费，就如同下面的会话那样:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ grun Simple prog
class T {
  int x;
  ;
class U { int y; }
EOF
var x
line 3:2 extraneous input &#39;;&#39; expecting {&#39;int&#39;, &#39;}&#39;}
class T
var y
class U
</code></pre></div>
<p>如我们所见，语法分析器在看到关键字class时会停止从语法分析树重新同步。</p>

<p><img src="/uploads/parse-tree-11.png" alt="parse-tree-11"></p>

<p>除了记号和子规则的识别之外，语法分析器也可能无法匹配语义谓词。</p>

<h4 id="捕捉失败的语义谓词">捕捉失败的语义谓词</h4>

<p>语义谓词就像断言，它指定在运行时必须为真的条件以便让语法分析器通过它们。如果谓词评估为假，则语法分析器将抛出FailedPredicateException异常，被当前规则的catch所捕获。语法分析器报告错误，并进行通用的同步和返回恢复。</p>

<p>让我们来看一个使用语义谓词限制矢量中的整数数量的例子，规则ints匹配max整数。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">vec4: &#39;[&#39; ints[4] &#39;]&#39; ;
ints[int max]
locals [int i=1]
    : INT ( &#39;,&#39; { $i++; } { $i&lt;=$max }? INT )*
    ;
</code></pre></div>
<p>如果像下面的会话那样，给定一个太多整数的矢量，我们会看到错误消息并得到抛出额外逗号和整数的错误恢复：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ antlr Vec.g
$ compile Vec
$ grun Vec vec4
[1,2,3,4,5,6]
EOF
line 1:9 rule ints failed predicate: { $i&lt;=$max }?
</code></pre></div>
<p>语法分析树显示语法分析器在第5个整数处检测到错误。</p>

<p><img src="/uploads/parse-tree-12.png" alt="parse-tree-12"></p>

<p>错误消息<code>{ $i &lt;= $max }</code>可能对作为文法设计者的我们有帮助，但对我们的用户肯定没有帮助。我们可以通过使用语义谓词上的失败选项把消息变得更加可读。例如，下面是带有计算可读字符串动作的ints规则：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">ints[int max]
locals [int i=1]
    : INT ( &#39;,&#39; { $i++; } { $i&lt;=$max }?&lt;fail={&quot;exceeded max &quot;+$max}&gt; INT )*
    ;
</code></pre></div>
<p>对于相同的输入，现在我们得到一个更好的消息。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ antlr VecMsg.g
$ compile VecMsg
$ grun VecMsg vec4
[1,2,3,4,5,6]
EOF
line 1:9 rule ints exceeded max 4
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（30）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part30/"/>
    <updated>2016-10-26T18:02:32+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part30</id>
    <content type="html"><![CDATA[<p>有时我们在调试语法时需要ANTLR提供更好的消息提示，为达到这个目的，我们可以改变ANTLR的标准错误报告。</p>

<h3 id="改变和重定向antlr错误消息">改变和重定向ANTLR错误消息</h3>

<p>默认情况下，ANTLR把所有的错误发送给标准错误，但我们可以通过提供ANTLRErrorListener接口的实现来修改目标和内容。该接口有syntaxError()方法可以应用于词法分析器和语法分析器。方法syntaxError()接收各种有关错误的位置以及错误消息的信息。它也接收语法分析器的一个引用，因此我们可以查询关于识别的状态。</p>

<p>例如，这里是一个错误监听器，它打印规则调用栈以及随后的用有问题的记号信息来加强的通常错误消息：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public static class VerboseListener extends BaseErrorListener {
    @Override
    public void syntaxError(Recognizer&lt;?, ?&gt; recognizer,
                            Object offendingSymbol,
                            int line, int charPositionInLine,
                            String msg,
                            RecognitionException e)
    {
        List&lt;String&gt; stack = ((Parser)recognizer).getRuleInvocationStack();
        Collections.reverse(stack);
        System.err.println(&quot;rule stack: &quot;+stack);
        System.err.println(&quot;line &quot;+line+&quot;:&quot;+charPositionInLine+&quot; at &quot;+
        offendingSymbol+&quot;: &quot;+msg);
    }
}
</code></pre></div>
<p>使用这个定义，我们的应用可以很容易地在调用开始规则前给语法分析器添加一个错误监听器。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SimpleParser parser = new SimpleParser(tokens);
parser.removeErrorListeners();    // remove ConsoleErrorListener
parser.addErrorListener(new VerboseListener());    // add ours
parser.prog();    // parse as usual
</code></pre></div>
<p>在添加我们自己的错误监听器之前，必须先移除标准的终端错误监听器，否则的话就会得到重复的错误消息。</p>

<p>现在让我们看下包含一个额外类名以及缺少字段名的类定义的错误消息看起来是什么样子：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">compile *.java
run TestE_Listener
</code></pre></div>
<p>以下是包含额外类名以及缺少字段名的类定义：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class T T {
  int ;
}
</code></pre></div>
<p>然后我们就会看到如下错误消息：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">rule stack: [prog, classDef]
line 1:8 at [@2,8:8=&#39;T&#39;,&lt;9&gt;,1:8]: extraneous input &#39;T&#39; expecting &#39;{&#39;
rule stack: [prog, classDef, member]
line 2:6 at [@5,18:18=&#39;;&#39;,&lt;8&gt;,2:6]: no viable alternative at input &#39;int;&#39;
class T
</code></pre></div>
<p>栈[prog, classDef]指出语法分析器在规则classDef中，且被prog调用。注意，记号信息包含在输入流中的字符位置，这在高亮输入中的错误时是非常有用的。例如，记号[@2,8:8=&#39;T&#39;,<9>,1:8]指出它是记号流中的第3个记号（索引从0开始），字符范围从8到8，记号类型为9，位于第1行，并且在字符位置8（计数从0开始，且TAB被当作一个字符）。</p>

<p>作为另一个示例，让我们构建一个错误监听器TestE_Listener2.java，它打印带有被下划线强调的有错误的记号的行。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">compile *.java
run TestE_Listener2
</code></pre></div>
<p>输入以下数据：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class T XYZ {
  int ;
}
</code></pre></div>
<p>然后就会看如如下错误信息：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">line 1:8 extraneous input &#39;XYZ&#39; expecting &#39;{&#39;
class T XYZ {
        ^^^
line 2:6 no viable alternative at input &#39;int;&#39;
  int ;
      ^
class T
</code></pre></div>
<p>为了让事情变得更容易，我们将忽略TAB——charPositionInLine不是列号，因为TAB的大小不是统一定义的。这里是一个错误监听器实现，强调输入中的错误位置。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public static class UnderlineListener extends BaseErrorListener {
    public void syntaxError(Recognizer&lt;?, ?&gt; recognizer,
                            Object offendingSymbol,
                            int line, int charPositionInLine,
                            String msg,
                            RecognitionException e) {
        System.err.println(&quot;line &quot;+line+&quot;:&quot;+charPositionInLine+&quot; &quot;+msg);
        underlineError(recognizer,(Token)offendingSymbol,
        line, charPositionInLine);
    }

    protected void underlineError(Recognizer recognizer,
                                  Token offendingToken, int line,
                                  int charPositionInLine) {
        CommonTokenStream tokens =
            (CommonTokenStream)recognizer.getInputStream();
        String input = tokens.getTokenSource().getInputStream().toString();
        String[] lines = input.split(&quot;\n&quot;);
        String errorLine = lines[line - 1];
        System.err.println(errorLine);
        for (int i=0; i&lt;charPositionInLine; i++) System.err.print(&quot; &quot;);
        int start = offendingToken.getStartIndex();
        int stop = offendingToken.getStopIndex();
        if ( start&gt;=0 &amp;&amp; stop&gt;=0 ) {
            for (int i=start; i&lt;=stop; i++) System.err.print(&quot;^&quot;);
        }
        System.err.println();
    }
}
</code></pre></div>
<p>关于错误监听器还有一件事需要知道。当语法分析器侦测到一个模棱两可的输入序列时，它会通知错误监听器。默认的错误监听器ConsoleErrorListener实际上不会在终端打印任何东西，也就是说，语法分析器不会通知用户。让我们回顾下能用两种方式匹配输入<code>f();</code>的那段歧义语法。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grammar Ambig;

stat: expr &#39;;&#39;    // expression statement
    | ID &#39;(&#39; &#39;)&#39; &#39;;&#39;    // function call statement
    ;

expr: ID &#39;(&#39; &#39;)&#39;
    | INT
    ;

INT : [0-9]+ ;
ID  : [a-zA-Z]+ ;
WS  : [ \t\r\n]+ -&gt; skip ;
</code></pre></div>
<p>如果我们测试这段语法，我们不会看到有关模棱两可的输入的警告。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr Ambig.g
compile *.java
grun Ambig stat
</code></pre></div>
<p>然后输入：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">f();
</code></pre></div>
<p>等到语法分析器侦测到二义性时，告诉语法分析器通过addErrorListener()使用DiagnosticErrorListener的实例。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">parser.removeErrorListeners(); // remove ConsoleErrorListener
parser.addErrorListener(new DiagnosticErrorListener());
</code></pre></div>
<p>你还应该通知语法分析器你对所有的二义性警告感兴趣，而不仅仅是那些可以被侦测到的。为了效率，ANTLR的决策机制并不总是追逐完整的二义性信息。以下代码告诉你如何让语法分析器报告所有的二义性：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">parser.getInterpreter()
.setPredictionMode(PredictionMode.LL_EXACT_AMBIG_DETECTION);
</code></pre></div>
<p>如果你通过grun使用TestRig，用选项-diagnostics去让它使用DiagnosticErrorListener代替默认的终端错误监听器（并且开启LL_EXACT_AMBIG_DETECTION）。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grun Ambig stat -diagnostics
</code></pre></div>
<p>输入：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">f();
</code></pre></div>
<p>你会看到：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">line 1:3 reportAttemptingFullContext d=0, input=&#39;f();&#39;
line 1:3 reportAmbiguity d=0: ambigAlts={1, 2}, input=&#39;f();&#39;
</code></pre></div>
<p>输出显示语法分析器也会调用reportAttemptingFullContext()。当<code>SLL(*)</code>分析失败并且语法分析器进行更强大的全<code>ALL(*)</code>机制时，ANTLR调用这个方法。</p>

<p>在开发中使用诊断错误监听器是个好主意，因为ANTLR工具不能给你有关歧义语法结构的警告（当生成语法分析器时）。只有在运行时语法分析器才可以侦测到二义性。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（29）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part29/"/>
    <updated>2016-10-18T11:22:11+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part29</id>
    <content type="html"><![CDATA[<p>当我们开发一套语法时，会有很多错误要去修复。在完成语法前，生成的语法分析器不会识别所有有效的句子。在这期间，提供有用信息的错误消息帮助我们追踪到语法问题。一旦我们有了一套正确的语法，然后我们就必须处理用户输入的不合语法的句子，或者甚至由其它程序发生故障生成的不合语法的句子。在这两种情况下，语法分析器对不合语法的输入的响应方式是一个需要重点考虑的问题。</p>

<p>在这里，我们将学习被ANTLR生成的语法分析器使用的自动错误报告和恢复策略。</p>

<h3 id="错误展示">错误展示</h3>

<p>描述ANTLR的错误恢复策略的最好方式是观察由它生成的语法分析器对错误输入的响应。让我们看一个类Java语言的语法，它包含带有字段和方法成员的类定义。该方法有简单的语句和表达式。嵌入动作在语法分析器找到元素时就打印它们。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grammar Simple;

prog: classDef+ ; // match one or more class definitions

classDef
    : &#39;class&#39; ID &#39;{&#39; member+ &#39;}&#39; // a class has one or more members
      {System.out.println(&quot;class &quot;+$ID.text);}
    ;

member
    : &#39;int&#39; ID &#39;;&#39;    // field definition
      {System.out.println(&quot;var &quot;+$ID.text);}
    | &#39;int&#39; f=ID &#39;(&#39; ID &#39;)&#39; &#39;{&#39; stat &#39;}&#39;    // method definition
      {System.out.println(&quot;method: &quot;+$f.text);}
    ;

stat: expr &#39;;&#39;
      {System.out.println(&quot;found expr: &quot;+$stat.text);}
    | ID &#39;=&#39; expr &#39;;&#39;
      {System.out.println(&quot;found assign: &quot;+$stat.text);}
    ;

expr: INT
    | ID &#39;(&#39; INT &#39;)&#39;
    ;

INT : [0-9]+ ;
ID  : [a-zA-Z]+ ;
WS  : [ \t\r\n]+ -&gt; skip ;
</code></pre></div>
<p>现在，先让我们使用一些有效的输入运行语法分析器，借以观测正常的输出。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr Simple.g
compile *.java
grun Simple prog
</code></pre></div>
<p>输入以下数据：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class T { int i; }
</code></pre></div>
<p>你就会看到：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">var i
class T
</code></pre></div>
<p>语法分析器没有显示任何错误，它执行打印语句，报告关于变量i和类定义T的正确识别。</p>

<p>接下来，让我们尝试一个带有方法定义的类，该方法含有一个虚假赋值表达式。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grun Simple prog -gui
</code></pre></div>
<p>输入测试数据：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class T {
  int f(x) { a = 3 4 5; }
}
</code></pre></div>
<p>然后你就会看到：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">line 2:19 mismatched input &#39;4&#39; expecting &#39;;&#39;
method: f
class T
</code></pre></div>
<p>在4记号处，语法分析器没有找到它期待的“;”，所以它报告一个错误。line 2:19指出有问题的标记是在第2行第19列的字符位置（字符位置从0开始）。因为使用了-gui参数，我们可以看到带有高亮错误节点的语法分析树。</p>

<p><img src="/uploads/simple-parse-tree.png" alt="simple-parse-tree"></p>

<p>在这里，有两个额外的记号，并且语法分析器给出一个不匹配的通用错误消息。如果只有单个的额外记号，语法分析器可能会智能一点，指出它是一个额外的记号。在接下来的运行测试中，有个额外的“;”在类名和类体之间：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grun Simple prog
</code></pre></div>
<p>输入如下：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class T ; { int i; }
</code></pre></div>
<p>输出结果：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">line 1:8 extraneous input &#39;;&#39; expecting &#39;{&#39;
var i
class T
</code></pre></div>
<p>在“;”处语法分析器报告一个错误，但给出了一个稍微翔实的答案，因为它知道下一个记号就是它实际上在寻找的那个。这个特性被称为单个记号删除（single-token deletion），因为语法分析器可以简单地装作额外的记号不存在并继续执行。</p>

<p>同样的，语法分析器可以在侦测到缺少一个记号时做单个记号插入（single-token insertion）。让我们删掉结束的“}”看看会发生什么。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grun Simple prog
</code></pre></div>
<p>然后输入：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class T {
  int f(x) { a = 3; }
</code></pre></div>
<p>结果是：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">found assign: a=3;
method: f
line 3:0 missing &#39;}&#39; at &#39;&lt;EOF&gt;&#39;
class T
</code></pre></div>
<p>语法分析器报告它不能找到必须的结束记号“}”。</p>

<p>当语法分析器处于决策点时，会出现另一个常见的语法错误，并且剩余的输入与规则或子规则的任何选项都不一致。例如，如果我们忘记字段声明中的变量名，规则member中的选项都不匹配。语法分析器报告没有可行的选项。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grun Simple prog
</code></pre></div>
<p>输入以下代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class T { int ; }
</code></pre></div>
<p>然后结果是：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">line 1:14 no viable alternative at input &#39;int;&#39;
class T
</code></pre></div>
<p>在“int”和“;”之间没有空格，因为我们在WS()规则中告诉词法分析器skip()。</p>

<p>如果有词法错误，ANTLR也会放出错误消息，指出哪些字符不能匹配为记号。例如，如果我们提交一个完全未知的字符，我们将得到一个记号识别错误。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grun Simple prog
</code></pre></div>
<p>输入：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class # { int i; }
</code></pre></div>
<p>输出：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">line 1:6 token recognition error at: &#39;#&#39;
line 1:8 missing ID at &#39;{&#39;
var i
class &lt;missing ID&gt;
</code></pre></div>
<p>因为没有给出有效的类名，单个记号插入机制召唤了“missing ID”名字，以致类名记号是非空值。如果想控制语法分析器如何召唤记号，可以覆盖DefaultErrorStrategy中的getMissingSymbol()。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（28）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part28/"/>
    <updated>2016-10-06T18:42:25+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part28</id>
    <content type="html"><![CDATA[<ul>
<li>scope 作用域</li>
</ul>

<p>为了阐明Cymbol语法是可复用的，本节中我们将在不做修改的基础上再次使用它，用于构建一个完全不同的应用。不仅如此，我们还会在同样的树上使用两个不同的监听器做两次遍历。</p>

<h3 id="验证程序符号的使用情况">验证程序符号的使用情况</h3>

<p>为Cymbol这样的编程语言构建解释器、编译器或者转换器，我们需要验证Cymbol程序是否正确地使用符号（标志符）。接下来，我们将构建一个Cymbol验证器用于检查以下的条件：</p>

<ul>
<li>可见的变量引用有相应的定义（在作用域内）。</li>
<li>函数引用有相应的定义（函数可以以任何顺序出现）。</li>
<li>变量不作为函数使用。</li>
<li>函数不作为变量使用。</li>
</ul>

<p>让我们看一下有许多不同引用的Cymbol示例代码，其中有些是无效的。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">int f(int x, float y) {
    g();      // forward reference is ok
    i = 3;    // no declaration for i (error)
    g = 4;    // g is not variable (error)
    return x + y;    // x, y are defined, so no problem
}
void g() {
    int x = 0;
    float y;
    y = 9;    // y is defined
    f();      // backward reference is ok
    z();      // no such function (error)
    y();      // y is not function (error)
    x = f;    // f is not a variable (error)
}
</code></pre></div>
<p>为验证程序中的一切都没问题，根据前面的条件，我们应该打印出函数列表和本地变量以及全局符号列表（函数和全局变量）。更进一步，当我们发现问题时应该给出一个错误。例如，使用上述输入，让我们构建一个称为CheckSymbols的应用。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">java CheckSymbols vars.cymbol
</code></pre></div>
<p>在执行以上命令后会生成如下输出：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">locals:[]
function&lt;f:tINT&gt;:[&lt;x:tINT&gt;, &lt;y:tFLOAT&gt;]
locals:[x, y]
function&lt;g:tVOID&gt;:[]
globals:[f, g]
line 3:4 no such variable: i
line 4:4 g is not a variable
line 13:4 no such function: z
line 14:4 y is not a function
line 15:8 f is not a variable
</code></pre></div>
<p>实现这类问题的关键是一个被称为符号表的相应的数据结构。我们的应用会把符号存在符号表中，然后通过在符号表中查找符号引用检查它们的正确性。在接下来的部分，我们将大概看一看数据结构看起来像什么，并且使用它去解决手头的验证问题。</p>

<h3 id="符号表中的速成课">符号表中的速成课</h3>

<p>语言实现者通常称持有符号的数据结构为符号表。语言的实现决定符号表的结构和复杂性，如果一门语言允许相同的标志符在不同的上下文中指向不同的东西，符号表会将那些符号分组到不同的作用域中。作用域只是一组符号，例如函数的参数列表或变量列表以及在全局作用域内的函数。</p>

<p>符号表自身只是一个符号定义的存储库——它不作任何检查。为了验证代码，我们需要检查表达式中违反我们之前设置的规则的变量和函数引用。符号验证有两个基本操作：定义符号和解决符号。定义一个符号意味着把它添加到一个作用域中。解决一个符号意味着计算出符号指向哪个定义。在某种程度上，解决一个符号意味着找到最近的匹配定义。最近的作用域是最近的封闭作用域。例如，让我们看看另一个Cymbol例子，它在不同的作用域有符号定义。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">int x;
int y;
void a()
{
    int x;
    x = 1;
    // x resolves to current scope, not x in global scope
    y = 2;
    // y is not found in current scope, but resolves in global
    { int y = x; }
}
void b(int z)
{ }
</code></pre></div>
<p>全局作用域包含变量x和y以及函数a()和b()。函数处于全局作用域，但它们也构成新的作用域用于持有函数的参数，如果有的话。同样嵌套在函数作用域内的是函数本地代码块，它们构成另一个新的作用域。本地变量被约束在嵌套在函数作用域内的本地作用域内。</p>

<p>因为符号x被定义了两次，所以做不到仅把所有标识符都填充进单个集合而没有冲突。这也是作用域出现的原因。我们保留一组作用域，并且一个作用域中的每个标志符只允许有单个定义。我们还保留一个指向父作用域的指针，以便在外层作用域中找到符号定义。这些作用域形成了一棵树。</p>

<p><img src="/uploads/cymbol-scope-tree.png" alt="cymbol-scope-tree"></p>

<p>沿着从任何作用域到根（全局作用域）的路径的所有节点形成一堆作用域。为了找到一个符号的定义，我们从围绕着引用的作用域开始，并沿着作用域树向上遍历，直到找到它的定义。</p>

<h3 id="验证器架构">验证器架构</h3>

<p>开始构建验证器前，先让我们思考下大方向和总体策略。我们可以根据关键操作——定义和解决——把问题分解。对于定义，我们需要侦听变量和函数定义事件，然后把符号对象插入围绕着定义的作用域。在函数定义的开始处，我们需要压栈一个新的作用域，然后在函数定义的结尾处把它出栈。</p>

<p>为解决和检查符号引用，我们需要侦听在表达式中的变量和函数名字引用。针对每个引用，我们将验证是否有匹配的定义，以及引用是否正确使用符号。</p>

<p>这似乎很直截了当，但有个并发症：在源码文件中，Cymbol程序可以调用在它之后定义的一个函数。我们称它为前向引用。为支持这个特性，我们需要在语法分析树上执行两次遍历。第一遍，或者阶段，定义包含函数的符号，然后第二遍进行解决。用这种方法，第二遍可以看到文件中的所有函数。以下是用于触发在语法分析树上两次遍历的代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">ParseTreeWalker walker = new ParseTreeWalker();
DefPhase def = new DefPhase();
walker.walk(def, tree);
// create next phase and feed symbol table info from def to ref phase
RefPhase ref = new RefPhase(def.globals, def.scopes);
walker.walk(ref, tree);
</code></pre></div>
<p>在定义阶段，我们将创建许多作用域。除非我们保持对它们的引用，否则垃圾收集器会回收它们。为了符号表能够度过从定义到解决阶段的转变，我们需要追踪这些作用域。储存它们最合乎逻辑的地方是在语法分析树本身（或者，从技术上讲，使用关联值与树节点的注解映射）。然后引用阶段就可以在它下行语法分析树时很简单地获得当前作用域的指针。与函数和本地块关联的树节点将可以获得它们的作用域的指针。</p>

<h3 id="定义和解决符号">定义和解决符号</h3>

<p>考虑到我们的基本策略，让我们从DefPhase开始构建我们的验证器。这个阶段类需要3个字段：一个全局作用域的引用、一个用于追踪我们创建的作用域的语法分析树注解器，以及一个当前作用域的指针。enterFile()的监听器代码在活动开始时创建全局变量。当活动结束时，exitFile()负责打印结果。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class DefPhase extends CymbolBaseListener {
    ParseTreeProperty&lt;Scope&gt; scopes = new ParseTreeProperty&lt;Scope&gt;();
    GlobalScope globals;
    Scope currentScope;    // define symbols in this scope
    public void enterFile(CymbolParser.FileContext ctx) {
        globals = new GlobalScope(null);
        currentScope = globals;
    }
    public void exitFile(CymbolParser.FileContext ctx) {
        System.out.println(globals);
    }
</code></pre></div>
<p>当语法分析器找到函数声明时，应用需要创建一个FunctionSymbol对象。作为一个符号和作为一个包含参数的作用域，FunctionSymbol对象负有双重责任。为把函数作用域嵌套在全局作用域内，我们需要把函数作用域压栈。我们通过设置函数的封闭作用域为当前作用域并重置当前作用域来做到这点。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void enterFunctionDecl(CymbolParser.FunctionDeclContext ctx) {
    String name = ctx.ID().getText();
    int typeTokenType = ctx.type().start.getType();
    Symbol.Type type = CheckSymbols.getType(typeTokenType);

    // push new scope by making new one that points to enclosing scope
    FunctionSymbol function = new FunctionSymbol(name, type, currentScope);
    currentScope.define(function);    // Define function in current scope
    saveScope(ctx, function);         // Push: set function&#39;s parent to current
    currentScope = function;          // Current scope is now function scope
}

void saveScope(ParserRuleContext ctx, Scope s) {
    scopes.put(ctx, s);
}
</code></pre></div>
<p>方法saveScope()使用函数作用域注解functionDecl规则节点，以便在随后的引用阶段可以获得它。当我们离开函数时就出栈函数作用域，因此当前作用域仍然是全局作用域。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitFunctionDecl(CymbolParser.FunctionDeclContext ctx) {
    System.out.println(currentScope);
    currentScope = currentScope.getEnclosingScope();    // pop scope
}
</code></pre></div>
<p>本地作用域以类似的方式工作。我们在监听器方法enterBlock()中压栈一个作用域，然后在exitBlock()中出栈它。</p>

<p>在处理好作用域和函数定义后，我们就可以开始定义参数和变量。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitFormalParameter(CymbolParser.FormalParameterContext ctx) {
    defineVar(ctx.type(), ctx.ID().getSymbol());
}
public void exitVarDecl(CymbolParser.VarDeclContext ctx) {
    defineVar(ctx.type(), ctx.ID().getSymbol());
}
void defineVar(CymbolParser.TypeContext typeCtx, Token nameToken) {
    int typeTokenType = typeCtx.start.getType();
    Symbol.Type type = CheckSymbols.getType(typeTokenType);
    VariableSymbol var = new VariableSymbol(nameToken.getText(), type);
    currentScope.define(var); // Define symbol in current scope
}
</code></pre></div>
<p>到此，定义阶段已经完成。</p>

<p>为构建引用阶段，让我们将当前作用域设置为从定义阶段传递过来的全局作用域。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public RefPhase(GlobalScope globals, ParseTreeProperty&lt;Scope&gt; scopes) {
    this.scopes = scopes;
    this.globals = globals;
}
public void enterFile(CymbolParser.FileContext ctx) {
    currentScope = globals;
}
</code></pre></div>
<p>然后，就像树遍历器触发Cymbol函数和块的进入与退出事件那样，监听器方法通过访问在定义阶段期间存储在树中的值来及时更新currentScope。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void enterFunctionDecl(CymbolParser.FunctionDeclContext ctx) {
    currentScope = scopes.get(ctx);
}
public void exitFunctionDecl(CymbolParser.FunctionDeclContext ctx) {
    currentScope = currentScope.getEnclosingScope();
}
public void enterBlock(CymbolParser.BlockContext ctx) {
    currentScope = scopes.get(ctx);
}
public void exitBlock(CymbolParser.BlockContext ctx) {
    currentScope = currentScope.getEnclosingScope();
}
</code></pre></div>
<p>随着遍历器的行进恰当地设置作用域，我们可以通过实现变量引用和函数调用的监听器方法解决符号。当遍历器遇到一个变量引用时，它调用exitVar()，该方法使用resolve()试图在当前作用域的符号表中查找变量名。如果resolve()在当前作用域中没有找到符号，它会查找封闭作用域链。如果必要，resolve()将寻找所有方式直到全局作用域。如果找不到一个合适的定义，它会返回null值。如果resolve()找到的符号是一个函数而不是变量，就需要生成一个错误消息。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitVar(CymbolParser.VarContext ctx) {
    String name = ctx.ID().getSymbol().getText();
    Symbol var = currentScope.resolve(name);
    if ( var==null ) {
        CheckSymbols.error(ctx.ID().getSymbol(), &quot;no such variable: &quot;+name);
    }
    if ( var instanceof FunctionSymbol ) {
        CheckSymbols.error(ctx.ID().getSymbol(), name+&quot; is not a variable&quot;);
    }
}
</code></pre></div>
<p>处理函数调用基本上是相同的，如果不能找到一个定义或找到了一个变量，都需要发出一个错误。</p>

<p>最后，是用来显示早先需要的输出的构建和测试序列：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr Cymbol.g
compile *.java
run CheckSymbols vars.cymbol
</code></pre></div>
<p>输出结果如下所示：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">locals:[]
function&lt;f:tINT&gt;:[&lt;x:tINT&gt;, &lt;y:tFLOAT&gt;]
...
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（27）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part27/"/>
    <updated>2016-09-28T09:32:41+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part27</id>
    <content type="html"><![CDATA[<p>前面我们主要处理的是数据，今天我们就来做些编程语言方面的事情。</p>

<h3 id="生成调用关系图">生成调用关系图</h3>

<p>软件很难编写和维护，这就是为什么我们试图构建工具去提高我们的生产力和工作效率。例如，在过去的十年里，我们已经看到测试框架、代码覆盖工具和代码分析器的激增，也很高心看到类层次结构的可视化树，以及大部分开发环境支持这个功能。其中有种可视化被称为调用图，它由函数作为节点，并且函数调用作为节点间的有向边。</p>

<p>这本节中，我们将使用Cymbol语法构建一个调用图生成器。考虑以下函数和函数调用集：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">int main() { fact(); a(); }
float fact(int n) {
    print(n);
    if (n == 0) then return 1;
    return n * fact(n - 1);
}
void a() { int x = b(); if false then {c(); d();} }
void b() { c(); }
void c() { b(); }
void d() { }
void e() { }
</code></pre></div>
<p>我们将会把它可视化成如下的调用图：</p>

<p><img src="/uploads/cymbol-call-graph.png" alt="cymbol-call-graph"></p>

<p>可视化的好处是人眼可以很容易地挑出偏差。例如，e()节点是个孤立节点，它意味着没有函数调用它，因此它是一段死代码。一目了然，我们找到一个可以被丢弃的函数。我们还可以通过在图中寻找像fact() -&gt; fact()和b() -&gt; c() -&gt; d()这样的循环非常容易地检测递归。</p>

<p>为了可视化调用图，我们需要读入一段Cymol程序和创建一个DOT文件。例如，以下是我们需要为t.cymbol生成的DOT文件。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">digraph G {
    ranksep=.25;
    edge [arrowsize=.5]
    node [shape=circle, fontname=&quot;ArialNarrow&quot;,
    fontsize=12, fixedsize=true, height=.45];
    main; fact; a; b; c; d; e;
    main -&gt; fact;
    main -&gt; a;
    fact -&gt; print;
    fact -&gt; fact;
    a -&gt; b;
    a -&gt; c;
    a -&gt; d;
    b -&gt; c;
    c -&gt; b;
}
</code></pre></div>
<p>上面的输出包括样本设置描述，例如ranksep=.25;和一列节点和边。为抓住孤立节点，我们需要确保为每个函数名生成节点定义，即使它没有出边和入边。否则它将不会出现在图中。注意在节点定义行末尾的e节点。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">main; fact; a; b; c; d; e;
</code></pre></div>
<p>我们的策略很简单，当语法分析器找到一个函数声明时，应用会把当前函数名添加到一个列表，并且设置一个字段称为currentFunctionName。当语法分析器看到一个函数调用，应用会记录从currentFunctionName到被调用函数名的一条边。</p>

<p>开始之前，让我们给Cymbol.g中的一些规则选项打上标签，以便获得更精确的监听器方法。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">expr: ID &#39;(&#39; exprList? &#39;)&#39;    # Call
    | expr &#39;[&#39; expr &#39;]&#39;       # Index
    | &#39;-&#39; expr                # Negate
    | &#39;!&#39; expr                # Not
    | expr &#39;*&#39; expr           # Mult
    | expr (&#39;+&#39;|&#39;-&#39;) expr     # AddSub
    | expr &#39;==&#39; expr          # Equal
    | ID                      # Var
    | INT                     # Int
    | &#39;(&#39; expr &#39;)&#39;            # Parens
    ;
</code></pre></div>
<p>然后，作为语言应用的基础，把所有图相关的东西封装进一个类。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">static class Graph {
    // I&#39;m using org.antlr.v4.runtime.misc: OrderedHashSet, MultiMap
    Set&lt;String&gt; nodes = new OrderedHashSet&lt;String&gt;();    // list of functions
    MultiMap&lt;String, String&gt; edges = new MultiMap&lt;String, String&gt;();    // caller-&gt;callee
    public void edge(String source, String target) {
        edges.map(source, target);
    }
</code></pre></div>
<p>从节点和边的集合中，我们可以在类Graph的toDOT()中使用一些Java代码转储出适当的DOT代码。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public String toDOT() {
    StringBuilder buf = new StringBuilder();
    buf.append(&quot;digraph G {\n&quot;);
    buf.append(&quot;    ranksep=.25;\n&quot;);
    buf.append(&quot;    edge [arrowsize=.5]\n&quot;);
    buf.append(&quot;    node [shape=circle, fontname=\&quot;ArialNarrow\&quot;,\n&quot;);
    buf.append(&quot;    fontsize=12, fixedsize=true, height=.45];\n&quot;);
    buf.append(&quot;    &quot;);
    for (String node : nodes) {    // print all nodes first
        buf.append(node);
        buf.append(&quot;; &quot;);
    }
    buf.append(&quot;\n&quot;);
    for (String src : edges.keySet()) {
        for (String trg : edges.get(src)) {
            buf.append(&quot;    &quot;);
            buf.append(src);
            buf.append(&quot; -&gt; &quot;);
            buf.append(trg);
            buf.append(&quot;;\n&quot;);
        }
    }
    buf.append(&quot;}\n&quot;);
    return buf.toString();
}
</code></pre></div>
<p>现在我们要做的是使用监听器填满这些数据结构，监听器需要两个字段用于记录。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">static class FunctionListener extends CymbolBaseListener {
    Graph graph = new Graph();
    String currentFunctionName = null;
</code></pre></div>
<p>然后应用只需要监听两个事件。首先，在语法分析器发现函数声明时记录当前的函数名。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void enterFunctionDecl(CymbolParser.FunctionDeclContext ctx) {
    currentFunctionName = ctx.ID().getText();
    graph.nodes.add(currentFunctionName);
}
</code></pre></div>
<p>其次，当语法分析器侦测到函数调用时，应用需要记录从当前函数到被调用函数的一条边。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitCall(CymbolParser.CallContext ctx) {
    String funcName = ctx.ID().getText();
    // map current function to the callee
    graph.edge(currentFunctionName, funcName);
}
</code></pre></div>
<p>注意，函数调用不能隐藏在嵌套代码块或诸如a()这样的声明中。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">void a() { int x = b(); if false then {c(); d();} }
</code></pre></div>
<p>无论什么时候，只要树遍历器发现函数调用就触发监听器方法exitCall()。</p>

<p>通过语法分析树和类FunctionListener，我们可以启动带有监听器的一个遍历器去产生输出。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">ParseTreeWalker walker = new ParseTreeWalker();
FunctionListener collector = new FunctionListener();
walker.walk(collector, tree);
System.out.println(collector.graph.toString())
</code></pre></div>
<p>在转储DOT字符串前，该代码会打印出函数和边的列表。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr Cymbol.g
compile *.java
run CallGraph t.cymbol
</code></pre></div>
<p>以下是部分输出结果：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">edges: {main=[fact, a], fact=[print, fact], a=[b, c, d], b=[c], c=[b]},
functions: [main, fact, a, b, c, d, e]
digraph G {
ranksep=.25;
edge [arrowsize=.5]
...
</code></pre></div>]]></content>
  </entry>
  
</feed>
