<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: ANTLR | 乐者为王]]></title>
  <link href="http://codemany.com/tags/antlr/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2018-01-09T09:21:14+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（33）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part33/"/>
    <updated>2016-12-03T09:22:11+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part33</id>
    <content type="html"><![CDATA[<p>ANTLR的语法分析器可以生成错误信息，也可以从大量不同情况的错误中恢复。我们还可以自定义错误信息以及将它们重定向到不同的错误监听器。所有这些功能都被封装在指定ANTLR错误处理策略的对象中。接下来我们就将详细研究该策略，以学习更多关于自定义语法分析器如何响应错误的知识。</p>

<h3 id="更改antlr的错误处理策略">更改ANTLR的错误处理策略</h3>

<p>默认的错误处理机制工作得很好，但在有些非典型的情况下我们可能要更改它。首先，我们可能由于运行时开销而想要禁用一些内联错误处理。其次，我们可能希望在出现第一个语法错误时就退出语法分析器。例如，当为类似bash这样的shell解析命令行时，没必要试图从错误中恢复。无论如何我们不能冒险执行该命令，所以语法分析器可以在一遇到麻烦时就推出。</p>

<p>要了解错误处理策略，请查看接口ANTLRErrorStrategy及其具体的实现类DefaultErrorStrategy。这个类持有与默认错误处理行为相关联的一切。ANTLR语法分析器指示该对象报告错误并恢复。例如，下面是在每个ANTLR生成的规则函数里面的捕获块：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">_errHandler.reportError(this, re);
_errHandler.recover(this, re);
</code></pre></div>
<p>_errHandler是一个持有DefaultErrorStrategy实例的引用的变量。方法reportError()和recover()表示错误报告和同步和返回功能。reportError()根据抛出的异常类型将错误报告委托给3个方法的其中之一。</p>

<p>回到第一种非典型的情况，让我们来降低语法分析器上的错误处理在运行时的负担。看看下面这段ANTLR为语法Simple中member+子规则生成的代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">_errHandler.sync(this);
_la = _input.LA(1);
do {
    setState(22); member();
    setState(26);
    _errHandler.sync(this);
    _la = _input.LA(1);
} while ( _la==6 );
</code></pre></div>
<p>对于可以安全地假设输入语法是正确的应用程序，比如网络协议，我们最好避免检测并从错误中恢复的开销。我们可以通过继承DefaultErrorStrategy并用空方法覆写sync()来做到这点。Java编译器可能会内联并消除_errHandler.sync(this)调用。我们将在下个例子中阐述如何通知语法分析器使用不同的错误策略。</p>

<p>另一种非典型的情况是在出现第一个语法错误时就退出语法分析器。为使它工作，我们必须覆写3个关键的恢复方法，如下面的代码所示：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">import org.antlr.v4.runtime.*;

public class BailErrorStrategy extends DefaultErrorStrategy {
    /** Instead of recovering from exception e, rethrow it wrapped
     *  in a generic RuntimeException so it is not caught by the
     *  rule function catches. Exception e is the &quot;cause&quot; of the
     *  RuntimeException.
     */
    @Override
    public void recover(Parser recognizer, RecognitionException e) {
        throw new RuntimeException(e);
    }

    /** Make sure we don&#39;t attempt to recover inline; if the parser
     *  successfully recovers, it won&#39;t throw an exception.
     */
    @Override
    public Token recoverInline(Parser recognizer) throws RecognitionException {
        throw new RuntimeException(new InputMismatchException(recognizer));
    }

    /** Make sure we don&#39;t attempt to recover from problems in subrules. */
    @Override
    public void sync(Parser recognizer) { }
}
</code></pre></div>
<p>对于测试平台，我们可以重复使用我们典型的样板代码。除了创建并启动语法分析器，我们需要创建一个新的BailErrorStrategy实例，并告诉语法分析器使用它替换默认的策略。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">parser.setErrorHandler(new BailErrorStrategy());
</code></pre></div>
<p>当我们处理这个问题的时候，我们也应该在出现第一个词汇错误时退出。要做到这点，我们必须重写Lexer中的recover()方法。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public static class BailSimpleLexer extends SimpleLexer {
    public BailSimpleLexer(CharStream input) { super(input); }

    public void recover(LexerNoViableAltException e) {
        throw new RuntimeException(e);    // Bail out
    }
}
</code></pre></div>
<p>让我们先尝试一个词法错误，通过在输入开头插入一个#字符，词法分析器会抛出异常并从控制流中返回到主程序。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ antlr Simple.g
$ compile Simple TestBail
$ run TestBail
# class T { int i; }
EOF
line 1:1 token recognition error at: &#39;#&#39;
Exception in thread &quot;main&quot;
java.lang.RuntimeException: LexerNoViableAltException(&#39;#&#39;)
at TestBail$BailSimpleLexer.recover(TestBail.java:9)
at org.antlr.v4.runtime.Lexer.nextToken(Lexer.java:165)
at org.antlr.v4.runtime.BufferedTokenStream.fetch(BufferedT...Stream.java:139)
at org.antlr.v4.runtime.BufferedTokenStream.sync(BufferedT...Stream.java:133)
at org.antlr.v4.runtime.CommonTokenStream.setup(CommonTokenStream.java:129)
at org.antlr.v4.runtime.CommonTokenStream.LT(CommonTokenStream.java:111)
at org.antlr.v4.runtime.Parser.enterRule(Parser.java:424)
at SimpleParser.prog(SimpleParser.java:68)
at TestBail.main(TestBail.java:23)
...
</code></pre></div>
<p>语法分析器也会从第一个语法错误中退出（在这里是缺少类名）。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ run TestBail
class { }
EOF
Exception in thread &quot;main&quot; java.lang.RuntimeException:
org.antlr.v4.runtime.InputMismatchException
...
</code></pre></div>
<p>我们将通过下面更改语法分析器报告错误的方式来演示ANTLRErrorStrategy接口的灵活性。要改变标准的消息“noviable alternative at input X,”，我们可以覆盖reportNoViableAlternative()并将消息更改为其它不同的内容。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">import org.antlr.v4.runtime.*;

public class MyErrorStrategy extends DefaultErrorStrategy {
    @Override
    public void reportNoViableAlternative(Parser parser, NoViableAltException e)
        throws RecognitionException {
        // ANTLR generates Parser subclasses from grammars and
        // Parser extends Recognizer. Parameter parser is a
        // pointer to the parser that detected the error
        String msg = &quot;can&#39;t choose between alternatives&quot;;    // nonstandard msg
        parser.notifyErrorListeners(e.getOffendingToken(), msg, e);
    }
}
</code></pre></div>
<p>到这里，我们已经涵盖了ANTLR内所有重要的错误报告和恢复设施。因为ANTLRErrorListener和ANTLRErrorStategy接口，我们在错误消息发生的地方具有很大的灵活性：这些消息是什么，以及语法分析器如何从错误中恢复。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（32）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part32/"/>
    <updated>2016-11-18T05:58:56+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part32</id>
    <content type="html"><![CDATA[<p>前面我们介绍过ANTLR的自动错误恢复机制，现在让我们看看手动机制，有些时候它能够提供更好的错误恢复。</p>

<h3 id="错误选项">错误选项</h3>

<p>某些语法错误非常常见，所以值得特别处理。例如，程序员经常在带有嵌套参数的函数调用结尾处忘记写大括号。特别是处理这些情况，我们所要做的就是添加选项来匹配错误但常见的语法。下面的语法识别单个参数或者可能在参数中使用嵌套括号的函数调用。规则fcall有两个所谓的错误选项。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">stat: fcall &#39;;&#39; ;
fcall
    : ID &#39;(&#39; expr &#39;)&#39;
    | ID &#39;(&#39; expr &#39;)&#39; &#39;)&#39; { notifyErrorListeners(&quot;Too many parentheses&quot;); }
    | ID &#39;(&#39; expr         { notifyErrorListeners(&quot;Missing closing &#39;)&#39;&quot;); }
    ;
expr: &#39;(&#39; expr &#39;)&#39;
    | INT
    ;
</code></pre></div>
<p>虽然这些错误选项可能使ANTLR生成的语法分析器在选项之间选择时更困难，但它们不以任何方式混淆语法分析器。就像任何其它选项，如果它们与当前的输入一致，语法分析器就会匹配它们。现在，让我们从一个有效的函数调用开始，尝试一些匹配错误选项的输入序列。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ antlr Call.g
$ compile Call
$ grun Call stat
f(34);
EOF
$ grun Call stat
f((34);
EOF
line 1:6 Missing closing &#39;)&#39;
$ grun Call stat
f((34)));
EOF
line 1:8 Too many parentheses
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（31）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part31/"/>
    <updated>2016-11-12T14:21:50+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part31</id>
    <content type="html"><![CDATA[<ul>
<li>lookahead 前导符</li>
</ul>

<p>现在我们已经对ANTLR语法分析器生成的消息种类以及如何调整和重定向它们有很好的了解，让我们来探讨错误恢复。</p>

<h3 id="自动错误恢复策略">自动错误恢复策略</h3>

<p>错误恢复是允许语法分析器找到语法错误后还能继续的东西。ANTLR的错误恢复机制是：如果可能的话，语法分析器在不匹配的记号错误上执行单次记号插入和单次记号删除。如果不能，语法分析器会吞掉记号直到它找到可以合理遵循当前规则的记号然后返回它，继续下去，就好像什么事都没发生。在本节中，我们将探讨ANTLR如何在各种情况下从错误中恢复。让我们从ANTLR使用的基本恢复策略开始。</p>

<h4 id="通过扫描后续记号恢复">通过扫描后续记号恢复</h4>

<p>当真正面对残缺的输入时，当前规则不能继续，因此语法分析器通过吞掉记号来恢复，直到它认为它已经重新同步然后返回到调用规则。我们可以称之为“同步和返回策略”。有些人称它是“恐慌模式”，但它工作的非常好。语法分析器知道它不能用当前规则匹配当前输入。它只能抛出记号直到前导符与语法分析器退出规则后应该匹配的内容一致。例如，如果在赋值语句中有个语法错误，在语法分析器看到分号或其它语句终结符之前抛出记号是非常有意义的。激烈但有效。正如我们将看到的，ANTLR试图在规则中恢复，然后在撤回到这个基本策略。</p>

<p>每个ANTLR生成的规则方法都被包裹在try-catch中，通过报告错误并在返回之前尝试恢复来响应语法错误。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">try {
    ...
} catch (RecognitionException re) {
    _errHandler.reportError(this, re);
    _errHandler.recover(this, re);
}
</code></pre></div>
<p>在这里，recover()会消费记号直到它在重新同步集合中找到记号。重新同步集合是所有调用栈上的规则的规则引用跟随集合的并集。规则引用的跟随集合是可以立即匹配引用而无需离开当前规则的跟随引用的记号集合。例如，选项<code>assign &#39;;&#39;</code>，规则引用assign的跟随集合是{&#39;;&#39;}。如果选项仅仅是assign，它的跟随集合就为空。</p>

<p>让我们通过示例来看看重新同步集合中包含什么。考虑以下语法，并设想在每个规则调用中，语法分析器跟踪每个规则调用的跟随集合。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">// Filename: F.g

grammar F;

group
    : &#39;[&#39; expr &#39;]&#39;      // Tokens following ref to expr: {&#39;]&#39;}
    | &#39;(&#39; expr &#39;)&#39;      // Tokens following ref to expr: {&#39;)&#39;}
    ;
expr: atom &#39;^&#39; INT ;    // Tokens following ref to atom: {&#39;^&#39;}
atom: ID
    | INT
    ;

INT : [0-9]+ ;
ID  : [a-zA-Z]+ ;
WS  : [ \t\r\n]+ -&gt; skip ;
</code></pre></div>
<p>对于输入<code>[1^2]</code>，考虑下图中左边的语法分析树：</p>

<p><img src="/uploads/syntax-parse-tree.png" alt="syntax-parse-tree"></p>

<p>当在规则atom中匹配记号1时，调用栈是[group, expr, atom]（group调用expr，expr调用atom）。通过查看调用栈，我们可以准确地知道记号集合可以跟随语法分析器调用的任何规则，以便把我们带到当前位置。在当前规则中跟随集合只考虑记号，以至在运行时，我们可以只组合与当前调用栈有关系的集合。换句话说，我们不能同时从group的所有选项到达规则expr。</p>

<p>结合从语法F中的注释里提取的跟随集合，我们得到一个重新同步集合<code>{&#39;^&#39;, &#39;]&#39;}</code>。为什么这是我们想要的，让我们观察当语法分析器遇到错误的输入<code>[]</code>时会发生什么。我们得到上图中显示在右边的语法分析树。在规则atom中，语法分析器发现当前记号<code>]</code>不符合atom的任何选项。要想重新同步，语法分析器需要消费记号直到它在重新同步集合找到记号。在这种情况下，当前记号<code>]</code>作为重新同步集合的成员开始，所以语法分析器不会消费任何记号以便在atom中重新同步。</p>

<p>在规则atom中完成恢复过程之后，语法分析器回到规则expr但是立刻发现它没有<code>^</code>记号。重复同样的过程，语法分析器消费记号直到它在重新同步集合找到记号。expr的重新同步集合是在group的第一个选项中的expr引用的跟随集合：<code>{ &#39;]&#39; }</code>。再次，语法分析器不消费任何东西并退出expr，回到规则group的第一个选项。现在，跟随着expr的引用，语法分析器明确知道它在寻找什么。它成功地匹配规则group中的<code>&#39;]&#39;</code>。语法分析器现在已经正确地同步。</p>

<p>在恢复期间，ANTLR语法分析器避免发出级联错误消息。也就是说，语法分析器为每个语法错误发出单独的错误消息，直到它们从该错误成功地恢复。通过使用一个简单的布尔变量，设置语法错误，语法分析器避免发出更多的错误，直到语法分析器成功匹配记号和重置变量。</p>

<p>在许多情况下，ANTLR可以比单纯消费更智能地恢复，直到重新同步集合并从当前规则返回。尝试“修复”输入并在相同的规则内继续是值得的。在接下来的几个部分，我们将看看语法分析器如何从不匹配的记号以及子规则里的错误中恢复。</p>

<h4 id="从不匹配记号中恢复">从不匹配记号中恢复</h4>

<p>在语法分析过程中最常见的操作之一是“匹配记号”。对于语法中的每个记号引用T，语法分析器调用match(T)。如果当前的记号不是T，match()通知错误监听器并尝试重新同步。要重新同步，它有3个选择。它可以删除一个记号，它可以想象出一个，或者可以放弃并抛出异常以便从事基本的同步和返回机制。</p>

<p>如果这样做有意义的话，删除当前记号是最容易去重新同步的方法。让我们再次讨论来自在语法Simple中的简单类定义语言的规则classDef。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">classDef
    : &#39;class&#39; ID &#39;{&#39; member+ &#39;}&#39;    // a class has one or more members
      { System.out.println(&quot;class &quot; + $ID.text); }
    ;
</code></pre></div>
<p>给定输入<code>class 9 T {int i; }</code>，语法分析器将删除9并继续在规则中进行来匹配类体。下图说明了语法分析器消费class后的输入状态：</p>

<p><img src="/uploads/input-state-1.png" alt="input-state-1"></p>

<p>LA(1)和LA(2)记号前导符号的第一个记号（当前记号）和第二个记号。match(ID)期望LA(1)是一个ID，但它不是。实际上，下一个记号LA(2)才是一个ID。为了恢复分析，我们只需要删除当前记号，消费我们期望的ID并退出match()。</p>

<p>如果语法分析器无法通过删除记号重新同步，则会尝试插入一个记号作为代替。假设我们忘记了ID，以致classDef看到输入<code>class { int i; }</code>。匹配class后，输入状态如下所示：</p>

<p><img src="/uploads/input-state-2.png" alt="input-state-2"></p>

<p>语法分析器调用match(ID)后发现是{。在这种情况下，语法分析器知道{是下一步需要的记号，因为它在classDef中跟随ID引用。要重新同步，match()可以假装看到标识符并返回，从而允许下一个match(&#39;{&#39;)调用成功。</p>

<p>如果我们忽略嵌入动作（如引用类名标识符的print语句），那么这很有用。print语句通过$ID.text引用缺失的记号，如果记号为空，将导致异常。而不是简单地假装记号存在，由错误处理程序想象出一个。这个想象出的记号有语法分析器期望的记号类型以及从当前输入记号LA(1)中获得的行和字符的位置信息。这个想象出的记号也用于阻止在监听器和访问者中引用缺失记号的异常。</p>

<p>看看发生了什么的最简单的方法是查看语法分析树，它显示语法分析器如何识别所有记号。在出现错误的情况下，
语法分析树用红色突出显示在重新同步期间语法分析器删除或想象出的记号。对于输入<code>class { int i; }</code>和语法Simple，我们得到以下的语法分析树：</p>

<p><img src="/uploads/error-parse-tree.png" alt="error-parse-tree"></p>

<p>语法分析器也会执行嵌入print动作而不抛出异常，因为错误恢复会为$ID想象出一个有效的Token对象。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ grun Simple prog -gui
class { int i; }
EOF
line 1:6 missing ID at &#39;{&#39;
var i
class &lt;missing ID&gt;
</code></pre></div>
<p>当然，带有文本<code>&lt;missing ID&gt;</code>的标识符对于任何我们试图完成的目标都不是很有用，但至少错误恢复不会导致一堆空指针异常。现在我们知道ANTLR如何对简单的记号引用进行规则内恢复，下面让我们来探讨如何从以前和子规则识别期间的错误中恢复。</p>

<h4 id="从子规则的错误中恢复">从子规则的错误中恢复</h4>

<p>为避免刚碰到错误就从子规则循环中抽身，对周围规则强制同步和返回恢复，ANTLR v4会在开始和循环继续测试处自动插入同步检查。机制看起来是这样：</p>

<p><em>子规则开始</em> 在任何子规则的开头，语法分析器尝试单个记号删除。但是，与记号匹配不同，语法分析器不会尝试单个记号插入。ANTLR很难想象出一个记号，因为它将不得不猜测几个选项中的哪个最终会成功。</p>

<p><em>循环子规则继续测试</em> 如果子规则是循环结构，<code>(...)*</code>或者<code>(...)+</code>，语法分析器在错误出现时积极尝试恢复以停留在循环中。在成功匹配循环的某个选项后，语法分析器消费直到它找到符合以下这些集合之一的记号：</p>

<ol>
<li>循环的另个迭代</li>
<li>循环后面的</li>
<li>当前的重新同步集合</li>
</ol>

<p>让我们先来看下子规则前的单个符号删除。考虑规则classDef中的<code>member+</code>循环结构。如果我们不小心输入一个额外的<code>{</code>，<code>member+</code>子规则在跳进member前将会删除这个额外的记号，就像下面语法分析树显示的那样：</p>

<p><img src="/uploads/member-parse-tree.png" alt="member-parse-tree"></p>

<p>以下的会话可以证实恢复是妥当的，因为它能正确地识别变量i：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ grun Simple prog
class T { { int i; }
EOF
line 1:9 extraneous input &#39;{&#39; expecting &#39;int&#39;
var i
class T
</code></pre></div>
<p>现在让我们尝试一些真正混乱的输入，看看<code>member+</code>循环能否恢复并继续寻找member。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ grun Simple prog
class T { {
  int x;
  y;;;
  int z;
}
EOF
line 1:9 extraneous input &#39;{&#39; expecting &#39;int&#39;
var x
line 3:2 extraneous input &#39;y&#39; expecting {&#39;int&#39;, &#39;}&#39;}
var z
class T
</code></pre></div>
<p>语法分析器重新同步并停留在循环中是因为它确定了变量z。语法分析器消费<code>y;;;</code>直到看到另一个成员的开始（就如前面所说的集合3），然后循环回到member。如果输入不包含<code>int z</code>，语法分析器会一直消费下去直到看到<code>}</code>（前面的集合2）并退出循环。语法分析树突出显示已被删除的记号并说明语法分析器仍然把<code>int z;</code>解释为有效的成员。</p>

<p><img src="/uploads/parse-tree-10.png" alt="parse-tree-10"></p>

<p>如果提供的规则member有语法错误并且没有<code>}</code>，在语法分析器找到<code>}</code>之前我们不希望它进行扫描。语法分析器重新同步可以为查找<code>}</code>抛出整个下面的类定义。相反，语法分析器如果看到集合3中的记号会停止消费，就如同下面的会话那样：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ grun Simple prog
class T {
  int x;
  ;
class U { int y; }
EOF
var x
line 3:2 extraneous input &#39;;&#39; expecting {&#39;int&#39;, &#39;}&#39;}
class T
var y
class U
</code></pre></div>
<p>如我们所见，语法分析器在看到关键字class时会停止从语法分析树重新同步。</p>

<p><img src="/uploads/parse-tree-11.png" alt="parse-tree-11"></p>

<p>除了记号和子规则的识别之外，语法分析器也可能无法匹配语义谓词。</p>

<h4 id="捕捉失败的语义谓词">捕捉失败的语义谓词</h4>

<p>语义谓词就像断言，它指定在运行时必须为真的条件以便让语法分析器通过它们。如果谓词评估为假，则语法分析器将抛出FailedPredicateException异常，被当前规则的catch所捕获。语法分析器报告错误，并进行通用的同步和返回恢复。</p>

<p>让我们来看一个使用语义谓词限制矢量中的整数数量的例子，规则ints匹配max整数。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">vec4: &#39;[&#39; ints[4] &#39;]&#39; ;
ints[int max]
locals [int i=1]
    : INT ( &#39;,&#39; { $i++; } { $i&lt;=$max }? INT )*
    ;
</code></pre></div>
<p>如果像下面的会话那样，给定一个太多整数的矢量，我们会看到错误消息并得到抛出额外逗号和整数的错误恢复：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ antlr Vec.g
$ compile Vec
$ grun Vec vec4
[1,2,3,4,5,6]
EOF
line 1:9 rule ints failed predicate: { $i&lt;=$max }?
</code></pre></div>
<p>语法分析树显示语法分析器在第5个整数处检测到错误。</p>

<p><img src="/uploads/parse-tree-12.png" alt="parse-tree-12"></p>

<p>错误消息<code>{ $i &lt;= $max }</code>可能对作为文法设计者的我们有帮助，但对我们的用户肯定没有帮助。我们可以通过使用语义谓词上的失败选项把消息变得更加可读。例如，下面是带有计算可读字符串动作的ints规则：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">ints[int max]
locals [int i=1]
    : INT ( &#39;,&#39; { $i++; } { $i&lt;=$max }?&lt;fail={&quot;exceeded max &quot;+$max}&gt; INT )*
    ;
</code></pre></div>
<p>对于相同的输入，现在我们得到一个更好的消息。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ antlr VecMsg.g
$ compile VecMsg
$ grun VecMsg vec4
[1,2,3,4,5,6]
EOF
line 1:9 rule ints exceeded max 4
</code></pre></div>
<p>fail选项使用在双引号中的字符串字面量或者计算结果是字符串的动作。如果你想在谓词失败时执行一个函数，这个动作是很方便的。只需使用一个调用<code>{...}?&lt;fail={failedMaxTest()}&gt;</code>那样的函数的动作。</p>

<p>谨慎使用语义谓词来测试输入有效性。在向量示例中，谓词强制执行语法规则，所以它可以抛出异常并尝试恢复。另一方面，如果我们有一个语法上有效但语义无效的结构，那么使用语义谓词并不是一个好主意。</p>

<p>想象一下，在某种语言中，我们可以给变量赋除0外的任何值。这意味着赋值语句<code>x = 0;</code>在语法上是有效的，但在语义上是无效的。当然，我们必须向用户发出一个错误，但是我们不应该触发错误恢复。<code>x = 0;</code>在语法上是完全合法的。从某种意义上说，语法分析器会从错误中自动执行“恢复”。这是个简单的语法问题：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">assign
    : ID &#39;=&#39; v=INT {$v.int&gt;0}? &#39;;&#39;
      { System.out.println(&quot;assign &quot;+$ID.text+&quot; to &quot;); }
    ;
</code></pre></div>
<p>如果规则assign中的谓词抛出异常，则同步和返回行为会在谓词之后抛出<code>;</code>。这可能会进行的很顺利，但我们冒着不完美重新同步的风险。更好的解决办法是手动发出一个出错，并让语法分析器继续匹配正确的语法。所以，我们应该用一个有条件的简单动作而不是谓词。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">{if ($v.int==0) notifyListeners(&quot;values must be &gt; 0&quot;);}
</code></pre></div>
<p>现在我们已经看过所有可能引发错误恢复的情况。现在需要指出这个机制存在潜在的缺陷。鉴于语法分析器有时在单次恢复尝试期间不消费任何记号，整体恢复可能会陷入无限循环。如果我们能够不消费记号而恢复并回到语法分析器中的相同位置，我们可以再次恢复而不消费记号。在下一节中，我们将会显示ANTLR如何避免这个陷阱。</p>

<h4 id="错误恢复的失效保护">错误恢复的失效保护</h4>

<p>ANTLR语法分析器具有内置的失效保护，以保证错误恢复终止。如果我们到达相同的语法分析器位置并具有相同的输入位置，语法分析器在尝试恢复之前会强制消费一个记号。现在让我们来看一个失效保护的例子。如果我们在字段定义中添加一个额外的int记号，语法分析器检测到错误并尝试恢复。就像我们将在下个测试中看到的那样，语法分析器将调用recover()并在正确重新同步前尝试重新分析多次。</p>

<p><img src="/uploads/parser-resynchronization.png" alt="parser-resynchronization"></p>

<p>右边的语法分析树显示从classDef到member有3次调用。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ grun Simple prog
class T {
  int int x;
}
EOF
line 2:6 no viable alternative at input &#39;intint&#39;
var x
class T
</code></pre></div>
<p>第一个引用不匹配任何东西，但第二个引用匹配没有直接联系的int记号。匹配member的第三次尝试匹配正确的<code>int x;</code>序列。</p>

<p>我们来看一下事件的确切顺序。当语法分析器检测到第一个错误时它在规则member中。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">member
    : &#39;int&#39; ID &#39;;&#39;                          // field definition
      { System.out.println(&quot;var &quot;+$ID.text); }
    | &#39;int&#39; f=ID &#39;(&#39; ID &#39;)&#39; &#39;{&#39; stat &#39;}&#39;    // method definition
      { System.out.println(&quot;method: &quot;+$f.text); }
    ;
</code></pre></div>
<p>输入<code>int int</code>不适合member的任何选项，所以语法分析器参与同步并返回错误恢复策略。它发出第一个错误信息然后消费记号，直到它在调用栈<code>[prog, classDef, member]</code>的重新同步集合中看到记号为止。</p>

<p>由于语法中的<code>classDef+</code>和<code>member+</code>循环，计算重新同步集合有点复杂。在调用member之后，语法分析器可以循环回去并找到另一个成员，或退出循环并找到关闭类定义的<code>&#39;}&#39;</code>。在调用classDef之后，语法分析器可以循环回去查看另一个类的开始或简单地退出prog。因此对于调用栈<code>[prog, classDef, member]</code>，重新同步集合是<code>{&#39;int&#39;, &#39;}&#39;, &#39;class&#39;}</code>。</p>

<p>在这点上，语法分析器恢复不消费记号，因为当前输入记号int在重新同步集合中。它只是返回到调用者：classDef中的<code>member+</code>循环。然后循环尝试匹配另一个成员。不幸的是，因为它没有消费任何记号，当语法分析器返回到member时它检测到另一个错误（虽然它凭借errorRecovery标志消除了虚假错误消息）。</p>

<p>在第2次错误的恢复过程中，语法分析器触发失效保护，因为它已经到达相同的语法分析器位置和输入位置。失效保护在尝试重新同步之前强制记号消费。由于int是在重新同步集合中，它不会消费第2个记号。幸运的是，这正是我们想要的，因为语法分析器现在是正确地同步的。接下来的3个记号表示一个有效的成员定义：<code>int x;</code>。语法分析器再次从member返回到classDef中的循环。第3次，我们回到member，但现在语法分析将会成功。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（30）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part30/"/>
    <updated>2016-10-26T18:02:32+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part30</id>
    <content type="html"><![CDATA[<p>有时我们在调试语法时需要ANTLR提供更好的消息提示，为达到这个目的，我们可以改变ANTLR的标准错误报告。</p>

<h3 id="改变和重定向antlr错误消息">改变和重定向ANTLR错误消息</h3>

<p>默认情况下，ANTLR把所有的错误发送给标准错误，但我们可以通过提供ANTLRErrorListener接口的实现来修改目标和内容。该接口有syntaxError()方法可以应用于词法分析器和语法分析器。方法syntaxError()接收各种有关错误的位置以及错误消息的信息。它也接收语法分析器的一个引用，因此我们可以查询关于识别的状态。</p>

<p>例如，这里是一个错误监听器，它打印规则调用栈以及随后的用有问题的记号信息来加强的通常错误消息：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public static class VerboseListener extends BaseErrorListener {
    @Override
    public void syntaxError(Recognizer&lt;?, ?&gt; recognizer,
                            Object offendingSymbol,
                            int line, int charPositionInLine,
                            String msg,
                            RecognitionException e)
    {
        List&lt;String&gt; stack = ((Parser)recognizer).getRuleInvocationStack();
        Collections.reverse(stack);
        System.err.println(&quot;rule stack: &quot;+stack);
        System.err.println(&quot;line &quot;+line+&quot;:&quot;+charPositionInLine+&quot; at &quot;+
        offendingSymbol+&quot;: &quot;+msg);
    }
}
</code></pre></div>
<p>使用这个定义，我们的应用可以很容易地在调用开始规则前给语法分析器添加一个错误监听器。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SimpleParser parser = new SimpleParser(tokens);
parser.removeErrorListeners();    // remove ConsoleErrorListener
parser.addErrorListener(new VerboseListener());    // add ours
parser.prog();    // parse as usual
</code></pre></div>
<p>在添加我们自己的错误监听器之前，必须先移除标准的终端错误监听器，否则的话就会得到重复的错误消息。</p>

<p>现在让我们看下包含一个额外类名以及缺少字段名的类定义的错误消息看起来是什么样子：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">compile *.java
run TestE_Listener
</code></pre></div>
<p>以下是包含额外类名以及缺少字段名的类定义：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class T T {
  int ;
}
</code></pre></div>
<p>然后我们就会看到如下错误消息：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">rule stack: [prog, classDef]
line 1:8 at [@2,8:8=&#39;T&#39;,&lt;9&gt;,1:8]: extraneous input &#39;T&#39; expecting &#39;{&#39;
rule stack: [prog, classDef, member]
line 2:6 at [@5,18:18=&#39;;&#39;,&lt;8&gt;,2:6]: no viable alternative at input &#39;int;&#39;
class T
</code></pre></div>
<p>栈[prog, classDef]指出语法分析器在规则classDef中，且被prog调用。注意，记号信息包含在输入流中的字符位置，这在高亮输入中的错误时是非常有用的。例如，记号[@2,8:8=&#39;T&#39;,<9>,1:8]指出它是记号流中的第3个记号（索引从0开始），字符范围从8到8，记号类型为9，位于第1行，并且在字符位置8（计数从0开始，且TAB被当作一个字符）。</p>

<p>作为另一个示例，让我们构建一个错误监听器TestE_Listener2.java，它打印带有被下划线强调的有错误的记号的行。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">compile *.java
run TestE_Listener2
</code></pre></div>
<p>输入以下数据：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class T XYZ {
  int ;
}
</code></pre></div>
<p>然后就会看如如下错误信息：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">line 1:8 extraneous input &#39;XYZ&#39; expecting &#39;{&#39;
class T XYZ {
        ^^^
line 2:6 no viable alternative at input &#39;int;&#39;
  int ;
      ^
class T
</code></pre></div>
<p>为了让事情变得更容易，我们将忽略TAB——charPositionInLine不是列号，因为TAB的大小不是统一定义的。这里是一个错误监听器实现，强调输入中的错误位置。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public static class UnderlineListener extends BaseErrorListener {
    public void syntaxError(Recognizer&lt;?, ?&gt; recognizer,
                            Object offendingSymbol,
                            int line, int charPositionInLine,
                            String msg,
                            RecognitionException e) {
        System.err.println(&quot;line &quot;+line+&quot;:&quot;+charPositionInLine+&quot; &quot;+msg);
        underlineError(recognizer,(Token)offendingSymbol,
        line, charPositionInLine);
    }

    protected void underlineError(Recognizer recognizer,
                                  Token offendingToken, int line,
                                  int charPositionInLine) {
        CommonTokenStream tokens =
            (CommonTokenStream)recognizer.getInputStream();
        String input = tokens.getTokenSource().getInputStream().toString();
        String[] lines = input.split(&quot;\n&quot;);
        String errorLine = lines[line - 1];
        System.err.println(errorLine);
        for (int i=0; i&lt;charPositionInLine; i++) System.err.print(&quot; &quot;);
        int start = offendingToken.getStartIndex();
        int stop = offendingToken.getStopIndex();
        if ( start&gt;=0 &amp;&amp; stop&gt;=0 ) {
            for (int i=start; i&lt;=stop; i++) System.err.print(&quot;^&quot;);
        }
        System.err.println();
    }
}
</code></pre></div>
<p>关于错误监听器还有一件事需要知道。当语法分析器侦测到一个模棱两可的输入序列时，它会通知错误监听器。默认的错误监听器ConsoleErrorListener实际上不会在终端打印任何东西，也就是说，语法分析器不会通知用户。让我们回顾下能用两种方式匹配输入<code>f();</code>的那段歧义语法。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grammar Ambig;

stat: expr &#39;;&#39;    // expression statement
    | ID &#39;(&#39; &#39;)&#39; &#39;;&#39;    // function call statement
    ;

expr: ID &#39;(&#39; &#39;)&#39;
    | INT
    ;

INT : [0-9]+ ;
ID  : [a-zA-Z]+ ;
WS  : [ \t\r\n]+ -&gt; skip ;
</code></pre></div>
<p>如果我们测试这段语法，我们不会看到有关模棱两可的输入的警告。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr Ambig.g
compile *.java
grun Ambig stat
</code></pre></div>
<p>然后输入：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">f();
</code></pre></div>
<p>等到语法分析器侦测到二义性时，告诉语法分析器通过addErrorListener()使用DiagnosticErrorListener的实例。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">parser.removeErrorListeners(); // remove ConsoleErrorListener
parser.addErrorListener(new DiagnosticErrorListener());
</code></pre></div>
<p>你还应该通知语法分析器你对所有的二义性警告感兴趣，而不仅仅是那些可以被侦测到的。为了效率，ANTLR的决策机制并不总是追逐完整的二义性信息。以下代码告诉你如何让语法分析器报告所有的二义性：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">parser.getInterpreter()
.setPredictionMode(PredictionMode.LL_EXACT_AMBIG_DETECTION);
</code></pre></div>
<p>如果你通过grun使用TestRig，用选项-diagnostics去让它使用DiagnosticErrorListener代替默认的终端错误监听器（并且开启LL_EXACT_AMBIG_DETECTION）。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grun Ambig stat -diagnostics
</code></pre></div>
<p>输入：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">f();
</code></pre></div>
<p>你会看到：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">line 1:3 reportAttemptingFullContext d=0, input=&#39;f();&#39;
line 1:3 reportAmbiguity d=0: ambigAlts={1, 2}, input=&#39;f();&#39;
</code></pre></div>
<p>输出显示语法分析器也会调用reportAttemptingFullContext()。当<code>SLL(*)</code>分析失败并且语法分析器进行更强大的全<code>ALL(*)</code>机制时，ANTLR调用这个方法。</p>

<p>在开发中使用诊断错误监听器是个好主意，因为ANTLR工具不能给你有关歧义语法结构的警告（当生成语法分析器时）。只有在运行时语法分析器才可以侦测到二义性。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（29）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part29/"/>
    <updated>2016-10-18T11:22:11+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part29</id>
    <content type="html"><![CDATA[<p>当我们开发一套语法时，会有很多错误要去修复。在完成语法前，生成的语法分析器不会识别所有有效的句子。在这期间，提供有用信息的错误消息帮助我们追踪到语法问题。一旦我们有了一套正确的语法，然后我们就必须处理用户输入的不合语法的句子，或者甚至由其它程序发生故障生成的不合语法的句子。在这两种情况下，语法分析器对不合语法的输入的响应方式是一个需要重点考虑的问题。</p>

<p>在这里，我们将学习被ANTLR生成的语法分析器使用的自动错误报告和恢复策略。</p>

<h3 id="错误展示">错误展示</h3>

<p>描述ANTLR的错误恢复策略的最好方式是观察由它生成的语法分析器对错误输入的响应。让我们看一个类Java语言的语法，它包含带有字段和方法成员的类定义。该方法有简单的语句和表达式。嵌入动作在语法分析器找到元素时就打印它们。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grammar Simple;

prog: classDef+ ; // match one or more class definitions

classDef
    : &#39;class&#39; ID &#39;{&#39; member+ &#39;}&#39; // a class has one or more members
      {System.out.println(&quot;class &quot;+$ID.text);}
    ;

member
    : &#39;int&#39; ID &#39;;&#39;    // field definition
      {System.out.println(&quot;var &quot;+$ID.text);}
    | &#39;int&#39; f=ID &#39;(&#39; ID &#39;)&#39; &#39;{&#39; stat &#39;}&#39;    // method definition
      {System.out.println(&quot;method: &quot;+$f.text);}
    ;

stat: expr &#39;;&#39;
      {System.out.println(&quot;found expr: &quot;+$stat.text);}
    | ID &#39;=&#39; expr &#39;;&#39;
      {System.out.println(&quot;found assign: &quot;+$stat.text);}
    ;

expr: INT
    | ID &#39;(&#39; INT &#39;)&#39;
    ;

INT : [0-9]+ ;
ID  : [a-zA-Z]+ ;
WS  : [ \t\r\n]+ -&gt; skip ;
</code></pre></div>
<p>现在，先让我们使用一些有效的输入运行语法分析器，借以观测正常的输出。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr Simple.g
compile *.java
grun Simple prog
</code></pre></div>
<p>输入以下数据：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class T { int i; }
</code></pre></div>
<p>你就会看到：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">var i
class T
</code></pre></div>
<p>语法分析器没有显示任何错误，它执行打印语句，报告关于变量i和类定义T的正确识别。</p>

<p>接下来，让我们尝试一个带有方法定义的类，该方法含有一个虚假赋值表达式。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grun Simple prog -gui
</code></pre></div>
<p>输入测试数据：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class T {
  int f(x) { a = 3 4 5; }
}
</code></pre></div>
<p>然后你就会看到：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">line 2:19 mismatched input &#39;4&#39; expecting &#39;;&#39;
method: f
class T
</code></pre></div>
<p>在4记号处，语法分析器没有找到它期待的“;”，所以它报告一个错误。line 2:19指出有问题的标记是在第2行第19列的字符位置（字符位置从0开始）。因为使用了-gui参数，我们可以看到带有高亮错误节点的语法分析树。</p>

<p><img src="/uploads/simple-parse-tree.png" alt="simple-parse-tree"></p>

<p>在这里，有两个额外的记号，并且语法分析器给出一个不匹配的通用错误消息。如果只有单个的额外记号，语法分析器可能会智能一点，指出它是一个额外的记号。在接下来的运行测试中，有个额外的“;”在类名和类体之间：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grun Simple prog
</code></pre></div>
<p>输入如下：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class T ; { int i; }
</code></pre></div>
<p>输出结果：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">line 1:8 extraneous input &#39;;&#39; expecting &#39;{&#39;
var i
class T
</code></pre></div>
<p>在“;”处语法分析器报告一个错误，但给出了一个稍微翔实的答案，因为它知道下一个记号就是它实际上在寻找的那个。这个特性被称为单个记号删除（single-token deletion），因为语法分析器可以简单地装作额外的记号不存在并继续执行。</p>

<p>同样的，语法分析器可以在侦测到缺少一个记号时做单个记号插入（single-token insertion）。让我们删掉结束的“}”看看会发生什么。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grun Simple prog
</code></pre></div>
<p>然后输入：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class T {
  int f(x) { a = 3; }
</code></pre></div>
<p>结果是：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">found assign: a=3;
method: f
line 3:0 missing &#39;}&#39; at &#39;&lt;EOF&gt;&#39;
class T
</code></pre></div>
<p>语法分析器报告它不能找到必须的结束记号“}”。</p>

<p>当语法分析器处于决策点时，会出现另一个常见的语法错误，并且剩余的输入与规则或子规则的任何选项都不一致。例如，如果我们忘记字段声明中的变量名，规则member中的选项都不匹配。语法分析器报告没有可行的选项。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grun Simple prog
</code></pre></div>
<p>输入以下代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class T { int ; }
</code></pre></div>
<p>然后结果是：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">line 1:14 no viable alternative at input &#39;int;&#39;
class T
</code></pre></div>
<p>在“int”和“;”之间没有空格，因为我们在WS()规则中告诉词法分析器skip()。</p>

<p>如果有词法错误，ANTLR也会放出错误消息，指出哪些字符不能匹配为记号。例如，如果我们提交一个完全未知的字符，我们将得到一个记号识别错误。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grun Simple prog
</code></pre></div>
<p>输入：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class # { int i; }
</code></pre></div>
<p>输出：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">line 1:6 token recognition error at: &#39;#&#39;
line 1:8 missing ID at &#39;{&#39;
var i
class &lt;missing ID&gt;
</code></pre></div>
<p>因为没有给出有效的类名，单个记号插入机制召唤了“missing ID”名字，以致类名记号是非空值。如果想控制语法分析器如何召唤记号，可以覆盖DefaultErrorStrategy中的getMissingSymbol()。</p>
]]></content>
  </entry>
  
</feed>
