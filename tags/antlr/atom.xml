<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: ANTLR | 乐者为王]]></title>
  <link href="http://codemany.com/tags/antlr/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2017-01-09T21:51:28+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（27）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part27/"/>
    <updated>2016-09-28T09:32:41+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part27</id>
    <content type="html"><![CDATA[<p>前面我们主要处理的是数据，今天我们就来做些编程语言方面的事情。</p>

<h3 id="生成调用关系图">生成调用关系图</h3>

<p>软件很难编写和维护，这就是为什么我们试图构建工具去提高我们的生产力和工作效率。例如，在过去的十年里，我们已经看到测试框架、代码覆盖工具和代码分析器的激增，也很高心看到类层次结构的可视化树，以及大部分开发环境支持这个功能。其中有种可视化被称为调用图，它由函数作为节点，并且函数调用作为节点间的有向边。</p>

<p>这本节中，我们将使用Cymbol语法构建一个调用图生成器。考虑以下函数和函数调用集：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">int main() { fact(); a(); }
float fact(int n) {
    print(n);
    if (n == 0) then return 1;
    return n * fact(n - 1);
}
void a() { int x = b(); if false then {c(); d();} }
void b() { c(); }
void c() { b(); }
void d() { }
void e() { }
</code></pre></div>
<p>我们将会把它可视化成如下的调用图：</p>

<p><img src="/uploads/cymbol-call-graph.png" title="cymbol-call-graph" ></p>

<p>可视化的好处是人眼可以很容易地挑出偏差。例如，e()节点是个孤立节点，它意味着没有函数调用它，因此它是一段死代码。一目了然，我们找到一个可以被丢弃的函数。我们还可以通过在图中寻找像fact() -&gt; fact()和b() -&gt; c() -&gt; d()这样的循环非常容易地检测递归。</p>

<p>为了可视化调用图，我们需要读入一段Cymol程序和创建一个DOT文件。例如，以下是我们需要为t.cymbol生成的DOT文件。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">digraph G {
    ranksep=.25;
    edge [arrowsize=.5]
    node [shape=circle, fontname=&quot;ArialNarrow&quot;,
    fontsize=12, fixedsize=true, height=.45];
    main; fact; a; b; c; d; e;
    main -&gt; fact;
    main -&gt; a;
    fact -&gt; print;
    fact -&gt; fact;
    a -&gt; b;
    a -&gt; c;
    a -&gt; d;
    b -&gt; c;
    c -&gt; b;
}
</code></pre></div>
<p>上面的输出包括样本设置描述，例如ranksep=.25;和一列节点和边。为抓住孤立节点，我们需要确保为每个函数名生成节点定义，即使它没有出边和入边。否则它将不会出现在图中。注意在节点定义行末尾的e节点。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">main; fact; a; b; c; d; e;
</code></pre></div>
<p>我们的策略很简单，当语法分析器找到一个函数声明时，应用会把当前函数名添加到一个列表，并且设置一个字段称为currentFunctionName。当语法分析器看到一个函数调用，应用会记录从currentFunctionName到被调用函数名的一条边。</p>

<p>开始之前，让我们给Cymbol.g中的一些规则选项打上标签，以便获得更精确的监听器方法。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">expr: ID &#39;(&#39; exprList? &#39;)&#39;    # Call
    | expr &#39;[&#39; expr &#39;]&#39;       # Index
    | &#39;-&#39; expr                # Negate
    | &#39;!&#39; expr                # Not
    | expr &#39;*&#39; expr           # Mult
    | expr (&#39;+&#39;|&#39;-&#39;) expr     # AddSub
    | expr &#39;==&#39; expr          # Equal
    | ID                      # Var
    | INT                     # Int
    | &#39;(&#39; expr &#39;)&#39;            # Parens
    ;
</code></pre></div>
<p>然后，作为语言应用的基础，把所有图相关的东西封装进一个类。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">static class Graph {
    // I&#39;m using org.antlr.v4.runtime.misc: OrderedHashSet, MultiMap
    Set&lt;String&gt; nodes = new OrderedHashSet&lt;String&gt;();    // list of functions
    MultiMap&lt;String, String&gt; edges = new MultiMap&lt;String, String&gt;();    // caller-&gt;callee
    public void edge(String source, String target) {
        edges.map(source, target);
    }
</code></pre></div>
<p>从节点和边的集合中，我们可以在类Graph的toDOT()中使用一些Java代码转储出适当的DOT代码。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public String toDOT() {
    StringBuilder buf = new StringBuilder();
    buf.append(&quot;digraph G {\n&quot;);
    buf.append(&quot;    ranksep=.25;\n&quot;);
    buf.append(&quot;    edge [arrowsize=.5]\n&quot;);
    buf.append(&quot;    node [shape=circle, fontname=\&quot;ArialNarrow\&quot;,\n&quot;);
    buf.append(&quot;    fontsize=12, fixedsize=true, height=.45];\n&quot;);
    buf.append(&quot;    &quot;);
    for (String node : nodes) {    // print all nodes first
        buf.append(node);
        buf.append(&quot;; &quot;);
    }
    buf.append(&quot;\n&quot;);
    for (String src : edges.keySet()) {
        for (String trg : edges.get(src)) {
            buf.append(&quot;    &quot;);
            buf.append(src);
            buf.append(&quot; -&gt; &quot;);
            buf.append(trg);
            buf.append(&quot;;\n&quot;);
        }
    }
    buf.append(&quot;}\n&quot;);
    return buf.toString();
}
</code></pre></div>
<p>现在我们要做的是使用监听器填满这些数据结构，监听器需要两个字段用于记录。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">static class FunctionListener extends CymbolBaseListener {
    Graph graph = new Graph();
    String currentFunctionName = null;
</code></pre></div>
<p>然后应用只需要监听两个事件。首先，在语法分析器发现函数声明时记录当前的函数名。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void enterFunctionDecl(CymbolParser.FunctionDeclContext ctx) {
    currentFunctionName = ctx.ID().getText();
    graph.nodes.add(currentFunctionName);
}
</code></pre></div>
<p>其次，当语法分析器侦测到函数调用时，应用需要记录从当前函数到被调用函数的一条边。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitCall(CymbolParser.CallContext ctx) {
    String funcName = ctx.ID().getText();
    // map current function to the callee
    graph.edge(currentFunctionName, funcName);
}
</code></pre></div>
<p>注意，函数调用不能隐藏在嵌套代码块或诸如a()这样的声明中。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">void a() { int x = b(); if false then {c(); d();} }
</code></pre></div>
<p>无论什么时候，只要树遍历器发现函数调用就触发监听器方法exitCall()。</p>

<p>通过语法分析树和类FunctionListener，我们可以启动带有监听器的一个遍历器去产生输出。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">ParseTreeWalker walker = new ParseTreeWalker();
FunctionListener collector = new FunctionListener();
walker.walk(collector, tree);
System.out.println(collector.graph.toString())
</code></pre></div>
<p>在转储DOT字符串前，该代码会打印出函数和边的列表。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr Cymbol.g
compile *.java
run CallGraph t.cymbol
</code></pre></div>
<p>以下是部分输出结果：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">edges: {main=[fact, a], fact=[print, fact], a=[b, c, d], b=[c], c=[b]},
functions: [main, fact, a, b, c, d, e]
digraph G {
ranksep=.25;
edge [arrowsize=.5]
...
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（26）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part26/"/>
    <updated>2016-09-09T22:22:47+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part26</id>
    <content type="html"><![CDATA[<p>今天准备做的是把JSON文本文件转换成XML文本文件。</p>

<h3 id="把json转换成xml">把JSON转换成XML</h3>

<p>许多Web服务返回的是JSON数据，但是我们可能会遇到一种情况，需要把JSON数据送给那些只接受XML数据的代码。这就需要我们构建一个JSON到XML的转换器。我们的目标是读入像下面这样的JSON数据：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">{
&quot;description&quot; : &quot;An imaginary server config file&quot;,
&quot;logs&quot; : {&quot;level&quot;:&quot;verbose&quot;, &quot;dir&quot;:&quot;/var/log&quot;},
&quot;host&quot; : &quot;antlr.org&quot;,
&quot;admin&quot;: [&quot;parrt&quot;, &quot;tombu&quot;],
&quot;aliases&quot;: []
}
</code></pre></div>
<p>放出等价的XML数据，就像下面这样的：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&lt;description&gt;An imaginary server config file&lt;/description&gt;
&lt;logs&gt;
  &lt;level&gt;verbose&lt;/level&gt;
  &lt;dir&gt;/var/log&lt;/dir&gt;
&lt;/logs&gt;
&lt;host&gt;antlr.org&lt;/host&gt;
&lt;admin&gt;
  &lt;element&gt;parrt&lt;/element&gt;
  &lt;element&gt;tombu&lt;/element&gt;
&lt;/admin&gt;
&lt;aliases&gt;&lt;/aliases&gt;
</code></pre></div>
<p>正如我们对CSV做的那样，让我们给JSON语法中的一些选项打上标签，以便让ANTLR生成更精确的监听器方法。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">object
    : &#39;{&#39; pair (&#39;,&#39; pair)* &#39;}&#39;    # AnObject
    | &#39;{&#39; &#39;}&#39;                     # EmptyObject
    ;
array
    : &#39;[&#39; value (&#39;,&#39; value)* &#39;]&#39;  # ArrayOfValues
    | &#39;[&#39; &#39;]&#39;                     # EmptyArray
    ;
</code></pre></div>
<p>我们将对规则value做同样的事，但是稍有不同。除3个选项外的其它所有选项只需要返回被匹配的值的文本，所以我们可以为其它所有选项使用相同的标签，使语法分析树遍历器为那些选项触发相同的监听器方法。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">value
    : STRING    # String
    | NUMBER    # Atom
    | object    # ObjectValue
    | array     # ArrayValue
    | &#39;true&#39;    # Atom
    | &#39;false&#39;   # Atom
    | &#39;null&#39;    # Atom
    ;
</code></pre></div>
<p>为构建这样的转换器，明智的做法是让每个规则返回被它匹配的输入短语的XML等价物。为追踪部分结构，我们使用字段xml和两个帮助方法来注解语法分析树。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public static class XMLEmitter extends JSONBaseListener {
    ParseTreeProperty&lt;String&gt; xml = new ParseTreeProperty&lt;String&gt;();
    String getXML(ParseTree ctx) { return xml.get(ctx); }
    void setXML(ParseTree ctx, String s) { xml.put(ctx, s); }
</code></pre></div>
<p>我们把每棵子树转换后的字符串挂载到该子树的根节点。在语法分析树更高节点上工作的方法可以捕获这些值以便计算更大的字符串。然后挂载在根节点上的字符串完成计算。</p>

<p>让我们从最简单的转换开始。value的Atom选项返回匹配记号的文本。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitAtom(JSONParser.AtomContext ctx) {
    setXML(ctx, ctx.getText());
}
</code></pre></div>
<p>字符串基本上是相同的，只是我们必须去除双引号。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitString(JSONParser.StringContext ctx) {
    setXML(ctx, stripQuotes(ctx.getText()));
}
</code></pre></div>
<p>如果value()规则方法找到一个对象或数组，它可以把组合元素的部分转换拷贝到它自己的语法分析树节点。以下代码是找到对象时的处理：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitObjectValue(JSONParser.ObjectValueContext ctx) {
    // analogous to String value() {return object();}
    setXML(ctx, getXML(ctx.object()));
}
</code></pre></div>
<p>一旦我们可以转换所有的值，我们需要担心名-值对以及把它们转换成标签和文本。生成的XML的标签名字来源于STRING &#39;:&#39; value选项中的STRING。在左右尖括号之间的文本来源于挂载在value子节点上的文本。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitPair(JSONParser.PairContext ctx) {
    String tag = stripQuotes(ctx.STRING().getText());
    JSONParser.ValueContext vctx = ctx.value();
    String x = String.format(&quot;&lt;%s&gt;%s&lt;/%s&gt;\n&quot;, tag, getXML(vctx), tag);
    setXML(ctx, x);
}
</code></pre></div>
<p>JSON对象由名-值对组成。因此，对于被选项中标记为AnObject的object找到的每个对，我们把计算后的结果追加在语法分析树。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitAnObject(JSONParser.AnObjectContext ctx) {
    StringBuilder buf = new StringBuilder();
    buf.append(&quot;\n&quot;);
    for (JSONParser.PairContext pctx : ctx.pair()) {
        buf.append(getXML(pctx));
    }
    setXML(ctx, buf.toString());
}
public void exitEmptyObject(JSONParser.EmptyObjectContext ctx) {
    setXML(ctx, &quot;&quot;);
}
</code></pre></div>
<p>处理数组遵循相似的模式，只是简单地连接来自子节点的结果列表，然后把它们包裹在<code>&lt;element&gt;</code>标签中。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitArrayOfValues(JSONParser.ArrayOfValuesContext ctx) {
    StringBuilder buf = new StringBuilder();
    buf.append(&quot;\n&quot;);
    for (JSONParser.ValueContext vctx : ctx.value()) {
        buf.append(&quot;&lt;element&gt;&quot;); // conjure up element for valid XML
        buf.append(getXML(vctx));
        buf.append(&quot;&lt;/element&gt;&quot;);
        buf.append(&quot;\n&quot;);
    }
    setXML(ctx, buf.toString());
}
public void exitEmptyArray(JSONParser.EmptyArrayContext ctx) {
    setXML(ctx, &quot;&quot;);
}
</code></pre></div>
<p>最后，我们需要使用从一个对象或数组收集来的全部转换注解语法分析树的根节点。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">json: object
    | array
    ;
</code></pre></div>
<p>我们可以在监听器里用一个集合运算做到这点。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitJson(JSONParser.JsonContext ctx) {
    setXML(ctx, getXML(ctx.getChild(0)));
}
</code></pre></div>
<p>以下是构建和测试序列：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr JSON.g
compile *.java
run JSON2XML t.json
</code></pre></div>
<p>下面的是部分的输出结果：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&lt;description&gt;An imaginary server config file&lt;/description&gt;
&lt;logs&gt;
&lt;level&gt;verbose&lt;/level&gt;
...
</code></pre></div>
<p>有些转换不总是像JSON到XML那样直白的。但是，这个例子向我们表明如何通过拼凑部分翻译短语处理句子转换问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（25）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part25/"/>
    <updated>2016-09-03T16:16:56+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part25</id>
    <content type="html"><![CDATA[<p>这次我们要做的是通过监听器实现CSV文件的加载器，用于建立一个二维列表数据结构。</p>

<h3 id="加载csv数据">加载CSV数据</h3>

<p>我们的目标是构建一个监听器去加载CSV数据到一个映射列表数据结构中，这是任何数据格式阅读器或配置文件阅读器都会做的事。我们会收集每行的字段并放到一个映射中，构成头名-值组合。以下是示例文件t.csv的内容：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Details,Month,Amount
Mid Bonus,June,&quot;$2,000&quot;
,January,&quot;&quot;&quot;zippo&quot;&quot;&quot;
Total Bonuses,&quot;&quot;,&quot;$5,000&quot;
</code></pre></div>
<p>我们想要看到如下的映射列表被打印出：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">[{Details=Mid Bonus, Month=June, Amount=&quot;$2,000&quot;},
 {Details=, Month=January, Amount=&quot;&quot;&quot;zippo&quot;&quot;&quot;},
 {Details=Total Bonuses, Month=&quot;&quot;, Amount=&quot;$5,000&quot;}]
</code></pre></div>
<p>为了在监听器中得到精确的方法，我们给CSV语法中field规则的每个选项打上标签：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grammar CSV;

file : hdr row+ ;
hdr : row ;
row : field (&#39;,&#39; field)* &#39;\r&#39;? &#39;\n&#39; ;
field
    : TEXT    # text
    | STRING  # string
    |         # empty
    ;

TEXT : ~[,\n\r&quot;]+ ;
STRING : &#39;&quot;&#39; (&#39;&quot;&quot;&#39;|~&#39;&quot;&#39;)* &#39;&quot;&#39; ;     // quote-quote is an escaped quote
</code></pre></div>
<p>我们可以从定义我们需要的数据结构开始监听器的实现。首先，我们需要的数据结构是称为rows的映射列表。我们也需要在头行中找到的列名列表header。为处理数据行，我们需要把字段值读到一个临时列表currentRowFieldValues中，然后把列名映射到那些值上。以下是监听器LoadCSV.java的实现代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public static class Loader extends CSVBaseListener {
    public static final String EMPTY = &quot;&quot;;
    /** Load a list of row maps that map field name to value */
    List&lt;Map&lt;String,String&gt;&gt; rows = new ArrayList&lt;Map&lt;String, String&gt;&gt;();
    /** List of column names */
    List&lt;String&gt; header;
    /** Build up a list of fields in current row */
    List&lt;String&gt; currentRowFieldValues;
</code></pre></div>
<p>下面的3个规则方法通过计算适当的字符串处理字段值，并把它添加到currentRowFieldValues中。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitString(CSVParser.StringContext ctx) {
    currentRowFieldValues.add(ctx.STRING().getText());
}
public void exitText(CSVParser.TextContext ctx) {
    currentRowFieldValues.add(ctx.TEXT().getText());
}
public void exitEmpty(CSVParser.EmptyContext ctx) {
    currentRowFieldValues.add(EMPTY);
}
</code></pre></div>
<p>在我们能处理数据行之前，我们需要从第一行取得列名列表。头行在语法上仅仅是另外的行，但我们在对待它时要不同于常规的数据行，那意味着我们需要检查上下文。暂时让我们假设在exitRow()执行后，currentRowFieldValues包含列名列表。要填充header，我们只需要捕获第一行的字段值。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitHdr(CSVParser.HdrContext ctx) {
    header = new ArrayList&lt;String&gt;();
    header.addAll(currentRowFieldValues);
}
</code></pre></div>
<p>谈到行时，我们需要两个操作：一个是当我们开始一行时，另一个是当我们结束一行时。当我们开始一行时，我们需要分配或清除currentRowFieldValues，准备获取一组新的数据。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void enterRow(CSVParser.RowContext ctx) {
    currentRowFieldValues = new ArrayList&lt;String&gt;();
}
</code></pre></div>
<p>在行结束的时候，我们必须考虑上下文。如果我们仅仅加载头行，那我们不能改变rows字段，因为列名不是数据。在exitRow()中，我们可以通过查看在语法分析树中的父节点的getRuleIndex()值（或者询问父节点是否是HdrContext类型）测试上下文。如果当前行是数据行，我们将通过同时遍历header中的列名和currentRowFieldValues中的值获取的内容创建映射。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitRow(CSVParser.RowContext ctx) {
    // If this is the header row, do nothing
    // if ( ctx.parent instanceof CSVParser.HdrContext ) return; OR:
    if ( ctx.getParent().getRuleIndex() == CSVParser.RULE_hdr ) {
        return;
    }
    // It&#39;s a data row
    Map&lt;String, String&gt; m = new LinkedHashMap&lt;String, String&gt;();
    int i = 0;
    for (String v : currentRowFieldValues) {
        m.put(header.get(i), v);
        i++;
    }
    rows.add(m);
}
</code></pre></div>
<p>到这里，加载CSV数据到数据结构中的任务就算已经完成。在使用ParseTreeWalker遍历树后，我们就可以紧接着打印出rows字段：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">ParseTreeWalker walker = new ParseTreeWalker();
Loader loader = new Loader();
walker.walk(loader, tree);
System.out.println(loader.rows);
</code></pre></div>
<p>以下是构建和测试序列：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr CSV.g
compile *.java
run LoadCSV t.csv
</code></pre></div>
<p>下面显示的是输出结果：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">[{Details=Mid Bonus, Month=June, Amount=&quot;$2,000&quot;}, {Details=, Month=January,
Amount=&quot;&quot;&quot;zippo&quot;&quot;&quot;}, {Details=Total Bonuses, Month=&quot;&quot;, Amount=&quot;$5,000&quot;}]
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（24）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part24/"/>
    <updated>2016-08-26T18:46:37+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part24</id>
    <content type="html"><![CDATA[<p>在本节中，我们准备讲讲有时候事件方法需要传递部分结果或其它信息的问题。</p>

<h3 id="在事件方法间共享信息">在事件方法间共享信息</h3>

<p>无论收集信息还是计算值，传递参数和返回值都是比使用字段和全局变量更方便良好的编程实践。问题是ANTLR自动生成的监听器方法的签名不需要特定应用的返回值或参数，ANTLR也自动生成访问者方法而不需要特定应用的参数。</p>

<p>接下来，我们将探讨让事件方法无需修改事件方法签名就能传递数据的机制。我们将构建同样的简单计算器的3个不同实现，基于前面章节的LExpr表达式语法。第一个实现使用访问者方法返回值，第二个定义了一个在事件方法间共享的字段，第三个则注解语法分析树节点以便储存感兴趣的值。</p>

<h4 id="使用访问者遍历语法分析树">使用访问者遍历语法分析树</h4>

<p>构建基于访问者的计算器，最简单的方法是让和规则expr相关的事件方法返回子表达式的值。例如，visitAdd()将返回两个子表达式相加的值，visitInt()将返回整型的值。传统的访问者不指定visit方法的返回值。当我们为特定应用需求实现一个类时添加返回类型是容易的，扩展LExprBaseVisitor<T>并提供Integer作为<T>类型参数。访问者代码看起来如下所示：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public static class EvalVisitor extends LExprBaseVisitor&lt;Integer&gt; {
    public Integer visitMult(LExprParser.MultContext ctx) {
        return visit(ctx.e(0)) * visit(ctx.e(1));
    }
    public Integer visitAdd(LExprParser.AddContext ctx) {
        return visit(ctx.e(0)) + visit(ctx.e(1));
    }
    public Integer visitInt(LExprParser.IntContext ctx) {
        return Integer.valueOf(ctx.INT().getText());
    }
}
</code></pre></div>
<p>EvalVisitor从ANTLR生成的AbstractParseTreeVisitor类继承通用的visit()方法，我们的访问者使用它去准确地触发子树访问。</p>

<p>注意，EvalVisitor没有针对规则s的访问者方法。在LExprBaseVisitor中的visitS()的默认实现调用预定义的方法ParseTreeVisitor.visitChildren(). visitChildren()返回从最后的子节点访问返回的值。在这里，visitS()返回访问它唯一的子节点（节点e）时返回的表达式的值。我们可以使用这种默认的行为。</p>

<p>在测试文件TestLEvalVisitor.java中，我们有常用代码去启动LExprParser和打印语法分析树，然后我们需要编码去启动EvalVisitor和打印出当访问树时计算出的表达式的值。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">EvalVisitor evalVisitor = new EvalVisitor();
int result = evalVisitor.visit(tree);
System.out.println(&quot;visitor result = &quot; + result);
</code></pre></div>
<p>要构建计算器，需要告诉ANTLR使用-visitor参数去生成访问者。（如果我们不再需要生成监听器，可以使用-no-listener参数）以下是完整的构建和测试序列：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr -visitor LExpr.g
compile *.java
run TestLEvalVisitor
</code></pre></div>
<p>接着输入以下内容：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">1+2*3
EOF
</code></pre></div>
<p>你就会看到如下结果：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(s (e (e 1) + (e (e 2) * (e 3))))
visitor result = 7
</code></pre></div>
<p>如果我们需要特定应用的返回值，访问者工作的相当好，因为我们使用了内建的Java返回值机制。如果我们不希望显式地调用访问者方法去访问子节点，我们可以切换到监听器机制，不幸的是，这意味着我们要放弃使用Java方法返回值的整洁。</p>

<h4 id="使用栈模拟返回值">使用栈模拟返回值</h4>

<p>ANTLR生成的监听器事件方法没有返回值。为了给在语法分析树更高节点上执行的监听器方法返回值，我们可以把部分的值存储在监听器的一个字段中。我们会想到用栈来存储值，方法就是把计算一个子表达式的结果推送到栈中，在语法分析树上用于子表达式的方法则把运算元从栈中弹出。以下是完整的Evaluator计算器监听器（代码在TestLEvaluator.java文件中）：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public static class Evaluator extends LExprBaseListener {
    Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
    public void exitMult(LExprParser.MultContext ctx) {
        int right = stack.pop();
        int left = stack.pop();
        stack.push(left * right);
    }
    public void exitAdd(LExprParser.AddContext ctx) {
        int right = stack.pop();
        int left = stack.pop();
        stack.push(left + right);
    }
    public void exitInt(LExprParser.IntContext ctx) {
        stack.push(Integer.valueOf(ctx.INT().getText()));
    }
}
</code></pre></div>
<p>要测试上面的这段代码，我们可以创建和使用在代码TestLEvaluator中的ParseTreeWalker，以下是完整的构建和测试序列：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr LExpr.g
compile *.java
run TestLEvaluator
</code></pre></div>
<p>接着输入以下内容：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">1+2*3
EOF
</code></pre></div>
<p>你就会看到如下结果：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(s (e (e 1) + (e (e 2) * (e 3))))
stack result = 7
</code></pre></div>
<p>使用栈字段有点别扭但工作得很好。我们必须确保事件方法以正确的顺序压入和弹出跨越监听器事件的值。带有返回值的访问者没有栈的这种笨拙但却需要手工访问树的节点。第三种实现是通过把部分值隐藏在树节点中来捕获它们。</p>

<h4 id="注解语法分析树">注解语法分析树</h4>

<p>作为使用临时存储在事件方法间共享数据的替代，我们可以把这些值存储在语法分析树本身中。使用树注解方法时我们可以带有监听器或访问者，但在这里我们使用监听器来阐明如何使用它。让我们首先看一下用部分结果注解的1+2*3的LExpr语法分析树。</p>

<p><img src="/uploads/lexpr-parse-tree.png" title="lexpr-parse-tree" ></p>

<p>每个子表达式对应一个子树根（和对应一个e规则调用）。从e节点发出的水平线指向的数字是我们想要返回的部分结果。</p>

<p>让我们看看节点注解策略将如何工作在来自LExpr语法的规则e上。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">e : e MULT e    # Mult
  | e ADD e     # Add
  | INT         # Int
  ;
</code></pre></div>
<p>e选项的监听器方法每个都会存储一个结果在相对应的e语法分析树节点中。任何随后的在语法分析树更高节点上的add或multiply事件将通过查看存储在它们对应的子节点中的值来抓取子表达式的值。</p>

<p>现在，让我们假设每个语法分析树节点（每个规则上下文对象）都有一个字段value，那么exitAdd()看起来将是这样；</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitAdd(LExprParser.AddContext ctx) {
    // e(0).value is the subexpression value of the first e in the alternative
    ctx.value = ctx.e(0).value + ctx.e(1).value;    // e &#39;+&#39; e # Add
}
</code></pre></div>
<p>这看起来相当合理，但不幸的是，在Java中我们不能扩展类ExprContext去动态地添加字段。为了让语法分析树注解生效，我们需要一种方法去注解各式各样的节点而不需要手工修改由ANTLR生成的关联节点类。</p>

<p>注解语法分析树节点最简单的方式是使用与节点任意值相关联的一个Map。因此，ANTLR提供了一个简单的帮助类ParseTreeProperty。让我们在文件TestLEvaluatorWithProps.java中构建称作EvaluatorWithProps的另一个计算器版本，它使用ParseTreeProperty关联了LExpr语法分析树节点和部分结果。以下是在监听器开始处的适当的定义：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public static class EvaluatorWithProps extends LExprBaseListener {
    /** maps nodes to integers with Map&lt;ParseTree,Integer&gt; */
    ParseTreeProperty&lt;Integer&gt; values = new ParseTreeProperty&lt;Integer&gt;();
</code></pre></div>
<p>注意：如果你想使用自己的Map类型字段代替ParseTreeProperty，确保它继承自IdentityHashMap，而不是通常的HashMap。我们需要去注解特殊的节点，进行同一性测试而不是equals()。两个e节点可能是equals()，但在内存中不是同一个物理节点。</p>

<p>为注解一个节点，我们使用values.put(node, value)。为得到和一个节点有关联的值，我们使用values.get(node)。这很好，但是让我们创建一些有直白名字的帮助方法以便让代码更容易阅读。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void setValue(ParseTree node, int value) { values.put(node, value); }
public int getValue(ParseTree node) { return values.get(node); }
</code></pre></div>
<p>让我们从最简单的表达式选项Int开始监听器方法。我们想使用它匹配的INT记号的整型值去注解它的语法分析树e节点。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitInt(LExprParser.IntContext ctx) {
    String intText = ctx.INT().getText();    // INT    # Int
    setValue(ctx, Integer.valueOf(intText));
}
</code></pre></div>
<p>对于加法树，我们得到两个子表达式子节点的值（运算元）和带有和的注释的子树跟。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitAdd(LExprParser.AddContext ctx) {
    int left = getValue(ctx.e(0));    // e &#39;+&#39; e    # Add
    int right = getValue(ctx.e(1));
    setValue(ctx, left + right);
}
</code></pre></div>
<p>方法exitMult()是相同的，只是运算的时候用multiply代替了add。</p>

<p>我们的测试代码从分析规则s开始。因此我们必须确保语法分析树根有e子树的值。为把值从e节点冒泡到根s节点，我们实现了exitS()。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">/** Need to pass e&#39;s value out of rule s : e ; */
public void exitS(LExprParser.SContext ctx) {
    setValue(ctx, getValue(ctx.e()));    // like: int s() { return e(); }
}
</code></pre></div>
<p>以下是如何启动监听器以及打印出来自语法分析树根节点的表达式的值：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">ParseTreeWalker walker = new ParseTreeWalker();
EvaluatorWithProps evalProp = new EvaluatorWithProps();
walker.walk(evalProp, tree);
System.out.println(&quot;properties result = &quot; + evalProp.getValue(tree));
</code></pre></div>
<p>以下是构建和测试序列：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr LExpr.g
compile *.java
run TestLEvaluatorWithProps
</code></pre></div>
<p>接着输入以下内容：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">1+2*3
EOF
</code></pre></div>
<p>你就会看到如下结果：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(s (e (e 1) + (e (e 2) * (e 3))))
stack result = 7
</code></pre></div>
<p>现在我们已经看到了相同计算器的3个实现，并且我们也已经准备好把我们的知识用于构建真实案例。因为每个方法都有它的优势和劣势，下面就让我们来比较下不同的技术。</p>

<h3 id="比较信息共享方法">比较信息共享方法</h3>

<p>为得到可复用和可重定目标的语法，我们需要让它们完全清除用户定义的动作。这意味着要把所有特定应用的代码放到语法外的某些监听器和访问者中。监听器和访问者操作语法分析树，ANTLR自动生成合适的树遍历接口和默认实现。因为事件方法签名是固定的和不特定于应用的，所以事件方法可以共享信息的方式有3种：</p>

<ul>
<li>本地Java调用栈：访问者返回用户定义类型的一个值。如果访问者需要传递参数，它也必须使用下面两种技术的一种。</li>
<li>基于栈：一个栈字段模仿参数和返回值，像Java调用栈那样。</li>
<li>注解者：一个Map字段使用有用的值注解节点。</li>
</ul>

<p>所有这3种方法是和语法本身完全解耦的，并且很好地封装在专门的对象中。除此之外，它们也都有各自的优点和缺点。我们可以根据问题的需要和个人的喜好决定采取哪种方法。你甚至可以在同一个应用中使用多种方法。</p>

<p>访问者方法很好懂，因为它们直接调用其它访问者方法去获取部分结果，并且能像其它任何方法那样返回值。这也是它们的缺点，访问者方法必须显式地访问它们的子节点。而监听器就不需要。因为访问者有个通用的接口，所以它不能定义参数。访问者必须使用其它解决方案的一种去传递参数给它在子节点上调用的访问者方法。访问者的空间效率很好，因为它在任何时间仅需保留少数的部分结果。在树遍历后没有部分结果保留。当访问者方法可以返回值时，每个值必须是同种类型，不想其它的解决方案。</p>

<p>基于栈的解决方案可以模仿参数和返回带有一个栈的值，但在手动管理栈时有个断开的机会。这可能会发生，因为监听器方法不能直接调用彼此。作为程序员，我们必须确定推入栈中的在将来事件方法调用能适当地弹出。栈可以传递多个值和多个返回值。基于栈的解决方案也是空间有效的，因为它不会把任何东西固定到树上。在树遍历后所有的部分结果存储消失。</p>

<p>注解者通常可以作为默认解决方案采用，因为它允许你任意地提供信息给事件方法操作语法分析树中上上下下的节点。你也可以传递多个值，它们可以是任意类型。在许多情况下注解胜于使用带有短暂值的栈。在各种方法的数据传递准备间很少有断开的机会。比起在编程语言中说返回值，使用setValue(ctx, value)注解树不太直观，但是更通用。超过其它两种的这种方法的唯一缺点是在树遍历期间部分结果是保留的，因此它有较大的内存占用。</p>

<p>从另一方面来说，在某些应用中能够注解树正是我们需要的。应用需要在树上通过多遍，第一遍是很方便在树上计算和储存数据的。当语法分析树遍历器重新遍历树的时候第二遍然后就很容易访问数据。总的来说，树注解非常灵活，有一个可接受的内存负担。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（23）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part23/"/>
    <updated>2016-08-16T18:09:05+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part23</id>
    <content type="html"><![CDATA[<p>默认情况下，ANTLR为每个规则生成一个单一的事件类型，而不管语法分析器匹配了哪个选项。这很不方便，因为监听器和访问者方法必须确定哪个选项被语法分析器匹配。在本节中，我们将看到如何得到更细粒度的事件。</p>

<h3 id="为规则选项贴标签以得到精确的事件方法">为规则选项贴标签以得到精确的事件方法</h3>

<p>为阐明事件粒度问题，让我们为以下的表达式语法构建一个带有监听器的简单计算器：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grammar Expr;
s : e ;
e : e op=MULT e    // MULT is &#39;*&#39;
  | e op=ADD e     // ADD is &#39;+&#39;
  | INT
  ;
</code></pre></div>
<p>按照上面的语法，规则e会产生一个相当无用的监听器，因为规则e的所有选项导致树遍历器触发相同的enterE()和exitE()方法。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public interface ExprListener extends ParseTreeListener {
    void enterE(ExprParser.EContext ctx);
    void exitE(ExprParser.EContext ctx);
</code></pre></div>
<p>监听器方法必须使用op记号标签和ctx的方法进行测试以查看语法分析器为每个e子树匹配了哪个选项。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitE(ExprParser.EContext ctx) {
    if (ctx.getChildCount() == 3) {    // operations have 3 children
        int left = values.get(ctx.e(0));
        int right = values.get(ctx.e(1));
        if (ctx.op.getType() == ExprParser.MULT) {
            values.put(ctx, left * right);
        } else {
            values.put(ctx, left + right);
        }
    } else {
        values.put(ctx, values.get(ctx.getChild(0)));    // an INT
    }
}
</code></pre></div>
<p>在exitE()中引用的MULT字段是在ExprParser中由ANTLR自动生成的：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class ExprParser extends Parser {
    public static final int MULT=1, ADD=2, INT=3, WS=4;
</code></pre></div>
<p>如果我们查看在类ExprParser中的类EContext，我们可以看到ANTLR把来自3个选项的所有元素都塞进了相同的上下文对象。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public static class EContext extends ParserRuleContext {
    public Token op;                     // derived from label op
    public List&lt;EContext&gt; e() { ... }    // get all e subtrees
    public EContext e(int i) { ... }     // get ith e subtree
    public TerminalNode INT() { ... }    // get INT node if alt 3 of e
</code></pre></div>
<p>为得到更精确的监听器事件，ANTLR让我们使用#运算符给任何规则最外层的选项打标签。让我们从Expr派生语法LExpr，并给e的选项打上标签，以下是修改后的e规则：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">e : e MULT e  # Mult
  | e ADD e   # Add
  | INT       # Int
  ;
</code></pre></div>
<p>现在，ANTLR为e的每个选项生成了单独的监听器方法，因此，我们不再需要op记号标签。对于选项标签X，ANTLR生成方法enterX()和exitX()。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public interface LExprListener extends ParseTreeListener {
    void enterMult(LExprParser.MultContext ctx);
    void exitMult(LExprParser.MultContext ctx);
    void enterAdd(LExprParser.AddContext ctx);
    void exitAdd(LExprParser.AddContext ctx);
    void enterInt(LExprParser.IntContext ctx);
    void exitInt(LExprParser.IntContext ctx);
    ...
}
</code></pre></div>
<p>注意，ANTLR也为选项生成特定的以标签命名的上下文对象（EContext的子类）。专门的上下文对象的getter方法只限于应用在那些相关的选项。例如，IntContext只有一个INT()方法，我们可以在enterInt()中调用ctx.INT()，但在enterAdd()中就不能。</p>

<p>监听器和访问者是极好的。我们只需要通过充实事件方法就可以得到可复用和可重定目标的语法以及封装的语言应用。ANTLR甚至会为我们自动生成骨架代码。</p>
]]></content>
  </entry>
  
</feed>
