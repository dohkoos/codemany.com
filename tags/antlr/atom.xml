<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: ANTLR | 乐者为王]]></title>
  <link href="http://codemany.com/tags/antlr/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2017-02-24T13:09:22+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（30）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part30/"/>
    <updated>2016-10-26T18:02:32+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part30</id>
    <content type="html"><![CDATA[<p>有时我们在调试语法时需要ANTLR提供更好的消息提示，为达到这个目的，我们可以改变ANTLR的标准错误报告。</p>

<h3 id="改变和重定向antlr错误消息">改变和重定向ANTLR错误消息</h3>

<p>默认情况下，ANTLR把所有的错误发送给标准错误，但我们可以通过提供ANTLRErrorListener接口的实现来修改目标和内容。该接口有syntaxError()方法可以应用于词法分析器和语法分析器。方法syntaxError()接收各种有关错误的位置以及错误消息的信息。它也接收语法分析器的一个引用，因此我们可以查询关于识别的状态。</p>

<p>例如，这里是一个错误监听器，它打印规则调用栈以及随后的用有问题的记号信息来加强的通常错误消息：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public static class VerboseListener extends BaseErrorListener {
    @Override
    public void syntaxError(Recognizer&lt;?, ?&gt; recognizer,
                            Object offendingSymbol,
                            int line, int charPositionInLine,
                            String msg,
                            RecognitionException e)
    {
        List&lt;String&gt; stack = ((Parser)recognizer).getRuleInvocationStack();
        Collections.reverse(stack);
        System.err.println(&quot;rule stack: &quot;+stack);
        System.err.println(&quot;line &quot;+line+&quot;:&quot;+charPositionInLine+&quot; at &quot;+
        offendingSymbol+&quot;: &quot;+msg);
    }
}
</code></pre></div>
<p>使用这个定义，我们的应用可以很容易地在调用开始规则前给语法分析器添加一个错误监听器。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">SimpleParser parser = new SimpleParser(tokens);
parser.removeErrorListeners();    // remove ConsoleErrorListener
parser.addErrorListener(new VerboseListener());    // add ours
parser.prog();    // parse as usual
</code></pre></div>
<p>在添加我们自己的错误监听器之前，必须先移除标准的终端错误监听器，否则的话就会得到重复的错误消息。</p>

<p>现在让我们看下包含一个额外类名以及缺少字段名的类定义的错误消息看起来是什么样子：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">compile *.java
run TestE_Listener
</code></pre></div>
<p>以下是包含额外类名以及缺少字段名的类定义：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class T T {
  int ;
}
</code></pre></div>
<p>然后我们就会看到如下错误消息：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">rule stack: [prog, classDef]
line 1:8 at [@2,8:8=&#39;T&#39;,&lt;9&gt;,1:8]: extraneous input &#39;T&#39; expecting &#39;{&#39;
rule stack: [prog, classDef, member]
line 2:6 at [@5,18:18=&#39;;&#39;,&lt;8&gt;,2:6]: no viable alternative at input &#39;int;&#39;
class T
</code></pre></div>
<p>栈[prog, classDef]指出语法分析器在规则classDef中，且被prog调用。注意，记号信息包含在输入流中的字符位置，这在高亮输入中的错误时是非常有用的。例如，记号[@2,8:8=&#39;T&#39;,<9>,1:8]指出它是记号流中的第3个记号（索引从0开始），字符范围从8到8，记号类型为9，位于第1行，并且在字符位置8（计数从0开始，且TAB被当作一个字符）。</p>

<p>作为另一个示例，让我们构建一个错误监听器TestE_Listener2.java，它打印带有被下划线强调的有错误的记号的行。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">compile *.java
run TestE_Listener2
</code></pre></div>
<p>输入以下数据：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class T XYZ {
  int ;
}
</code></pre></div>
<p>然后就会看如如下错误信息：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">line 1:8 extraneous input &#39;XYZ&#39; expecting &#39;{&#39;
class T XYZ {
        ^^^
line 2:6 no viable alternative at input &#39;int;&#39;
  int ;
      ^
class T
</code></pre></div>
<p>为了让事情变得更容易，我们将忽略TAB——charPositionInLine不是列号，因为TAB的大小不是统一定义的。这里是一个错误监听器实现，强调输入中的错误位置。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public static class UnderlineListener extends BaseErrorListener {
    public void syntaxError(Recognizer&lt;?, ?&gt; recognizer,
                            Object offendingSymbol,
                            int line, int charPositionInLine,
                            String msg,
                            RecognitionException e) {
        System.err.println(&quot;line &quot;+line+&quot;:&quot;+charPositionInLine+&quot; &quot;+msg);
        underlineError(recognizer,(Token)offendingSymbol,
        line, charPositionInLine);
    }

    protected void underlineError(Recognizer recognizer,
                                  Token offendingToken, int line,
                                  int charPositionInLine) {
        CommonTokenStream tokens =
            (CommonTokenStream)recognizer.getInputStream();
        String input = tokens.getTokenSource().getInputStream().toString();
        String[] lines = input.split(&quot;\n&quot;);
        String errorLine = lines[line - 1];
        System.err.println(errorLine);
        for (int i=0; i&lt;charPositionInLine; i++) System.err.print(&quot; &quot;);
        int start = offendingToken.getStartIndex();
        int stop = offendingToken.getStopIndex();
        if ( start&gt;=0 &amp;&amp; stop&gt;=0 ) {
            for (int i=start; i&lt;=stop; i++) System.err.print(&quot;^&quot;);
        }
        System.err.println();
    }
}
</code></pre></div>
<p>关于错误监听器还有一件事需要知道。当语法分析器侦测到一个模棱两可的输入序列时，它会通知错误监听器。默认的错误监听器ConsoleErrorListener实际上不会在终端打印任何东西，也就是说，语法分析器不会通知用户。让我们回顾下能用两种方式匹配输入<code>f();</code>的那段歧义语法。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grammar Ambig;

stat: expr &#39;;&#39;    // expression statement
    | ID &#39;(&#39; &#39;)&#39; &#39;;&#39;    // function call statement
    ;

expr: ID &#39;(&#39; &#39;)&#39;
    | INT
    ;

INT : [0-9]+ ;
ID  : [a-zA-Z]+ ;
WS  : [ \t\r\n]+ -&gt; skip ;
</code></pre></div>
<p>如果我们测试这段语法，我们不会看到有关模棱两可的输入的警告。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr Ambig.g
compile *.java
grun Ambig stat
</code></pre></div>
<p>然后输入：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">f();
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（29）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part29/"/>
    <updated>2016-10-18T11:22:11+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part29</id>
    <content type="html"><![CDATA[<p>当我们开发一套语法时，会有很多错误要去修复。在完成语法前，生成的语法分析器不会识别所有有效的句子。在这期间，提供有用信息的错误消息帮助我们追踪到语法问题。一旦我们有了一套正确的语法，然后我们就必须处理用户输入的不合语法的句子，或者甚至由其它程序发生故障生成的不合语法的句子。在这两种情况下，语法分析器对不合语法的输入的响应方式是一个需要重点考虑的问题。</p>

<p>在这里，我们将学习被ANTLR生成的语法分析器使用的自动错误报告和恢复策略。</p>

<h3 id="错误展示">错误展示</h3>

<p>描述ANTLR的错误恢复策略的最好方式是观察由它生成的语法分析器对错误输入的响应。让我们看一个类Java语言的语法，它包含带有字段和方法成员的类定义。该方法有简单的语句和表达式。嵌入动作在语法分析器找到元素时就打印它们。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grammar Simple;

prog: classDef+ ; // match one or more class definitions

classDef
    : &#39;class&#39; ID &#39;{&#39; member+ &#39;}&#39; // a class has one or more members
      {System.out.println(&quot;class &quot;+$ID.text);}
    ;

member
    : &#39;int&#39; ID &#39;;&#39;    // field definition
      {System.out.println(&quot;var &quot;+$ID.text);}
    | &#39;int&#39; f=ID &#39;(&#39; ID &#39;)&#39; &#39;{&#39; stat &#39;}&#39;    // method definition
      {System.out.println(&quot;method: &quot;+$f.text);}
    ;

stat: expr &#39;;&#39;
      {System.out.println(&quot;found expr: &quot;+$stat.text);}
    | ID &#39;=&#39; expr &#39;;&#39;
      {System.out.println(&quot;found assign: &quot;+$stat.text);}
    ;

expr: INT
    | ID &#39;(&#39; INT &#39;)&#39;
    ;

INT : [0-9]+ ;
ID  : [a-zA-Z]+ ;
WS  : [ \t\r\n]+ -&gt; skip ;
</code></pre></div>
<p>现在，先让我们使用一些有效的输入运行语法分析器，借以观测正常的输出。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr Simple.g
compile *.java
grun Simple prog
</code></pre></div>
<p>输入以下数据：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class T { int i; }
</code></pre></div>
<p>你就会看到：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">var i
class T
</code></pre></div>
<p>语法分析器没有显示任何错误，它执行打印语句，报告关于变量i和类定义T的正确识别。</p>

<p>接下来，让我们尝试一个带有方法定义的类，该方法含有一个虚假赋值表达式。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grun Simple prog -gui
</code></pre></div>
<p>输入测试数据：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class T {
  int f(x) { a = 3 4 5; }
}
</code></pre></div>
<p>然后你就会看到：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">line 2:19 mismatched input &#39;4&#39; expecting &#39;;&#39;
method: f
class T
</code></pre></div>
<p>在4记号处，语法分析器没有找到它期待的“;”，所以它报告一个错误。line 2:19指出有问题的标记是在第2行第19列的字符位置（字符位置从0开始）。因为使用了-gui参数，我们可以看到带有高亮错误节点的语法分析树。</p>

<p><img src="/uploads/simple-parse-tree.png" title="simple-parse-tree" ></p>

<p>在这里，有两个额外的记号，并且语法分析器给出一个不匹配的通用错误消息。如果只有单个的额外记号，语法分析器可能会智能一点，指出它是一个额外的记号。在接下来的运行测试中，有个额外的“;”在类名和类体之间：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grun Simple prog
</code></pre></div>
<p>输入如下：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class T ; { int i; }
</code></pre></div>
<p>输出结果：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">line 1:8 extraneous input &#39;;&#39; expecting &#39;{&#39;
var i
class T
</code></pre></div>
<p>在“;”处语法分析器报告一个错误，但给出了一个稍微翔实的答案，因为它知道下一个记号就是它实际上在寻找的那个。这个特性被称为单个记号删除（single-token deletion），因为语法分析器可以简单地装作额外的记号不存在并继续执行。</p>

<p>同样的，语法分析器可以在侦测到缺少一个记号时做单个记号插入（single-token insertion）。让我们删掉结束的“}”看看会发生什么。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grun Simple prog
</code></pre></div>
<p>然后输入：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class T {
  int f(x) { a = 3; }
</code></pre></div>
<p>结果是：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">found assign: a=3;
method: f
line 3:0 missing &#39;}&#39; at &#39;&lt;EOF&gt;&#39;
class T
</code></pre></div>
<p>语法分析器报告它不能找到必须的结束记号“}”。</p>

<p>当语法分析器处于决策点时，会出现另一个常见的语法错误，并且剩余的输入与规则或子规则的任何选项都不一致。例如，如果我们忘记字段声明中的变量名，规则member中的选项都不匹配。语法分析器报告没有可行的选项。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grun Simple prog
</code></pre></div>
<p>输入以下代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class T { int ; }
</code></pre></div>
<p>然后结果是：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">line 1:14 no viable alternative at input &#39;int;&#39;
class T
</code></pre></div>
<p>在“int”和“;”之间没有空格，因为我们在WS()规则中告诉词法分析器skip()。</p>

<p>如果有词法错误，ANTLR也会放出错误消息，指出哪些字符不能匹配为记号。例如，如果我们提交一个完全未知的字符，我们将得到一个记号识别错误。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grun Simple prog
</code></pre></div>
<p>输入：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class # { int i; }
</code></pre></div>
<p>输出：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">line 1:6 token recognition error at: &#39;#&#39;
line 1:8 missing ID at &#39;{&#39;
var i
class &lt;missing ID&gt;
</code></pre></div>
<p>因为没有给出有效的类名，单个记号插入机制召唤了“missing ID”名字，以致类名记号是非空值。如果想控制语法分析器如何召唤记号，可以覆盖DefaultErrorStrategy中的getMissingSymbol()。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（28）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part28/"/>
    <updated>2016-10-06T18:42:25+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part28</id>
    <content type="html"><![CDATA[<ul>
<li>scope 作用域</li>
</ul>

<p>为了阐明Cymbol语法是可复用的，本节中我们将在不做修改的基础上再次使用它，用于构建一个完全不同的应用。不仅如此，我们还会在同样的树上使用两个不同的监听器做两次遍历。</p>

<h3 id="验证程序符号的使用情况">验证程序符号的使用情况</h3>

<p>为Cymbol这样的编程语言构建解释器、编译器或者转换器，我们需要验证Cymbol程序是否正确地使用符号（标志符）。接下来，我们将构建一个Cymbol验证器用于检查以下的条件：</p>

<ul>
<li>可见的变量引用有相应的定义（在作用域内）。</li>
<li>函数引用有相应的定义（函数可以以任何顺序出现）。</li>
<li>变量不作为函数使用。</li>
<li>函数不作为变量使用。</li>
</ul>

<p>让我们看一下有许多不同引用的Cymbol示例代码，其中有些是无效的。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">int f(int x, float y) {
    g();      // forward reference is ok
    i = 3;    // no declaration for i (error)
    g = 4;    // g is not variable (error)
    return x + y;    // x, y are defined, so no problem
}
void g() {
    int x = 0;
    float y;
    y = 9;    // y is defined
    f();      // backward reference is ok
    z();      // no such function (error)
    y();      // y is not function (error)
    x = f;    // f is not a variable (error)
}
</code></pre></div>
<p>为验证程序中的一切都没问题，根据前面的条件，我们应该打印出函数列表和本地变量以及全局符号列表（函数和全局变量）。更进一步，当我们发现问题时应该给出一个错误。例如，使用上述输入，让我们构建一个称为CheckSymbols的应用。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">java CheckSymbols vars.cymbol
</code></pre></div>
<p>在执行以上命令后会生成如下输出：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">locals:[]
function&lt;f:tINT&gt;:[&lt;x:tINT&gt;, &lt;y:tFLOAT&gt;]
locals:[x, y]
function&lt;g:tVOID&gt;:[]
globals:[f, g]
line 3:4 no such variable: i
line 4:4 g is not a variable
line 13:4 no such function: z
line 14:4 y is not a function
line 15:8 f is not a variable
</code></pre></div>
<p>实现这类问题的关键是一个被称为符号表的相应的数据结构。我们的应用会把符号存在符号表中，然后通过在符号表中查找符号引用检查它们的正确性。在接下来的部分，我们将大概看一看数据结构看起来像什么，并且使用它去解决手头的验证问题。</p>

<h3 id="符号表中的速成课">符号表中的速成课</h3>

<p>语言实现者通常称持有符号的数据结构为符号表。语言的实现决定符号表的结构和复杂性，如果一门语言允许相同的标志符在不同的上下文中指向不同的东西，符号表会将那些符号分组到不同的作用域中。作用域只是一组符号，例如函数的参数列表或变量列表以及在全局作用域内的函数。</p>

<p>符号表自身只是一个符号定义的存储库——它不作任何检查。为了验证代码，我们需要检查表达式中违反我们之前设置的规则的变量和函数引用。符号验证有两个基本操作：定义符号和解决符号。定义一个符号意味着把它添加到一个作用域中。解决一个符号意味着计算出符号指向哪个定义。在某种程度上，解决一个符号意味着找到最近的匹配定义。最近的作用域是最近的封闭作用域。例如，让我们看看另一个Cymbol例子，它在不同的作用域有符号定义。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">int x;
int y;
void a()
{
    int x;
    x = 1;
    // x resolves to current scope, not x in global scope
    y = 2;
    // y is not found in current scope, but resolves in global
    { int y = x; }
}
void b(int z)
{ }
</code></pre></div>
<p>全局作用域包含变量x和y以及函数a()和b()。函数处于全局作用域，但它们也构成新的作用域用于持有函数的参数，如果有的话。同样嵌套在函数作用域内的是函数本地代码块，它们构成另一个新的作用域。本地变量被约束在嵌套在函数作用域内的本地作用域内。</p>

<p>因为符号x被定义了两次，所以做不到仅把所有标识符都填充进单个集合而没有冲突。这也是作用域出现的原因。我们保留一组作用域，并且一个作用域中的每个标志符只允许有单个定义。我们还保留一个指向父作用域的指针，以便在外层作用域中找到符号定义。这些作用域形成了一棵树。</p>

<p><img src="/uploads/cymbol-scope-tree.png" title="cymbol-scope-tree" ></p>

<p>沿着从任何作用域到根（全局作用域）的路径的所有节点形成一堆作用域。为了找到一个符号的定义，我们从围绕着引用的作用域开始，并沿着作用域树向上遍历，直到找到它的定义。</p>

<h3 id="验证器架构">验证器架构</h3>

<p>开始构建验证器前，先让我们思考下大方向和总体策略。我们可以根据关键操作——定义和解决——把问题分解。对于定义，我们需要侦听变量和函数定义事件，然后把符号对象插入围绕着定义的作用域。在函数定义的开始处，我们需要压栈一个新的作用域，然后在函数定义的结尾处把它出栈。</p>

<p>为解决和检查符号引用，我们需要侦听在表达式中的变量和函数名字引用。针对每个引用，我们将验证是否有匹配的定义，以及引用是否正确使用符号。</p>

<p>这似乎很直截了当，但有个并发症：在源码文件中，Cymbol程序可以调用在它之后定义的一个函数。我们称它为前向引用。为支持这个特性，我们需要在语法分析树上执行两次遍历。第一遍，或者阶段，定义包含函数的符号，然后第二遍进行解决。用这种方法，第二遍可以看到文件中的所有函数。以下是用于触发在语法分析树上两次遍历的代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">ParseTreeWalker walker = new ParseTreeWalker();
DefPhase def = new DefPhase();
walker.walk(def, tree);
// create next phase and feed symbol table info from def to ref phase
RefPhase ref = new RefPhase(def.globals, def.scopes);
walker.walk(ref, tree);
</code></pre></div>
<p>在定义阶段，我们将创建许多作用域。除非我们保持对它们的引用，否则垃圾收集器会回收它们。为了符号表能够度过从定义到解决阶段的转变，我们需要追踪这些作用域。储存它们最合乎逻辑的地方是在语法分析树本身（或者，从技术上讲，使用关联值与树节点的注解映射）。然后引用阶段就可以在它下行语法分析树时很简单地获得当前作用域的指针。与函数和本地块关联的树节点将可以获得它们的作用域的指针。</p>

<h3 id="定义和解决符号">定义和解决符号</h3>

<p>考虑到我们的基本策略，让我们从DefPhase开始构建我们的验证器。这个阶段类需要3个字段：一个全局作用域的引用、一个用于追踪我们创建的作用域的语法分析树注解器，以及一个当前作用域的指针。enterFile()的监听器代码在活动开始时创建全局变量。当活动结束时，exitFile()负责打印结果。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class DefPhase extends CymbolBaseListener {
    ParseTreeProperty&lt;Scope&gt; scopes = new ParseTreeProperty&lt;Scope&gt;();
    GlobalScope globals;
    Scope currentScope;    // define symbols in this scope
    public void enterFile(CymbolParser.FileContext ctx) {
        globals = new GlobalScope(null);
        currentScope = globals;
    }
    public void exitFile(CymbolParser.FileContext ctx) {
        System.out.println(globals);
    }
</code></pre></div>
<p>当语法分析器找到函数声明时，应用需要创建一个FunctionSymbol对象。作为一个符号和作为一个包含参数的作用域，FunctionSymbol对象负有双重责任。为把函数作用域嵌套在全局作用域内，我们需要把函数作用域压栈。我们通过设置函数的封闭作用域为当前作用域并重置当前作用域来做到这点。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void enterFunctionDecl(CymbolParser.FunctionDeclContext ctx) {
    String name = ctx.ID().getText();
    int typeTokenType = ctx.type().start.getType();
    Symbol.Type type = CheckSymbols.getType(typeTokenType);

    // push new scope by making new one that points to enclosing scope
    FunctionSymbol function = new FunctionSymbol(name, type, currentScope);
    currentScope.define(function);    // Define function in current scope
    saveScope(ctx, function);         // Push: set function&#39;s parent to current
    currentScope = function;          // Current scope is now function scope
}

void saveScope(ParserRuleContext ctx, Scope s) {
    scopes.put(ctx, s);
}
</code></pre></div>
<p>方法saveScope()使用函数作用域注解functionDecl规则节点，以便在随后的引用阶段可以获得它。当我们离开函数时就出栈函数作用域，因此当前作用域仍然是全局作用域。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitFunctionDecl(CymbolParser.FunctionDeclContext ctx) {
    System.out.println(currentScope);
    currentScope = currentScope.getEnclosingScope();    // pop scope
}
</code></pre></div>
<p>本地作用域以类似的方式工作。我们在监听器方法enterBlock()中压栈一个作用域，然后在exitBlock()中出栈它。</p>

<p>在处理好作用域和函数定义后，我们就可以开始定义参数和变量。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitFormalParameter(CymbolParser.FormalParameterContext ctx) {
    defineVar(ctx.type(), ctx.ID().getSymbol());
}
public void exitVarDecl(CymbolParser.VarDeclContext ctx) {
    defineVar(ctx.type(), ctx.ID().getSymbol());
}
void defineVar(CymbolParser.TypeContext typeCtx, Token nameToken) {
    int typeTokenType = typeCtx.start.getType();
    Symbol.Type type = CheckSymbols.getType(typeTokenType);
    VariableSymbol var = new VariableSymbol(nameToken.getText(), type);
    currentScope.define(var); // Define symbol in current scope
}
</code></pre></div>
<p>到此，定义阶段已经完成。</p>

<p>为构建引用阶段，让我们将当前作用域设置为从定义阶段传递过来的全局作用域。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public RefPhase(GlobalScope globals, ParseTreeProperty&lt;Scope&gt; scopes) {
    this.scopes = scopes;
    this.globals = globals;
}
public void enterFile(CymbolParser.FileContext ctx) {
    currentScope = globals;
}
</code></pre></div>
<p>然后，就像树遍历器触发Cymbol函数和块的进入与退出事件那样，监听器方法通过访问在定义阶段期间存储在树中的值来及时更新currentScope。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void enterFunctionDecl(CymbolParser.FunctionDeclContext ctx) {
    currentScope = scopes.get(ctx);
}
public void exitFunctionDecl(CymbolParser.FunctionDeclContext ctx) {
    currentScope = currentScope.getEnclosingScope();
}
public void enterBlock(CymbolParser.BlockContext ctx) {
    currentScope = scopes.get(ctx);
}
public void exitBlock(CymbolParser.BlockContext ctx) {
    currentScope = currentScope.getEnclosingScope();
}
</code></pre></div>
<p>随着遍历器的行进恰当地设置作用域，我们可以通过实现变量引用和函数调用的监听器方法解决符号。当遍历器遇到一个变量引用时，它调用exitVar()，该方法使用resolve()试图在当前作用域的符号表中查找变量名。如果resolve()在当前作用域中没有找到符号，它会查找封闭作用域链。如果必要，resolve()将寻找所有方式直到全局作用域。如果找不到一个合适的定义，它会返回null值。如果resolve()找到的符号是一个函数而不是变量，就需要生成一个错误消息。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitVar(CymbolParser.VarContext ctx) {
    String name = ctx.ID().getSymbol().getText();
    Symbol var = currentScope.resolve(name);
    if ( var==null ) {
        CheckSymbols.error(ctx.ID().getSymbol(), &quot;no such variable: &quot;+name);
    }
    if ( var instanceof FunctionSymbol ) {
        CheckSymbols.error(ctx.ID().getSymbol(), name+&quot; is not a variable&quot;);
    }
}
</code></pre></div>
<p>处理函数调用基本上是相同的，如果不能找到一个定义或找到了一个变量，都需要发出一个错误。</p>

<p>最后，是用来显示早先需要的输出的构建和测试序列：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr Cymbol.g
compile *.java
run CheckSymbols vars.cymbol
</code></pre></div>
<p>输出结果如下所示：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">locals:[]
function&lt;f:tINT&gt;:[&lt;x:tINT&gt;, &lt;y:tFLOAT&gt;]
...
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（27）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part27/"/>
    <updated>2016-09-28T09:32:41+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part27</id>
    <content type="html"><![CDATA[<p>前面我们主要处理的是数据，今天我们就来做些编程语言方面的事情。</p>

<h3 id="生成调用关系图">生成调用关系图</h3>

<p>软件很难编写和维护，这就是为什么我们试图构建工具去提高我们的生产力和工作效率。例如，在过去的十年里，我们已经看到测试框架、代码覆盖工具和代码分析器的激增，也很高心看到类层次结构的可视化树，以及大部分开发环境支持这个功能。其中有种可视化被称为调用图，它由函数作为节点，并且函数调用作为节点间的有向边。</p>

<p>这本节中，我们将使用Cymbol语法构建一个调用图生成器。考虑以下函数和函数调用集：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">int main() { fact(); a(); }
float fact(int n) {
    print(n);
    if (n == 0) then return 1;
    return n * fact(n - 1);
}
void a() { int x = b(); if false then {c(); d();} }
void b() { c(); }
void c() { b(); }
void d() { }
void e() { }
</code></pre></div>
<p>我们将会把它可视化成如下的调用图：</p>

<p><img src="/uploads/cymbol-call-graph.png" title="cymbol-call-graph" ></p>

<p>可视化的好处是人眼可以很容易地挑出偏差。例如，e()节点是个孤立节点，它意味着没有函数调用它，因此它是一段死代码。一目了然，我们找到一个可以被丢弃的函数。我们还可以通过在图中寻找像fact() -&gt; fact()和b() -&gt; c() -&gt; d()这样的循环非常容易地检测递归。</p>

<p>为了可视化调用图，我们需要读入一段Cymol程序和创建一个DOT文件。例如，以下是我们需要为t.cymbol生成的DOT文件。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">digraph G {
    ranksep=.25;
    edge [arrowsize=.5]
    node [shape=circle, fontname=&quot;ArialNarrow&quot;,
    fontsize=12, fixedsize=true, height=.45];
    main; fact; a; b; c; d; e;
    main -&gt; fact;
    main -&gt; a;
    fact -&gt; print;
    fact -&gt; fact;
    a -&gt; b;
    a -&gt; c;
    a -&gt; d;
    b -&gt; c;
    c -&gt; b;
}
</code></pre></div>
<p>上面的输出包括样本设置描述，例如ranksep=.25;和一列节点和边。为抓住孤立节点，我们需要确保为每个函数名生成节点定义，即使它没有出边和入边。否则它将不会出现在图中。注意在节点定义行末尾的e节点。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">main; fact; a; b; c; d; e;
</code></pre></div>
<p>我们的策略很简单，当语法分析器找到一个函数声明时，应用会把当前函数名添加到一个列表，并且设置一个字段称为currentFunctionName。当语法分析器看到一个函数调用，应用会记录从currentFunctionName到被调用函数名的一条边。</p>

<p>开始之前，让我们给Cymbol.g中的一些规则选项打上标签，以便获得更精确的监听器方法。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">expr: ID &#39;(&#39; exprList? &#39;)&#39;    # Call
    | expr &#39;[&#39; expr &#39;]&#39;       # Index
    | &#39;-&#39; expr                # Negate
    | &#39;!&#39; expr                # Not
    | expr &#39;*&#39; expr           # Mult
    | expr (&#39;+&#39;|&#39;-&#39;) expr     # AddSub
    | expr &#39;==&#39; expr          # Equal
    | ID                      # Var
    | INT                     # Int
    | &#39;(&#39; expr &#39;)&#39;            # Parens
    ;
</code></pre></div>
<p>然后，作为语言应用的基础，把所有图相关的东西封装进一个类。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">static class Graph {
    // I&#39;m using org.antlr.v4.runtime.misc: OrderedHashSet, MultiMap
    Set&lt;String&gt; nodes = new OrderedHashSet&lt;String&gt;();    // list of functions
    MultiMap&lt;String, String&gt; edges = new MultiMap&lt;String, String&gt;();    // caller-&gt;callee
    public void edge(String source, String target) {
        edges.map(source, target);
    }
</code></pre></div>
<p>从节点和边的集合中，我们可以在类Graph的toDOT()中使用一些Java代码转储出适当的DOT代码。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public String toDOT() {
    StringBuilder buf = new StringBuilder();
    buf.append(&quot;digraph G {\n&quot;);
    buf.append(&quot;    ranksep=.25;\n&quot;);
    buf.append(&quot;    edge [arrowsize=.5]\n&quot;);
    buf.append(&quot;    node [shape=circle, fontname=\&quot;ArialNarrow\&quot;,\n&quot;);
    buf.append(&quot;    fontsize=12, fixedsize=true, height=.45];\n&quot;);
    buf.append(&quot;    &quot;);
    for (String node : nodes) {    // print all nodes first
        buf.append(node);
        buf.append(&quot;; &quot;);
    }
    buf.append(&quot;\n&quot;);
    for (String src : edges.keySet()) {
        for (String trg : edges.get(src)) {
            buf.append(&quot;    &quot;);
            buf.append(src);
            buf.append(&quot; -&gt; &quot;);
            buf.append(trg);
            buf.append(&quot;;\n&quot;);
        }
    }
    buf.append(&quot;}\n&quot;);
    return buf.toString();
}
</code></pre></div>
<p>现在我们要做的是使用监听器填满这些数据结构，监听器需要两个字段用于记录。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">static class FunctionListener extends CymbolBaseListener {
    Graph graph = new Graph();
    String currentFunctionName = null;
</code></pre></div>
<p>然后应用只需要监听两个事件。首先，在语法分析器发现函数声明时记录当前的函数名。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void enterFunctionDecl(CymbolParser.FunctionDeclContext ctx) {
    currentFunctionName = ctx.ID().getText();
    graph.nodes.add(currentFunctionName);
}
</code></pre></div>
<p>其次，当语法分析器侦测到函数调用时，应用需要记录从当前函数到被调用函数的一条边。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitCall(CymbolParser.CallContext ctx) {
    String funcName = ctx.ID().getText();
    // map current function to the callee
    graph.edge(currentFunctionName, funcName);
}
</code></pre></div>
<p>注意，函数调用不能隐藏在嵌套代码块或诸如a()这样的声明中。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">void a() { int x = b(); if false then {c(); d();} }
</code></pre></div>
<p>无论什么时候，只要树遍历器发现函数调用就触发监听器方法exitCall()。</p>

<p>通过语法分析树和类FunctionListener，我们可以启动带有监听器的一个遍历器去产生输出。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">ParseTreeWalker walker = new ParseTreeWalker();
FunctionListener collector = new FunctionListener();
walker.walk(collector, tree);
System.out.println(collector.graph.toString())
</code></pre></div>
<p>在转储DOT字符串前，该代码会打印出函数和边的列表。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr Cymbol.g
compile *.java
run CallGraph t.cymbol
</code></pre></div>
<p>以下是部分输出结果：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">edges: {main=[fact, a], fact=[print, fact], a=[b, c, d], b=[c], c=[b]},
functions: [main, fact, a, b, c, d, e]
digraph G {
ranksep=.25;
edge [arrowsize=.5]
...
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（26）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part26/"/>
    <updated>2016-09-09T22:22:47+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part26</id>
    <content type="html"><![CDATA[<p>今天准备做的是把JSON文本文件转换成XML文本文件。</p>

<h3 id="把json转换成xml">把JSON转换成XML</h3>

<p>许多Web服务返回的是JSON数据，但是我们可能会遇到一种情况，需要把JSON数据送给那些只接受XML数据的代码。这就需要我们构建一个JSON到XML的转换器。我们的目标是读入像下面这样的JSON数据：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">{
&quot;description&quot; : &quot;An imaginary server config file&quot;,
&quot;logs&quot; : {&quot;level&quot;:&quot;verbose&quot;, &quot;dir&quot;:&quot;/var/log&quot;},
&quot;host&quot; : &quot;antlr.org&quot;,
&quot;admin&quot;: [&quot;parrt&quot;, &quot;tombu&quot;],
&quot;aliases&quot;: []
}
</code></pre></div>
<p>放出等价的XML数据，就像下面这样的：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&lt;description&gt;An imaginary server config file&lt;/description&gt;
&lt;logs&gt;
  &lt;level&gt;verbose&lt;/level&gt;
  &lt;dir&gt;/var/log&lt;/dir&gt;
&lt;/logs&gt;
&lt;host&gt;antlr.org&lt;/host&gt;
&lt;admin&gt;
  &lt;element&gt;parrt&lt;/element&gt;
  &lt;element&gt;tombu&lt;/element&gt;
&lt;/admin&gt;
&lt;aliases&gt;&lt;/aliases&gt;
</code></pre></div>
<p>正如我们对CSV做的那样，让我们给JSON语法中的一些选项打上标签，以便让ANTLR生成更精确的监听器方法。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">object
    : &#39;{&#39; pair (&#39;,&#39; pair)* &#39;}&#39;    # AnObject
    | &#39;{&#39; &#39;}&#39;                     # EmptyObject
    ;
array
    : &#39;[&#39; value (&#39;,&#39; value)* &#39;]&#39;  # ArrayOfValues
    | &#39;[&#39; &#39;]&#39;                     # EmptyArray
    ;
</code></pre></div>
<p>我们将对规则value做同样的事，但是稍有不同。除3个选项外的其它所有选项只需要返回被匹配的值的文本，所以我们可以为其它所有选项使用相同的标签，使语法分析树遍历器为那些选项触发相同的监听器方法。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">value
    : STRING    # String
    | NUMBER    # Atom
    | object    # ObjectValue
    | array     # ArrayValue
    | &#39;true&#39;    # Atom
    | &#39;false&#39;   # Atom
    | &#39;null&#39;    # Atom
    ;
</code></pre></div>
<p>为构建这样的转换器，明智的做法是让每个规则返回被它匹配的输入短语的XML等价物。为追踪部分结构，我们使用字段xml和两个帮助方法来注解语法分析树。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public static class XMLEmitter extends JSONBaseListener {
    ParseTreeProperty&lt;String&gt; xml = new ParseTreeProperty&lt;String&gt;();
    String getXML(ParseTree ctx) { return xml.get(ctx); }
    void setXML(ParseTree ctx, String s) { xml.put(ctx, s); }
</code></pre></div>
<p>我们把每棵子树转换后的字符串挂载到该子树的根节点。在语法分析树更高节点上工作的方法可以捕获这些值以便计算更大的字符串。然后挂载在根节点上的字符串完成计算。</p>

<p>让我们从最简单的转换开始。value的Atom选项返回匹配记号的文本。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitAtom(JSONParser.AtomContext ctx) {
    setXML(ctx, ctx.getText());
}
</code></pre></div>
<p>字符串基本上是相同的，只是我们必须去除双引号。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitString(JSONParser.StringContext ctx) {
    setXML(ctx, stripQuotes(ctx.getText()));
}
</code></pre></div>
<p>如果value()规则方法找到一个对象或数组，它可以把组合元素的部分转换拷贝到它自己的语法分析树节点。以下代码是找到对象时的处理：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitObjectValue(JSONParser.ObjectValueContext ctx) {
    // analogous to String value() {return object();}
    setXML(ctx, getXML(ctx.object()));
}
</code></pre></div>
<p>一旦我们可以转换所有的值，我们需要担心名-值对以及把它们转换成标签和文本。生成的XML的标签名字来源于STRING &#39;:&#39; value选项中的STRING。在左右尖括号之间的文本来源于挂载在value子节点上的文本。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitPair(JSONParser.PairContext ctx) {
    String tag = stripQuotes(ctx.STRING().getText());
    JSONParser.ValueContext vctx = ctx.value();
    String x = String.format(&quot;&lt;%s&gt;%s&lt;/%s&gt;\n&quot;, tag, getXML(vctx), tag);
    setXML(ctx, x);
}
</code></pre></div>
<p>JSON对象由名-值对组成。因此，对于被选项中标记为AnObject的object找到的每个对，我们把计算后的结果追加在语法分析树。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitAnObject(JSONParser.AnObjectContext ctx) {
    StringBuilder buf = new StringBuilder();
    buf.append(&quot;\n&quot;);
    for (JSONParser.PairContext pctx : ctx.pair()) {
        buf.append(getXML(pctx));
    }
    setXML(ctx, buf.toString());
}
public void exitEmptyObject(JSONParser.EmptyObjectContext ctx) {
    setXML(ctx, &quot;&quot;);
}
</code></pre></div>
<p>处理数组遵循相似的模式，只是简单地连接来自子节点的结果列表，然后把它们包裹在<code>&lt;element&gt;</code>标签中。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitArrayOfValues(JSONParser.ArrayOfValuesContext ctx) {
    StringBuilder buf = new StringBuilder();
    buf.append(&quot;\n&quot;);
    for (JSONParser.ValueContext vctx : ctx.value()) {
        buf.append(&quot;&lt;element&gt;&quot;); // conjure up element for valid XML
        buf.append(getXML(vctx));
        buf.append(&quot;&lt;/element&gt;&quot;);
        buf.append(&quot;\n&quot;);
    }
    setXML(ctx, buf.toString());
}
public void exitEmptyArray(JSONParser.EmptyArrayContext ctx) {
    setXML(ctx, &quot;&quot;);
}
</code></pre></div>
<p>最后，我们需要使用从一个对象或数组收集来的全部转换注解语法分析树的根节点。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">json: object
    | array
    ;
</code></pre></div>
<p>我们可以在监听器里用一个集合运算做到这点。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitJson(JSONParser.JsonContext ctx) {
    setXML(ctx, getXML(ctx.getChild(0)));
}
</code></pre></div>
<p>以下是构建和测试序列：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr JSON.g
compile *.java
run JSON2XML t.json
</code></pre></div>
<p>下面的是部分的输出结果：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&lt;description&gt;An imaginary server config file&lt;/description&gt;
&lt;logs&gt;
&lt;level&gt;verbose&lt;/level&gt;
...
</code></pre></div>
<p>有些转换不总是像JSON到XML那样直白的。但是，这个例子向我们表明如何通过拼凑部分翻译短语处理句子转换问题。</p>
]]></content>
  </entry>
  
</feed>
