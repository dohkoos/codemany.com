<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: ANTLR | 乐者为王]]></title>
  <link href="http://codemany.com/tags/antlr/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2017-01-07T20:41:20+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（25）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part25/"/>
    <updated>2016-09-03T16:16:56+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part25</id>
    <content type="html"><![CDATA[<p>这次我们要做的是通过监听器实现CSV文件的加载器，用于建立一个二维列表数据结构。</p>

<h3 id="加载csv数据">加载CSV数据</h3>

<p>我们的目标是构建一个监听器去加载CSV数据到一个映射列表数据结构中，这是任何数据格式阅读器或配置文件阅读器都会做的事。我们会收集每行的字段并放到一个映射中，构成头名-值组合。以下是示例文件t.csv的内容：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Details,Month,Amount
Mid Bonus,June,&quot;$2,000&quot;
,January,&quot;&quot;&quot;zippo&quot;&quot;&quot;
Total Bonuses,&quot;&quot;,&quot;$5,000&quot;
</code></pre></div>
<p>我们想要看到如下的映射列表被打印出：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">[{Details=Mid Bonus, Month=June, Amount=&quot;$2,000&quot;},
 {Details=, Month=January, Amount=&quot;&quot;&quot;zippo&quot;&quot;&quot;},
 {Details=Total Bonuses, Month=&quot;&quot;, Amount=&quot;$5,000&quot;}]
</code></pre></div>
<p>为了在监听器中得到精确的方法，我们给CSV语法中field规则的每个选项打上标签：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grammar CSV;

file : hdr row+ ;
hdr : row ;
row : field (&#39;,&#39; field)* &#39;\r&#39;? &#39;\n&#39; ;
field
    : TEXT    # text
    | STRING  # string
    |         # empty
    ;

TEXT : ~[,\n\r&quot;]+ ;
STRING : &#39;&quot;&#39; (&#39;&quot;&quot;&#39;|~&#39;&quot;&#39;)* &#39;&quot;&#39; ;     // quote-quote is an escaped quote
</code></pre></div>
<p>我们可以从定义我们需要的数据结构开始监听器的实现。首先，我们需要的数据结构是称为rows的映射列表。我们也需要在头行中找到的列名列表header。为处理数据行，我们需要把字段值读到一个临时列表currentRowFieldValues中，然后把列名映射到那些值上。以下是监听器LoadCSV.java的实现代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public static class Loader extends CSVBaseListener {
    public static final String EMPTY = &quot;&quot;;
    /** Load a list of row maps that map field name to value */
    List&lt;Map&lt;String,String&gt;&gt; rows = new ArrayList&lt;Map&lt;String, String&gt;&gt;();
    /** List of column names */
    List&lt;String&gt; header;
    /** Build up a list of fields in current row */
    List&lt;String&gt; currentRowFieldValues;
</code></pre></div>
<p>下面的3个规则方法通过计算适当的字符串处理字段值，并把它添加到currentRowFieldValues中。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitString(CSVParser.StringContext ctx) {
    currentRowFieldValues.add(ctx.STRING().getText());
}
public void exitText(CSVParser.TextContext ctx) {
    currentRowFieldValues.add(ctx.TEXT().getText());
}
public void exitEmpty(CSVParser.EmptyContext ctx) {
    currentRowFieldValues.add(EMPTY);
}
</code></pre></div>
<p>在我们能处理数据行之前，我们需要从第一行取得列名列表。头行在语法上仅仅是另外的行，但我们在对待它时要不同于常规的数据行，那意味着我们需要检查上下文。暂时让我们假设在exitRow()执行后，currentRowFieldValues包含列名列表。要填充header，我们只需要捕获第一行的字段值。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitHdr(CSVParser.HdrContext ctx) {
    header = new ArrayList&lt;String&gt;();
    header.addAll(currentRowFieldValues);
}
</code></pre></div>
<p>谈到行时，我们需要两个操作：一个是当我们开始一行时，另一个是当我们结束一行时。当我们开始一行时，我们需要分配或清除currentRowFieldValues，准备获取一组新的数据。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void enterRow(CSVParser.RowContext ctx) {
    currentRowFieldValues = new ArrayList&lt;String&gt;();
}
</code></pre></div>
<p>在行结束的时候，我们必须考虑上下文。如果我们仅仅加载头行，那我们不能改变rows字段，因为列名不是数据。在exitRow()中，我们可以通过查看在语法分析树中的父节点的getRuleIndex()值（或者询问父节点是否是HdrContext类型）测试上下文。如果当前行是数据行，我们将通过同时遍历header中的列名和currentRowFieldValues中的值获取的内容创建映射。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitRow(CSVParser.RowContext ctx) {
    // If this is the header row, do nothing
    // if ( ctx.parent instanceof CSVParser.HdrContext ) return; OR:
    if ( ctx.getParent().getRuleIndex() == CSVParser.RULE_hdr ) {
        return;
    }
    // It&#39;s a data row
    Map&lt;String, String&gt; m = new LinkedHashMap&lt;String, String&gt;();
    int i = 0;
    for (String v : currentRowFieldValues) {
        m.put(header.get(i), v);
        i++;
    }
    rows.add(m);
}
</code></pre></div>
<p>到这里，加载CSV数据到数据结构中的任务就算已经完成。在使用ParseTreeWalker遍历树后，我们就可以紧接着打印出rows字段：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">ParseTreeWalker walker = new ParseTreeWalker();
Loader loader = new Loader();
walker.walk(loader, tree);
System.out.println(loader.rows);
</code></pre></div>
<p>以下是构建和测试序列：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr CSV.g
compile *.java
run LoadCSV t.csv
</code></pre></div>
<p>下面显示的是输出结果：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">[{Details=Mid Bonus, Month=June, Amount=&quot;$2,000&quot;}, {Details=, Month=January,
Amount=&quot;&quot;&quot;zippo&quot;&quot;&quot;}, {Details=Total Bonuses, Month=&quot;&quot;, Amount=&quot;$5,000&quot;}]
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（24）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part24/"/>
    <updated>2016-08-26T18:46:37+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part24</id>
    <content type="html"><![CDATA[<p>在本节中，我们准备讲讲有时候事件方法需要传递部分结果或其它信息的问题。</p>

<h3 id="在事件方法间共享信息">在事件方法间共享信息</h3>

<p>无论收集信息还是计算值，传递参数和返回值都是比使用字段和全局变量更方便良好的编程实践。问题是ANTLR自动生成的监听器方法的签名不需要特定应用的返回值或参数，ANTLR也自动生成访问者方法而不需要特定应用的参数。</p>

<p>接下来，我们将探讨让事件方法无需修改事件方法签名就能传递数据的机制。我们将构建同样的简单计算器的3个不同实现，基于前面章节的LExpr表达式语法。第一个实现使用访问者方法返回值，第二个定义了一个在事件方法间共享的字段，第三个则注解语法分析树节点以便储存感兴趣的值。</p>

<h4 id="使用访问者遍历语法分析树">使用访问者遍历语法分析树</h4>

<p>构建基于访问者的计算器，最简单的方法是让和规则expr相关的事件方法返回子表达式的值。例如，visitAdd()将返回两个子表达式相加的值，visitInt()将返回整型的值。传统的访问者不指定visit方法的返回值。当我们为特定应用需求实现一个类时添加返回类型是容易的，扩展LExprBaseVisitor<T>并提供Integer作为<T>类型参数。访问者代码看起来如下所示：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public static class EvalVisitor extends LExprBaseVisitor&lt;Integer&gt; {
    public Integer visitMult(LExprParser.MultContext ctx) {
        return visit(ctx.e(0)) * visit(ctx.e(1));
    }
    public Integer visitAdd(LExprParser.AddContext ctx) {
        return visit(ctx.e(0)) + visit(ctx.e(1));
    }
    public Integer visitInt(LExprParser.IntContext ctx) {
        return Integer.valueOf(ctx.INT().getText());
    }
}
</code></pre></div>
<p>EvalVisitor从ANTLR生成的AbstractParseTreeVisitor类继承通用的visit()方法，我们的访问者使用它去准确地触发子树访问。</p>

<p>注意，EvalVisitor没有针对规则s的访问者方法。在LExprBaseVisitor中的visitS()的默认实现调用预定义的方法ParseTreeVisitor.visitChildren(). visitChildren()返回从最后的子节点访问返回的值。在这里，visitS()返回访问它唯一的子节点（节点e）时返回的表达式的值。我们可以使用这种默认的行为。</p>

<p>在测试文件TestLEvalVisitor.java中，我们有常用代码去启动LExprParser和打印语法分析树，然后我们需要编码去启动EvalVisitor和打印出当访问树时计算出的表达式的值。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">EvalVisitor evalVisitor = new EvalVisitor();
int result = evalVisitor.visit(tree);
System.out.println(&quot;visitor result = &quot; + result);
</code></pre></div>
<p>要构建计算器，需要告诉ANTLR使用-visitor参数去生成访问者。（如果我们不再需要生成监听器，可以使用-no-listener参数）以下是完整的构建和测试序列：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr -visitor LExpr.g
compile *.java
run TestLEvalVisitor
</code></pre></div>
<p>接着输入以下内容：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">1+2*3
EOF
</code></pre></div>
<p>你就会看到如下结果：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(s (e (e 1) + (e (e 2) * (e 3))))
visitor result = 7
</code></pre></div>
<p>如果我们需要特定应用的返回值，访问者工作的相当好，因为我们使用了内建的Java返回值机制。如果我们不希望显式地调用访问者方法去访问子节点，我们可以切换到监听器机制，不幸的是，这意味着我们要放弃使用Java方法返回值的整洁。</p>

<h4 id="使用栈模拟返回值">使用栈模拟返回值</h4>

<p>ANTLR生成的监听器事件方法没有返回值。为了给在语法分析树更高节点上执行的监听器方法返回值，我们可以把部分的值存储在监听器的一个字段中。我们会想到用栈来存储值，方法就是把计算一个子表达式的结果推送到栈中，在语法分析树上用于子表达式的方法则把运算元从栈中弹出。以下是完整的Evaluator计算器监听器（代码在TestLEvaluator.java文件中）：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public static class Evaluator extends LExprBaseListener {
    Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
    public void exitMult(LExprParser.MultContext ctx) {
        int right = stack.pop();
        int left = stack.pop();
        stack.push(left * right);
    }
    public void exitAdd(LExprParser.AddContext ctx) {
        int right = stack.pop();
        int left = stack.pop();
        stack.push(left + right);
    }
    public void exitInt(LExprParser.IntContext ctx) {
        stack.push(Integer.valueOf(ctx.INT().getText()));
    }
}
</code></pre></div>
<p>要测试上面的这段代码，我们可以创建和使用在代码TestLEvaluator中的ParseTreeWalker，以下是完整的构建和测试序列：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr LExpr.g
compile *.java
run TestLEvaluator
</code></pre></div>
<p>接着输入以下内容：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">1+2*3
EOF
</code></pre></div>
<p>你就会看到如下结果：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(s (e (e 1) + (e (e 2) * (e 3))))
stack result = 7
</code></pre></div>
<p>使用栈字段有点别扭但工作得很好。我们必须确保事件方法以正确的顺序压入和弹出跨越监听器事件的值。带有返回值的访问者没有栈的这种笨拙但却需要手工访问树的节点。第三种实现是通过把部分值隐藏在树节点中来捕获它们。</p>

<h4 id="注解语法分析树">注解语法分析树</h4>

<p>作为使用临时存储在事件方法间共享数据的替代，我们可以把这些值存储在语法分析树本身中。使用树注解方法时我们可以带有监听器或访问者，但在这里我们使用监听器来阐明如何使用它。让我们首先看一下用部分结果注解的1+2*3的LExpr语法分析树。</p>

<p><img src="/uploads/lexpr-parse-tree.png" title="lexpr-parse-tree" ></p>

<p>每个子表达式对应一个子树根（和对应一个e规则调用）。从e节点发出的水平线指向的数字是我们想要返回的部分结果。</p>

<p>让我们看看节点注解策略将如何工作在来自LExpr语法的规则e上。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">e : e MULT e    # Mult
  | e ADD e     # Add
  | INT         # Int
  ;
</code></pre></div>
<p>e选项的监听器方法每个都会存储一个结果在相对应的e语法分析树节点中。任何随后的在语法分析树更高节点上的add或multiply事件将通过查看存储在它们对应的子节点中的值来抓取子表达式的值。</p>

<p>现在，让我们假设每个语法分析树节点（每个规则上下文对象）都有一个字段value，那么exitAdd()看起来将是这样；</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitAdd(LExprParser.AddContext ctx) {
    // e(0).value is the subexpression value of the first e in the alternative
    ctx.value = ctx.e(0).value + ctx.e(1).value;    // e &#39;+&#39; e # Add
}
</code></pre></div>
<p>这看起来相当合理，但不幸的是，在Java中我们不能扩展类ExprContext去动态地添加字段。为了让语法分析树注解生效，我们需要一种方法去注解各式各样的节点而不需要手工修改由ANTLR生成的关联节点类。</p>

<p>注解语法分析树节点最简单的方式是使用与节点任意值相关联的一个Map。因此，ANTLR提供了一个简单的帮助类ParseTreeProperty。让我们在文件TestLEvaluatorWithProps.java中构建称作EvaluatorWithProps的另一个计算器版本，它使用ParseTreeProperty关联了LExpr语法分析树节点和部分结果。以下是在监听器开始处的适当的定义：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public static class EvaluatorWithProps extends LExprBaseListener {
    /** maps nodes to integers with Map&lt;ParseTree,Integer&gt; */
    ParseTreeProperty&lt;Integer&gt; values = new ParseTreeProperty&lt;Integer&gt;();
</code></pre></div>
<p>注意：如果你想使用自己的Map类型字段代替ParseTreeProperty，确保它继承自IdentityHashMap，而不是通常的HashMap。我们需要去注解特殊的节点，进行同一性测试而不是equals()。两个e节点可能是equals()，但在内存中不是同一个物理节点。</p>

<p>为注解一个节点，我们使用values.put(node, value)。为得到和一个节点有关联的值，我们使用values.get(node)。这很好，但是让我们创建一些有直白名字的帮助方法以便让代码更容易阅读。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void setValue(ParseTree node, int value) { values.put(node, value); }
public int getValue(ParseTree node) { return values.get(node); }
</code></pre></div>
<p>让我们从最简单的表达式选项Int开始监听器方法。我们想使用它匹配的INT记号的整型值去注解它的语法分析树e节点。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitInt(LExprParser.IntContext ctx) {
    String intText = ctx.INT().getText();    // INT    # Int
    setValue(ctx, Integer.valueOf(intText));
}
</code></pre></div>
<p>对于加法树，我们得到两个子表达式子节点的值（运算元）和带有和的注释的子树跟。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitAdd(LExprParser.AddContext ctx) {
    int left = getValue(ctx.e(0));    // e &#39;+&#39; e    # Add
    int right = getValue(ctx.e(1));
    setValue(ctx, left + right);
}
</code></pre></div>
<p>方法exitMult()是相同的，只是运算的时候用multiply代替了add。</p>

<p>我们的测试代码从分析规则s开始。因此我们必须确保语法分析树根有e子树的值。为把值从e节点冒泡到根s节点，我们实现了exitS()。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">/** Need to pass e&#39;s value out of rule s : e ; */
public void exitS(LExprParser.SContext ctx) {
    setValue(ctx, getValue(ctx.e()));    // like: int s() { return e(); }
}
</code></pre></div>
<p>以下是如何启动监听器以及打印出来自语法分析树根节点的表达式的值：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">ParseTreeWalker walker = new ParseTreeWalker();
EvaluatorWithProps evalProp = new EvaluatorWithProps();
walker.walk(evalProp, tree);
System.out.println(&quot;properties result = &quot; + evalProp.getValue(tree));
</code></pre></div>
<p>以下是构建和测试序列：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr LExpr.g
compile *.java
run TestLEvaluatorWithProps
</code></pre></div>
<p>接着输入以下内容：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">1+2*3
EOF
</code></pre></div>
<p>你就会看到如下结果：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(s (e (e 1) + (e (e 2) * (e 3))))
stack result = 7
</code></pre></div>
<p>现在我们已经看到了相同计算器的3个实现，并且我们也已经准备好把我们的知识用于构建真实案例。因为每个方法都有它的优势和劣势，下面就让我们来比较下不同的技术。</p>

<h3 id="比较信息共享方法">比较信息共享方法</h3>

<p>为得到可复用和可重定目标的语法，我们需要让它们完全清除用户定义的动作。这意味着要把所有特定应用的代码放到语法外的某些监听器和访问者中。监听器和访问者操作语法分析树，ANTLR自动生成合适的树遍历接口和默认实现。因为事件方法签名是固定的和不特定于应用的，所以事件方法可以共享信息的方式有3种：</p>

<ul>
<li>本地Java调用栈：访问者返回用户定义类型的一个值。如果访问者需要传递参数，它也必须使用下面两种技术的一种。</li>
<li>基于栈：一个栈字段模仿参数和返回值，像Java调用栈那样。</li>
<li>注解者：一个Map字段使用有用的值注解节点。</li>
</ul>

<p>所有这3种方法是和语法本身完全解耦的，并且很好地封装在专门的对象中。除此之外，它们也都有各自的优点和缺点。我们可以根据问题的需要和个人的喜好决定采取哪种方法。你甚至可以在同一个应用中使用多种方法。</p>

<p>访问者方法很好懂，因为它们直接调用其它访问者方法去获取部分结果，并且能像其它任何方法那样返回值。这也是它们的缺点，访问者方法必须显式地访问它们的子节点。而监听器就不需要。因为访问者有个通用的接口，所以它不能定义参数。访问者必须使用其它解决方案的一种去传递参数给它在子节点上调用的访问者方法。访问者的空间效率很好，因为它在任何时间仅需保留少数的部分结果。在树遍历后没有部分结果保留。当访问者方法可以返回值时，每个值必须是同种类型，不想其它的解决方案。</p>

<p>基于栈的解决方案可以模仿参数和返回带有一个栈的值，但在手动管理栈时有个断开的机会。这可能会发生，因为监听器方法不能直接调用彼此。作为程序员，我们必须确定推入栈中的在将来事件方法调用能适当地弹出。栈可以传递多个值和多个返回值。基于栈的解决方案也是空间有效的，因为它不会把任何东西固定到树上。在树遍历后所有的部分结果存储消失。</p>

<p>注解者通常可以作为默认解决方案采用，因为它允许你任意地提供信息给事件方法操作语法分析树中上上下下的节点。你也可以传递多个值，它们可以是任意类型。在许多情况下注解胜于使用带有短暂值的栈。在各种方法的数据传递准备间很少有断开的机会。比起在编程语言中说返回值，使用setValue(ctx, value)注解树不太直观，但是更通用。超过其它两种的这种方法的唯一缺点是在树遍历期间部分结果是保留的，因此它有较大的内存占用。</p>

<p>从另一方面来说，在某些应用中能够注解树正是我们需要的。应用需要在树上通过多遍，第一遍是很方便在树上计算和储存数据的。当语法分析树遍历器重新遍历树的时候第二遍然后就很容易访问数据。总的来说，树注解非常灵活，有一个可接受的内存负担。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（23）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part23/"/>
    <updated>2016-08-16T18:09:05+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part23</id>
    <content type="html"><![CDATA[<p>默认情况下，ANTLR为每个规则生成一个单一的事件类型，而不管语法分析器匹配了哪个选项。这很不方便，因为监听器和访问者方法必须确定哪个选项被语法分析器匹配。在本节中，我们将看到如何得到更细粒度的事件。</p>

<h3 id="为规则选项贴标签以得到精确的事件方法">为规则选项贴标签以得到精确的事件方法</h3>

<p>为阐明事件粒度问题，让我们为以下的表达式语法构建一个带有监听器的简单计算器：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grammar Expr;
s : e ;
e : e op=MULT e    // MULT is &#39;*&#39;
  | e op=ADD e     // ADD is &#39;+&#39;
  | INT
  ;
</code></pre></div>
<p>按照上面的语法，规则e会产生一个相当无用的监听器，因为规则e的所有选项导致树遍历器触发相同的enterE()和exitE()方法。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public interface ExprListener extends ParseTreeListener {
    void enterE(ExprParser.EContext ctx);
    void exitE(ExprParser.EContext ctx);
</code></pre></div>
<p>监听器方法必须使用op记号标签和ctx的方法进行测试以查看语法分析器为每个e子树匹配了哪个选项。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void exitE(ExprParser.EContext ctx) {
    if (ctx.getChildCount() == 3) {    // operations have 3 children
        int left = values.get(ctx.e(0));
        int right = values.get(ctx.e(1));
        if (ctx.op.getType() == ExprParser.MULT) {
            values.put(ctx, left * right);
        } else {
            values.put(ctx, left + right);
        }
    } else {
        values.put(ctx, values.get(ctx.getChild(0)));    // an INT
    }
}
</code></pre></div>
<p>在exitE()中引用的MULT字段是在ExprParser中由ANTLR自动生成的：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class ExprParser extends Parser {
    public static final int MULT=1, ADD=2, INT=3, WS=4;
</code></pre></div>
<p>如果我们查看在类ExprParser中的类EContext，我们可以看到ANTLR把来自3个选项的所有元素都塞进了相同的上下文对象。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public static class EContext extends ParserRuleContext {
    public Token op;                     // derived from label op
    public List&lt;EContext&gt; e() { ... }    // get all e subtrees
    public EContext e(int i) { ... }     // get ith e subtree
    public TerminalNode INT() { ... }    // get INT node if alt 3 of e
</code></pre></div>
<p>为得到更精确的监听器事件，ANTLR让我们使用#运算符给任何规则最外层的选项打标签。让我们从Expr派生语法LExpr，并给e的选项打上标签，以下是修改后的e规则：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">e : e MULT e  # Mult
  | e ADD e   # Add
  | INT       # Int
  ;
</code></pre></div>
<p>现在，ANTLR为e的每个选项生成了单独的监听器方法，因此，我们不再需要op记号标签。对于选项标签X，ANTLR生成方法enterX()和exitX()。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public interface LExprListener extends ParseTreeListener {
    void enterMult(LExprParser.MultContext ctx);
    void exitMult(LExprParser.MultContext ctx);
    void enterAdd(LExprParser.AddContext ctx);
    void exitAdd(LExprParser.AddContext ctx);
    void enterInt(LExprParser.IntContext ctx);
    void exitInt(LExprParser.IntContext ctx);
    ...
}
</code></pre></div>
<p>注意，ANTLR也为选项生成特定的以标签命名的上下文对象（EContext的子类）。专门的上下文对象的getter方法只限于应用在那些相关的选项。例如，IntContext只有一个INT()方法，我们可以在enterInt()中调用ctx.INT()，但在enterAdd()中就不能。</p>

<p>监听器和访问者是极好的。我们只需要通过充实事件方法就可以得到可复用和可重定目标的语法以及封装的语言应用。ANTLR甚至会为我们自动生成骨架代码。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（22）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part22/"/>
    <updated>2016-07-24T21:40:28+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part22</id>
    <content type="html"><![CDATA[<p>基于监听器的方法是极好的，因为所有树遍历和方法触发被自动完成。尽管有时候自动树遍历也是一个缺点，因为我们不能控制遍历本身。例如，我们可能想遍历一段C程序的语法分析树，通过跳过函数体子树忽略函数中的一切。监听器事件方法也不能使用方法返回值去传递数据。当我们需要控制遍历或返回带有事件方法返回值的值时，我们使用访问者模式。现在，让我们构建一个基于访问者版本的属性文件加载器去比较这两种方法。</p>

<h3 id="使用访问者实现应用">使用访问者实现应用</h3>

<p>使用访问者代替监听器，我们只需要让ANTLR生成访问者接口和实现接口，然后创建一段测试代码在语法分析树上调用visit()，根本不需要触及到语法。</p>

<p>在命令行使用-visitor参数时，ANTLR生成接口PropertyFileVisitor和类PropertyFileBaseVisitor，后者有如下的默认实现：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class PropertyFileBaseVisitor&lt;T&gt; extends AbstractParseTreeVisitor&lt;T&gt;
                                        implements PropertyFileVisitor&lt;T&gt; {
    @Override
    public T visitFile(PropertyFileParser.FileContext ctx) { ... }
    @Override
    public T visitProp(PropertyFileParser.PropContext ctx) { ... }
}
</code></pre></div>
<p>我们可以从监听器的exitProp()中拷贝映射功能，然后把它粘贴到与规则prop相关的访问者方法中。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class TestPropertyFileVisitor {
    public static class PropertyFileVisitor extends PropertyFileBaseVisitor&lt;Void&gt; {
        Map&lt;String,String&gt; props = new OrderedHashMap&lt;String, String&gt;();
        public Void visitProp(PropertyFileParser.PropContext ctx) {
            String id = ctx.ID().getText();    // prop : ID &#39;=&#39; STRING &#39;\n&#39; ;
            String value = ctx.STRING().getText();
            props.put(id, value);
            return null;    // Java says must return something even when Void
        }
    }
</code></pre></div>
<p>这里是访问者接口和类之间的继承关系：</p>

<p><img src="/uploads/propertyfile-visitor-hierachy.png" title="propertyfile-visitor-hierachy" ></p>

<p>访问者在子节点上通过显式地调用接口ParseTreeVisitor的visit()方法遍历语法分析树。那些方法在AbstractParseTreeVisitor中实现。在这里，为prop调用创建的节点没有子树，因此visitProp()不需要调用visit()。</p>

<p>在监听器和访问者的测试代码（例如TestPropertyFileVisitor）之间最大的不同是访问者的测试代码不需要ParseTreeWalker，它只需要让访问者去访问由语法分析器创建的树。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">PropertyFileVisitor loader = new PropertyFileVisitor();
loader.visit(tree);
System.out.println(loader.props);    // print results
</code></pre></div>
<p>以下是构建和测试序列：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr -visitor PropertyFile.g  # create visitor as well this time
compile *.java
run TestPropertyFileVisitor t.properties
</code></pre></div>
<p>这里是输出的内容：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">{user=&quot;parrt&quot;, machine=&quot;maniac&quot;}
</code></pre></div>
<p>我们可以使用监听器和访问者构建几乎任何我们想要的。一旦我们处于Java空间，就不再需要学习更多的ANTLR知识。我们只要知道语法、语法分析树、监听器和访问者事件方法之间的关系。除此之外，就是代码。在对识别中的输入短语的回答中，我们可以生成输出、收集信息、以某种方式验证短语，或者执行计算。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（21）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part21/"/>
    <updated>2016-07-14T18:38:42+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part21</id>
    <content type="html"><![CDATA[<p>前文的语法仍然存在问题，因为它限制我们只能使用Java生成语法分析器。为使语法可复用和语言无关，我们需要完全避免嵌入动作。接下来就将展示如何用监听器做到这点。</p>

<h3 id="使用语法分析树监听器实现应用">使用语法分析树监听器实现应用</h3>

<p>在构建语言应用时要避免应用和语法纠缠在一起，关键是让语法分析器生成语法分析树，然后遍历该树去触发特定的应用代码。我们可以使用我们最喜欢的技术遍历树，也可以使用ANTLR生成的树遍历机制中的一个。在本节中，我们将使用ANTLR内建的ParseTreeWalker构建一个基于监听器版本的属性文件应用。</p>

<p>让我们从属性文件语法的原始版本开始：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">file : prop+ ;
prop : ID &#39;=&#39; STRING &#39;\n&#39; ;
</code></pre></div>
<p>下面是属性示例文件t.properties的内容：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">user=&quot;parrt&quot;
machine=&quot;maniac&quot;
</code></pre></div>
<p>通过上述语法，ANTLR生成PropertyFileParser，该语法分析器会自动构建如下图所示的语法分析树：</p>

<p><img src="/uploads/propertyfile-parse-tree.png" title="propertyfile-parse-tree" ></p>

<p>有了语法分析树，我们就可以使用ParseTreeWalker去访问所有的节点，触发进入和退出方法。</p>

<p>现在来看一下ANTLR通过语法PropertyFile生成的监听器接口PropertyFileListener，当ANTLR的ParseTreeWalker发现和完成节点时，它会为每个规则子树分别触发进入和退出方法。因为在语法PropertyFile中只有两条语法规则，所以在接口中有4个方法：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public interface PropertyFileListener extends ParseTreeListener {
    void enterFile(PropertyFileParser.FileContext ctx);
    void exitFile(PropertyFileParser.FileContext ctx);
    void enterProp(PropertyFileParser.PropContext ctx);
    void exitProp(PropertyFileParser.PropContext ctx);
}
</code></pre></div>
<p>FileContext和PropContext对象是针对每条语法规则的语法分析树节点的实现，它们包含一些有用的方法。</p>

<p>为方便起见，ANTLR也会生成带有默认实现的类PropertyFileBaseListener，这些默认实现模仿在前文语法中@member区域我们手写的空白方法。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class PropertyFileBaseVisitor&lt;T&gt; extends AbstractParseTreeVisitor&lt;T&gt;
                                        implements PropertyFileVisitor&lt;T&gt; {
    @Override
    public T visitFile(PropertyFileParser.FileContext ctx) { }
    @Override
    public T visitProp(PropertyFileParser.PropContext ctx) { }
}
</code></pre></div>
<p>默认实现让我们只需要覆盖和实现那些我们关心的方法。例如，以下是属性文件加载器的一个重新实现，像前面那样它只有一个方法，但使用监听器机制：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public static class PropertyFileLoader extends PropertyFileBaseListener {
    Map&lt;String,String&gt; props = new OrderedHashMap&lt;String, String&gt;();
    public void exitProp(PropertyFileParser.PropContext ctx) {
        String id = ctx.ID().getText();    // prop : ID &#39;=&#39; STRING &#39;\n&#39; ;
        String value = ctx.STRING().getText();
        props.put(id, value);
    }
}
</code></pre></div>
<p>主要的不同是这个版本扩展了基类监听器，而不是语法分析器，监听器方法在语法分析器完成后被触发。</p>

<p>这里面有很多的接口和类，让我们看一下在这些关键元素间的继承关系。</p>

<p><img src="/uploads/propertyfile-listener-hierachy.png" title="propertyfile-listener-hierachy" ></p>

<p>处于ANTLR运行库中的接口ParseTreeListener要求每个监听器对事件visitTerminal()、enterEveryRule()和exitEveryRule()作出反应，如果有语法错误的还要加上visitErrorNode()。ANTLR从语法文件PropertyFile生成接口PropertyFileListener，并且为类PropertyFileBaseListener的所有方法生成默认实现。我们仅需要构建PropertyFileLoader，它继承了PropertyFileBaseListener中的所有空方法。</p>

<p>方法exitProp()可以访问与规则prop相关的规则上下文对象PropContext，该上下文对象持有在规则prop中提到的每个元素（ID和STRING）的对应方法。因为这些元素是语法中的记号引用，所以方法返回语法分析树节点TerminalNode。我们既可以通过getText()直接访问记号的文本，也可以通过getSymbol()首先获取Token。</p>

<p>现在让我们创建测试文件TestPropertyFile.java遍历树，倾听来自PropertyFileLoader的声音：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">// create a standard ANTLR parse tree walker
ParseTreeWalker walker = new ParseTreeWalker();
// create listener then feed to walker
PropertyFileLoader loader = new PropertyFileLoader();
walker.walk(loader, tree);    // walk parse tree
System.out.println(loader.props);    // print results
</code></pre></div>
<p>然后就是编译和生成代码，运行测试程序去处理输入文件：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr PropertyFile.g
compile *.java
run TestPropertyFile t.properties
</code></pre></div>
<p>这里是输出的内容：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">{user=&quot;parrt&quot;, machine=&quot;maniac&quot;}
</code></pre></div>
<p>测试程序成功地把文件中的属性赋值重组成内存中的映射数据结构。</p>
]]></content>
  </entry>
  
</feed>
