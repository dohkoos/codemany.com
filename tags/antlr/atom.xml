<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: ANTLR | 乐者为王]]></title>
  <link href="http://codemany.com/tags/antlr/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2016-07-02T10:46:59+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（9）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part9/"/>
    <updated>2016-03-27T07:10:05+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part9</id>
    <content type="html"><![CDATA[<ul>
<li>predication 预测</li>
<li>predict 预判</li>
<li>lookahead 预读</li>
</ul>

<p>ANTLR工具根据语法规则，例如我们刚才看到的assign，生成递归下降语法分析器。递归下降语法分析器只是递归方法的一个集合，每个规则一个方法。下降这个术语指的是分析从语法分析树的根开始向着叶子进行（记号）。我们首先调用的规则，即prog符号，成为语法分析树的根。那也就意味着对<a href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part8/">ANTLR 4权威参考读书笔记（8）</a>中的语法分析树来说需要调用方法prog()。这类分析更通用的术语是自顶向下分析：递归下降语法分析器仅仅是自顶向下语法分析器实现的一种。</p>

<p>要了解递归下降语法分析器是什么样子，这里是ANTLR为规则assign生成的方法（稍微整理）：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">// assign : ID &#39;=&#39; expr ;
void assign() {    // 根据规则assign生成的方法
    match(ID);     // 比较ID和当前输入符号然后消费
    match(&#39;=&#39;);
    expr();        // 通过调用expr()匹配表达式
}
</code></pre></div>
<p>递归下降语法分析器最酷的部分是通过调用方法prog()、assign()和expr()跟踪出的调用关系图反映了内部的语法分析树节点。match()的调用对应语法分析树叶子。为了在一个手工构建的语法分析器中手动构建一颗语法分析树，我们需要在每个规则方法的开始处插入“添加新子树根”操作，以及给match()一个“添加新叶子节点”操作。</p>

<p>方法assign()只是检查确保所有必要的记号存在且以正确的顺序。当语法分析器进入assign()时，它不必在多个选项之间进行选择。选项是规则定义右边的选择之一。例如，调用assign的prog规则可能有其它类型的语句。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">/** 匹配起始于当前输入位置的任何语句 */
prog
    : assign    // 第一个选项（&#39;|&#39;是选项分隔符）
    | ifstat    // 第二个选项
    | whilestat
    ...
    ;
</code></pre></div>
<p>prog的分析规则看起来像一条switch语句：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">void prog() {
    switch ( «current input token» ) {
        CASE ID : assign(); break;
        CASE IF : ifstat(); break;    // IF是关键字&#39;if&#39;的记号类型
        CASE WHILE : whilestat(); break;
        ...
        default : «raise no viable alternative exception»
    }
}
</code></pre></div>
<p>方法prog()必须通过检查下一个输入记号作出分析决定或预测。分析决定预判哪一个选项将会成功。在本例中，当看到WHILE关键字时会预判是规则prog的第三个选项。规则方法prog()然后就会调用whilestat()。你以前可能听说过术语预读记号，那只是下一个输入记号。预读记号可以是语法分析器在匹配和消费它之前嗅探的任何记号。</p>

<p>有时候，语法分析器需要一些预读记号去预判哪个选项会成功。它甚至必须考虑从当前位置直到文件结尾的所有的记号！ANTLR默默地为你处理所有的这些事情，但是对决策过程有个基本的了解是有帮助的，可以让调试生成的语法分析器更容易。</p>

<p>为更好地理解分析决定，想象有个单一入口和单一出口的迷宫，有单词写在地板上。每个沿着从入口到出口路径的单词序列表示一个句子。迷宫的结构与定义一门语言的语法规则类似。为测试一个句子在一门语言中的成员身份，我们在穿越迷宫时把句子的单词和沿着地板的单词作比较。如果通过句子的单词我们能到达出口，那么句子是有效的。</p>

<p>为了通过迷宫，我们必须在每个岔口选择一条有效路径，正如我们必须在语法分析器中选择选项。我们必须决定该走哪条路，通过把我们句子中下一个单词（们）和沿着来自每个岔口的每条路径上可见的单词比较。我们能从岔口看到的单词与预读记号类似。当每条路径以唯一的单词开始时决定是相当容易的。在规则prog中，每个选项从唯一的记号开始，因此prog()可以通过查看第一个预读记号识别选项。</p>

<p>当单词从一个岔口重叠部分开始每条路径时，语法分析器需要继续往前看，扫描可以识别选项的单词。ANTLR根据需要为每个决定自动上下调节预读数量。如果预读的结果是多条同样的到出口的路径，即当前的输入短语有多种解释。解决这样的二义性将是我们的下一个主题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（8）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part8/"/>
    <updated>2016-03-20T09:57:45+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part8</id>
    <content type="html"><![CDATA[<ul>
<li>syntax analyzer 语法分析器</li>
<li>syntax tree 语法树</li>
</ul>

<p>一门语言由有效的句子组成，一个句子由短语组成，一个短语由子短语和词汇符号组成。要实现一门语言，我们必须构建一个能读取句子以及对发现的短语和输入符号作出适当反应的应用。</p>

<p>这样的应用必须能识别特定语言的所有有效的句子、短语和子短语。识别一个短语意味着我们能确定短语的各种组件并能指出它与其它短语的区别。例如，我们把输入a=5识别为赋值语句，这就意味着我们知道a是赋值目标以及5是要存储的值。识别赋值语句a=5也意味着应用认为它是明显不同于，比如说，a+b语句的。在识别后，应用将执行适当的操作，例如performAssignment(&quot;a&quot;, 5)或者translateAssignment(&quot;a&quot;, 5)。</p>

<p>识别语言的程序被称为语法分析器。语法指代控制语言成员的规则，每条规则都表示一个短语的结构。为了更容易地实现识别语言的程序，通常我们会把识别语言的语法分析拆解成两个相似但不同的任务或阶段。</p>

<p>把字符组成单词或符号（记号）的过程被称为词法分析或简单标记化。我们把标记输入的程序称为词法分析器。词法分析器能把相关的记号组成记号类型，例如INT（整数）、ID（标志符）、FLOAT（浮点数）等。当语法分析器只关心类型的时候，词法分析器会把词汇符号组成类型，而不是单独的符号。记号至少包含两块信息：记号类型（确定词法结构）和匹配记号的文本。</p>

<p>第二阶段是真正的语法分析器，它使用这些记号去识别句子结构，在本例中是赋值语句。默认情况下，ANTLR生成的语法分析器会构建一个称为语法分析树或语法树的数据结构，它记录语法分析器如何识别输入句子的结构和它的组件短语。下图阐明了语言识别器的基本数据流：</p>

<p><img src="/uploads/basic-data-flow.png" title="basic-data-flow" ></p>

<p>语法分析树的内部节点是分组和确认它们子节点的短语名字。根节点是最抽象的短语名字，在本例中是prog（“program”的缩写）。语法分析树的叶子节点永远是输入记号。</p>

<p>通过生成语法分析树，语法分析器给应用的其余部分提供了方便的数据结构，它们含有关于语法分析器如何把符号组成短语的完整信息。树是非常容易处理的，并且也能被程序员很好的理解。更好的是，语法分析器能自动地生成语法分析树。</p>

<p>通过操作语法分析树，需要识别相同语言的多个应用能重用同一个语法分析器。当然，你也可以选择直接在语法中嵌入特定应用的代码片段，这是语法分析器生成器传统的做法。ANTLR v4仍然允许这样做，但是语法分析树有助于更简洁更解耦的设计。</p>

<p>语法分析树对于需要多次树遍历的转换也是非常有用的，因为在计算依赖关系的阶段通常会需要前一个阶段的信息。相比于在每个阶段都要准备输入字符，我们只需要遍历语法分析树多次，更具有效率。</p>

<p>因为我们用一套规则指定短语，语法分析树子树根节点对应于语法规则名。这里的语法规则对应于上图中assign子树的第一层：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">assign : ID &#39;=&#39; expr ;    // 匹配赋值语句像&quot;a=5&quot;
</code></pre></div>
<p>明白ANTLR如何把这些规则转换为人类可读的语法分析代码是使用和调试语法的基础，因此让我们深入地挖掘语法分析是如何工作的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（7）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part7/"/>
    <updated>2016-03-11T16:42:08+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part7</id>
    <content type="html"><![CDATA[<ul>
<li>sequence 序列</li>
</ul>

<p>在<a href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part6/">ANTLR 4权威参考读书笔记（6）</a>中的这些操作仅仅是提取和打印被语法分析器匹配的值，它们并没有改变语法分析器本身。</p>

<p>实际上，操作还可以影响语法分析器如何识别输入短语。这类特殊的操作被称为语义谓词。下面我们会用一个简单的例子来展示语义谓词的强大能力：动态地打开和关闭语法的某个部分。</p>

<h3 id="使用语义谓词改变语法分析">使用语义谓词改变语法分析</h3>

<p>有一个读入整数序列的语法，它的玄机是由输入的部分指定有多少个整数组合在一起，所以我们必须等到运行时才能知道有多少整数被匹配。这里是示例输入文件idata.txt的内容：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">2 9 10 3 1 2 3
</code></pre></div>
<p>第1个数字表示匹配后续两个数字9和10；紧跟10的数字3表示匹配接下来的三个数字。我们的目的是设计一个语法IData.g，把9和10组合在一起，把1、2和3组合在一起。在语法上执行以下命令后显示的语法分析树能够清楚地标识出整数的分组，就像下图显示的那样：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr -no-listener IData.g
compile *.java
grun IData file -gui idata.txt
</code></pre></div>
<p><img src="/uploads/idata-parse-tree.png" title="idata-parse-tree" ></p>

<p>要达成这个目标，以下语法中的关键是一个被称为语义谓词的布尔值操作：{$i &lt; $n}?。当谓词计算结果为true时，语法分析器匹配整数直到超过序列规则参数n要求的数量；当计算结果为false时，谓词让相关的选项从生成的语法分析器中“消失”。
在这个案例中，值为false的谓词让(...)*循环从规则序列里终止并返回。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grammar IData;

file : group+ ;

group: INT sequence[$INT.int] ;

sequence[int n]
locals [int i = 1;]
     : ( {$i&lt;=$n}? INT {$i++;} )*  // match n integers
     ;

INT  : [0-9]+ ;  // match integers
WS   : [ \t\n\r]+ -&gt; skip ;  // toss out all whitespace
</code></pre></div>
<p>被语法分析器使用的规则序列的内部语法表示看起来就像下图这样：</p>

<p><img src="/uploads/idata-rule-sequence.png" title="idata-rule-sequence" ></p>

<p>虚线表明谓词可以剪断那条路径，只给语法分析器留下一个选择：退出的路径。</p>

<p>虽然大部分时间我们不需要这样的微管理，但它至少让我们知道我们有这样的武器可以处理病理分析问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（6）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part6/"/>
    <updated>2016-02-14T16:16:37+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part6</id>
    <content type="html"><![CDATA[<ul>
<li>action 操作</li>
<li>clause 子句</li>
</ul>

<p>Listener和Visitor机制是极好的。大多数时候，我们可以用Listener或Visitor构建语言应用，它们让特定应用的代码置身于语法之外，使语法容易被阅读。</p>

<p>但有时候我们需要额外的控制权和灵活性。为了达到这个目的，我们可以直接在语法中嵌入代码片段（这些嵌入的代码片段被称为操作）。这些操作会被注入到由ANTLR工具生成的分析器代码中。这些被注入的代码在分析期间执行，并且能像其它任意代码片段一样收集信息或生成输出。结合语义谓词，我们甚至可以在运行时让我们语法的某部分消失！例如，我们可能想打开或关闭Java语法中的enum关键词，分析语言的不同版本。没有语义谓词，我们就需要两个不同版本的语法。</p>

<p>下面我们将实现一个简单的程序，读入数据行，然后打印出在特定列中找到的值。</p>

<h3 id="在语法中嵌入任意的操作">在语法中嵌入任意的操作</h3>

<p>如果我们不想付出构建语法分析树的开销，或者想要在分析期间动态地计算值或把东西打印出来，那么可以通过在语法中嵌入任意代码实现。它的比较困难的，因为我们必须明白在语法分析器上的操作的影响，以及在哪里放置这些操作。</p>

<p>为了解释嵌入在语法中的操作，让我们先来看下文件rows.txt中的数据：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">parrt   Terence Parr    101
tombu   Tom Burns       020
bke     Kevin Edgar     008
</code></pre></div>
<p>这些列是由TAB分隔的，每一行用一个换行结束。匹配这种类型的输入在语法上还是相当简单的。下面是此语法文件Rows.g的内容：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">file : (row NL)+ ;  // NL is newline token: &#39;\r&#39;? &#39;\n&#39;
row  : STUFF+ ;
</code></pre></div>
<p>我们需要创建一个构造器以便我们能传递我们想要的列号（从1开始计数），所以我们需要在规则中添加一些操作来做这些事情：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">grammar Rows;

@parser::members {  // add members to generated RowsParser
    int col;
    public RowsParser(TokenStream input, int col) { // custom constructor
        this(input);
        this.col = col;
    }
}

file: (row NL)+ ;

row
locals [int i=0]
    : ( STUFF
        {
        $i++;
        if ( $i == col ) System.out.println($STUFF.text);
        }
      )+
    ;

TAB  :  &#39;\t&#39; -&gt; skip ;  // match but don&#39;t pass to the parser
NL   :  &#39;\r&#39;? &#39;\n&#39; ;    // match and pass to the parser
STUFF:  ~[\t\r\n]+ ;    // match any chars except tab, newline
</code></pre></div>
<p>在上述语法中，操作是被花括号括起来的代码片段；members操作的代码将会被注入到生成的语法分析器类中的成员区；在规则row中的操作访问的$i是由locals子句定义的局部变量，该操作也用$STUFF.text获取最近匹配的STUFF记号的文本内容。STUFF词法规则匹配任何非TAB或换行的字符，这意味着在列中可以有空格字符。</p>

<p>现在，是时候去思考如何使用定制的构造器传递一个列号给语法分析器，并且告诉语法分析器不要构建语法分析树了：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class Rows {

    public static void main(String[] args) throws Exception {
        ANTLRInputStream input = new ANTLRInputStream(System.in);
        RowsLexer lexer = new RowsLexer(input);
        CommonTokenStream tokens = new CommonTokenStream(lexer);
        int col = Integer.valueOf(args[0]);
        RowsParser parser = new RowsParser(tokens, col);    // pass column number!
        parser.setBuildParseTree(false);    // don&#39;t waste time bulding a tree
        parser.file();
    }
}
</code></pre></div>
<p>现在，让我们核实下我们的语法分析器能否正确匹配一些示例输入：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">antlr -no-listener Rows.g  # don&#39;t need the listener
compile *.java
run Rows 1 &lt; rows.txt
</code></pre></div>
<p>这时你会看到rows.txt文件的第1列内容被输出：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">parrt
tombu
bke
</code></pre></div>
<p>如果将上面命令中的1换成2，你会看到rows.txt文件的第2列内容被输出；如果换成3，那么rows.txt文件的第3列内容将会被输出。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（5）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part5/"/>
    <updated>2016-01-22T21:18:51+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part5</id>
    <content type="html"><![CDATA[<p>在<a href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part3/">ANTLR 4权威参考读书笔记（3）</a>以及<a href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part4/">ANTLR 4权威参考读书笔记（4）</a>中我们分别用Visitor和Listener机制实现了计算器的解释执行和编译执行。但并没有给出这两种机制的太多细节，这次就来详细地讲讲。</p>

<p>ANTLR在它的运行库中为两种树遍历机制提供支持。默认情况下，ANTLR生成一个语法分析树Listener接口，在其中定义了回调方法，用于响应被内建的树遍历器触发的事件。</p>

<p>在Listener和Visitor机制之间最大的不同是：Listener方法被ANTLR提供的遍历器对象调用；而Visitor方法必须显式的调用visit方法遍历它们的子节点，在一个节点的子节点上如果忘记调用visit方法就意味着那些子树没有得到访问。</p>

<p>让我们首先从Listener开始。在我们了解Listener之后，我们也将看到ANTLR如何生成遵循Visitor设计模式的树遍历器。</p>

<h3 id="语法分析树listener">语法分析树Listener</h3>

<p>在Calc.java中有这样两行代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">ParseTreeWalker walker = new ParseTreeWalker();
walker.walk(new DirectiveListener(), tree);
</code></pre></div>
<p>类ParseTreeWalker是ANTLR运行时提供的用于遍历语法分析树和触发Listener中回调方法的树遍历器。ANTLR工具根据Calc.g中的语法自动生成ParseTreeListener接口的子接口CalcListener和默认实现CalcBaseListener，其中含有针对语法中每个规则的enter和exit方法。DirectiveListener是我们编写的继承自CalcBaseListener的包含特定应用代码的实现，把它传递给树遍历器后，树遍历器在遍历语法分析树时就会触发DirectiveListener中的回调方法。</p>

<p><img src="/uploads/calc-listener-hierachy.png" title="calc-listener-hierachy" ></p>

<p>下图左边的语法分析树显示ParseTreeWalker执行了一次深度优先遍历，由粗虚线表示，箭头方向代表遍历方向。右边显示的是语法分析树的完整调用序列，它们由ParseTreeWalker触发调用。当树遍历器遇到规则assign的节点时，它触发enterAssign()并且给它传递AssignContext语法分析树节点。在树遍历器访问完assign节点的所有子节点后，它触发exitAssign()。</p>

<p><img src="/uploads/listener-call-sequence.png" title="listener-call-sequence" ></p>

<p>Listener机制的强大之处在于所有都是自动的。我们不必要写语法分析树遍历器，而且我们的Listener方法也不必要显式地访问它们的子节点。</p>

<h3 id="语法分析树visitor">语法分析树Visitor</h3>

<p>有些情况下，我们实际想要控制的是遍历本身，在那里我们可以显式地调用visit方法去访问子树节点。选项-visitor告诉ANTLR工具从相应语法生成Visitor接口和默认实现，其中含有针对语法中每个规则的visit方法。</p>

<p>下图是我们熟悉的Visitor模式操作在语法分析树上。左边部分的粗虚线表示语法分析树的深度优先遍历，箭头方向代表遍历方向。右边部分指明Visitor中的方法调用序列。</p>

<p><img src="/uploads/visitor-call-sequence.png" title="visitor-call-sequence" ></p>

<p>下面是Calc.java中的两行代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">EvalVisitor eval = new EvalVisitor();
// To start walking the parse tree
eval.visit(tree);
</code></pre></div>
<p>我们首先初始化自制的树遍历器EvalVisitor，然后调用visit()去访问整棵语法分析树。ANTLR运行时提供的Visitor支持代码会在看到根节点时调用visitProg()。在那里，visitProg()会把子树作为参数调用visit方法继续遍历，如此等等。</p>

<p><img src="/uploads/calc-visitor-hierachy.png" title="calc-visitor-hierachy" ></p>

<p>ANTLR自动生成的Visitor接口和默认实现可以让我们为Visitor方法编写自己的实现，让我们避免必须覆写接口中的每个方法，让我们仅仅聚焦在我们感兴趣的方法上。这种方法减少了我们学习ANTLR必须要花费的时间，让我们回到我们所熟悉的编程语言领域。</p>
]]></content>
  </entry>
  
</feed>
