<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: wxWidgets | 乐者为王]]></title>
  <link href="http://codemany.com/tags/wxwidgets/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2014-09-15T15:50:49+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[利用WHOIS协议查询域名信息]]></title>
    <link href="http://codemany.com/blog/2009/09/16/using-whois-protocol-to-query-domain-information/"/>
    <updated>2009-09-16T06:15:04+08:00</updated>
    <id>http://codemany.com/blog/2009/09/16/using-whois-protocol-to-query-domain-information</id>
    <content type="html"><![CDATA[<p>域名信息的查询原理非常简单，主要是基于RFC 954（RFC 812已被废弃）提供的WHOIS协议。WHOIS服务器是一个基于“查询/响应”的TCP事务服务器，用户程序通过访问WHOIS服务器，从WHOIS数据库中查询得到我们所需要的内容。其主要过程有以下三步：</p>

<ol>
<li>在TCP服务端口43连接WHOIS服务主机；</li>
<li>发送一个命令，以回车换行符结尾；</li>
<li>接受相应命令的返回信息，一旦输出结束，服务器将关闭连接。</li>
</ol>


<p>命令的格式非常简单。可以直接输入域名（例如example.com）查询相关域名信息；也可以使用help得到详细的帮助信息。以下是查询的代码：</p>

<p>```
wxString Whois::Lookup(wxString&amp; host, wxString&amp; szAddress)
{</p>

<pre><code>char szQuery[512];
char szBuffer[512];
wxString szResult;

strcpy(szQuery, szAddress);
strcat(szQuery, "\r\n");

wxIPV4address addr;
addr.Hostname(host);
addr.Service(43);

wxSocketClient socket;
socket.Connect(addr, false);
socket.WaitOnConnect(30);

if (socket.IsConnected())
{
    socket.Write(szQuery, strlen(szQuery));
    szResult = "";
    while (true)
    {
        // Clear buffer before each iteration
        memset(szBuffer, 0, 512);

        // Try to receive some data
        socket.Read(szBuffer, 500);
        if (socket.LastCount() &lt;= 0)
        {
            break;
        }
        szResult += szBuffer;
    }
}
else
{
    szResult = wxT("Failed! Unable to connect\n");
}
socket.Close();

return wxString::FromUTF8(szResult);
</code></pre>

<p>}
```</p>

<p>常用的WHOIS服务器：</p>

<p><code>
.cn=whois.cnnic.net.cn
.com=whois.internic.com
.net=whois.internic.com
.name=www.whois.name
.cc=whois.nic.cc
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修复wxWidgets Wizard for Visual Studio 2005/2008中的一个bug]]></title>
    <link href="http://codemany.com/blog/2008/10/16/fix-bug-wxwidgets-wizard-for-visual-studio-2005-and-2008/"/>
    <updated>2008-10-16T17:41:47+08:00</updated>
    <id>http://codemany.com/blog/2008/10/16/fix-bug-wxwidgets-wizard-for-visual-studio-2005-and-2008</id>
    <content type="html"><![CDATA[<p>前面发布的wxWidgets Wizard for Visual Studio 2005/2008存在一个bug，安装在VS2008中后不能创建新的wxWidgets项目。原因是没有将wxAppWiz.vsz文件中VsWizardEngine的版本号改为9.0。现在做了一些修改，修改后的代码如下：</p>

<p>```
procedure CurStepChanged(CurStep: TSetupStep);
var</p>

<pre><code>i: Integer;
Signature: String;
VsdirLine: String;
ConfigFile: String;
ConfigFileLines: TArrayOfString;
</code></pre>

<p>begin</p>

<pre><code>if CurStep = ssPostInstall then begin
    if (Pos('Visual Studio 9.0', ExpandConstant('{app}')) &gt; 0) then begin
        Signature := 'Wizard=VsWizard.VsWizardEngine';
        ConfigFile := ExpandConstant('{app}\VCProjects\wxAppWiz.vsz');
        LoadStringsFromFile(ConfigFile, ConfigFileLines);
        for i := 0 to GetArrayLength(ConfigFileLines) - 1 do begin
            if (Pos(Signature, ConfigFileLines[i]) &gt; 0) then begin
                ConfigFileLines[i] := 'Wizard=VsWizard.VsWizardEngine.9.0'
                SaveStringsToFile(ConfigFile, ConfigFileLines, False);
                break;
            end;
        end;
    end;

    Signature := 'wxWidgets';
    VsdirLine := 'wxWidgets|{1B027A40-8F43-11D0-8D11-00A0C91BC942}|#1043|70' + #13#10;
    ConfigFile:= ExpandConstant('{app}\VCProjects\vc.vsdir');
    LoadStringsFromFile(ConfigFile, ConfigFileLines);
    for i:= 0 to GetArrayLength(ConfigFileLines) - 1 do begin
        if (Pos(Signature, ConfigFileLines[i]) &gt; 0) then abort;
    end;
    SaveStringToFile(ConfigFile, VsdirLine, True);
end;
</code></pre>

<p>end;
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[wxWidgets Wizard for Visual Studio 2005/2008]]></title>
    <link href="http://codemany.com/blog/2008/02/16/wxwidgets-wizard-for-visual-studio-2005-and-2008/"/>
    <updated>2008-02-16T08:13:19+08:00</updated>
    <id>http://codemany.com/blog/2008/02/16/wxwidgets-wizard-for-visual-studio-2005-and-2008</id>
    <content type="html"><![CDATA[<p>花了点时间为VS2005/VS2008写了一个简单的wxWidgets wizard。本来想写的更完善一些再发布出来的，只是实在没有多少心思再继续地写下去了。而且该向导程序已经基本可以满足我自己的要求了。不过，如果以后有时间的话还是会继续完善它的。以下是我原本打算要实现的一些功能：</p>

<ol>
<li>支持创建对话框程序；</li>
<li>可以直接安装wxWidgets Wizard到VS2005中的安装程序；</li>
<li>集成wxWidgets Help文档到VS2005中；</li>
<li>实现代码智能提示功能；</li>
<li>可以在VS2005中直接编辑和编译xrc资源；</li>
<li>在向导过程中可以设置一些wxWidgets的高级特性（比如Menu Bar，Status Bar等）。</li>
</ol>


<p><img src="/uploads/wxwizard-generated-classes.png" title="wxwizard-generated-classes" ></p>

<p>代码下载：<a href="https://github.comdohkoos/wxwizard">https://github.comdohkoos/wxwizard</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[XRC和动态子菜单]]></title>
    <link href="http://codemany.com/blog/2008/01/11/xrc-and-dynamic-sub-menu/"/>
    <updated>2008-01-11T15:08:59+08:00</updated>
    <id>http://codemany.com/blog/2008/01/11/xrc-and-dynamic-sub-menu</id>
    <content type="html"><![CDATA[<p>一、什么是XRC</p>

<p>XRC是基于XML的资源系统。它的基本出发点是将界面布局和程序逻辑分离，即将界面布局代码保存在分离的XML文件中，在程序中不涉及控件的创建和布局，只需要加载相应的资源并处理事件绑定即可。</p>

<p>二、XRC文件格式</p>

<p>```
&lt;?xml version="1.0"?>
<resource version="2.3.0.1"></p>

<pre><code>&lt;object class="wxFrame" name="ID_MAIN_FRAME"&gt;
    &lt;size&gt;200, 300&lt;/size&gt;
&lt;/object&gt;
</code></pre>

<p></resource>
```</p>

<p>三、XRC文件中菜单资源的相关属性</p>

<table>
<thead>
<tr>
<th>类         </th>
<th> 属性      </th>
<th> 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>wxMenuBar  </td>
<td> style     </td>
<td> Menu bar style: wxMB_DOCKABLE</td>
</tr>
<tr>
<td>wxMenu     </td>
<td> style     </td>
<td> Menu style: wxMENU_TEAROFF</td>
</tr>
<tr>
<td>           </td>
<td> label     </td>
<td> Text: label of the menu.</td>
</tr>
<tr>
<td>           </td>
<td> help      </td>
<td> Text: displayed help string.</td>
</tr>
<tr>
<td>wxMenuItem </td>
<td> style     </td>
<td> Menu style: wxMENU_TEAROFF</td>
</tr>
<tr>
<td>           </td>
<td> label     </td>
<td> Text: label of the menu.</td>
</tr>
<tr>
<td>           </td>
<td> accel     </td>
<td> Text: accelerator associated to this item ( Alt-X for example ).</td>
</tr>
<tr>
<td>           </td>
<td> help      </td>
<td> Text: displayed help string.</td>
</tr>
<tr>
<td>           </td>
<td> radio     </td>
<td> bool value(0/1): 1 if this item is a radio menu item.</td>
</tr>
<tr>
<td>           </td>
<td> checkable </td>
<td> bool value(0/1): 1 if this item is a check menu item.</td>
</tr>
<tr>
<td>           </td>
<td> enabled   </td>
<td> bool value(0/1): 1 if this item is initially enabled.</td>
</tr>
<tr>
<td>           </td>
<td> checked   </td>
<td> bool value(0/1): 1 if this (check) item is initially checked.</td>
</tr>
<tr>
<td>           </td>
<td> bitmap    </td>
<td> Text: path to a bitmap to draw at the left of the item.</td>
</tr>
</tbody>
</table>


<p>四、使用XRC创建菜单</p>

<p>创建一个包含菜单布局信息的XML资源文件MenuBar.xrc：</p>

<p>```
&lt;?xml version="1.0" encoding="utf-8" ?>
<resource version="2.3.0.1" xmlns="http://www.wxwindows.org/wxxrc"></p>

<pre><code>&lt;object class="wxMenuBar" name="ID_MENUBAR"&gt;
    &lt;object class="wxMenu" name="ID_MENU_FILE"&gt;
        &lt;label&gt;&amp;File&lt;/label&gt;
        &lt;object class="wxMenuItem" name="wxID_CLOSE"&gt;
            &lt;label&gt;E&amp;xit&lt;/label&gt;
            &lt;accel&gt;Ctrl+Q&lt;/accel&gt;
            &lt;help&gt;Quit the application&lt;/help&gt;
        &lt;/object&gt;
    &lt;/object&gt;
    &lt;object class="wxMenu" name="ID_MENU_VIEW"&gt;
        &lt;label&gt;&amp;View&lt;/label&gt;
    &lt;/object&gt;
    &lt;object class="wxMenu" name="ID_MENU_TOOLS"&gt;
        &lt;label&gt;&amp;Tools&lt;/label&gt;
        &lt;object class="wxMenuItem" name="wxID_OPTIONS"&gt;
            &lt;label&gt;&amp;Options...&lt;/label&gt;
        &lt;/object&gt;
    &lt;/object&gt;
    &lt;object class="wxMenu" name="ID_MENU_HELP"&gt;
        &lt;label&gt;&amp;Help&lt;/label&gt;
        &lt;object class="wxMenuItem" name="wxID_CHECKFORUPDATES"&gt;
            &lt;label&gt;Check for &amp;Updates...&lt;/label&gt;
        &lt;/object&gt;
        &lt;object class="separator" /&gt;
        &lt;object class="wxMenuItem" name="wxID_ABOUT"&gt;
            &lt;label&gt;&amp;About...&lt;/label&gt;
        &lt;/object&gt;
    &lt;/object&gt;
&lt;/object&gt;
</code></pre>

<p></resource>
```</p>

<p>加载资源文件：</p>

<p>```
bool MainApp::OnInit()
{</p>

<pre><code>wxXmlResource* pResource = wxXmlResource::Get();
pResource-&gt;AddHandler(new wxMenuBarXmlHandler);
pResource-&gt;AddHandler(new wxMenuXmlHandler);
pResource-&gt;Load(wxT("resources/MenuBar.xrc"));
...
</code></pre>

<p>}
```</p>

<p>初始化资源文件：</p>

<p>```
MainFrame::MainFrame(const wxString&amp; title) : wxFrame(NULL, wxID_ANY, title)
{</p>

<pre><code>m_menuBar = NULL;
InitMenuBar();
</code></pre>

<p>}</p>

<p>bool MainFrame::InitMenuBar()
{</p>

<pre><code>if (m_menuBar)
{
    SetMenuBar(NULL);
    delete m_menuBar;
}
// Initialize the resource system
m_menuBar = wxXmlResource::Get()-&gt;LoadMenuBar(wxT("ID_MENUBAR"));
if (!m_menuBar)
{
    wxLogError(wxT("Cannot load main menu from resource file"));
    return false;
}
SetMenuBar(m_menuBar);
return true;
</code></pre>

<p>}
```</p>

<p>五、在XRC菜单上添加动态子菜单</p>

<p>在资源文件中添加一个新的菜单项（wxID_LANGUAGES）：</p>

<p>```</p>

<p><object class="wxMenu" name="ID_MENU_VIEW"></p>

<pre><code>&lt;label&gt;&amp;View&lt;/label&gt;
&lt;object class="wxMenu" name="wxID_LANGUAGE"&gt;
    &lt;label&gt;&amp;Language&lt;/label&gt;
    &lt;object class="wxMenuItem" name="wxID_LANGUAGES"&gt;
        &lt;label&gt;Get Additional/Update language pack&lt;/label&gt;
        &lt;help&gt;Downloading Additional/Update language pack&lt;/help&gt;
    &lt;/object&gt;
    &lt;object class="separator" /&gt;
&lt;/object&gt;
</code></pre>

<p></object>
```</p>

<p>创建动态子菜单：</p>

<p>```
// Initialize the resource system
m_menuBar = wxXmlResource::Get()->LoadMenuBar(wxT("ID_MENUBAR"));
if (!m_menuBar)
{</p>

<pre><code>wxLogError(wxT("Cannot load main menu from resource file"));
return false;
</code></pre>

<p>}
/<em>
 * 这里很奇怪，在XRC文件wxID_LANGUAGE的类型明明是wxMenu，可在这里确只能用wxMenuItem。
 * 查看wxWidgets源代码发现XRC系统只会把最上层的class为wxMenu的object创建为wxMenu对象。
 * 其它的则都被创建成了wxMenuItem对象。
 </em>/
// 使用XRCID方法获取控件ID，创建动态子菜单
wxMenuItem* menuItem = m_menuBar->FindItem(XRCID("wxID_LANGUAGE"));
if (menuItem)
{</p>

<pre><code>wxMenu* subMenu = menuItem-&gt;GetSubMenu();
subMenu-&gt;AppendRadioItem(wxID_LANGUAGE_LOWEST + 1, wxT("English"));
subMenu-&gt;AppendRadioItem(wxID_LANGUAGE_LOWEST + 2, wxT("Chinese(Simplified)"));
</code></pre>

<p>}
SetMenuBar(m_menuBar);
return true;
```</p>

<p><a href="/uploads/wxXRC.zip" title="wxXRC.zip">代码下载</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何实现一个可拖动的无标题栏窗口]]></title>
    <link href="http://codemany.com/blog/2007/12/03/how-to-implement-draggable-window-without-title-bar/"/>
    <updated>2007-12-03T15:46:55+08:00</updated>
    <id>http://codemany.com/blog/2007/12/03/how-to-implement-draggable-window-without-title-bar</id>
    <content type="html"><![CDATA[<p>无标题栏窗口的实现很简单。先将窗口从wxMiniFrame继承，然后在窗口的构造函数中设置一下窗口的样式。</p>

<p>```
MainFrame::MainFrame(const wxPoint&amp; pos, const wxSize&amp; size)</p>

<pre><code>: wxMiniFrame(NULL, wxID_ANY, wxEmptyString, pos, size)
</code></pre>

<p>{</p>

<pre><code>SetWindowStyleFlag(wxFRAME_NO_TASKBAR | wxNO_BORDER);
</code></pre>

<p>}
```</p>

<p>但是，窗口的移动通常都是通过鼠标点住标题栏拖动窗口来实现的，那么现在没有了标题栏，该如何移动窗口呢？我们知道，当鼠标拖动窗口时，它在窗口中的位置是始终不变的。所以如果能够在鼠标移动过程中，通过改变窗口在桌面上的坐标，并且始终保持鼠标相对于窗口的坐标不变，即可实现鼠标的拖动效果。</p>

<p>在具体的设计中，先在鼠标的MouseDown事件中记录下鼠标相对于窗口的偏移，在鼠标的MouseMove事件中根据鼠标在桌面上的位置实时设置窗口的位置，即可达到鼠标拖动窗口的操作。利用此方法实现鼠标拖动，与常规的标题栏鼠标拖动在效果上有一点区别。通过标题栏拖动时，鼠标移动过程中不重画窗口，只有松开鼠标后才在固定位置重画窗口，因此其速度较快。而采用本方法的拖动过程中，每移动一步都需要重画窗口，因此对速度稍有影响，在慢一些的机器上可能会出现轻微的拖尾现象。</p>

<p>```
void MainFrame::OnMouseMove(wxMouseEvent&amp; event)
{</p>

<pre><code>if (event.Dragging() &amp;&amp; event.LeftIsDown())
{
    wxPoint pt = ClientToScreen(event.GetPosition());
    int x = pt.x - m_delta.x;
    int y = pt.y - m_delta.y;
    Move(x, y);
}
</code></pre>

<p>}</p>

<p>void MainFrame::OnMouseLeftDown(wxMouseEvent&amp; event)
{</p>

<pre><code>CaptureMouse();
wxPoint pt = ClientToScreen(event.GetPosition());
wxPoint origin = GetPosition();
int dx = pt.x - origin.x;
int dy = pt.y - origin.y;
m_delta = wxPoint(dx, dy);
</code></pre>

<p>}</p>

<p>void MainFrame::OnMouseLeftUp(wxMouseEvent&amp; WXUNUSED(event))
{</p>

<pre><code>if (HasCapture())
{
    ReleaseMouse();
}
</code></pre>

<p>}
```</p>

<p><a href="/uploads/wxDragAndDrop.zip" title="wxDragAndDrop.zip">代码下载</a></p>
]]></content>
  </entry>
  
</feed>
