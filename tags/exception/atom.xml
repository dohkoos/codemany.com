<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Exception | 乐者为王]]></title>
  <link href="http://codemany.com/tags/exception/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2016-05-29T21:22:44+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[异常处理最佳实践]]></title>
    <link href="http://codemany.com/blog/best-practices-for-exception-handling/"/>
    <updated>2005-08-12T10:02:48+08:00</updated>
    <id>http://codemany.com/blog/best-practices-for-exception-handling</id>
    <content type="html"><![CDATA[<p>英文原文：<a href="http://www.onjava.com/pub/a/onjava/2003/11/19/exceptions.html">http://www.onjava.com/pub/a/onjava/2003/11/19/exceptions.html</a></p>

<p>异常处理的问题之一是知道何时以及如何使用它。在这篇文章中，我将讨论一些异常处理的最佳实践。我也会总结最近关于使用Checked异常的争论。</p>

<p>作为程序员，我们想要编写解决问题的质量代码。不幸的是，异常作为我们代码的意外结果出现。没有人喜欢意外结果，因此我们很快找到我们自己的方法去绕过它们。我曾经看到过一些聪明的程序员以下列方式对待异常：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void consumeAndForgetAllExceptions() {
    try {
        // some code that throws exceptions
    } catch (Exception ex) {
        ex.printStacktrace();
    }
}
</code></pre></div>
<p>上面的代码有什么问题？</p>

<p>一旦一个异常被抛出，正常的程序执行被挂起，并且控制权转移到catch块。catch块捕获异常后什么也没做。在catch块后面的程序继续执行，就好象什么也没发生。</p>

<p>下面的代码怎么样？</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void someMethod() throws Exception {
}
</code></pre></div>
<p>这是一个空方法，它里面没有任何代码。空方法如何能抛出异常呢？Java不能阻止你这么做。最近我正好遇见过类似的代码：方法声明抛出异常，但方法里没有代码实际生成那个异常。当我问那个程序员时，他回复说：“我知道，这会让API看起来很糟糕，但我一直都是这样做的，而且很管用。”</p>

<p>C++社区花了好几年去确定如何使用异常。这种争论在Java社区刚刚开始。我已经见过几个Java程序员与异常的使用作斗争。如果没有正确使用，异常会减缓你的程序，因为它需要内存和CPU能力去创建、抛出和捕获异常。如果过度使用，会使代码难以阅读，让使用API的程序员感到挫折。我们都知道挫折感（frustrations）会导致特殊技巧（ hacks）和代码味道。客户端代码只需要忽略异常或者抛出它们就可以规避这个问题，就像前面的两个例子。</p>

<h3 id="异常的本质">异常的本质</h3>

<p>大体上说，有三种不同的情况可以导致异常被抛出：</p>

<ul>
<li><strong>由于编程错误的异常：</strong> 在此类别中，异常是由于编程错误产生的（例如，NullPointerException和IllegalArgumentException）。客户端代码通常不能解决关于编程错误的任何事情。</li>
<li><strong>由于客户端代码错误的异常：</strong> 客户端代码尝试API不允许的东西，从而违反了它的契约。客户端可以采取一些替代的做法，如果在异常中有提供有用的信息。例如：当分析一个非格式良好的XML文档时一个异常被抛出。异常包含有XML文档中引起问题的位置信息。客户端可以使用该信息去采取恢复措施。</li>
<li><strong>由于资源失败的异常：</strong> 当资源失败时生成的异常。比如说：系统内存不足或者网络连接失败。资源失败的客户端响应是上下文驱动的。客户端可以过一段时间后重试操作或者仅仅记录资源失败然后使应用程序停止。</li>
</ul>

<h3 id="java中异常的类型">Java中异常的类型</h3>

<p>Java定义了两类异常：</p>

<ul>
<li><strong>Checked异常：</strong> 继承自Exception类的异常是Checked异常。客户端代码必须处理被API抛出的Checked异常，不是在catch子句中就是通过throw子句向外转发。</li>
<li><strong>Unchecked异常：</strong> RuntimeException也扩展自Exception。然而，所有继承自RuntimeException的异常享有特殊待遇。对客户端代码是否处理它们不做任何要求，因此它们被称为Unchecked异常。</li>
</ul>

<p>举例来说，图1显示了NullPointerException层次结构。</p>

<p><img src="/uploads/exception-hierarchy.gif" title="exception-hierarchy" ></p>

<p>图1. 示例异常层次结构</p>

<p>在这个图中，NullPointerException扩展自RuntimeException，因此是一个Unchecked异常。</p>

<p>我曾经见过Checked异常的重度使用和Unchecked异常的最小使用。最近，在Java社区有激烈的争论关于Checked异常和其真正的价值。这场争论源于Java似乎是第一个带有Checked异常的主流OO语言这个事实。C++和C#根本没有Checked异常，在这些语言中所有的异常都是Unchecked的。</p>

<p>由较低层引发的Checked异常是强制性的，要求调用层必须捕获或者抛出它。如果客户端代码无法有效地处理异常，在API和它客户端之间的Checked异常契约很快就会转变为不必要的负担。客户端代码的程序员可能会走捷径，通过使用一个空的catch块抑制异常或者仅仅抛出它。实际上，它只是把负担放到了客户端调用者身上。</p>

<p>Checked异常也被指责破坏了封装。考虑以下代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public List getAllAccounts() throws FileNotFoundException, SQLException {
}
</code></pre></div>
<p>方法getAllAccounts()抛出两个Checked异常。该方法的客户端必须显式地处理这些特定实现的异常，即使它不知道在getAllAccounts()中什么文件或数据库调用失败，或者没有业务提供文件系统或数据库逻辑。因此，异常处理在方法和它的调用者之间强制造成了一个不适当的紧密耦合。</p>

<h3 id="设计api的最佳实践">设计API的最佳实践</h3>

<p>说了这么多，现在让我们谈谈如何设计一个正确抛出异常的API。</p>

<h4 id="1-当确定使用checked异常还是unchecked异常时，问问你自己：“当异常发生时客户端代码可以采取哪些措施？”">1. 当确定使用Checked异常还是Unchecked异常时，问问你自己：“当异常发生时客户端代码可以采取哪些措施？”</h4>

<p>If the client can take some alternate action to recover from the exception, make it a checked exception. If the client cannot do anything useful, then make the exception unchecked. By useful, I mean taking steps to recover from the exception and not just logging the exception. To summarize:</p>

<table><thead>
<tr>
<th>当异常发生时客户端的反应</th>
<th>异常类型</th>
</tr>
</thead><tbody>
<tr>
<td>客户端代码什么都不能做</td>
<td>把它设置为Unchecked异常</td>
</tr>
<tr>
<td>客户端代码将基于异常中的信息采取一些有用的恢复操作</td>
<td>把它设置为Checked异常</td>
</tr>
</tbody></table>

<p>Moreover, prefer unchecked exceptions for all programming errors: unchecked exceptions have the benefit of not forcing the client API to explicitly deal with them. They propagate to where you want to catch them, or they go all the way out and get reported. The Java API has many unchecked exceptions, such as NullPointerException, IllegalArgumentException, and IllegalStateException. I prefer working with standard exceptions provided in Java rather than creating my own. They make my code easy to understand and avoid increasing the memory footprint of code.</p>

<h4 id="2-保护封装性。">2. 保护封装性。</h4>

<p>Never let implementation-specific checked exceptions escalate to the higher layers. For example, do not propagate SQLException from data access code to the business objects layer. Business objects layer do not need to know about SQLException. You have two options:</p>

<ul>
<li>Convert SQLException into another checked exception, if the client code is expected to recuperate from the exception.</li>
<li>Convert SQLException into an unchecked exception, if the client code cannot do anything about it.</li>
</ul>

<p>Most of the time, client code cannot do anything about SQLExceptions. Do not hesitate to convert them into unchecked exceptions. Consider the following piece of code:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void dataAccessCode() {
    try {
        // some code that throws SQLException
    } catch(SQLException ex) {
        ex.printStacktrace();
    }
}
</code></pre></div>
<p>This catch block just suppresses the exception and does nothing. The justification is that there is nothing my client could do about an SQLException. How about dealing with it in the following manner?</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void dataAccessCode() {
    try {
        // some code that throws SQLException
    } catch(SQLException ex) {
        throw new RuntimeException(ex);
    }
}
</code></pre></div>
<p>This converts SQLException to RuntimeException. If SQLException occurs, the catch clause throws a new RuntimeException. The execution thread is suspended and the exception gets reported. However, I am not corrupting my business object layer with unnecessary exception handling, especially since it cannot do anything about an SQLException. If my catch needs the root exception cause, I can make use of the getCause() method available in all exception classes as of JDK1.4.</p>

<p>If you are confident that the business layer can take some recovery action when SQLException occurs, you can convert it into a more meaningful checked exception. But I have found that just throwing RuntimeException suffices most of the time.</p>

<h4 id="3-如果不能给客户端代码提供有用的信息就不要试图去创建新的定制异常。">3. 如果不能给客户端代码提供有用的信息就不要试图去创建新的定制异常。</h4>

<p>What is wrong with following code?</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class DuplicateUsernameException extends Exception {
}
</code></pre></div>
<p>It is not giving any useful information to the client code, other than an indicative exception name. Do not forget that Java Exception classes are like other classes, wherein you can add methods that you think the client code will invoke to get more information.</p>

<p>We could add useful methods to DuplicateUsernameException, such as:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class DuplicateUsernameException extends Exception {
    public DuplicateUsernameException(String username) {}
    public String requestedUsername() {}
    public String[] availableNames() {}
}
</code></pre></div>
<p>The new version provides two useful methods: requestedUsername(), which returns the requested name, and availableNames(), which returns an array of available usernames similar to the one requested. The client could use these methods to inform that the requested username is not available and that other usernames are available. But if you are not going to add extra information, then just throw a standard exception:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">throw new Exception(&quot;Username already taken&quot;);
</code></pre></div>
<p>Even better, if you think the client code is not going to take any action other than logging if the username is already taken, throw a unchecked exception:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">throw new RuntimeException(&quot;Username already taken&quot;);
</code></pre></div>
<p>Alternatively, you can even provide a method that checks if the username is already taken.</p>

<p>It is worth repeating that checked exceptions are to be used in situations where the client API can take some productive action based on the information in the exception. Prefer unchecked exceptions for all programmatic errors. They make your code more readable.</p>

<h4 id="4-document-exceptions">4. Document exceptions.</h4>

<p>You can use Javadoc&#39;s @throws tag to document both checked and unchecked exceptions that your API throws. However, I prefer to write unit tests to document exceptions. Tests allow me to see the exceptions in action and hence serve as documentation that can be executed. Whatever you do, have some way by which the client code can learn of the exceptions that your API throws. Here is a sample unit test that tests for IndexOutOfBoundsException:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void testIndexOutOfBoundsException() {
    ArrayList blankList = new ArrayList();
    try {
        blankList.get(10);
        fail(&quot;Should raise an IndexOutOfBoundsException&quot;);
    } catch (IndexOutOfBoundsException success) {
    }
}
</code></pre></div>
<p>The code above should throw an IndexOutOfBoundsException when blankList.get(10) is invoked. If it does not, the fail(&quot;Should raise an IndexOutOfBoundsException&quot;) statement explicitly fails the test. By writing unit tests for exceptions, you not only document how the exceptions work, but also make your code robust by testing for exceptional scenarios.</p>

<h3 id="使用异常的最佳实践">使用异常的最佳实践</h3>

<p>The next set of best practices show how the client code should deal with an API that throws checked exceptions.</p>

<h4 id="1-always-clean-up-after-yourself">1. Always clean up after yourself</h4>

<p>If you are using resources like database connections or network connections, make sure you clean them up. If the API you are invoking uses only unchecked exceptions, you should still clean up resources after use, with try - finally blocks.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void dataAccessCode() {
    Connection conn = null;
    try {
        conn = getConnection();
        // some code that throws SQLException
    } catch(SQLException ex) {
        ex.printStacktrace();
    } finally {
        DBUtil.closeConnection(conn);
    }
}

class DBUtil {
    public static void closeConnection(Connection conn) {
        try {
            conn.close();
        } catch(SQLException ex) {
            logger.error(&quot;Cannot close connection&quot;);
            throw new RuntimeException(ex);
        }
    }
}
</code></pre></div>
<p>DBUtil is a utility class that closes the Connection. The important point is the use of finally block, which executes whether or not an exception is caught. In this example, the finally closes the connection and throws a RuntimeException if there is problem with closing the connection.</p>

<h4 id="2-never-use-exceptions-for-flow-control">2. Never use exceptions for flow control</h4>

<p>Generating stack traces is expensive and the value of a stack trace is in debugging. In a flow-control situation, the stack trace would be ignored, since the client just wants to know how to proceed.</p>

<p>In the code below, a custom exception, MaximumCountReachedException, is used to control the flow.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void useExceptionsForFlowControl() {
    try {
        while (true) {
            increaseCount();
        }
    } catch (MaximumCountReachedException ex) {
    }
    // Continue execution
}

public void increaseCount()
    throws MaximumCountReachedException {
    if (count &gt;= 5000)
        throw new MaximumCountReachedException();
}
</code></pre></div>
<p>The useExceptionsForFlowControl() uses an infinite loop to increase the count until the exception is thrown. This not only makes the code difficult to read, but also makes it slower. Use exception handling only in exceptional situations.</p>

<h4 id="3-do-not-suppress-or-ignore-exceptions">3. Do not suppress or ignore exceptions</h4>

<p>When a method from an API throws a checked exception, it is trying to tell you that you should take some counter action. If the checked exception does not make sense to you, do not hesitate to convert it into an unchecked exception and throw it again, but do not ignore it by catching it with {} and then continue as if nothing had happened.</p>

<h4 id="4-do-not-catch-top-level-exceptions">4. Do not catch top-level exceptions</h4>

<p>Unchecked exceptions inherit from the RuntimeException class, which in turn inherits from Exception. By catching the Exception class, you are also catching RuntimeException as in the following code:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">try {
} catch(Exception ex) {
}
</code></pre></div>
<p>The code above ignores unchecked exceptions, as well.</p>

<h4 id="5-log-exceptions-just-once">5. Log exceptions just once</h4>

<p>Logging the same exception stack trace more than once can confuse the programmer examining the stack trace about the original source of exception. So just log it once.</p>

<h3 id="总结">总结</h3>

<p>These are some suggestions for exception-handling best practices. I have no intention of staring a religious war on checked exceptions vs. unchecked exceptions. You will have to customize the design and usage according to your requirements. I am confident that over time, we will find better ways to code with exceptions.</p>

<p>I would like to thank Bruce Eckel, Joshua Kerievsky, and Somik Raha for their support in writing this article.</p>

<h3 id="相关资源">相关资源</h3>

<ul>
<li><a href="http://www.mindview.net/Etc/Discussions/CheckedExceptions">&quot;Does Java need Checked Exceptions?&quot;</a> by Bruce Eckel</li>
<li><a href="http://www.octopull.demon.co.uk/java/ExceptionalJava.html">&quot;Exceptional Java,&quot;</a> by Alan Griffiths</li>
<li><a href="http://www.artima.com/intv/handcuffs.html">&quot;The trouble with checked exceptions: A conversation with Anders Hejlsberg, Part II&quot;</a> on Artima.com</li>
<li><a href="http://www.c2.com/cgi/wiki?CheckedExceptionsAreOfDubiousValue">&quot;Checked exceptions are of dubious value,&quot;</a> on C2.com</li>
<li><a href="http://www.artima.com/intv/solid.html">Conversation with James Gosling</a> by Bill Venners</li>
</ul>
]]></content>
  </entry>
  
</feed>
