<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: HTTP | 乐者为王]]></title>
  <link href="http://codemany.com/tags/http/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2016-05-13T09:49:50+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[如何避免点击链接下载文件时浏览器自动打开文件]]></title>
    <link href="http://codemany.com/blog/how-to-avoid-browser-open-the-file-automatically-when-click-link-to-download-file/"/>
    <updated>2012-06-03T07:26:02+08:00</updated>
    <id>http://codemany.com/blog/how-to-avoid-browser-open-the-file-automatically-when-click-link-to-download-file</id>
    <content type="html"><![CDATA[<p>HTTP Response Header有个Content-Disposition参数，该参数的目的是为了在客户端另存文件时提供一个建议的文件名。将它的值设置为attachment后，浏览器就会老老实实地显示另存为对话框，如果这个值设成inline，则无论怎样浏览器都会自动尝试用已知关联的程序打开文件。</p>

<p>注意：在Firefox中需要把filename用双引号包起来才能得到想要的文件名，不然如果含有空格就会丢掉空格后面的部分，而IE会把空格转为下划线。</p>

<p>Java设置header代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">res.addHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot; + res.encodeURL(filename));
</code></pre></div>
<p>Ruby设置header代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">headers[&#39;Content-Disposition&#39;] = &quot;attachment; filename=#{filename}&quot;
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何在Web应用的HTTP与HTTPS间的相互切换]]></title>
    <link href="http://codemany.com/blog/how-to-switch-between-http-and-https-in-web-application/"/>
    <updated>2008-03-27T16:26:53+08:00</updated>
    <id>http://codemany.com/blog/how-to-switch-between-http-and-https-in-web-application</id>
    <content type="html"><![CDATA[<p>对于HTTPS和HTTP的不同请求，Web容器会生成两个不同的session对象。因此，如果在同一个Web应用中只有部分页面使用SSL，要保证使用SSL的页面与不使用SSL的页面间的相互切换（也就是HTTPS请求与HTTP请求间的切换）会话保持连续，那么可以通过在访问的URL中传递sessionId来实现，也就是说在进入或退出HTTPS的URL上绑定一个sessionId。比如从HTTP切换到HTTPS时，URL为<code>https://example.com/login.do;jsessionid=&lt;%=session.getId()%&gt;</code>，从HTTPS切换到HTTP时为<code>http://example.com/welcome.do;jsessionid=&lt;%=session.getId()%&gt;</code>。这样Web容器会根据这个sessionId获取session对象，而不是生成新的session对象。就可以保证HTTP和HTTPS切换时会话不变。</p>

<p>由于在URL上绑定的sessionId容易被窃取，为了保证用户安全，会话认证时需要结合客户端IP地址。即当用户登录后，通过session.setAttribute(&quot;clientIp&quot;, request.getRemoteAddr())保存客户端的IP地址，在后继认证会话的合法性时判断客户端的IP是否是原先存储在session对象的clientIP属性的IP地址，如果不是则该会话是非法会话。</p>
]]></content>
  </entry>
  
</feed>
