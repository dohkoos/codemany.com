<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: DataWindow | 乐者为王]]></title>
  <link href="http://codemany.com/tags/datawindow/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2016-04-01T22:08:01+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[DataWindow的数据缓冲区]]></title>
    <link href="http://codemany.com/blog/datawindows-data-buffer/"/>
    <updated>2009-10-15T09:03:29+08:00</updated>
    <id>http://codemany.com/blog/datawindows-data-buffer</id>
    <content type="html"><![CDATA[<p>在PowerBuilder中，DataWindow是用来存储和操纵数据的对象。在每个DataWindow对象中都有4个二维表作为数据缓冲区来存储数据。用户在DataWindow中对数据的操作实际上都是将数据在这几个缓冲区中进行修改和移动，最后在用户提交数据库时，系统根据这四个缓冲区中的信息形成SQL的INSERT、UPDATE、DELETE等语句。这四个缓冲区是：</p>

<p>Primary Buffer</p>

<p>这个缓冲区是存放填充窗口中DataWindow控件的数据的，调用DataWindow控件的Retrieve()函数和InsertRow()函数可以将数据填入这个缓冲区中。当使用有关DataWindow删除和过滤函数时，相应记录将从这一缓冲区中删除。而在执行DataWindow的Update()函数时，PowerBuilder将查看这一缓冲区中的记录以形成INSERT和UPDATE语句。</p>

<p>Delete Buffer</p>

<p>这个缓冲区保存的是用DeleteRow()函数从Primary Buffer中删除的记录，执行Update()函数时，系统根据这一缓冲区的记录形成DELETE语句。</p>

<p>Filter Buffer</p>

<p>这个缓冲区存储的是从Original Buffer使用Filter()函数过滤到Primary Buffer中后剩余的记录。</p>

<p>Original Buffer</p>

<p>这一缓冲区存储的是DataWindow最初执行Retrieve()函数时得到的全部记录。当提交数据库时，根据Primary Buffer生成的UPDATE语句和根据Delete Buffer生成的DELETE语句都要依据这一缓冲区来构造这些SQL语句中的WHERE子句。</p>

<p>Original Buffer由PowerBuilder内部维护，PowerBuilder所提供的任何函数都无法改变它的值，不过通过PowerBuilder所提供的GetItem系列函数可以读出DataWindow最初从数据库中查到的原始值。通过这些函数我们可以编程实现所谓的Undo功能，并且得到在使用乐观锁时形成提交数据库的WHERE子句。如果你当前使用的DataWindow没有设置修改的权力，你将不能对Delete Buffer和Original Buffer进行操作，而且当调用Update()时也将引起系统错误。</p>

<p>Primary Buffer和Delete Buffer都有行级和列级的状态值，这个状态值是一个枚举类型。在提交时由该行的状态值来决定是否要产生SQL语句，其中Primary Buffer产生的是INSERT和UPDATE语句，而Delete Buffer产生的是DELETE语句。我们用GetItemStatus()函数和SetItemStatus()函数可以对这一状态值进行操纵。这一枚举状态有以下四种：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">NotModified! —— 指定单元的数据和原始数据相同，没有发生改变。
DataModified! —— 指定单元的数据和原始数据不同，发生了改变。
New! —— 该数据行是新增加的，但数据没有发生改变（数据为空或缺省值）。
NewModified! —— 该数据行是新增加的，且数据已发生改变（用户键盘输入或调用SetItem()函数）。
</code></pre></div>
<p>在上面的这四个值中，NotModifed!和DataModified!可以表示行和列的状态，而New!和NewModified!只可以表示行的状态。</p>

<p>让我们来看一个实例。有这样一张表，表中有3个字段，其中item是主键。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">item CHAR(5)
name CHAR(20)
quantity INT
</code></pre></div>
<p>在代码中我们查询这张表的记录，得到以下的这些信息，它们被存储在Primary Buffer和Origianal Buffer中。</p>

<p><img src="/uploads/dwbuffer-1.png" title="dwbuffer-1" ></p>

<p>在窗口中，我们过滤掉数量为0的行，并且加上一个空行：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">dw_1.SetFilter(&quot;quantity=0&quot;)
dw_1.Filter()
dw_1.InsertRow()
</code></pre></div>
<p>这时Primary Buffer的状态为：</p>

<p><img src="/uploads/dwbuffer-2.png" title="dwbuffer-2" ></p>

<p>在Filter Buffer中的记录为：</p>

<p><img src="/uploads/dwbuffer-3.png" title="dwbuffer-3" ></p>

<p>用户在新插入行中输入数据，删除了第3行数据，并修改了第2行数据。当他离开这个DataWindow时，Primary Buffer和Delete Buffer的状态如下：</p>

<p><img src="/uploads/dwbuffer-4.png" title="dwbuffer-4" ></p>

<p><img src="/uploads/dwbuffer-5.png" title="dwbuffer-5" ></p>

<p>这时执行dw_1.Update()函数，系统将基于这两个缓冲区生成SQL语句。</p>

<p><img src="/uploads/dwbuffer-6.png" title="dwbuffer-6" ></p>

<p>在Primary Buffer中，状态为NotModified!和New!的行将被忽略而不产生SQL语句。状态为DataModified!的行将产生UPDATE语句，状态为NewModified!的行将产生INSERT语句，在Delete Buffer中的行将产生DELETE语句。使用DataWindow的Reset()函数和Retrieve()函数以及改变DataObject属性时，系统将重置这几个缓冲区。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据窗口中高亮一行时出现的问题]]></title>
    <link href="http://codemany.com/blog/problem-highlight-a-row-on-datawindow/"/>
    <updated>2007-09-14T12:18:36+08:00</updated>
    <id>http://codemany.com/blog/problem-highlight-a-row-on-datawindow</id>
    <content type="html"><![CDATA[<p>高亮数据窗口中的一行很简单，只要在数据窗口控件的rowfocuschanged事件中添加下面的代码就可以了：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">long ll_row = this.GetRow()
if ll_row &gt; 0 then
    this.SelectRow(0, false)
    this.SelectRow(ll_row, true)
end if
</code></pre></div>
<p>不过这样处理后会有些问题，当你点击某一行时该行会显示成边框为深蓝色，背景为白色的矩形，如下图：</p>

<p><img src="/uploads/pb-highlight-1.png" title="pb-highlight-1" ></p>

<p>这是因为该行中列的样式类型是Edit，可以编辑，所以才会出现上图的效果。由此推断，只要将列设置为不可编辑就行。将一列设为不可编辑有三种方式：TabSequence为0、Edit.DisplayOnly被选中、Protect为1，设置其中任何一种都会使列变为不可编辑。</p>

<p>实践后发现选中Edit.DisplayOnly后还是会出现如上图那样的问题，而在设置TabSequence或Protect后则显示出了完美的高亮效果。</p>

<p><img src="/uploads/pb-highlight-2.png" title="pb-highlight-2" ></p>
]]></content>
  </entry>
  
</feed>
