<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Git | 乐者为王]]></title>
  <link href="http://codemany.com/tags/git/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2016-03-30T12:04:01+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Git笔记之rebase --onto]]></title>
    <link href="http://codemany.com/blog/git-notes-rebase-onto/"/>
    <updated>2014-10-26T13:41:19+08:00</updated>
    <id>http://codemany.com/blog/git-notes-rebase-onto</id>
    <content type="html"><![CDATA[<p>有的时候，可能需要修改某个已提交commit。如果是修改最近提交的commit，可以使用git commit --amend命令；如果是修改更早提交的commit，可以使用git rebase -i HEAD~n。不过这个命令有个缺陷，就是不能修改最早提交的那个commit。假设有如下提交历史：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">C1--C2--C3--C4
</code></pre></div>
<p>要修改C4可以使用git commit --amend；要修改C2、C3或C4可以使用git rebase -i HEAD~n；但是如果要修改C1呢？这就需要rebase --onto出场了。下面就来实例讲解如何使用rebase --onto命令。</p>

<p>因为要修改C1这个commit，所以先在它之上创建临时分支tb：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">git checkout -b tb C1
</code></pre></div>
<p>然后就可以在tb分支上做想要的修改，改完之后用下面的命令提交更改的内容：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">git commit -a --amend
</code></pre></div>
<p>这时查看tb分支的提交历史，可以发现SHA1值已经发生了变化（master分支的SHA1值仍然不变）：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">C1&#39;
</code></pre></div>
<p>接着可以把修改后的内容和master分支合并：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">git rebase --onto tb C1 master
</code></pre></div>
<p>表示把master分支上从C1之后的所有commit重新apply到tb分支最新的commit之后。</p>

<p>这里有两点要注意：一个是C1处的开闭问题，rebase --onto的机制是左开右闭，也就是说上述命令只会apply三个提交C2、C3和C4；第二个是rebase --onto之后tb分支的提交历史没有改变，还是只有一个提交C1’，当前分支也切换到了master，并且所有commit的SHA1值都发生了改变。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">C1&#39;--C2&#39;--C3&#39;--C4&#39;
</code></pre></div>
<p>最后就是正常的rebase --continue流程了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git笔记之branch，merge和rebase]]></title>
    <link href="http://codemany.com/blog/git-notes-branch-merge-and-rebase/"/>
    <updated>2011-08-05T21:05:02+08:00</updated>
    <id>http://codemany.com/blog/git-notes-branch-merge-and-rebase</id>
    <content type="html"><![CDATA[<div class="highlight"><pre><code class="language-text" data-lang="text">git branch  # 列出所有分支以及当前在哪个分支上
git branch &lt;branch&gt;  # 建立分支
git branch -m &lt;oldbranch&gt; &lt;newbranch&gt;  # 修改分支的名字
git checkout &lt;branch&gt;  # 切换分支
git checkout -b &lt;branch&gt; &lt;commit&gt;  # 新建分支并切换过去
git branch -d &lt;branch&gt;  # 刪除分支
git merge &lt;branch&gt;  # 合并分支到当前分支上
git rebase &lt;branch&gt;  # 将提交迁移到上游分支
</code></pre></div>
<p>在merge/rebase的过程中，也许会出现冲突。在这种情况，Git会停止merge/rebase并让你去解决冲突，冲突内容以如下形式存在：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
Here is the original change.
=======
Here is the modified chagne.
&gt;&gt;&gt;&gt;&gt;&gt;&gt;
</code></pre></div>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt;下面的是当前版本的内容；=======和&gt;&gt;&gt;&gt;&gt;&gt;&gt;之间的则是分支里与之对应的有冲突的内容。修复冲突要做的就是把&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD和&gt;&gt;&gt;&gt;&gt;&gt;&gt;之间的内容改成我们想要的。在解决完冲突后，用git add命令去更新这些内容，如果是rebase，那么你无需执行git commit，只要执行git rebase --continue命令即可，这样Git会继续apply余下的补丁。</p>

<p>rebase的做法是先将HEAD指向目标分支的最新commit，这时HEAD的内容变为目标分支最新commit的SHA1值，然后将当前分支的commit，一个个重新apply到目标分支上，完成后再将HEAD指向新的commit。例如，当前分支是master，然后执行git rebase dev，就会把两个分支的共同祖先的commit之后的所有master的commit记录，重新在dev分支上再commit一遍。</p>

<p><img src="/uploads/git-rebase.png" title="git-rebase" ></p>

<p>fast-forward在Git中是一种merge术语，当dev分支是从master分支的最新commit分出来的时候，那么如果master要把dev分支merge进来，由于dev的parent commit是master的最新commit，所以这两个分支的合并不会有任何冲突，实际上的动作只是把master的HEAD指向dev的最新commit而已。线图上来看两个分支根本是同一条线。</p>

<p><img src="/uploads/git-merge-ff.png" title="git-merge-ff" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git笔记之tag]]></title>
    <link href="http://codemany.com/blog/git-notes-tag/"/>
    <updated>2009-03-29T09:25:20+08:00</updated>
    <id>http://codemany.com/blog/git-notes-tag</id>
    <content type="html"><![CDATA[<p>git tag的主要作用是给某个commit起一个好记的名字。这里列举了一些常用的tag命令：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">git tag  # 显示所有标签
git tag v1.1.0  # 轻量级标签
git tag -a v1.1.0 -m &quot;Release v1.1.0&quot;  # 带注释的标签
git tag -d v1.1.0  # 删除特定标签
</code></pre></div>
<p>如果想给某个commit添加标签，可以使用如下命令：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">git tag -a v1.1.0 &lt;commit&gt;
</code></pre></div>
<p>查看指定tag的信息可以用：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">git show v1.1.0
</code></pre></div>
<p>要筛选同类标签的话，可以使用：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">git tag -l &#39;v1.1.*&#39;
</code></pre></div>
<p>它会列出前缀为v1.1.的所有标签。</p>

<p>有了标签要在团队之间分享怎么办？可以使用下面的命令把标签推送到远程仓库中：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">git push origin v1.1.0  # 推送指定标签
git push origin --tags  # 推送所有标签
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git笔记之status]]></title>
    <link href="http://codemany.com/blog/git-notes-status/"/>
    <updated>2009-03-13T11:56:53+08:00</updated>
    <id>http://codemany.com/blog/git-notes-status</id>
    <content type="html"><![CDATA[<p>git status命令会显示当前项目状态的一个简单总结：</p>

<ul>
<li>当Git提示说“Untracked files”表示新增加的文件还没有被纳入到Git版本控制系统的追踪；</li>
<li>如果提示说“Changed but not updated”表示在工作目录下做的修改还没有被添加到索引文件中；</li>
<li>如果你看到提示说“Changes to be committed”则表示发现了你已经添加到索引文件里，但尚未提交的内容。</li>
</ul>

<p>当然你也有可能喜欢短小的输出提示，那么可以使用-s选项：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">git status -s
</code></pre></div>
<ul>
<li>它会用??表示“Untracked files”的文件；</li>
<li>用红色的M表示“Changed but not updated”的文件；</li>
<li>用绿色的M表示“Changes to be committed”；</li>
<li>用绿色的A表示新增加但“Changes to be committed”的文件。</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git笔记之diff]]></title>
    <link href="http://codemany.com/blog/git-notes-diff/"/>
    <updated>2009-03-09T21:33:41+08:00</updated>
    <id>http://codemany.com/blog/git-notes-diff</id>
    <content type="html"><![CDATA[<p>今天，我们重点来探讨一下git diff的用法。</p>

<p>我们知道在Git提交环节存在三大部分：工作目录、索引文件、仓库。每当你对代码进行了修改，工作目录的状态就发生了改变。索引文件是连接工作目录和仓库的桥梁，每次当我们使用git add命令后，索引文件的内容就改变了，变得和工作目录同步。仓库是提交环节的最后阶段，只有在我们使用git commit命令将索引文件中的内容提交后，我们的代码才真正地进入了仓库。</p>

<p>git diff就是用来比较提交环节三大部分的差别。其中，纯粹的git diff是查看工作目录与索引文件之间的差别；git diff –cached是查看索引文件和仓库之间的差别；git diff HEAD则是查看工作目录和仓库之间的差别。</p>

<p>下图是三种查看方式的说明：</p>

<p><img src="/uploads/git-diff.png" title="git-diff" ></p>

<p>git diff会输出全部的差别内容，但有时我们只想看看修改的内容的汇总，这时就可以使用--stat选项。这里是它的使用实例：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">git diff --stat
git diff --cached --stat
git diff HEAD --stat
</code></pre></div>
<p>如果你想查看其它分支与当前分支的差别，只要运行以下命令即可：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">git diff &lt;otherbranch&gt;
</code></pre></div>
<p>你也可以加上路径限定符，来比较某一个文件或目录：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">git diff &lt;otherbranch&gt; &lt;filename&gt;
</code></pre></div>]]></content>
  </entry>
  
</feed>
