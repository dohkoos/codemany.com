<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Git | 乐者为王]]></title>
  <link href="http://codemany.com/tags/git/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2014-10-21T18:18:40+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Git笔记之branch，merge和rebase]]></title>
    <link href="http://codemany.com/blog/git-notes-branch-merge-and-rebase/"/>
    <updated>2011-08-05T21:05:02+08:00</updated>
    <id>http://codemany.com/blog/git-notes-branch-merge-and-rebase</id>
    <content type="html"><![CDATA[<p><code>
git branch &lt;branch_name&gt;  # 建立branch
git branch -m &lt;old_branch_name&gt; &lt;new_branch_name&gt;  # 修改branch名字
git branch  # 列出所有branch以及当前在哪个branch
git checkout &lt;branch_name&gt;  # 切换branch
git checkout -b &lt;branch_name&gt;  # 新建branch并切换过去
git branch -d &lt;branch_name&gt;  # 刪除branch
git merge &lt;branch_name&gt;  # 合并分支到当前分支上
git rebase &lt;branch_name&gt;  # 将以往的变更迁移到最新的上游版本库的状态中
</code></p>

<p>在merge/rebase的过程中，也许会出现冲突（conflict）。在这种情况，Git会停止merge/rebase并让你去解决冲突，冲突内容以下列形式存在：</p>

<p>```
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p>

<h1>Here is the original change.</h1>

<p>Here is the modified chagne.</p>

<blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>```</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote>

<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD下面的是当前版本里的内容；=======和>>>>>>>之间的则表示分支里与之对应的有冲突的内容。修复冲突要做的就是把&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD和>>>>>>>之间的改成我们想要的内容。在解决完冲突后，用git add命令去更新这些内容的索引（index），如果是rebase，那么你无需执行git commit，只要执行git rebase --continue命令，这样Git会继续应用（apply）余下的补丁。</p>

<p>rebase是将目前branch的commits，一个个重新apply（或者叫patch）到要被rebase的branch上。例如，当前branch是A，然后执行git rebase B，就会把原本分支点之后所有A的commits记录，重新在B分支上再commit一遍，这时新分支点变成B分支的最新的commit。</p>

<p>fast-forward在Git中是一种merge术语，当B分支是从A分支的最新版（HEAD）分出来的，那么当A要把B merge进来时，因为B的parent commit是A的HEAD，所以这两个分支唯一的差异就是B后来的commit而已，而不会有任何conflict。所以实际上的动作只是把A的HEAD改成B的HEAD而已，线图上来看两个分支根本是同一条线。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git笔记之项目创建]]></title>
    <link href="http://codemany.com/blog/git-notes-create-project/"/>
    <updated>2009-01-04T13:42:54+08:00</updated>
    <id>http://codemany.com/blog/git-notes-create-project</id>
    <content type="html"><![CDATA[<p>Git的官网地址：<a href="http://git.or.cz/">http://git.or.cz/</a></p>

<p>官网的学习路线推介：新手请浏览<a href="http://www.kernel.org/pub/software/scm/git/docs/gittutorial.html">gittutorial(7)</a>，然后是<a href="http://www.kernel.org/pub/software/scm/git/docs/everyday.html">Everyday Git（包括了常用命令）</a>，接着是“man git-commandname”，CVS用户需要看<a href="http://www.kernel.org/pub/software/scm/git/docs/gitcvs-migration.html">gitcvs-migration(7)</a>，需要更全面的了解Git请看<a href="http://www.kernel.org/pub/software/scm/git/docs/user-manual.html">Git User's Manual</a>。</p>

<p>1、创建一个版本库</p>

<p><code>
mkdir gittest
cd gittest
git init  # 初始化当前所在目录的这个项目
</code></p>

<p>2、告诉项目你的信息</p>

<p><code>
git config user.name "yourname"
git config user.email yourname@example.com
</code></p>

<p>注意，这样会在当前repository目录下的.git/config中写入配置信息。如果加了<code>--global</code>选项，那么配置信息就会写入到~/.gitconfig文件中。</p>

<p>3、植入内容跟踪信息</p>

<p><code>
echo "This is a test!" &gt; test.txt
git add test.txt  # 用git add命令将文件加入到版本库文件索引中
</code></p>

<p>git add实际上是个脚本命令，它是对Git内核命令git-update-index的调用。git-update-index只是刷新了Git的跟踪信息，并不会将test.txt这个文件中的内容提交到Git的版本库中。你也可以使用git add .来将当前目录下的所有内容加入到版本库文件索引中。git rm则是在版本库文件索引中标记指定文件为删除，并删除存在的对应文件。</p>

<p>4、查看版本库的状态</p>

<p><code>
git status
</code></p>

<p>5、提交内容到版本库</p>

<p><code>
git commit  # 将文件索引中登记的内容永久写入Git版本库中
</code></p>

<p>在输入git commit并按回车后会转到一个vi窗口，要求开发者输入这次提交的版本和开发信息。我们可以通过修改环境变量GIT_EDITOR来修改commit时用来编辑信息的编辑器。还有要注意的是必须要先add或rm后再commit。</p>

<p>git commit的参数：</p>

<ul>
<li>-s 在变更日志注释末尾添加提交者的Signed-off-by行。</li>
<li>-m 使用给定的信息作为变更注释。没有该参数会自动打开一个使用GIT_EDITOR指定的文本编辑器来输入注释。</li>
<li>-a 自动检测所有修改过或删除的文件，并将它们添到版本库文件索引中（新建但没有git-add的文件不会被影响）。</li>
</ul>


<p>6、查看项目历史</p>

<p><code>
git log
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在EGit-0.3.1中使用Compare With Git Revision]]></title>
    <link href="http://codemany.com/blog/using-compare-with-git-revision-in-egit-031/"/>
    <updated>2008-08-28T17:51:20+08:00</updated>
    <id>http://codemany.com/blog/using-compare-with-git-revision-in-egit-031</id>
    <content type="html"><![CDATA[<p>EGit是一个Eclipse环境下的Git客户端插件，EGit的0.3.1版本已经提供了Compare With Revision功能，只是还没有注册到plugin.xml中。所以要使用该功能的话，必须自己动手在ui包中的plugin.xml中添加一些代码，即下面的action部分：</p>

<p>```
&lt;objectContribution</p>

<pre><code>    adaptable="true"
    id="org.spearce.egit.ui.fileFolderContributions"
    objectClass="org.eclipse.core.resources.IResource"&gt;
&lt;filter name="projectPersistentProperty"
    value="org.eclipse.team.core.repository=org.spearce.egit.core.GitProvider"&gt;
&lt;/filter&gt;
&lt;action
    class="org.spearce.egit.ui.internal.actions.CompareWithRevisionAction"
    id="org.spearce.egit.ui.internal.actions.CompareWithRevisionAction"
    label="%CompareWithRevisionAction_label"
    menubarPath="compareWithMenu/compareWithGroup"
    overrideActionId="org.eclipse.team.ui.compareLocalHistory"
    tooltip="%CompareWithRevisionAction_tooltip" /&gt;
</code></pre>

<p></objectContribution>
```</p>

<p>另外，还要将CompareWithRevisionAction.java中run方法里的super.action(action)注释掉，否则会报StackOverflow异常。</p>

<p>```
public void run(IAction action) {</p>

<pre><code>// super.action(action);
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
