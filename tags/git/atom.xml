<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Git | 乐者为王]]></title>
  <link href="http://codemany.com/tags/git/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2016-02-07T17:44:15+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Git笔记之rebase --onto]]></title>
    <link href="http://codemany.com/blog/git-notes-rebase-onto/"/>
    <updated>2014-10-26T13:41:19+08:00</updated>
    <id>http://codemany.com/blog/git-notes-rebase-onto</id>
    <content type="html"><![CDATA[<p>有的时候，可能需要修改某个已提交commit。如果是修改最近提交的commit，可以使用git commit --amend命令；如果是修改更早提交的commit，可以使用git rebase -i HEAD~n。不过这个命令有个缺陷，就是不能修改最早提交的那个commit。假设有如下提交历史：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">C1--C2--C3--C4
</code></pre></div>
<p>要修改C4可以使用git commit --amend；要修改C2、C3或C4可以使用git rebase -i HEAD~n；但是如果要修改C1呢？这就需要rebase --onto出场了。下面就来实例讲解如何使用rebase --onto命令。</p>

<p>因为要修改C1这个commit，所以先在它之上创建临时分支tb：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">git checkout -b tb C1
</code></pre></div>
<p>然后就可以在tb分支上做想要的修改，改完之后用下面的命令提交更改的内容：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">git commit -a --amend
</code></pre></div>
<p>这时查看tb分支的提交历史，可以发现SHA1值已经发生了变化（master分支的SHA1值仍然不变）：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">C1&#39;
</code></pre></div>
<p>接着可以把修改后的内容和master分支合并：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">git rebase --onto tb C1 master
</code></pre></div>
<p>表示把master分支上从C1之后的所有commit重新apply到tb分支最新的commit之后。</p>

<p>这里有两点要注意：一个是C1处的开闭问题，rebase --onto的机制是左开右闭，也就是说上述命令只会apply三个提交C2、C3和C4；第二个是rebase --onto之后tb分支的提交历史没有改变，还是只有一个提交C1’，当前分支也切换到了master，并且所有commit的SHA1值都发生了改变。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">C1&#39;--C2&#39;--C3&#39;--C4&#39;
</code></pre></div>
<p>最后就是正常的rebase --continue流程了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git笔记之branch，merge和rebase]]></title>
    <link href="http://codemany.com/blog/git-notes-branch-merge-and-rebase/"/>
    <updated>2011-08-05T21:05:02+08:00</updated>
    <id>http://codemany.com/blog/git-notes-branch-merge-and-rebase</id>
    <content type="html"><![CDATA[<div class="highlight"><pre><code class="language-text" data-lang="text">git branch  # 列出所有分支以及当前在哪个分支上
git branch &lt;branch&gt;  # 建立分支
git branch -m &lt;oldbranch&gt; &lt;newbranch&gt;  # 修改分支的名字
git checkout &lt;branch&gt;  # 切换分支
git checkout -b &lt;branch&gt; &lt;commit&gt;  # 新建分支并切换过去
git branch -d &lt;branch&gt;  # 刪除分支
git merge &lt;branch&gt;  # 合并分支到当前分支上
git rebase &lt;branch&gt;  # 将提交迁移到上游分支
</code></pre></div>
<p>在merge/rebase的过程中，也许会出现冲突。在这种情况，Git会停止merge/rebase并让你去解决冲突，冲突内容以如下形式存在：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
Here is the original change.
=======
Here is the modified chagne.
&gt;&gt;&gt;&gt;&gt;&gt;&gt;
</code></pre></div>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt;下面的是当前版本的内容；=======和&gt;&gt;&gt;&gt;&gt;&gt;&gt;之间的则是分支里与之对应的有冲突的内容。修复冲突要做的就是把&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD和&gt;&gt;&gt;&gt;&gt;&gt;&gt;之间的内容改成我们想要的。在解决完冲突后，用git add命令去更新这些内容，如果是rebase，那么你无需执行git commit，只要执行git rebase --continue命令即可，这样Git会继续apply余下的补丁。</p>

<p>rebase的做法是先将HEAD指向目标分支的最新commit，这时HEAD的内容变为目标分支最新commit的SHA1值，然后将当前分支的commit，一个个重新apply到目标分支上，完成后再将HEAD指向新的commit。例如，当前分支是master，然后执行git rebase dev，就会把两个分支的共同祖先的commit之后的所有master的commit记录，重新在dev分支上再commit一遍。</p>

<p><img src="/uploads/git-rebase.png" title="git-rebase" ></p>

<p>fast-forward在Git中是一种merge术语，当dev分支是从master分支的最新commit分出来的时候，那么如果master要把dev分支merge进来，由于dev的parent commit是master的最新commit，所以这两个分支的合并不会有任何冲突，实际上的动作只是把master的HEAD指向dev的最新commit而已。线图上来看两个分支根本是同一条线。</p>

<p><img src="/uploads/git-merge-ff.png" title="git-merge-ff" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git笔记之stash]]></title>
    <link href="http://codemany.com/blog/git-notes-stash/"/>
    <updated>2009-02-07T09:41:32+08:00</updated>
    <id>http://codemany.com/blog/git-notes-stash</id>
    <content type="html"><![CDATA[<p>在工作中，经常会碰到在修改代码以支持新功能时，发现线上版本出现问题需要在本地查错。因为还在进行中，所以并不想将半成品的代码提交，后面再来修改。这样就需要临时保存修改的文件，然后取出线上版本到工作目录。这个问题的解决之道就是使用git stash命令，它会暂存你的当前工作，这样以后随时可以再来修改：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">git stash
</code></pre></div>
<p>现在，工作目录变得干净，可以安全地做些别的事情了。</p>

<p>要查看暂存的修改可以使用以下命令：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">git stash list
</code></pre></div>
<p>稍后，在排除掉线上版本的错误后，你就可以取回所有暂存的修改：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">git stash pop
</code></pre></div>
<p>现在让我们在脑中想象一个场景：在排除线上版本错误后，没有立即取回暂存的修改，而是做了其它的一些的变更，然后想把暂存的修改并入进来以完成工作。如果两次修改的代码没有冲突，那么事情完美结束；如果后修改的代码和暂存的修改有冲突，那么就会得到Merge conflict的警告。Git没有提供强制pop的功能，所以我们需要一些技巧来解决：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">git stash show -p | git apply &amp;&amp; git stash drop
</code></pre></div>
<p>git stash的其它一些可用选项如下所示：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">git stash pop --index        # 不仅恢复工作目录，还恢复索引
git stash save &quot;stash name&quot;  # 使用save可以给暂存的修改添加名字
git stash save --keep-index  # 仅仅暂存未索引的文件
git stash clear              # 删除所有暂存的修改
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git笔记之gitignore]]></title>
    <link href="http://codemany.com/blog/git-notes-gitignore/"/>
    <updated>2009-01-25T18:53:36+08:00</updated>
    <id>http://codemany.com/blog/git-notes-gitignore</id>
    <content type="html"><![CDATA[<p>通常我们会有些文件不希望纳入Git的管理，也不希望它们总是出现在未跟踪文件列表中。这些文件大多是些自动生成的文件，譬如编译过程中生成的临时文件，或者一些本地的配置文件。为解决此类问题，Git提供了文件忽略机制，我们可以创建一个名为.gitignore的文件，在其中列出需要忽略的文件模式。文件.gitignore的格式规范如下：</p>

<ul>
<li>所有空行或者以#开头的行都会被忽略；</li>
<li>可以使用标准的glob模式匹配；</li>
<li>匹配模式可以以“/”开头防止递归；</li>
<li>匹配模式可以以“/”结尾指定目录；</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上“!”取反。</li>
</ul>

<p>上面所谓的glob模式是指简化了的正则表达式：<code>“*”</code>匹配零个或多个任意字符；“[abc]”匹配任何一个列在方括号中的字符；“?”匹配一个任意字符；“[a-z]”匹配所有在这两个字符范围内的字符。<code>“**”</code>匹配任意中间目录，比如<code>a/**/z</code>可以匹配a/z，a/b/z或a/b/c/z等。</p>

<p>要养成一开始就设置好.gitignore文件的习惯，避免将来误提交一些无用的文件。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git笔记之reset]]></title>
    <link href="http://codemany.com/blog/git-notes-reset/"/>
    <updated>2009-01-14T21:48:24+08:00</updated>
    <id>http://codemany.com/blog/git-notes-reset</id>
    <content type="html"><![CDATA[<p>git reset的作用是重置当前HEAD到指定状态，它有三个选项：<code>--soft</code>、<code>--mixed</code>和<code>--hard</code>。</p>

<ul>
<li><code>--soft</code>选项既不重置索引内容，也不改变工作目录中的任何内容，它仅仅是重置当前HEAD到指定commit。使用<code>--soft</code>后，git diff的返回信息不变，而git diff --cached和git diff HEAD的返回信息有变化。</li>
<li><code>--mixed</code>是git reset的默认选项，它的作用是重置索引内容，将其定位到指定的commit，但不改变工作目录中的任何内容。使用<code>--mixed</code>后，git diff和git diff HEAD的返回信息有变化，而git diff --cached的返回信息不变。</li>
<li><code>--hard</code>选项会重置索引内容，将其定位到指定的commit，并且会将工作目录中的内容也会完全回退到指定commit之时的状态。所以使用<code>--hard</code>后git diff，git diff --cached和git diff HEAD的返回信息都为空。不过由于这个选项杀伤力太大，需要谨慎使用。</li>
</ul>

<p>以下是根据三个选项的特性制作的表格，x表示</p>

<table><thead>
<tr>
<th></th>
<th style="text-align: center">是否重置索引</th>
<th style="text-align: center">是否重置工作目录</th>
</tr>
</thead><tbody>
<tr>
<td>--soft</td>
<td style="text-align: center">N</td>
<td style="text-align: center">N</td>
</tr>
<tr>
<td>--mixed</td>
<td style="text-align: center">Y</td>
<td style="text-align: center">N</td>
</tr>
<tr>
<td>--hard</td>
<td style="text-align: center">Y</td>
<td style="text-align: center">Y</td>
</tr>
</tbody></table>

<p>有时候你可能刚刚把一个文件添加到暂存区里，但是你突然发现这是错误的，你可能想从暂存区中删除该文件，这是你可以使用以下这个命令：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">git reset -- &lt;paths&gt;
</code></pre></div>
<p>它仅从索引中移除文件，但不会触及工作目录。</p>
]]></content>
  </entry>
  
</feed>
