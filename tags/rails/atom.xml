<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Rails | 乐者为王]]></title>
  <link href="http://codemany.com/tags/rails/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2017-01-04T20:37:25+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby调试工具概览]]></title>
    <link href="http://codemany.com/blog/ruby-debugger-overview/"/>
    <updated>2015-10-19T10:50:09+08:00</updated>
    <id>http://codemany.com/blog/ruby-debugger-overview</id>
    <content type="html"><![CDATA[<p>调试Ruby代码最简单的方式就是使用puts或p方法。当有很多变量需要查看时，到处添加puts或p方法就可能变的不那么实际。幸好，Ruby社区提供了许多强大的调试工具。</p>

<h3 id="ruby-1-8-时代">Ruby 1.8+时代</h3>

<p>调试Ruby代码使用<a href="https://github.com/ruby-debug/ruby-debug">ruby-debug</a>。调试Rails代码则是<a href="https://github.com/nixme/pry-nav">pry-nav</a>。不过在Ruby 1.9出来后ruby-debug就有问题了，于是就有了<a href="https://github.com/mark-moseley/ruby-debug">ruby-debug19</a>，一个针对Ruby 1.9的ruby-debug移植版本。</p>

<h3 id="ruby-1-9-2-时代">Ruby 1.9.2+时代</h3>

<p>等到Ruby 1.9.2发布，ruby-debug彻底歇菜，然后<a href="https://github.com/cldwalker/debugger">debugger</a>就出现了。pry-nav也不好使了，还好有<a href="https://github.com/nixme/pry-debugger">pry-debugger</a>。</p>

<h3 id="ruby-2-时代">Ruby 2+时代</h3>

<p>新的Ruby调试工具<a href="https://github.com/deivid-rodriguez/byebug">byebug</a>来了。虽然byebug也能调试Rails应用，但它不提供语法高亮，所以使用<a href="https://github.com/deivid-rodriguez/pry-byebug">pry-byebug</a>是个更好的选择。</p>

<table><thead>
<tr>
<th></th>
<th>Ruby 1.8+</th>
<th>Ruby 1.9</th>
<th>Ruby 1.9.2+</th>
<th>Ruby 2+</th>
</tr>
</thead><tbody>
<tr>
<td>Ruby</td>
<td>ruby-debug</td>
<td>ruby-debug19</td>
<td>debugger</td>
<td>byebug</td>
</tr>
<tr>
<td>Rails</td>
<td>pry-nav</td>
<td>pry-nav</td>
<td>pry-debugger</td>
<td>pry-byebug</td>
</tr>
</tbody></table>

<h3 id="其它">其它</h3>

<p><a href="https://github.com/pry/pry">Pry</a>其实不是纯粹的调试工具，它只是IRB的替代品，所以缺乏必要的调试指令。pry-nav、pry-debugger和pry-byebug做的只是分别把ruby-debug、debugger和byebug中的step、next、continue等指令添加到Pry中。</p>

<ul>
<li>pry-nav = Pry + ruby-debug</li>
<li>pry-debugger = Pry + debugger</li>
<li>pry-byebug = Pry + byebug</li>
</ul>

<p>如果要调试view怎么办？可以使用<a href="https://github.com/rails/web-console">Web Console</a>。在view里面加上&lt;%= console %&gt;，当view出现异常时，就会在异常界面下方，出现一个网页版的IRB，方便调试。Web Console默认只接受localhost的请求，假如需要让别的IP也能访问的话，可以这样做：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class Application &lt; Rails::Application
  config.web_console.whitelisted_ips = &#39;192.168.0.100&#39;
end
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重构Rails代码]]></title>
    <link href="http://codemany.com/blog/refactoring-rails-code/"/>
    <updated>2014-11-18T19:42:59+08:00</updated>
    <id>http://codemany.com/blog/refactoring-rails-code</id>
    <content type="html"><![CDATA[<p>在以前写的博文<a href="http://codemany.com/blog/problem-when-deploying-application-to-heroku/">部署应用到Heroku时的问题</a>里有这么一段话：</p>

<blockquote>
<p>股票功能需要导入交割单文件，因为导入后的文本文件不再使用，可以把上传路径由public/uploads改为tmp，这样就避免了Heroku不能写文件的问题。</p>
</blockquote>

<p>下面是那时候写的导入代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class StocksController &lt; ApplicationController
  UPLOADS_DIRECTORY = File.join(&quot;#{Rails.root}&quot;, &quot;public/uploads&quot;)

  def import
    filename = upload_file(params[:file])
    lines = File.readlines(&quot;#{UPLOADS_DIRECTORY}/#{filename}&quot;)
    lines.each do |line|
      # do something
    end
    redirect_to stocks_url
  end

  protected
    def upload_file(file)
      if !file.original_filename.empty?
        @filename = get_file_name(file.original_filename)
        Dir.mkdir(&quot;#{UPLOADS_DIRECTORY}&quot;) unless Dir.exist?(&quot;#{UPLOADS_DIRECTORY}&quot;)
        File.open(&quot;#{UPLOADS_DIRECTORY}/#{@filename}&quot;, &quot;wb&quot;) do |f|
          f.write(file.read)
        end
        return @filename
      end
    end

    def get_file_name(filename)
      if !filename.nil?
        # does not support chinese filename?
        Time.now.strftime(&quot;%Y%m%d%H%M%S&quot;) + &#39;.txt&#39;
      end
    end
end
</code></pre></div>
<p>这里的实现方法是先将上传文件保存到服务器上应用的public/uploads目录中，然后再读取和处理。</p>

<p>其实根本不需要写的这么复杂，因为导入的文件被读取一次后就不再使用了。所以在当时写代码的时候一直有这样的想法，如果能直接获得上传文件的数据，那么就不需要再另外去写保存和读取文件的代码了。</p>

<p>事实也是如此。通过表单提交的file数据会首先在服务器上形成临时文件，这时其实可以通过临时文件的路径来读取上传文件的数据。</p>

<p>根据该想法重构后的代码如下：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class StocksController &lt; ApplicationController
  def import
    lines = File.readlines(params[:file].tempfile.to_path.to_s)
    lines.each do |line|
      # do something
    end
    redirect_to stocks_url
  end
</code></pre></div>
<p>重构后的代码果然清爽多了，不过还是有改进的空间。</p>

<p>作为控制器，controller只是负责接收request，并返回response。而具体的业务逻辑，则应该交由model去完成。下面是依照该理念再次重构后的代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class StocksController &lt; ApplicationController
  def import
    Stock.import(params[:file])
    redirect_to stocks_url
  end
end

class Stock &lt; ActiveRecord::Base
  def self.import(file)
    lines = File.readlines(file.tempfile.to_path.to_s)
    lines.each do |line|
      # do something
    end
  end
end
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[打错multipart引发的血案]]></title>
    <link href="http://codemany.com/blog/multipart-misspelling-cause-bug/"/>
    <updated>2014-11-13T09:27:17+08:00</updated>
    <id>http://codemany.com/blog/multipart-misspelling-cause-bug</id>
    <content type="html"><![CDATA[<p>浪费几个小时，杀死无数脑细胞，最终发现是单词打错了。不过错有错招，这个问题也让我重新温习了一遍关于form数据编码的知识。</p>

<p>在做上传表单时，一直报告如下错误：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">undefined method &#39;original_filename&#39; for &quot;example.csv&quot;:String
</code></pre></div>
<p>在 <a href="http://guides.rubyonrails.org/form_helpers.html#what-gets-uploaded">http://guides.rubyonrails.org/form_helpers.html#what-gets-uploaded</a> 有这样一段文字：</p>

<blockquote>
<p>The object in the params hash is an instance of a subclass of IO. Depending on the size of the uploaded file it may in fact be a StringIO or an instance of File backed by a temporary file. In both cases the object will have an original_filename attribute containing the name the file had on the user&#39;s computer and a content_type attribute containing the MIME type of the uploaded file.</p>
</blockquote>

<p>说明example.csv应该是IO类型的，这里怎么显示是String呢？</p>

<p>表单代码为</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&lt;%= form_tag import_stocks_path, mutlipart: true do %&gt;
</code></pre></div>
<p>或</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&lt;%= form_tag import_stocks_path, method: :post, mutlipart: true do %&gt;
</code></pre></div>
<p>生成后的HTML代码都是：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&lt;form action=&quot;/stocks/import&quot; method=&quot;post&quot; mutlipart=&quot;true&quot;&gt;
</code></pre></div>
<p>正确的HTML代码应该是：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&lt;form action=&quot;/stocks/import&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
</code></pre></div>
<p>使用HttpFox工具抓取表单提交信息如下：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">POST /stocks/import HTTP/1.1
Host localhost:3000
Referer http://localhost:3000/stocks/import
Connection keep-alive
Content-Type application/x-www-form-urlencoded
Content-Length 112
</code></pre></div>
<p>什么是application/x-www-form-urlencoded？含有file类型字段的表单编码不应该是multipart/form-data吗。</p>

<p>form的enctype属性通常有两种：application/x-www-form-urlencoded和multipart/form-data，默认为前者。当method=get时，浏览器用application/x-www-form-urlencoded编码方式把form数据转换成一个字串（name1=value1&amp;name2=value2...），然后把这个字串附加到url后面，用?分割。当method=post的时候，浏览器把form数据封装到post-body中。如果没有type=file的控件，就用默认的application/x-www-form-urlencoded编码。但是如果有type=file的话，就要用到multipart/form-data了。浏览器会把整个表单以控件为单位分割，并为每个部分加上Content-Disposition（form-data或者file），Content-Type（默认为text/plain），name等信息，并加上分割边界（boundary）。</p>

<p>这时才发现原来是把multipart打错成mutlipart了，真是惨痛的教训啊！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Pry调试Rails应用]]></title>
    <link href="http://codemany.com/blog/debugging-rails-application-with-pry/"/>
    <updated>2014-07-07T23:26:08+08:00</updated>
    <id>http://codemany.com/blog/debugging-rails-application-with-pry</id>
    <content type="html"><![CDATA[<p>调试Rails程序有更好的工具了，这就是<a href="https://github.com/pry/pry">Pry</a>，它是一套全新的IRB替代方案，最闪亮点是它的语法高亮功能。</p>

<p>首先，在Gemfile中添加以下代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">gem &#39;pry&#39;, group: :development
</code></pre></div>
<p>然后执行</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">bundle install
</code></pre></div>
<p>在需要设置断点的地方添加binding.pry，当程序运行到这行代码时会打开一个窗口，可以在这里操作当前代码的上下文变量。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">def index
  @articles = Article.all
  binding.pry
end
</code></pre></div>
<p>退出调试用exit-all，但如果在循环中会遭遇失败，这时可以使用exit-program无条件地退出。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(1..100).each do |i|
  binding.pry
  puts i
end
</code></pre></div>
<p>Pry默认是没有调试中经常用到的上一步，下一步等命令的，可以安装<a href="https://github.com/nixme/pry-nav">pry-nav</a>，然后就可以使用step, next, continue跳来跳去了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[部署应用到Heroku时的问题]]></title>
    <link href="http://codemany.com/blog/problem-when-deploying-application-to-heroku/"/>
    <updated>2013-05-21T06:25:33+08:00</updated>
    <id>http://codemany.com/blog/problem-when-deploying-application-to-heroku</id>
    <content type="html"><![CDATA[<p>Heroku现在已经是纯粹的只读PaaS了，也就是说以前还支持的SQlite现在也不能使用了。因此部署到Heroku上的Rails应用需要把使用的数据库改成PostgreSQL，并且要关闭assets的预编译功能。</p>

<p>修改Gemfile，将SQLite换成PostgreSQL：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"># gem &#39;sqlite3&#39;
gem &#39;pg&#39;
</code></pre></div>
<p>在config/application.rb中添加：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">config.assets.initialize_on_precompile = false
</code></pre></div>
<p>股票功能需要导入交割单文件，因为导入后的文本文件不再使用，可以把上传路径由public/uploads改为tmp，这样就避免了Heroku不能写文件的问题。</p>

<p>应用上传后运行时出现异常，使用heroku logs -t查看日志发现有如下错误：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Error: column &quot;stocks.share_name&quot; must appear in the GROUP BY clause or be used in an aggregate function
</code></pre></div>
<p>这是因为在controller中有这么一行代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">current_user.stocks.select(&quot;share_code, share_name, sum(actual_amount) as amount&quot;).group(&quot;share_code&quot;)
</code></pre></div>
<p>在PostgreSQL中这会有问题。比如下面的数据表：</p>

<p><img src="/uploads/stocks-table.png" title="stocks-table" ></p>

<p>执行上面的SQL语句后，share_name的值到底是取Ruby呢还是ST Ruby？解决这个问题的方法是使用aggregate函数。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">current_user.stocks.select(&quot;share_code, max(share_name) as share_name, sum(actual_amount) as amount&quot;).group(&quot;share_code&quot;)
</code></pre></div>
<p>使用PostgreSQL还有个问题，就是decimal类型的字段，取出来的值是字符串类型。例如：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">if stock.amount &lt; 0
</code></pre></div>
<p>它会报错误：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">ArgumentError (comparison of String with 0 failed)
</code></pre></div>
<p>这个可以使用to_f函数解决：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">if stock.amount.to_f &lt; 0
</code></pre></div>]]></content>
  </entry>
  
</feed>
