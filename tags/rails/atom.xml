<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Rails | 乐者为王]]></title>
  <link href="http://codemany.com/tags/rails/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2014-11-17T22:14:06+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用Pry调试Rails应用]]></title>
    <link href="http://codemany.com/blog/debugging-rails-application-with-pry/"/>
    <updated>2014-07-07T23:26:08+08:00</updated>
    <id>http://codemany.com/blog/debugging-rails-application-with-pry</id>
    <content type="html"><![CDATA[<p>调试Rails程序的工具有ruby-debug、irb、rails-console等，不过现在这些工具都可以歇着了，因为有了Pry。</p>

<p>首先，在Gemfile中申明gem包：</p>

<pre><code>gem 'pry', group: :development
</code></pre>

<p>然后执行</p>

<pre><code>bundle install
</code></pre>

<p>用Pry代替irb，直接运行：</p>

<pre><code>pry
</code></pre>

<p>用Pry代替rails console，运行：</p>

<pre><code>pry -r ./config/environment.rb
</code></pre>

<p>调试Rails项目时，在需要调试的地方添加binding.pry，当rails server运行到这行代码时会自动调出一个pry窗口，可以在这里进行交互，退出调试用exit-all。例如：</p>

<pre><code>def index
  @articles = Article.all
  binding.pry
end
</code></pre>

<p>可以使用exit-program命令无条件地退出循环。</p>

<pre><code>(1..100).each do |i|
  binding.pry
  puts i
end
</code></pre>

<p>Pry默认没有调试中经常用到的上一步，下一步等命令，可以安装pry-nav，然后就可以使用step, next, continue跳来跳去了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[部署应用到Heroku时的问题]]></title>
    <link href="http://codemany.com/blog/problem-when-deploying-application-to-heroku/"/>
    <updated>2013-05-21T06:25:33+08:00</updated>
    <id>http://codemany.com/blog/problem-when-deploying-application-to-heroku</id>
    <content type="html"><![CDATA[<p>Heroku现在已经是纯粹的只读PaaS了，也就是说以前还支持的SQlite现在也不能使用了。因此部署到Heroku上的Rails应用需要把使用的数据库改成PostgreSQL，并且要关闭assets的预编译功能。</p>

<p>修改Gemfile，将SQLite换成PostgreSQL：</p>

<pre><code># gem 'sqlite3'
gem 'pg'
</code></pre>

<p>在config/application.rb中添加：</p>

<pre><code>config.assets.initialize_on_precompile = false
</code></pre>

<p>股票功能需要导入交割单文件，因为导入后的文本文件不再使用，可以把上传路径由public/uploads改为tmp，这样就避免了Heroku不能写文件的问题。</p>

<p>应用上传后运行时出现异常，使用heroku logs -t查看日志发现有如下错误：</p>

<pre><code>Error: column "stocks.share_name" must appear in the GROUP BY clause or be used in an aggregate function
</code></pre>

<p>这是因为在controller中有这么一行代码：</p>

<pre><code>current_user.stocks.select("share_code, share_name, sum(actual_amount) as amount").group("share_code")
</code></pre>

<p>在PostgreSQL中这会有问题。比如下面的数据表：</p>

<p>{% img /uploads/qianbao-stocks-table.png qianbao-stocks-table %}</p>

<p>执行上面的SQL语句后，share_name的值到底是取Ruby呢还是ST Ruby？解决这个问题的方法是使用aggregate函数。</p>

<pre><code>current_user.stocks.select("share_code, max(share_name) as share_name, sum(actual_amount) as amount").group("share_code")
</code></pre>

<p>使用PostgreSQL还有个问题，就是decimal类型的字段，取出来的值是字符串类型。例如：</p>

<pre><code>if stock.amount &lt; 0
</code></pre>

<p>它会报错误：</p>

<pre><code>ArgumentError (comparison of String with 0 failed)
</code></pre>

<p>这个可以使用to_f函数解决：</p>

<pre><code>if stock.amount.to_f &lt; 0
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails中通过Checkbox实现批量删除]]></title>
    <link href="http://codemany.com/blog/deleting-multiple-records-using-checkboxes-in-rails/"/>
    <updated>2012-12-14T18:20:20+08:00</updated>
    <id>http://codemany.com/blog/deleting-multiple-records-using-checkboxes-in-rails</id>
    <content type="html"><![CDATA[<p>在Rails生成的控制器模版中，包含的destroy方法只能处理单个对象，而批量删除要求能够同时处理多个对象，这需要自定义一个批量操作action。批量删除的效果图如下：</p>

<p>{% img /uploads/table-with-checkboxes.png table-with-checkboxes %}</p>

<p>每一行记录的第一列设置成Checkbox，用于标记此行是否被选中。表下方放置一个全选Checkbox，表示全部选中或全部反选。全选和反选的JavaScript代码如下：</p>

<p>&#8220;`</p>

<script>
function toggle_checkall(field_name, state) {
  var checkboxes = document.getElementsByTagName('input');
  var count = checkboxes.length;
  for (var i = 0; i < count; i++) {
    if (checkboxes[i].type == "checkbox"
        && checkboxes[i].name == field_name + "_ids[]") {
      checkboxes[i].checked = state;
    }
  }
}
</script>


<pre><code>
在routes.rb中配置批量删除action的映射：
</code></pre>

<p>resources :departs do
  delete &lsquo;destroy_multiple&rsquo;, :on => collection
end
&#8220;`</p>

<p>在index.html.erb中添加代码：</p>

<p>&#8220;`
&lt;%= form_tag destroy_multiple_departs_path, method: :delete do %>
&lt;%= submit_tag &ldquo;删除选中&rdquo; %></p>

<table>
  <thead>
    <tr>
      <th><input type="checkbox" onclick="toggle_checkall('depart', this.checked);" /></th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td><%= check_box_tag "depart_ids[]", depart.id %></td>
    </tr>
    <tr>
      <td><%= check_box_tag "depart_ids[]", depart.id %></td>
    </tr>
  </tbody>
</table>


<p>&lt;% end %>
&#8220;`</p>

<p>在controller中添加批量删除实现代码：</p>

<pre><code>def destroy_multiple
  Depart.destroy(params[:depart_ids]) unless params[:depart_ids].blank?

  respond_to do |format|
    format.html { redirect_to departs }
    format.json { head :no_content }
  end
end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[改写Rails 2.x generator到Rails 3.x时的一些记录]]></title>
    <link href="http://codemany.com/blog/notes-rewrite-generator-from-rails-2x-to-rails-3x/"/>
    <updated>2012-05-03T07:13:58+08:00</updated>
    <id>http://codemany.com/blog/notes-rewrite-generator-from-rails-2x-to-rails-3x</id>
    <content type="html"><![CDATA[<p>因为有个基于Rails 2.x的项目用到了<a href="https://github.com/jsboulanger/feedback">feedback</a>插件，在把项目迁移到Rails 3.x版本后，需要让feedback也支持Rails 3.x。但是原作者早已不再更新该插件，所以只能自己动手。花了两天时间查找资料，修改代码，终于完成。</p>

<p>Rails 3.x中生成generator可用下面的命令：</p>

<pre><code>rails g generator feedback_form
      create  lib/generators/feedback_form
      create  lib/generators/feedback_form/feedback_form_generator.rb
      create  lib/generators/feedback_form/USAGE
      create  lib/generators/feedback_form/templates
</code></pre>

<pre><code>class InitializerGenerator &lt; Rails::Generators::NamedBase
  source_root File.expand_path("../templates", __FILE__)
end
</code></pre>

<p>生成基类也从Rails::Generators::Base变成了Rails::Generators::NamedBase。它们的区别是Rails::Generators::NamedBase期望至少一个参数。</p>

<p>USAGE文件里的内容是输入-h参数时显示的文档：</p>

<pre><code>rails generate feedback_form --help
Usage:
  rails generate feedback_form NAME [options]
</code></pre>

<p>Rails 2.x中的manifest可以删除了，因为在3.x的generator中每个public方法在生成过程中会被自动调用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用Rails 3.2打造简单记账应用]]></title>
    <link href="http://codemany.com/blog/using-rails-32-to-create-a-simple-accounting-application/"/>
    <updated>2012-04-18T07:49:27+08:00</updated>
    <id>http://codemany.com/blog/using-rails-32-to-create-a-simple-accounting-application</id>
    <content type="html"><![CDATA[<p>Rails已经到3.2版本了，和以前的2.3版本有了很大的不同，决定把原来老版本的记账应用重新写一遍，更新部分插件。</p>

<p>首先是创建项目：</p>

<pre><code>rails new qianbao
cd qianbao
rails g scaffold entry amount:decimal tags:string comment:text effective_date:date
rails g controller home index
</code></pre>

<p>删除public/index.html，在config/routes.rb中添加根路由：</p>

<pre><code>root :to =&gt; 'home#index'
</code></pre>

<p>现在要给应用加上一个认证系统（注册、激活、登录、登出），这次使用<a href="https://github.com/plataformatec/devise">devise</a>插件实现。</p>

<p>在Gemfile中添加：</p>

<pre><code>gem 'devise'
</code></pre>

<p>然后执行下列命令：</p>

<pre><code>bundle install
rails g devise:install
rails g devise user
rails g devise:views
</code></pre>

<p>创建一个迁移任务，把User和Entry模型关联起来：</p>

<pre><code>class AddUserIdToEntries &lt; ActiveRecord::Migration
  def change
    add_column :entries, :user_id, :integer

    add_index :entries, :user_id
  end
end
</code></pre>

<p>修改Entry和User模型：</p>

<pre><code>class Entry &lt; ActiveRecord::Base
  validates :effective_date, :presence =&gt; true
  validates :amount,         :presence =&gt; true,
                             :numericality =&gt; { :greater_than =&gt; 0.0 },
                             :format =&gt; { :with =&gt; /^\d+??(?:\.\d{0,2})?$/ }
  validates :tags,           :presence =&gt; true,
                             :length =&gt; { :within =&gt; 1..255 }

  belongs_to :user
</code></pre>

<pre><code>class User &lt; ActiveRecord::Base
  has_many :entries
</code></pre>

<p>修改app/views/layouts/application.html.erb文件：</p>

<pre><code>&lt;body&gt;
  &lt;% if user_signed_in? %&gt;
    &lt;p&gt;
      &lt;strong&gt;&lt;%= link_to current_user.email, edit_user_registration_path %&gt;&lt;/strong&gt;
      &lt;%= link_to 'Logout', destroy_user_session_path, :method =&gt; :delete %&gt;
    &lt;/p&gt;
    &lt;%= link_to "All Entries", entries_path %&gt;
  &lt;% else %&gt;
    &lt;p&gt;
      &lt;strong&gt;You are currently not logged in.&lt;/strong&gt;
      &lt;%= link_to 'Sign in', new_user_session_path %&gt; or
      &lt;%= link_to 'Sign up', new_user_registration_path %&gt;
    &lt;/p&gt;
  &lt;% end %&gt;

  &lt;%= yield %&gt;
&lt;/body&gt;
</code></pre>

<p>修改app/controller/entries_controller.rb：</p>

<pre><code>class EntriesController &lt; ApplicationController
  before_filter :authenticate_user!

  # GET /entries
  # GET /entries.json
  def index
    @entries = current_user.entries

    respond_to do |format|
      format.html # index.html.erb
      format.json { render json: @entries }
    end
  end

  # GET /entries/1
  # GET /entries/1.json
  def show
    @entry = current_user.entries.find(params[:id])

    respond_to do |format|
      format.html # show.html.erb
      format.json { render json: @entry }
    end
  end

  # GET /entries/new
  # GET /entries/new.json
  def new
    @entry = Entry.new

    respond_to do |format|
      format.html # new.html.erb
      format.json { render json: @entry }
    end
  end

  # GET /entries/1/edit
  def edit
    @entry = current_user.entries.find(params[:id])
  end

  # POST /entries
  # POST /entries.json
  def create
    @entry = Entry.new(params[:entry])
    @entry.user = current_user

    respond_to do |format|
      if @entry.save
        format.html { redirect_to @entry, notice: 'Entry was successfully created.' }
        format.json { render json: @entry, status: :created, location: @entry }
      else
        format.html { render action: "new" }
        format.json { render json: @entry.errors, status: :unprocessable_entity }
      end
    end
  end

  # PUT /entries/1
  # PUT /entries/1.json
  def update
    @entry = current_user.entries.find(params[:id])

    respond_to do |format|
      if @entry.update_attributes(params[:entry])
        format.html { redirect_to @entry, notice: 'Entry was successfully updated.' }
        format.json { head :no_content }
      else
        format.html { render action: "edit" }
        format.json { render json: @entry.errors, status: :unprocessable_entity }
      end
    end
  end

  # DELETE /entries/1
  # DELETE /entries/1.json
  def destroy
    @entry = current_user.entries.find(params[:id])
    @entry.destroy

    respond_to do |format|
      format.html { redirect_to entries_url }
      format.json { head :no_content }
    end
  end
end
</code></pre>

<p>执行以下命令启动应用：</p>

<pre><code>rake db:migrate
rails s
</code></pre>

<p>以前的版本用的CSS框架是<a href="http://blueprintcss.org/">Blueprint</a>，这次使用比它更方便快捷的<a href="https://github.com/twitter/bootstrap">Bootstrap</a>。Bootstrap建立在Less上，有个<a href="https://github.com/metaskills/less-rails-bootstrap">less-rails-bootstrap</a>，不过在安装libv8时竟然要提示缺少Python，拜托！我用的是Ruby，要我装Python，啥意思啊！还是找个Sass版的Bootstrap吧。</p>

<p>下载<a href="https://github.com/jlong/sass-twitter-bootstrap">sass-twitter-bootstrap</a>：</p>

<pre><code>git clone https://github.com/jlong/sass-twitter-bootstrap.git
</code></pre>

<p>将sass-twitter-bootstrap/lib中的文件拷贝到app/assets/stylesheets/twitter目录下。然后将app/assets/stylesheets/application.css中的</p>

<pre><code>*= require_tree .
</code></pre>

<p>修改为</p>

<pre><code>*= require twitter/bootstrap
</code></pre>

<p>再在文件末尾添加：</p>

<pre><code>body { padding-top: 60px; }
</code></pre>

<p>现在就可以使用Bootstrap来布局美化应用了。</p>

<p>代码下载：<a href="https://github.com/dohkoos/qianbao32">https://github.com/dohkoos/qianbao32</a></p>
]]></content>
  </entry>
  
</feed>
