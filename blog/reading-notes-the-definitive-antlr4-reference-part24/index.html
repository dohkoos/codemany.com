
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>ANTLR 4权威参考读书笔记（24） - 乐者为王</title>
  <meta name="author" content="dohkoos">

  
  <meta name="description" content="在本节中，我们准备讲讲有时候事件方法需要传递部分结果或其它信息的问题。 在事件方法间共享信息 无论收集信息还是计算值，传递参数和返回值都是比使用字段和全局变量更方便良好的编程实践。问题是ANTLR自动生成的监听器方法的签名不需要特定应用的返回值或参数， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part24/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="乐者为王" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-46570161-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">乐者为王</a></h1>
  
    <h2>Do one thing, and do it well.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="codemany.com">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">ANTLR 4权威参考读书笔记（24）</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-08-26T18:46:37+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>26</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>6:46 pm</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p>在本节中，我们准备讲讲有时候事件方法需要传递部分结果或其它信息的问题。</p>

<h3 id="在事件方法间共享信息">在事件方法间共享信息</h3>

<p>无论收集信息还是计算值，传递参数和返回值都是比使用字段和全局变量更方便良好的编程实践。问题是ANTLR自动生成的监听器方法的签名不需要特定应用的返回值或参数，ANTLR也自动生成访问者方法而不需要特定应用的参数。</p>

<p>接下来，我们将探讨让事件方法无需修改事件方法签名就能传递数据的机制。我们将构建同样的简单计算器的3个不同实现，基于前面章节的LExpr表达式语法。第一个实现使用访问者方法返回值，第二个定义了一个在事件方法间共享的字段，第三个则注解语法分析树节点以便储存感兴趣的值。</p>

<h4 id="使用访问者遍历语法分析树">使用访问者遍历语法分析树</h4>

<p>构建基于访问者的计算器，最简单的方法是让和规则expr相关的事件方法返回子表达式的值。例如，visitAdd()将返回两个子表达式相加的值，visitInt()将返回整型的值。传统的访问者不指定visit方法的返回值。当我们为特定应用需求实现一个类时添加返回类型是容易的，扩展LExprBaseVisitor<T>并提供Integer作为<T>类型参数。访问者代码看起来如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static class EvalVisitor extends LExprBaseVisitor&lt;Integer&gt; {
</span><span class='line'>    public Integer visitMult(LExprParser.MultContext ctx) {
</span><span class='line'>        return visit(ctx.e(0)) * visit(ctx.e(1));
</span><span class='line'>    }
</span><span class='line'>    public Integer visitAdd(LExprParser.AddContext ctx) {
</span><span class='line'>        return visit(ctx.e(0)) + visit(ctx.e(1));
</span><span class='line'>    }
</span><span class='line'>    public Integer visitInt(LExprParser.IntContext ctx) {
</span><span class='line'>        return Integer.valueOf(ctx.INT().getText());
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>EvalVisitor从ANTLR生成的AbstractParseTreeVisitor类继承通用的visit()方法，我们的访问者使用它去准确地触发子树访问。</p>

<p>注意，EvalVisitor没有针对规则s的访问者方法。在LExprBaseVisitor中的visitS()的默认实现调用预定义的方法ParseTreeVisitor.visitChildren(). visitChildren()返回从最后的子节点访问返回的值。在这里，visitS()返回访问它唯一的子节点（节点e）时返回的表达式的值。我们可以使用这种默认的行为。</p>

<p>在测试文件TestLEvalVisitor.java中，我们有常用代码去启动LExprParser和打印语法分析树，然后我们需要编码去启动EvalVisitor和打印出当访问树时计算出的表达式的值。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>EvalVisitor evalVisitor = new EvalVisitor();
</span><span class='line'>int result = evalVisitor.visit(tree);
</span><span class='line'>System.out.println("visitor result = " + result);</span></code></pre></td></tr></table></div></figure>

<p>要构建计算器，需要告诉ANTLR使用-visitor参数去生成访问者。（如果我们不再需要生成监听器，可以使用-no-listener参数）以下是完整的构建和测试序列：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>antlr -visitor LExpr.g
</span><span class='line'>compile *.java
</span><span class='line'>run TestLEvalVisitor</span></code></pre></td></tr></table></div></figure>

<p>接着输入以下内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1+2*3
</span><span class='line'>EOF</span></code></pre></td></tr></table></div></figure>

<p>你就会看到如下结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(s (e (e 1) + (e (e 2) * (e 3))))
</span><span class='line'>visitor result = 7</span></code></pre></td></tr></table></div></figure>

<p>如果我们需要特定应用的返回值，访问者工作的相当好，因为我们使用了内建的Java返回值机制。如果我们不希望显式地调用访问者方法去访问子节点，我们可以切换到监听器机制，不幸的是，这意味着我们要放弃使用Java方法返回值的整洁。</p>

<h4 id="使用栈模拟返回值">使用栈模拟返回值</h4>

<p>ANTLR生成的监听器事件方法没有返回值。为了给在语法分析树更高节点上执行的监听器方法返回值，我们可以把部分的值存储在监听器的一个字段中。我们会想到用栈来存储值，方法就是把计算一个子表达式的结果推送到栈中，在语法分析树上用于子表达式的方法则把运算元从栈中弹出。以下是完整的Evaluator计算器监听器（代码在TestLEvaluator.java文件中）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static class Evaluator extends LExprBaseListener {
</span><span class='line'>    Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
</span><span class='line'>    public void exitMult(LExprParser.MultContext ctx) {
</span><span class='line'>        int right = stack.pop();
</span><span class='line'>        int left = stack.pop();
</span><span class='line'>        stack.push(left * right);
</span><span class='line'>    }
</span><span class='line'>    public void exitAdd(LExprParser.AddContext ctx) {
</span><span class='line'>        int right = stack.pop();
</span><span class='line'>        int left = stack.pop();
</span><span class='line'>        stack.push(left + right);
</span><span class='line'>    }
</span><span class='line'>    public void exitInt(LExprParser.IntContext ctx) {
</span><span class='line'>        stack.push(Integer.valueOf(ctx.INT().getText()));
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>要测试上面的这段代码，我们可以创建和使用在代码TestLEvaluator中的ParseTreeWalker，以下是完整的构建和测试序列：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>antlr LExpr.g
</span><span class='line'>compile *.java
</span><span class='line'>run TestLEvaluator</span></code></pre></td></tr></table></div></figure>

<p>接着输入以下内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1+2*3
</span><span class='line'>EOF</span></code></pre></td></tr></table></div></figure>

<p>你就会看到如下结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(s (e (e 1) + (e (e 2) * (e 3))))
</span><span class='line'>stack result = 7</span></code></pre></td></tr></table></div></figure>

<p>使用栈字段有点别扭但工作得很好。我们必须确保事件方法以正确的顺序压入和弹出跨越监听器事件的值。带有返回值的访问者没有栈的这种笨拙但却需要手工访问树的节点。第三种实现是通过把部分值隐藏在树节点中来捕获它们。</p>

<h4 id="注解语法分析树">注解语法分析树</h4>

<p>作为使用临时存储在事件方法间共享数据的替代，我们可以把这些值存储在语法分析树本身中。使用树注解方法时我们可以带有监听器或访问者，但在这里我们使用监听器来阐明如何使用它。让我们首先看一下用部分结果注解的1+2*3的LExpr语法分析树。</p>

<p><img src="/uploads/lexpr-parse-tree.png" title="lexpr-parse-tree" ></p>

<p>每个子表达式对应一个子树根（和对应一个e规则调用）。从e节点发出的水平线指向的数字是我们想要返回的部分结果。</p>

<p>让我们看看节点注解策略将如何工作在来自LExpr语法的规则e上。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>e : e MULT e    # Mult
</span><span class='line'>  | e ADD e     # Add
</span><span class='line'>  | INT         # Int
</span><span class='line'>  ;</span></code></pre></td></tr></table></div></figure>

<p>e选项的监听器方法每个都会存储一个结果在相对应的e语法分析树节点中。任何随后的在语法分析树更高节点上的add或multiply事件将通过查看存储在它们对应的子节点中的值来抓取子表达式的值。</p>

<p>现在，让我们假设每个语法分析树节点（每个规则上下文对象）都有一个字段value，那么exitAdd()看起来将是这样；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void exitAdd(LExprParser.AddContext ctx) {
</span><span class='line'>    // e(0).value is the subexpression value of the first e in the alternative
</span><span class='line'>    ctx.value = ctx.e(0).value + ctx.e(1).value;    // e '+' e # Add
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>这看起来相当合理，但不幸的是，在Java中我们不能扩展类ExprContext去动态地添加字段。为了让语法分析树注解生效，我们需要一种方法去注解各式各样的节点而不需要手工修改由ANTLR生成的关联节点类。</p>

<p>注解语法分析树节点最简单的方式是使用与节点任意值相关联的一个Map。因此，ANTLR提供了一个简单的帮助类ParseTreeProperty。让我们在文件TestLEvaluatorWithProps.java中构建称作EvaluatorWithProps的另一个计算器版本，它使用ParseTreeProperty关联了LExpr语法分析树节点和部分结果。以下是在监听器开始处的适当的定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static class EvaluatorWithProps extends LExprBaseListener {
</span><span class='line'>    /** maps nodes to integers with Map&lt;ParseTree,Integer&gt; */
</span><span class='line'>    ParseTreeProperty&lt;Integer&gt; values = new ParseTreeProperty&lt;Integer&gt;();</span></code></pre></td></tr></table></div></figure>

<p>注意：如果你想使用自己的Map类型字段代替ParseTreeProperty，确保它继承自IdentityHashMap，而不是通常的HashMap。我们需要去注解特殊的节点，进行同一性测试而不是equals()。两个e节点可能是equals()，但在内存中不是同一个物理节点。</p>

<p>为注解一个节点，我们使用values.put(node, value)。为得到和一个节点有关联的值，我们使用values.get(node)。这很好，但是让我们创建一些有直白名字的帮助方法以便让代码更容易阅读。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void setValue(ParseTree node, int value) { values.put(node, value); }
</span><span class='line'>public int getValue(ParseTree node) { return values.get(node); }</span></code></pre></td></tr></table></div></figure>

<p>让我们从最简单的表达式选项Int开始监听器方法。我们想使用它匹配的INT记号的整型值去注解它的语法分析树e节点。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void exitInt(LExprParser.IntContext ctx) {
</span><span class='line'>    String intText = ctx.INT().getText();    // INT    # Int
</span><span class='line'>    setValue(ctx, Integer.valueOf(intText));
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>对于加法树，我们得到两个子表达式子节点的值（运算元）和带有和的注释的子树跟。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void exitAdd(LExprParser.AddContext ctx) {
</span><span class='line'>    int left = getValue(ctx.e(0));    // e '+' e    # Add
</span><span class='line'>    int right = getValue(ctx.e(1));
</span><span class='line'>    setValue(ctx, left + right);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>方法exitMult()是相同的，只是运算的时候用multiply代替了add。</p>

<p>我们的测试代码从分析规则s开始。因此我们必须确保语法分析树根有e子树的值。为把值从e节点冒泡到根s节点，我们实现了exitS()。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/** Need to pass e's value out of rule s : e ; */
</span><span class='line'>public void exitS(LExprParser.SContext ctx) {
</span><span class='line'>    setValue(ctx, getValue(ctx.e()));    // like: int s() { return e(); }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>以下是如何启动监听器以及打印出来自语法分析树根节点的表达式的值：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ParseTreeWalker walker = new ParseTreeWalker();
</span><span class='line'>EvaluatorWithProps evalProp = new EvaluatorWithProps();
</span><span class='line'>walker.walk(evalProp, tree);
</span><span class='line'>System.out.println("properties result = " + evalProp.getValue(tree));</span></code></pre></td></tr></table></div></figure>

<p>以下是构建和测试序列：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>antlr LExpr.g
</span><span class='line'>compile *.java
</span><span class='line'>run TestLEvaluatorWithProps</span></code></pre></td></tr></table></div></figure>

<p>接着输入以下内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1+2*3
</span><span class='line'>EOF</span></code></pre></td></tr></table></div></figure>

<p>你就会看到如下结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(s (e (e 1) + (e (e 2) * (e 3))))
</span><span class='line'>stack result = 7</span></code></pre></td></tr></table></div></figure>

<p>现在我们已经看到了相同计算器的3个实现，并且我们也已经准备好把我们的知识用于构建真实案例。因为每个方法都有它的优势和劣势，下面就让我们来比较下不同的技术。</p>

<h3 id="比较信息共享方法">比较信息共享方法</h3>

<p>为得到可复用和可重定目标的语法，我们需要让它们完全清除用户定义的动作。这意味着要把所有特定应用的代码放到语法外的某些监听器和访问者中。监听器和访问者操作语法分析树，ANTLR自动生成合适的树遍历接口和默认实现。因为事件方法签名是固定的和不特定于应用的，所以事件方法可以共享信息的方式有3种：</p>

<ul>
<li>本地Java调用栈：访问者返回用户定义类型的一个值。如果访问者需要传递参数，它也必须使用下面两种技术的一种。</li>
<li>基于栈：一个栈字段模仿参数和返回值，像Java调用栈那样。</li>
<li>注解者：一个Map字段使用有用的值注解节点。</li>
</ul>

<p>所有这3种方法是和语法本身完全解耦的，并且很好地封装在专门的对象中。除此之外，它们也都有各自的优点和缺点。我们可以根据问题的需要和个人的喜好决定采取哪种方法。你甚至可以在同一个应用中使用多种方法。</p>

<p>访问者方法很好懂，因为它们直接调用其它访问者方法去获取部分结果，并且能像其它任何方法那样返回值。这也是它们的缺点，访问者方法必须显式地访问它们的子节点。而监听器就不需要。因为访问者有个通用的接口，所以它不能定义参数。访问者必须使用其它解决方案的一种去传递参数给它在子节点上调用的访问者方法。访问者的空间效率很好，因为它在任何时间仅需保留少数的部分结果。在树遍历后没有部分结果保留。当访问者方法可以返回值时，每个值必须是同种类型，不想其它的解决方案。</p>

<p>基于栈的解决方案可以模仿参数和返回带有一个栈的值，但在手动管理栈时有个断开的机会。这可能会发生，因为监听器方法不能直接调用彼此。作为程序员，我们必须确定推入栈中的在将来事件方法调用能适当地弹出。栈可以传递多个值和多个返回值。基于栈的解决方案也是空间有效的，因为它不会把任何东西固定到树上。在树遍历后所有的部分结果存储消失。</p>

<p>注解者通常可以作为默认解决方案采用，因为它允许你任意地提供信息给事件方法操作语法分析树中上上下下的节点。你也可以传递多个值，它们可以是任意类型。在许多情况下注解胜于使用带有短暂值的栈。在各种方法的数据传递准备间很少有断开的机会。比起在编程语言中说返回值，使用setValue(ctx, value)注解树不太直观，但是更通用。超过其它两种的这种方法的唯一缺点是在树遍历期间部分结果是保留的，因此它有较大的内存占用。</p>

<p>从另一方面来说，在某些应用中能够注解树正是我们需要的。应用需要在树上通过多遍，第一遍是很方便在树上计算和储存数据的。当语法分析树遍历器重新遍历树的时候第二遍然后就很容易访问数据。总的来说，树注解非常灵活，有一个可接受的内存负担。</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">dohkoos</span></span>

      




<time class='entry-date' datetime='2016-08-26T18:46:37+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>26</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>6:46 pm</span></time>
      


      

<span class="tags">
  
    <a class='tag' href='/tags/antlr/'>ANTLR</a>
  
</span>


    </p>
    
  <h3>Related Posts</h3>
  <ul class="posts">
  
    <li class="related">
      <a href="/blog/reading-notes-the-definitive-antlr4-reference-part30/">ANTLR 4权威参考读书笔记（30）</a>
    </li>
  
    <li class="related">
      <a href="/blog/reading-notes-the-definitive-antlr4-reference-part29/">ANTLR 4权威参考读书笔记（29）</a>
    </li>
  
    <li class="related">
      <a href="/blog/reading-notes-the-definitive-antlr4-reference-part28/">ANTLR 4权威参考读书笔记（28）</a>
    </li>
  
    <li class="related">
      <a href="/blog/reading-notes-the-definitive-antlr4-reference-part27/">ANTLR 4权威参考读书笔记（27）</a>
    </li>
  
    <li class="related">
      <a href="/blog/reading-notes-the-definitive-antlr4-reference-part26/">ANTLR 4权威参考读书笔记（26）</a>
    </li>
  
  </ul>


    
      <div id="jiathis_style_32x32">
	<a class="jiathis_button_qzone"></a>
	<a class="jiathis_button_tsina"></a>
	<a class="jiathis_button_tqq"></a>
    <a class="jiathis_button_weixin"></a>
	<a class="jiathis_button_renren"></a>
	<a href="http://www.jiathis.com/share/" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" src="http://v2.jiathis.com/code/jia.js" charset="utf-8"></script>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/reading-notes-the-definitive-antlr4-reference-part23/" title="Previous Post: ANTLR 4权威参考读书笔记（23）">&laquo; ANTLR 4权威参考读书笔记（23）</a>
      
      
        <a class="basic-alignment right" href="/blog/reading-notes-the-definitive-antlr4-reference-part25/" title="Next Post: ANTLR 4权威参考读书笔记（25）">ANTLR 4权威参考读书笔记（25） &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/the-mythical-10x-programmer/">神秘的10x程序员</a>
      </li>
    
      <li class="post">
        <a href="/blog/learn-anything-faster-with-the-feynman-technique/">费曼技巧：最好的学习方法</a>
      </li>
    
      <li class="post">
        <a href="/blog/code-coverage-100-percent-tragedy/">100%代码覆盖率的悲剧</a>
      </li>
    
      <li class="post">
        <a href="/blog/unconventional-way-of-learning-a-new-programming-language/">学习新编程语言的非传统方式</a>
      </li>
    
      <li class="post">
        <a href="/blog/the-impact-github-is-having-on-your-software-career-right-now/">GitHub对软件职业生涯的影响</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>Recent Comments</h1>
  <div class="dsq-widget">
    <script type="text/javascript" src="http://codemany.disqus.com/recent_comments_widget.js"></script>
  </div>
</section>
<section>
  <h1>Tags</h1>
  <ul class="tag-cloud">
    <a style="font-size: 141%" href="/tags/antlr/">ANTLR</a>
<a style="font-size: 106%" href="/tags/algorithm/">Algorithm</a>
<a style="font-size: 132%" href="/tags/android/">Android</a>
<a style="font-size: 103%" href="/tags/c-plus-plus/">C++</a>
<a style="font-size: 106%" href="/tags/css/">CSS</a>
<a style="font-size: 108%" href="/tags/crack/">Crack</a>
<a style="font-size: 106%" href="/tags/database/">Database</a>
<a style="font-size: 95%" href="/tags/eclipse/">Eclipse</a>
<a style="font-size: 113%" href="/tags/git/">Git</a>
<a style="font-size: 95%" href="/tags/html/">HTML</a>
<a style="font-size: 103%" href="/tags/jbookshelf/">JBookShelf</a>
<a style="font-size: 146%" href="/tags/java/">Java</a>
<a style="font-size: 99%" href="/tags/javascript/">JavaScript</a>
<a style="font-size: 95%" href="/tags/listview/">ListView</a>
<a style="font-size: 103%" href="/tags/mysql/">MySQL</a>
<a style="font-size: 103%" href="/tags/paperclip/">Paperclip</a>
<a style="font-size: 117%" href="/tags/powerbuilder/">PowerBuilder</a>
<a style="font-size: 99%" href="/tags/powerscript/">PowerScript</a>
<a style="font-size: 115%" href="/tags/qianbao/">Qianbao</a>
<a style="font-size: 150%" href="/tags/rails/">Rails</a>
<a style="font-size: 117%" href="/tags/ruby/">Ruby</a>
<a style="font-size: 95%" href="/tags/spring/">Spring</a>
<a style="font-size: 99%" href="/tags/struts/">Struts</a>
<a style="font-size: 143%" href="/tags/translation/">Translation</a>
<a style="font-size: 95%" href="/tags/ubuntu/">Ubuntu</a>
<a style="font-size: 106%" href="/tags/windows-server-2008/">Windows Server 2008</a>
<a style="font-size: 106%" href="/tags/wxwidgets/">wxWidgets</a>

  </ul>
</section>
<section>
  <h1>Blogroll</h1>
  <ul>
    <li><a href="http://mindhacks.cn/">刘未鹏MIND HACKS</a></li>
    <li><a href="http://www.importnew.com/">ImportNew</a></li>
    <li><a href="http://ifeve.com/">并发编程网</a></li>
    <li><a href="http://codingnow.com/">云风的 BLOG</a></li>
    <li><a href="http://dbanotes.net/">DBA Notes</a></li>
    <li><a href="http://www.ruanyifeng.com/blog/">阮一峰的网络日志</a></li>
    <li><a href="http://advdbg.org/">高端调试</a></li>
    <li><a href="http://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualization</a></li>
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/dohkoos">@dohkoos</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'dohkoos',
            count: 5,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>

<section>
  <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
  <div>This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.</div>
</section>

  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2017 - dohkoos -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'codemany';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part24/';
        var disqus_url = 'http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part24/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





</body>
</html>
