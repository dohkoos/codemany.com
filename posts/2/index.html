
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>乐者为王</title>
  <meta name="author" content="dohkoos">

  
  <meta name="description" content="今天准备做的是把JSON文本文件转换成XML文本文件。 把JSON转换成XML 许多Web服务返回的是JSON数据，但是我们可能会遇到一种情况，需要把JSON数据送给那些只接受XML数据的代码。这就需要我们构建一个JSON到XML的转换器。我们的目标是读入像下面这样的JSON数据： 1
2
3
4 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://codemany.com/posts/2/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="乐者为王" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-46570161-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">乐者为王</a></h1>
  
    <h2>Do one thing, and do it well.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="codemany.com">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/reading-notes-the-definitive-antlr4-reference-part26/">ANTLR 4权威参考读书笔记（26）</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-09-09T22:22:47+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>9</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>10:22 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>今天准备做的是把JSON文本文件转换成XML文本文件。</p>

<h3 id="把json转换成xml">把JSON转换成XML</h3>

<p>许多Web服务返回的是JSON数据，但是我们可能会遇到一种情况，需要把JSON数据送给那些只接受XML数据的代码。这就需要我们构建一个JSON到XML的转换器。我们的目标是读入像下面这样的JSON数据：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>"description" : "An imaginary server config file",
</span><span class='line'>"logs" : {"level":"verbose", "dir":"/var/log"},
</span><span class='line'>"host" : "antlr.org",
</span><span class='line'>"admin": ["parrt", "tombu"],
</span><span class='line'>"aliases": []
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>放出等价的XML数据，就像下面这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;description&gt;An imaginary server config file&lt;/description&gt;
</span><span class='line'>&lt;logs&gt;
</span><span class='line'>  &lt;level&gt;verbose&lt;/level&gt;
</span><span class='line'>  &lt;dir&gt;/var/log&lt;/dir&gt;
</span><span class='line'>&lt;/logs&gt;
</span><span class='line'>&lt;host&gt;antlr.org&lt;/host&gt;
</span><span class='line'>&lt;admin&gt;
</span><span class='line'>  &lt;element&gt;parrt&lt;/element&gt;
</span><span class='line'>  &lt;element&gt;tombu&lt;/element&gt;
</span><span class='line'>&lt;/admin&gt;
</span><span class='line'>&lt;aliases&gt;&lt;/aliases&gt;</span></code></pre></td></tr></table></div></figure>

<p>正如我们对CSV做的那样，让我们给JSON语法中的一些选项打上标签，以便让ANTLR生成更精确的监听器方法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>object
</span><span class='line'>    : '{' pair (',' pair)* '}'    # AnObject
</span><span class='line'>    | '{' '}'                     # EmptyObject
</span><span class='line'>    ;
</span><span class='line'>array
</span><span class='line'>    : '[' value (',' value)* ']'  # ArrayOfValues
</span><span class='line'>    | '[' ']'                     # EmptyArray
</span><span class='line'>    ;</span></code></pre></td></tr></table></div></figure>

<p>我们将对规则value做同样的事，但是稍有不同。除3个选项外的其它所有选项只需要返回被匹配的值的文本，所以我们可以为其它所有选项使用相同的标签，使语法分析树遍历器为那些选项触发相同的监听器方法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>value
</span><span class='line'>    : STRING    # String
</span><span class='line'>    | NUMBER    # Atom
</span><span class='line'>    | object    # ObjectValue
</span><span class='line'>    | array     # ArrayValue
</span><span class='line'>    | 'true'    # Atom
</span><span class='line'>    | 'false'   # Atom
</span><span class='line'>    | 'null'    # Atom
</span><span class='line'>    ;</span></code></pre></td></tr></table></div></figure>

<p>为构建这样的转换器，明智的做法是让每个规则返回被它匹配的输入短语的XML等价物。为追踪部分结构，我们使用字段xml和两个帮助方法来注解语法分析树。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static class XMLEmitter extends JSONBaseListener {
</span><span class='line'>    ParseTreeProperty&lt;String&gt; xml = new ParseTreeProperty&lt;String&gt;();
</span><span class='line'>    String getXML(ParseTree ctx) { return xml.get(ctx); }
</span><span class='line'>    void setXML(ParseTree ctx, String s) { xml.put(ctx, s); }</span></code></pre></td></tr></table></div></figure>

<p>我们把每棵子树转换后的字符串挂载到该子树的根节点。在语法分析树更高节点上工作的方法可以捕获这些值以便计算更大的字符串。然后挂载在根节点上的字符串完成计算。</p>

<p>让我们从最简单的转换开始。value的Atom选项返回匹配记号的文本。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void exitAtom(JSONParser.AtomContext ctx) {
</span><span class='line'>    setXML(ctx, ctx.getText());
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>字符串基本上是相同的，只是我们必须去除双引号。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void exitString(JSONParser.StringContext ctx) {
</span><span class='line'>    setXML(ctx, stripQuotes(ctx.getText()));
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>如果value()规则方法找到一个对象或数组，它可以把组合元素的部分转换拷贝到它自己的语法分析树节点。以下代码是找到对象时的处理：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void exitObjectValue(JSONParser.ObjectValueContext ctx) {
</span><span class='line'>    // analogous to String value() {return object();}
</span><span class='line'>    setXML(ctx, getXML(ctx.object()));
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>一旦我们可以转换所有的值，我们需要担心名-值对以及把它们转换成标签和文本。生成的XML的标签名字来源于STRING &#39;:&#39; value选项中的STRING。在左右尖括号之间的文本来源于挂载在value子节点上的文本。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void exitPair(JSONParser.PairContext ctx) {
</span><span class='line'>    String tag = stripQuotes(ctx.STRING().getText());
</span><span class='line'>    JSONParser.ValueContext vctx = ctx.value();
</span><span class='line'>    String x = String.format("&lt;%s&gt;%s&lt;/%s&gt;\n", tag, getXML(vctx), tag);
</span><span class='line'>    setXML(ctx, x);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>JSON对象由名-值对组成。因此，对于被选项中标记为AnObject的object找到的每个对，我们把计算后的结果追加在语法分析树。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void exitAnObject(JSONParser.AnObjectContext ctx) {
</span><span class='line'>    StringBuilder buf = new StringBuilder();
</span><span class='line'>    buf.append("\n");
</span><span class='line'>    for (JSONParser.PairContext pctx : ctx.pair()) {
</span><span class='line'>        buf.append(getXML(pctx));
</span><span class='line'>    }
</span><span class='line'>    setXML(ctx, buf.toString());
</span><span class='line'>}
</span><span class='line'>public void exitEmptyObject(JSONParser.EmptyObjectContext ctx) {
</span><span class='line'>    setXML(ctx, "");
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>处理数组遵循相似的模式，只是简单地连接来自子节点的结果列表，然后把它们包裹在<code>&lt;element&gt;</code>标签中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void exitArrayOfValues(JSONParser.ArrayOfValuesContext ctx) {
</span><span class='line'>    StringBuilder buf = new StringBuilder();
</span><span class='line'>    buf.append("\n");
</span><span class='line'>    for (JSONParser.ValueContext vctx : ctx.value()) {
</span><span class='line'>        buf.append("&lt;element&gt;"); // conjure up element for valid XML
</span><span class='line'>        buf.append(getXML(vctx));
</span><span class='line'>        buf.append("&lt;/element&gt;");
</span><span class='line'>        buf.append("\n");
</span><span class='line'>    }
</span><span class='line'>    setXML(ctx, buf.toString());
</span><span class='line'>}
</span><span class='line'>public void exitEmptyArray(JSONParser.EmptyArrayContext ctx) {
</span><span class='line'>    setXML(ctx, "");
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>最后，我们需要使用从一个对象或数组收集来的全部转换注解语法分析树的根节点。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>json: object
</span><span class='line'>    | array
</span><span class='line'>    ;</span></code></pre></td></tr></table></div></figure>

<p>我们可以在监听器里用一个集合运算做到这点。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void exitJson(JSONParser.JsonContext ctx) {
</span><span class='line'>    setXML(ctx, getXML(ctx.getChild(0)));
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>以下是构建和测试序列：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>antlr JSON.g
</span><span class='line'>compile *.java
</span><span class='line'>run JSON2XML t.json</span></code></pre></td></tr></table></div></figure>

<p>下面的是部分的输出结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;description&gt;An imaginary server config file&lt;/description&gt;
</span><span class='line'>&lt;logs&gt;
</span><span class='line'>&lt;level&gt;verbose&lt;/level&gt;
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>

<p>有些转换不总是像JSON到XML那样直白的。但是，这个例子向我们表明如何通过拼凑部分翻译短语处理句子转换问题。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/reading-notes-the-definitive-antlr4-reference-part25/">ANTLR 4权威参考读书笔记（25）</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-09-03T16:16:56+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2016</span></span> <span class='time'>4:16 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这次我们要做的是通过监听器实现CSV文件的加载器，用于建立一个二维列表数据结构。</p>

<h3 id="加载csv数据">加载CSV数据</h3>

<p>我们的目标是构建一个监听器去加载CSV数据到一个映射列表数据结构中，这是任何数据格式阅读器或配置文件阅读器都会做的事。我们会收集每行的字段并放到一个映射中，构成头名-值组合。以下是示例文件t.csv的内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Details,Month,Amount
</span><span class='line'>Mid Bonus,June,"$2,000"
</span><span class='line'>,January,"""zippo"""
</span><span class='line'>Total Bonuses,"","$5,000"</span></code></pre></td></tr></table></div></figure>

<p>我们想要看到如下的映射列表被打印出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[{Details=Mid Bonus, Month=June, Amount="$2,000"},
</span><span class='line'> {Details=, Month=January, Amount="""zippo"""},
</span><span class='line'> {Details=Total Bonuses, Month="", Amount="$5,000"}]</span></code></pre></td></tr></table></div></figure>

<p>为了在监听器中得到精确的方法，我们给CSV语法中field规则的每个选项打上标签：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grammar CSV;
</span><span class='line'>
</span><span class='line'>file : hdr row+ ;
</span><span class='line'>hdr : row ;
</span><span class='line'>row : field (',' field)* '\r'? '\n' ;
</span><span class='line'>field
</span><span class='line'>    : TEXT    # text
</span><span class='line'>    | STRING  # string
</span><span class='line'>    |         # empty
</span><span class='line'>    ;
</span><span class='line'>
</span><span class='line'>TEXT : ~[,\n\r"]+ ;
</span><span class='line'>STRING : '"' ('""'|~'"')* '"' ;     // quote-quote is an escaped quote</span></code></pre></td></tr></table></div></figure>

<p>我们可以从定义我们需要的数据结构开始监听器的实现。首先，我们需要的数据结构是称为rows的映射列表。我们也需要在头行中找到的列名列表header。为处理数据行，我们需要把字段值读到一个临时列表currentRowFieldValues中，然后把列名映射到那些值上。以下是监听器LoadCSV.java的实现代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static class Loader extends CSVBaseListener {
</span><span class='line'>    public static final String EMPTY = "";
</span><span class='line'>    /** Load a list of row maps that map field name to value */
</span><span class='line'>    List&lt;Map&lt;String,String&gt;&gt; rows = new ArrayList&lt;Map&lt;String, String&gt;&gt;();
</span><span class='line'>    /** List of column names */
</span><span class='line'>    List&lt;String&gt; header;
</span><span class='line'>    /** Build up a list of fields in current row */
</span><span class='line'>    List&lt;String&gt; currentRowFieldValues;</span></code></pre></td></tr></table></div></figure>

<p>下面的3个规则方法通过计算适当的字符串处理字段值，并把它添加到currentRowFieldValues中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void exitString(CSVParser.StringContext ctx) {
</span><span class='line'>    currentRowFieldValues.add(ctx.STRING().getText());
</span><span class='line'>}
</span><span class='line'>public void exitText(CSVParser.TextContext ctx) {
</span><span class='line'>    currentRowFieldValues.add(ctx.TEXT().getText());
</span><span class='line'>}
</span><span class='line'>public void exitEmpty(CSVParser.EmptyContext ctx) {
</span><span class='line'>    currentRowFieldValues.add(EMPTY);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>在我们能处理数据行之前，我们需要从第一行取得列名列表。头行在语法上仅仅是另外的行，但我们在对待它时要不同于常规的数据行，那意味着我们需要检查上下文。暂时让我们假设在exitRow()执行后，currentRowFieldValues包含列名列表。要填充header，我们只需要捕获第一行的字段值。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void exitHdr(CSVParser.HdrContext ctx) {
</span><span class='line'>    header = new ArrayList&lt;String&gt;();
</span><span class='line'>    header.addAll(currentRowFieldValues);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>谈到行时，我们需要两个操作：一个是当我们开始一行时，另一个是当我们结束一行时。当我们开始一行时，我们需要分配或清除currentRowFieldValues，准备获取一组新的数据。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void enterRow(CSVParser.RowContext ctx) {
</span><span class='line'>    currentRowFieldValues = new ArrayList&lt;String&gt;();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>在行结束的时候，我们必须考虑上下文。如果我们仅仅加载头行，那我们不能改变rows字段，因为列名不是数据。在exitRow()中，我们可以通过查看在语法分析树中的父节点的getRuleIndex()值（或者询问父节点是否是HdrContext类型）测试上下文。如果当前行是数据行，我们将通过同时遍历header中的列名和currentRowFieldValues中的值获取的内容创建映射。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void exitRow(CSVParser.RowContext ctx) {
</span><span class='line'>    // If this is the header row, do nothing
</span><span class='line'>    // if ( ctx.parent instanceof CSVParser.HdrContext ) return; OR:
</span><span class='line'>    if ( ctx.getParent().getRuleIndex() == CSVParser.RULE_hdr ) {
</span><span class='line'>        return;
</span><span class='line'>    }
</span><span class='line'>    // It's a data row
</span><span class='line'>    Map&lt;String, String&gt; m = new LinkedHashMap&lt;String, String&gt;();
</span><span class='line'>    int i = 0;
</span><span class='line'>    for (String v : currentRowFieldValues) {
</span><span class='line'>        m.put(header.get(i), v);
</span><span class='line'>        i++;
</span><span class='line'>    }
</span><span class='line'>    rows.add(m);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>到这里，加载CSV数据到数据结构中的任务就算已经完成。在使用ParseTreeWalker遍历树后，我们就可以紧接着打印出rows字段：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ParseTreeWalker walker = new ParseTreeWalker();
</span><span class='line'>Loader loader = new Loader();
</span><span class='line'>walker.walk(loader, tree);
</span><span class='line'>System.out.println(loader.rows);</span></code></pre></td></tr></table></div></figure>

<p>以下是构建和测试序列：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>antlr CSV.g
</span><span class='line'>compile *.java
</span><span class='line'>run LoadCSV t.csv</span></code></pre></td></tr></table></div></figure>

<p>下面显示的是输出结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[{Details=Mid Bonus, Month=June, Amount="$2,000"}, {Details=, Month=January,
</span><span class='line'>Amount="""zippo"""}, {Details=Total Bonuses, Month="", Amount="$5,000"}]</span></code></pre></td></tr></table></div></figure>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/reading-notes-the-definitive-antlr4-reference-part24/">ANTLR 4权威参考读书笔记（24）</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-08-26T18:46:37+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>26</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>6:46 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在本节中，我们准备讲讲有时候事件方法需要传递部分结果或其它信息的问题。</p>

<h3 id="在事件方法间共享信息">在事件方法间共享信息</h3>

<p>无论收集信息还是计算值，传递参数和返回值都是比使用字段和全局变量更方便良好的编程实践。问题是ANTLR自动生成的监听器方法的签名不需要特定应用的返回值或参数，ANTLR也自动生成访问者方法而不需要特定应用的参数。</p>

<p>接下来，我们将探讨让事件方法无需修改事件方法签名就能传递数据的机制。我们将构建同样的简单计算器的3个不同实现，基于前面章节的LExpr表达式语法。第一个实现使用访问者方法返回值，第二个定义了一个在事件方法间共享的字段，第三个则注解语法分析树节点以便储存感兴趣的值。</p>

<h4 id="使用访问者遍历语法分析树">使用访问者遍历语法分析树</h4>

<p>构建基于访问者的计算器，最简单的方法是让和规则expr相关的事件方法返回子表达式的值。例如，visitAdd()将返回两个子表达式相加的值，visitInt()将返回整型的值。传统的访问者不指定visit方法的返回值。当我们为特定应用需求实现一个类时添加返回类型是容易的，扩展LExprBaseVisitor<T>并提供Integer作为<T>类型参数。访问者代码看起来如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static class EvalVisitor extends LExprBaseVisitor&lt;Integer&gt; {
</span><span class='line'>    public Integer visitMult(LExprParser.MultContext ctx) {
</span><span class='line'>        return visit(ctx.e(0)) * visit(ctx.e(1));
</span><span class='line'>    }
</span><span class='line'>    public Integer visitAdd(LExprParser.AddContext ctx) {
</span><span class='line'>        return visit(ctx.e(0)) + visit(ctx.e(1));
</span><span class='line'>    }
</span><span class='line'>    public Integer visitInt(LExprParser.IntContext ctx) {
</span><span class='line'>        return Integer.valueOf(ctx.INT().getText());
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>EvalVisitor从ANTLR生成的AbstractParseTreeVisitor类继承通用的visit()方法，我们的访问者使用它去准确地触发子树访问。</p>

<p>注意，EvalVisitor没有针对规则s的访问者方法。在LExprBaseVisitor中的visitS()的默认实现调用预定义的方法ParseTreeVisitor.visitChildren(). visitChildren()返回从最后的子节点访问返回的值。在这里，visitS()返回访问它唯一的子节点（节点e）时返回的表达式的值。我们可以使用这种默认的行为。</p>

<p>在测试文件TestLEvalVisitor.java中，我们有常用代码去启动LExprParser和打印语法分析树，然后我们需要编码去启动EvalVisitor和打印出当访问树时计算出的表达式的值。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>EvalVisitor evalVisitor = new EvalVisitor();
</span><span class='line'>int result = evalVisitor.visit(tree);
</span><span class='line'>System.out.println("visitor result = " + result);</span></code></pre></td></tr></table></div></figure>

<p>要构建计算器，需要告诉ANTLR使用-visitor参数去生成访问者。（如果我们不再需要生成监听器，可以使用-no-listener参数）以下是完整的构建和测试序列：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>antlr -visitor LExpr.g
</span><span class='line'>compile *.java
</span><span class='line'>run TestLEvalVisitor</span></code></pre></td></tr></table></div></figure>

<p>接着输入以下内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1+2*3
</span><span class='line'>EOF</span></code></pre></td></tr></table></div></figure>

<p>你就会看到如下结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(s (e (e 1) + (e (e 2) * (e 3))))
</span><span class='line'>visitor result = 7</span></code></pre></td></tr></table></div></figure>

<p>如果我们需要特定应用的返回值，访问者工作的相当好，因为我们使用了内建的Java返回值机制。如果我们不希望显式地调用访问者方法去访问子节点，我们可以切换到监听器机制，不幸的是，这意味着我们要放弃使用Java方法返回值的整洁。</p>

<h4 id="使用栈模拟返回值">使用栈模拟返回值</h4>

<p>ANTLR生成的监听器事件方法没有返回值。为了给在语法分析树更高节点上执行的监听器方法返回值，我们可以把部分的值存储在监听器的一个字段中。我们会想到用栈来存储值，方法就是把计算一个子表达式的结果推送到栈中，在语法分析树上用于子表达式的方法则把运算元从栈中弹出。以下是完整的Evaluator计算器监听器（代码在TestLEvaluator.java文件中）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static class Evaluator extends LExprBaseListener {
</span><span class='line'>    Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
</span><span class='line'>    public void exitMult(LExprParser.MultContext ctx) {
</span><span class='line'>        int right = stack.pop();
</span><span class='line'>        int left = stack.pop();
</span><span class='line'>        stack.push(left * right);
</span><span class='line'>    }
</span><span class='line'>    public void exitAdd(LExprParser.AddContext ctx) {
</span><span class='line'>        int right = stack.pop();
</span><span class='line'>        int left = stack.pop();
</span><span class='line'>        stack.push(left + right);
</span><span class='line'>    }
</span><span class='line'>    public void exitInt(LExprParser.IntContext ctx) {
</span><span class='line'>        stack.push(Integer.valueOf(ctx.INT().getText()));
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>要测试上面的这段代码，我们可以创建和使用在代码TestLEvaluator中的ParseTreeWalker，以下是完整的构建和测试序列：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>antlr LExpr.g
</span><span class='line'>compile *.java
</span><span class='line'>run TestLEvaluator</span></code></pre></td></tr></table></div></figure>

<p>接着输入以下内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1+2*3
</span><span class='line'>EOF</span></code></pre></td></tr></table></div></figure>

<p>你就会看到如下结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(s (e (e 1) + (e (e 2) * (e 3))))
</span><span class='line'>stack result = 7</span></code></pre></td></tr></table></div></figure>

<p>使用栈字段有点别扭但工作得很好。我们必须确保事件方法以正确的顺序压入和弹出跨越监听器事件的值。带有返回值的访问者没有栈的这种笨拙但却需要手工访问树的节点。第三种实现是通过把部分值隐藏在树节点中来捕获它们。</p>

<h4 id="注解语法分析树">注解语法分析树</h4>

<p>作为使用临时存储在事件方法间共享数据的替代，我们可以把这些值存储在语法分析树本身中。使用树注解方法时我们可以带有监听器或访问者，但在这里我们使用监听器来阐明如何使用它。让我们首先看一下用部分结果注解的1+2*3的LExpr语法分析树。</p>

<p><img src="/uploads/lexpr-parse-tree.png" title="lexpr-parse-tree" ></p>

<p>每个子表达式对应一个子树根（和对应一个e规则调用）。从e节点发出的水平线指向的数字是我们想要返回的部分结果。</p>

<p>让我们看看节点注解策略将如何工作在来自LExpr语法的规则e上。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>e : e MULT e    # Mult
</span><span class='line'>  | e ADD e     # Add
</span><span class='line'>  | INT         # Int
</span><span class='line'>  ;</span></code></pre></td></tr></table></div></figure>

<p>e选项的监听器方法每个都会存储一个结果在相对应的e语法分析树节点中。任何随后的在语法分析树更高节点上的add或multiply事件将通过查看存储在它们对应的子节点中的值来抓取子表达式的值。</p>

<p>现在，让我们假设每个语法分析树节点（每个规则上下文对象）都有一个字段value，那么exitAdd()看起来将是这样；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void exitAdd(LExprParser.AddContext ctx) {
</span><span class='line'>    // e(0).value is the subexpression value of the first e in the alternative
</span><span class='line'>    ctx.value = ctx.e(0).value + ctx.e(1).value;    // e '+' e # Add
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>这看起来相当合理，但不幸的是，在Java中我们不能扩展类ExprContext去动态地添加字段。为了让语法分析树注解生效，我们需要一种方法去注解各式各样的节点而不需要手工修改由ANTLR生成的关联节点类。</p>

<p>注解语法分析树节点最简单的方式是使用与节点任意值相关联的一个Map。因此，ANTLR提供了一个简单的帮助类ParseTreeProperty。让我们在文件TestLEvaluatorWithProps.java中构建称作EvaluatorWithProps的另一个计算器版本，它使用ParseTreeProperty关联了LExpr语法分析树节点和部分结果。以下是在监听器开始处的适当的定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static class EvaluatorWithProps extends LExprBaseListener {
</span><span class='line'>    /** maps nodes to integers with Map&lt;ParseTree,Integer&gt; */
</span><span class='line'>    ParseTreeProperty&lt;Integer&gt; values = new ParseTreeProperty&lt;Integer&gt;();</span></code></pre></td></tr></table></div></figure>

<p>注意：如果你想使用自己的Map类型字段代替ParseTreeProperty，确保它继承自IdentityHashMap，而不是通常的HashMap。我们需要去注解特殊的节点，进行同一性测试而不是equals()。两个e节点可能是equals()，但在内存中不是同一个物理节点。</p>

<p>为注解一个节点，我们使用values.put(node, value)。为得到和一个节点有关联的值，我们使用values.get(node)。这很好，但是让我们创建一些有直白名字的帮助方法以便让代码更容易阅读。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void setValue(ParseTree node, int value) { values.put(node, value); }
</span><span class='line'>public int getValue(ParseTree node) { return values.get(node); }</span></code></pre></td></tr></table></div></figure>

<p>让我们从最简单的表达式选项Int开始监听器方法。我们想使用它匹配的INT记号的整型值去注解它的语法分析树e节点。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void exitInt(LExprParser.IntContext ctx) {
</span><span class='line'>    String intText = ctx.INT().getText();    // INT    # Int
</span><span class='line'>    setValue(ctx, Integer.valueOf(intText));
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>对于加法树，我们得到两个子表达式子节点的值（运算元）和带有和的注释的子树跟。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void exitAdd(LExprParser.AddContext ctx) {
</span><span class='line'>    int left = getValue(ctx.e(0));    // e '+' e    # Add
</span><span class='line'>    int right = getValue(ctx.e(1));
</span><span class='line'>    setValue(ctx, left + right);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>方法exitMult()是相同的，只是运算的时候用multiply代替了add。</p>

<p>我们的测试代码从分析规则s开始。因此我们必须确保语法分析树根有e子树的值。为把值从e节点冒泡到根s节点，我们实现了exitS()。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/** Need to pass e's value out of rule s : e ; */
</span><span class='line'>public void exitS(LExprParser.SContext ctx) {
</span><span class='line'>    setValue(ctx, getValue(ctx.e()));    // like: int s() { return e(); }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>以下是如何启动监听器以及打印出来自语法分析树根节点的表达式的值：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ParseTreeWalker walker = new ParseTreeWalker();
</span><span class='line'>EvaluatorWithProps evalProp = new EvaluatorWithProps();
</span><span class='line'>walker.walk(evalProp, tree);
</span><span class='line'>System.out.println("properties result = " + evalProp.getValue(tree));</span></code></pre></td></tr></table></div></figure>

<p>以下是构建和测试序列：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>antlr LExpr.g
</span><span class='line'>compile *.java
</span><span class='line'>run TestLEvaluatorWithProps</span></code></pre></td></tr></table></div></figure>

<p>接着输入以下内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1+2*3
</span><span class='line'>EOF</span></code></pre></td></tr></table></div></figure>

<p>你就会看到如下结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(s (e (e 1) + (e (e 2) * (e 3))))
</span><span class='line'>stack result = 7</span></code></pre></td></tr></table></div></figure>

<p>现在我们已经看到了相同计算器的3个实现，并且我们也已经准备好把我们的知识用于构建真实案例。因为每个方法都有它的优势和劣势，下面就让我们来比较下不同的技术。</p>

<h3 id="比较信息共享方法">比较信息共享方法</h3>

<p>为得到可复用和可重定目标的语法，我们需要让它们完全清除用户定义的动作。这意味着要把所有特定应用的代码放到语法外的某些监听器和访问者中。监听器和访问者操作语法分析树，ANTLR自动生成合适的树遍历接口和默认实现。因为事件方法签名是固定的和不特定于应用的，所以事件方法可以共享信息的方式有3种：</p>

<ul>
<li>本地Java调用栈：访问者返回用户定义类型的一个值。如果访问者需要传递参数，它也必须使用下面两种技术的一种。</li>
<li>基于栈：一个栈字段模仿参数和返回值，像Java调用栈那样。</li>
<li>注解者：一个Map字段使用有用的值注解节点。</li>
</ul>

<p>所有这3种方法是和语法本身完全解耦的，并且很好地封装在专门的对象中。除此之外，它们也都有各自的优点和缺点。我们可以根据问题的需要和个人的喜好决定采取哪种方法。你甚至可以在同一个应用中使用多种方法。</p>

<p>访问者方法很好懂，因为它们直接调用其它访问者方法去获取部分结果，并且能像其它任何方法那样返回值。这也是它们的缺点，访问者方法必须显式地访问它们的子节点。而监听器就不需要。因为访问者有个通用的接口，所以它不能定义参数。访问者必须使用其它解决方案的一种去传递参数给它在子节点上调用的访问者方法。访问者的空间效率很好，因为它在任何时间仅需保留少数的部分结果。在树遍历后没有部分结果保留。当访问者方法可以返回值时，每个值必须是同种类型，不想其它的解决方案。</p>

<p>基于栈的解决方案可以模仿参数和返回带有一个栈的值，但在手动管理栈时有个断开的机会。这可能会发生，因为监听器方法不能直接调用彼此。作为程序员，我们必须确定推入栈中的在将来事件方法调用能适当地弹出。栈可以传递多个值和多个返回值。基于栈的解决方案也是空间有效的，因为它不会把任何东西固定到树上。在树遍历后所有的部分结果存储消失。</p>

<p>注解者通常可以作为默认解决方案采用，因为它允许你任意地提供信息给事件方法操作语法分析树中上上下下的节点。你也可以传递多个值，它们可以是任意类型。在许多情况下注解胜于使用带有短暂值的栈。在各种方法的数据传递准备间很少有断开的机会。比起在编程语言中说返回值，使用setValue(ctx, value)注解树不太直观，但是更通用。超过其它两种的这种方法的唯一缺点是在树遍历期间部分结果是保留的，因此它有较大的内存占用。</p>

<p>从另一方面来说，在某些应用中能够注解树正是我们需要的。应用需要在树上通过多遍，第一遍是很方便在树上计算和储存数据的。当语法分析树遍历器重新遍历树的时候第二遍然后就很容易访问数据。总的来说，树注解非常灵活，有一个可接受的内存负担。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/reading-notes-the-definitive-antlr4-reference-part23/">ANTLR 4权威参考读书笔记（23）</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-08-16T18:09:05+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>16</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>6:09 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>默认情况下，ANTLR为每个规则生成一个单一的事件类型，而不管语法分析器匹配了哪个选项。这很不方便，因为监听器和访问者方法必须确定哪个选项被语法分析器匹配。在本节中，我们将看到如何得到更细粒度的事件。</p>

<h3 id="为规则选项贴标签以得到精确的事件方法">为规则选项贴标签以得到精确的事件方法</h3>

<p>为阐明事件粒度问题，让我们为以下的表达式语法构建一个带有监听器的简单计算器：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grammar Expr;
</span><span class='line'>s : e ;
</span><span class='line'>e : e op=MULT e    // MULT is '*'
</span><span class='line'>  | e op=ADD e     // ADD is '+'
</span><span class='line'>  | INT
</span><span class='line'>  ;</span></code></pre></td></tr></table></div></figure>

<p>按照上面的语法，规则e会产生一个相当无用的监听器，因为规则e的所有选项导致树遍历器触发相同的enterE()和exitE()方法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public interface ExprListener extends ParseTreeListener {
</span><span class='line'>    void enterE(ExprParser.EContext ctx);
</span><span class='line'>    void exitE(ExprParser.EContext ctx);</span></code></pre></td></tr></table></div></figure>

<p>监听器方法必须使用op记号标签和ctx的方法进行测试以查看语法分析器为每个e子树匹配了哪个选项。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void exitE(ExprParser.EContext ctx) {
</span><span class='line'>    if (ctx.getChildCount() == 3) {    // operations have 3 children
</span><span class='line'>        int left = values.get(ctx.e(0));
</span><span class='line'>        int right = values.get(ctx.e(1));
</span><span class='line'>        if (ctx.op.getType() == ExprParser.MULT) {
</span><span class='line'>            values.put(ctx, left * right);
</span><span class='line'>        } else {
</span><span class='line'>            values.put(ctx, left + right);
</span><span class='line'>        }
</span><span class='line'>    } else {
</span><span class='line'>        values.put(ctx, values.get(ctx.getChild(0)));    // an INT
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>在exitE()中引用的MULT字段是在ExprParser中由ANTLR自动生成的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class ExprParser extends Parser {
</span><span class='line'>    public static final int MULT=1, ADD=2, INT=3, WS=4;</span></code></pre></td></tr></table></div></figure>

<p>如果我们查看在类ExprParser中的类EContext，我们可以看到ANTLR把来自3个选项的所有元素都塞进了相同的上下文对象。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static class EContext extends ParserRuleContext {
</span><span class='line'>    public Token op;                     // derived from label op
</span><span class='line'>    public List&lt;EContext&gt; e() { ... }    // get all e subtrees
</span><span class='line'>    public EContext e(int i) { ... }     // get ith e subtree
</span><span class='line'>    public TerminalNode INT() { ... }    // get INT node if alt 3 of e</span></code></pre></td></tr></table></div></figure>

<p>为得到更精确的监听器事件，ANTLR让我们使用#运算符给任何规则最外层的选项打标签。让我们从Expr派生语法LExpr，并给e的选项打上标签，以下是修改后的e规则：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>e : e MULT e  # Mult
</span><span class='line'>  | e ADD e   # Add
</span><span class='line'>  | INT       # Int
</span><span class='line'>  ;</span></code></pre></td></tr></table></div></figure>

<p>现在，ANTLR为e的每个选项生成了单独的监听器方法，因此，我们不再需要op记号标签。对于选项标签X，ANTLR生成方法enterX()和exitX()。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public interface LExprListener extends ParseTreeListener {
</span><span class='line'>    void enterMult(LExprParser.MultContext ctx);
</span><span class='line'>    void exitMult(LExprParser.MultContext ctx);
</span><span class='line'>    void enterAdd(LExprParser.AddContext ctx);
</span><span class='line'>    void exitAdd(LExprParser.AddContext ctx);
</span><span class='line'>    void enterInt(LExprParser.IntContext ctx);
</span><span class='line'>    void exitInt(LExprParser.IntContext ctx);
</span><span class='line'>    ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>注意，ANTLR也为选项生成特定的以标签命名的上下文对象（EContext的子类）。专门的上下文对象的getter方法只限于应用在那些相关的选项。例如，IntContext只有一个INT()方法，我们可以在enterInt()中调用ctx.INT()，但在enterAdd()中就不能。</p>

<p>监听器和访问者是极好的。我们只需要通过充实事件方法就可以得到可复用和可重定目标的语法以及封装的语言应用。ANTLR甚至会为我们自动生成骨架代码。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/how-to-create-effective-icons/">如何创建有效的图标</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-08-06T12:43:17+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>6</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>12:43 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>英文原文：<a href="http://www.awwwards.com/how-to-create-effective-icons.html">http://www.awwwards.com/how-to-create-effective-icons.html</a></p>

<p>我可能就是你所说的图标爱好者。我喜欢图标，而且我更加喜欢制作它们！作为一个艺术家，我的背景在很大程度上是绘画——我喜欢绘画，并且我已经画了一辈子（甚至远远早于我知道什么是图形设计）。我想，这是我理解创建图标的一个关键。绘画教你看——然后把你所看到的转化成纸上的线条和图形——而这正是如何创建有效的图标。</p>

<h3 id="几何图形">几何图形</h3>

<p>因此，对初学者而言，基本上任何东西都可以用这四种图形组合而成：</p>

<p><img src="/uploads/effective-icons-1.png" title="effective-icons-1" ></p>

<p>当我想把某事物转换成一个图标时，我观察它然后尽可能地将其拆分为最简单的图形。例如，水滴可以用一个三角形和一个圆形组成。</p>

<p><img src="/uploads/effective-icons-2.png" title="effective-icons-2" ></p>

<p>心形图标可以由两个圆形和一个三角形构成。</p>

<p><img src="/uploads/effective-icons-3.png" title="effective-icons-3" ></p>

<p>我每次都是在Adobe Illustrator中创建这些图形。使用矢量图形可以让我控制线条的粗细，以及图形和其锚点的相互作用。Illustrator也可以让我自由地把线条转换成图形，反之亦然。这一切也许看起来十分基础，但它是我用于创建最复杂图标的同样的方法。下面是我最近在做的一个略微更加复杂些的《权利法案》图标的示例，在这里我应用了同样的原则。</p>

<p><img src="/uploads/effective-icons-4.png" title="effective-icons-4" ></p>

<h3 id="界面图标">界面图标</h3>

<p>我最近有机会为一款超赞的iPhone应用Parker Planner制作一组图标。我很喜欢做这个项目，这个项目其中最重要的一个方面是创建一组易懂的、私有的、实用的和美观的用户界面图标，可以帮助用户浏览操作这款略微复杂的计划应用。</p>

<p><img src="/uploads/effective-icons-5.png" title="effective-icons-5" ></p>

<p>让我们选取这些图标的其中之一分解看看我如何创建它。例如，垃圾桶图标是由三个圆角矩形和三条线构成。</p>

<p>1、选择圆角矩形工具。</p>

<p><img src="/uploads/effective-icons-6.png" title="effective-icons-6" ></p>

<p>2、拖动出一个图形。</p>

<p><img src="/uploads/effective-icons-7.png" title="effective-icons-7" ></p>

<p>3、调整笔划宽度直到你满意。</p>

<p><img src="/uploads/effective-icons-8.png" title="effective-icons-8" ></p>

<p>我通常选择在整组图标中使用一到两种笔划宽度。</p>

<p><img src="/uploads/effective-icons-9.png" title="effective-icons-9" ></p>

<p>这使它们看起来更一致和感觉更有整体性。</p>

<p>4、用另一个圆角矩形创建盖子。</p>

<p><img src="/uploads/effective-icons-10.png" title="effective-icons-10" ></p>

<p>5、再一个圆角矩形创建盖子的把手。</p>

<p><img src="/uploads/effective-icons-11.png" title="effective-icons-11" ></p>

<p>6、擦除圆角矩形的下半部分。</p>

<p><img src="/uploads/effective-icons-12.png" title="effective-icons-12" ></p>

<p>7、现在，通过添加三条竖线到桶身上给桶添加条纹。</p>

<p><img src="/uploads/effective-icons-13.png" title="effective-icons-13" ></p>

<p>8、然后你就获得了它！一个垃圾桶图标……如果你喜欢，你可以用颜色或线条宽度做进一步调整。</p>

<p><img src="/uploads/effective-icons-14.png" title="effective-icons-14" ></p>

<p>我在创建图标时经常使用的一些其它真正有用的工具是Pathfinder，我使用它来剪切、连接和挖空图形。</p>

<p><img src="/uploads/effective-icons-15.png" title="effective-icons-15" ></p>

<p>Stroke/Fill工具，它帮助你将图形在填满和笔划间切换。</p>

<p><img src="/uploads/effective-icons-16.png" title="effective-icons-16" ></p>

<p>以及我非常喜欢的工具Stroke Panel，它帮助你将拐角和线的末端从直角转换到圆角。</p>

<p><img src="/uploads/effective-icons-17.png" title="effective-icons-17" ></p>

<p>当我完成一组图标，我通常将它们全体紧挨着排成一排，看看是否有哪个看起来很奇怪或不到位。然后我会做任何必要的修改。</p>

<p><img src="/uploads/effective-icons-18.png" title="effective-icons-18" ></p>

<p>最后，我总是在应用中测试它们以确保它们感觉正确和功能良好。</p>

<p><img src="/uploads/effective-icons-19.png" title="effective-icons-19" ></p>

<p>最终，我想说创建优秀图标的方法不仅仅是学习Illustrator技巧，尽管它们也是必需的。最好的做法是练习把你周围看到的事物分解成简单图形。你在这点上越是变得更好，你越是能够成为更高超的图像设计师！加油！</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/reading-notes-the-definitive-antlr4-reference-part22/">ANTLR 4权威参考读书笔记（22）</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-07-24T21:40:28+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>24</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>9:40 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>基于监听器的方法是极好的，因为所有树遍历和方法触发被自动完成。尽管有时候自动树遍历也是一个缺点，因为我们不能控制遍历本身。例如，我们可能想遍历一段C程序的语法分析树，通过跳过函数体子树忽略函数中的一切。监听器事件方法也不能使用方法返回值去传递数据。当我们需要控制遍历或返回带有事件方法返回值的值时，我们使用访问者模式。现在，让我们构建一个基于访问者版本的属性文件加载器去比较这两种方法。</p>

<h3 id="使用访问者实现应用">使用访问者实现应用</h3>

<p>使用访问者代替监听器，我们只需要让ANTLR生成访问者接口和实现接口，然后创建一段测试代码在语法分析树上调用visit()，根本不需要触及到语法。</p>

<p>在命令行使用-visitor参数时，ANTLR生成接口PropertyFileVisitor和类PropertyFileBaseVisitor，后者有如下的默认实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class PropertyFileBaseVisitor&lt;T&gt; extends AbstractParseTreeVisitor&lt;T&gt;
</span><span class='line'>                                        implements PropertyFileVisitor&lt;T&gt; {
</span><span class='line'>    @Override
</span><span class='line'>    public T visitFile(PropertyFileParser.FileContext ctx) { ... }
</span><span class='line'>    @Override
</span><span class='line'>    public T visitProp(PropertyFileParser.PropContext ctx) { ... }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>我们可以从监听器的exitProp()中拷贝映射功能，然后把它粘贴到与规则prop相关的访问者方法中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class TestPropertyFileVisitor {
</span><span class='line'>    public static class PropertyFileVisitor extends PropertyFileBaseVisitor&lt;Void&gt; {
</span><span class='line'>        Map&lt;String,String&gt; props = new OrderedHashMap&lt;String, String&gt;();
</span><span class='line'>        public Void visitProp(PropertyFileParser.PropContext ctx) {
</span><span class='line'>            String id = ctx.ID().getText();    // prop : ID '=' STRING '\n' ;
</span><span class='line'>            String value = ctx.STRING().getText();
</span><span class='line'>            props.put(id, value);
</span><span class='line'>            return null;    // Java says must return something even when Void
</span><span class='line'>        }
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>

<p>这里是访问者接口和类之间的继承关系：</p>

<p><img src="/uploads/propertyfile-visitor-hierachy.png" title="propertyfile-visitor-hierachy" ></p>

<p>访问者在子节点上通过显式地调用接口ParseTreeVisitor的visit()方法遍历语法分析树。那些方法在AbstractParseTreeVisitor中实现。在这里，为prop调用创建的节点没有子树，因此visitProp()不需要调用visit()。</p>

<p>在监听器和访问者的测试代码（例如TestPropertyFileVisitor）之间最大的不同是访问者的测试代码不需要ParseTreeWalker，它只需要让访问者去访问由语法分析器创建的树。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>PropertyFileVisitor loader = new PropertyFileVisitor();
</span><span class='line'>loader.visit(tree);
</span><span class='line'>System.out.println(loader.props);    // print results</span></code></pre></td></tr></table></div></figure>

<p>以下是构建和测试序列：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>antlr -visitor PropertyFile.g  # create visitor as well this time
</span><span class='line'>compile *.java
</span><span class='line'>run TestPropertyFileVisitor t.properties</span></code></pre></td></tr></table></div></figure>

<p>这里是输出的内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{user="parrt", machine="maniac"}</span></code></pre></td></tr></table></div></figure>

<p>我们可以使用监听器和访问者构建几乎任何我们想要的。一旦我们处于Java空间，就不再需要学习更多的ANTLR知识。我们只要知道语法、语法分析树、监听器和访问者事件方法之间的关系。除此之外，就是代码。在对识别中的输入短语的回答中，我们可以生成输出、收集信息、以某种方式验证短语，或者执行计算。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/reading-notes-the-definitive-antlr4-reference-part21/">ANTLR 4权威参考读书笔记（21）</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-07-14T18:38:42+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>14</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>6:38 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>前文的语法仍然存在问题，因为它限制我们只能使用Java生成语法分析器。为使语法可复用和语言无关，我们需要完全避免嵌入动作。接下来就将展示如何用监听器做到这点。</p>

<h3 id="使用语法分析树监听器实现应用">使用语法分析树监听器实现应用</h3>

<p>在构建语言应用时要避免应用和语法纠缠在一起，关键是让语法分析器生成语法分析树，然后遍历该树去触发特定的应用代码。我们可以使用我们最喜欢的技术遍历树，也可以使用ANTLR生成的树遍历机制中的一个。在本节中，我们将使用ANTLR内建的ParseTreeWalker构建一个基于监听器版本的属性文件应用。</p>

<p>让我们从属性文件语法的原始版本开始：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>file : prop+ ;
</span><span class='line'>prop : ID '=' STRING '\n' ;</span></code></pre></td></tr></table></div></figure>

<p>下面是属性示例文件t.properties的内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>user="parrt"
</span><span class='line'>machine="maniac"</span></code></pre></td></tr></table></div></figure>

<p>通过上述语法，ANTLR生成PropertyFileParser，该语法分析器会自动构建如下图所示的语法分析树：</p>

<p><img src="/uploads/propertyfile-parse-tree.png" title="propertyfile-parse-tree" ></p>

<p>有了语法分析树，我们就可以使用ParseTreeWalker去访问所有的节点，触发进入和退出方法。</p>

<p>现在来看一下ANTLR通过语法PropertyFile生成的监听器接口PropertyFileListener，当ANTLR的ParseTreeWalker发现和完成节点时，它会为每个规则子树分别触发进入和退出方法。因为在语法PropertyFile中只有两条语法规则，所以在接口中有4个方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public interface PropertyFileListener extends ParseTreeListener {
</span><span class='line'>    void enterFile(PropertyFileParser.FileContext ctx);
</span><span class='line'>    void exitFile(PropertyFileParser.FileContext ctx);
</span><span class='line'>    void enterProp(PropertyFileParser.PropContext ctx);
</span><span class='line'>    void exitProp(PropertyFileParser.PropContext ctx);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>FileContext和PropContext对象是针对每条语法规则的语法分析树节点的实现，它们包含一些有用的方法。</p>

<p>为方便起见，ANTLR也会生成带有默认实现的类PropertyFileBaseListener，这些默认实现模仿在前文语法中@member区域我们手写的空白方法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class PropertyFileBaseVisitor&lt;T&gt; extends AbstractParseTreeVisitor&lt;T&gt;
</span><span class='line'>                                        implements PropertyFileVisitor&lt;T&gt; {
</span><span class='line'>    @Override
</span><span class='line'>    public T visitFile(PropertyFileParser.FileContext ctx) { }
</span><span class='line'>    @Override
</span><span class='line'>    public T visitProp(PropertyFileParser.PropContext ctx) { }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>默认实现让我们只需要覆盖和实现那些我们关心的方法。例如，以下是属性文件加载器的一个重新实现，像前面那样它只有一个方法，但使用监听器机制：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static class PropertyFileLoader extends PropertyFileBaseListener {
</span><span class='line'>    Map&lt;String,String&gt; props = new OrderedHashMap&lt;String, String&gt;();
</span><span class='line'>    public void exitProp(PropertyFileParser.PropContext ctx) {
</span><span class='line'>        String id = ctx.ID().getText();    // prop : ID '=' STRING '\n' ;
</span><span class='line'>        String value = ctx.STRING().getText();
</span><span class='line'>        props.put(id, value);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>主要的不同是这个版本扩展了基类监听器，而不是语法分析器，监听器方法在语法分析器完成后被触发。</p>

<p>这里面有很多的接口和类，让我们看一下在这些关键元素间的继承关系。</p>

<p><img src="/uploads/propertyfile-listener-hierachy.png" title="propertyfile-listener-hierachy" ></p>

<p>处于ANTLR运行库中的接口ParseTreeListener要求每个监听器对事件visitTerminal()、enterEveryRule()和exitEveryRule()作出反应，如果有语法错误的还要加上visitErrorNode()。ANTLR从语法文件PropertyFile生成接口PropertyFileListener，并且为类PropertyFileBaseListener的所有方法生成默认实现。我们仅需要构建PropertyFileLoader，它继承了PropertyFileBaseListener中的所有空方法。</p>

<p>方法exitProp()可以访问与规则prop相关的规则上下文对象PropContext，该上下文对象持有在规则prop中提到的每个元素（ID和STRING）的对应方法。因为这些元素是语法中的记号引用，所以方法返回语法分析树节点TerminalNode。我们既可以通过getText()直接访问记号的文本，也可以通过getSymbol()首先获取Token。</p>

<p>现在让我们创建测试文件TestPropertyFile.java遍历树，倾听来自PropertyFileLoader的声音：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// create a standard ANTLR parse tree walker
</span><span class='line'>ParseTreeWalker walker = new ParseTreeWalker();
</span><span class='line'>// create listener then feed to walker
</span><span class='line'>PropertyFileLoader loader = new PropertyFileLoader();
</span><span class='line'>walker.walk(loader, tree);    // walk parse tree
</span><span class='line'>System.out.println(loader.props);    // print results</span></code></pre></td></tr></table></div></figure>

<p>然后就是编译和生成代码，运行测试程序去处理输入文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>antlr PropertyFile.g
</span><span class='line'>compile *.java
</span><span class='line'>run TestPropertyFile t.properties</span></code></pre></td></tr></table></div></figure>

<p>这里是输出的内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{user="parrt", machine="maniac"}</span></code></pre></td></tr></table></div></figure>

<p>测试程序成功地把文件中的属性赋值重组成内存中的映射数据结构。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/reading-notes-the-definitive-antlr4-reference-part20/">ANTLR 4权威参考读书笔记（20）</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-07-03T18:37:26+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2016</span></span> <span class='time'>6:37 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>单独的语法不是很有用，因为相关的语法分析器只能告诉我们某个输入句子是否遵守语言规格。为构建语言应用，我们需要语法分析器在看到特定的输入句子、短语或者记号时触发特定的动作。这些短语-动作对的集合表示语言应用或者至少是在语法和一个更大的周边应用之间的接口。</p>

<p>我们可以使用语法分析树监听器和访问者构建语言应用。监听器是一个响应规则进入和退出事件的对象，这些短语识别事件在语法分析树遍历器发现和完成节点时触发。为了支持应用必须控制树是如何被遍历的这种情况，ANTLR生成的语法分析树也支持著名的树访问者模式。</p>

<p>监听器和访问者之间最大的不同是，监听器方法不对显式地调用方法去遍历它们的子树负责，而访问者必须显式地触发访问子节点以保持树的遍历继续。通过这些显式的访问子树的调用，访问者控制遍历的顺序以及多少树被访问。为方便起见，我们使用术语“事件方法”来指代监听器回调或者访问者方法。</p>

<p>为了确切地知道ANTLR为我们构建了什么样的树遍历设施以及为什么，让我们首先看看监听器机制的起源以及如何使用监听器和访问者把特定应用的代码和语法分离。</p>

<h3 id="从嵌入动作演化到监听器">从嵌入动作演化到监听器</h3>

<p>监听器和访问者机制将语法从应用代码中解耦，提供了一些令人信服的好处。这种解耦很好地封装了应用程序，而不是把它切割成碎片分散到语法中的各个地方。没有嵌入动作，我们可以在不同的应用中复用相同的语法，甚至不需要重新编译生成的语法分析器。如果没有嵌入动作，ANTLR还可以用相同的语法生成不同编程语言的语法分析器。集成语法缺陷修复或更新也更容易，因为我们不必担心嵌入动作导致的合并冲突。</p>

<p>接下来，我们将探讨从带有嵌入动作的语法到完全解耦的语法和应用的演化。以下含有用«...»描述的嵌入动作的属性文件语法读取属性文件，每行一个属性赋值。像«start file»这样的动作只是Java代码适当的替代。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grammar PropertyFile;
</span><span class='line'>file : {«start file»} prop+ {«finish file»} ;
</span><span class='line'>prop : ID '=' STRING '\n' {«process property»} ;
</span><span class='line'>ID   : [a-z]+ ;
</span><span class='line'>STRING : '"' .*? '"' ;</span></code></pre></td></tr></table></div></figure>

<p>这样的紧密耦合把语法束缚到一个特定的应用上。一个更好的方法是创建由ANTLR生成的语法分析器PropertyFileParser的子类，然后把嵌入动作转换成方法。重构仅留下不重要的方法调用在语法中触发新创建方法的动作，然后，通过子类化语法分析器，我们可以实现任意数量的不同应用而无需修改语法。这样的重构看起来像：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grammar PropertyFile;
</span><span class='line'>@members {
</span><span class='line'>    void startFile() { }    // blank implementations
</span><span class='line'>    void finishFile() { }
</span><span class='line'>    void defineProperty(Token name, Token value) { }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>file : {startFile();} prop+ {finishFile();} ;
</span><span class='line'>prop : ID '=' STRING '\n' {defineProperty($ID, $STRING)} ;
</span><span class='line'>ID   : [a-z]+ ;
</span><span class='line'>STRING : '"' .*? '"' ;</span></code></pre></td></tr></table></div></figure>

<p>解耦可以让语法被不同的应用复用，但语法因为方法调用的关系仍然被绑定在Java上。</p>

<p>为演示已重构语法的复用性，让我们构建两个不同的应用。首先从遇到属性后只是打印它们的那个开始。这个过程只是去扩展由ANTLR生成的语法分析器类和覆盖一个或多个由语法触发的方法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class PropertyFilePrinter extends PropertyFileParser {
</span><span class='line'>    void defineProperty(Token name, Token value) {
</span><span class='line'>        System.out.println(name.getText() + "=" + value.getText());
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>由于ANTLR生成的PropertyFileParser类中的默认实现，我们不需要覆盖startFile()或finishFile()。</p>

<p>为了启动这个应用，我们需要创建一个特定的PropertyFilePrinter语法分析器子类的实例，而不是常规的PropertyFileParser的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>PropertyFileLexer lexer = new PropertyFileLexer(input);
</span><span class='line'>CommonTokenStream tokens = new CommonTokenStream(lexer);
</span><span class='line'>PropertyFilePrinter parser = new PropertyFilePrinter(tokens);
</span><span class='line'>parser.file();    // launch our special version of the parser</span></code></pre></td></tr></table></div></figure>

<p>作为第二个应用，我们把属性加载到一个映射中而不是打印它们。我们需要做的就是创建一个新的子类并把不同的功能放到defineProperty()中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class PropertyFileLoader extends PropertyFileParser {
</span><span class='line'>    Map&lt;String,String&gt; props = new OrderedHashMap&lt;String, String&gt;();
</span><span class='line'>    void defineProperty(Token name, Token value) {
</span><span class='line'>        props.put(name.getText(), value.getText());
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>在语法分析器执行完毕后，字段props将会包含名-值对。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/reading-notes-the-definitive-antlr4-reference-part19/">ANTLR 4权威参考读书笔记（19）</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-06-21T21:12:40+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>21</span><span class='date-suffix'>st</span>, <span class='date-year'>2016</span></span> <span class='time'>9:12 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><ul>
<li>component 构件</li>
</ul>

<p>因为词法规则可以使用递归，所以词法解析器在技术上和语法解析器一样强大。那意味着我们甚至可以在词法分析器中匹配语法结构。或者，在另一个极端，我们可以把字符当作记号，使用语法分析器去把语法结构应用到字符流（这种被称为无扫描语法分析器）。这导致什么在词法分析器中匹配和什么在语法分析器中匹配的界线在哪里并不是很明显。幸运的是，有几条经验法则可以让我们做出判断：</p>

<ul>
<li>在词法分析器中匹配和丢弃任何语法分析器根本不需要见到的东西。例如，在词法分析器中识别和扔掉像注释和空格这些东西。否则，语法分析器必须经常查看是否有注释或空格在记号间。</li>
<li>在词法分析器中匹配诸如标志符、关键字、字符串和数字这样的常用记号。语法分析器比词法分析器有更多的开销，因此，我们不必让语法分析器承受把数字放在一起识别成整数的负担。</li>
<li>把那些语法分析器不需要去辨别的词法结构合并成一个单独的记号类型。例如，如果我们的应用把整数和浮点数当作同一事物对待，然后把它们合并成记号类型NUMBER，那么就没必要向语法分析器发送单独的记号类型。</li>
<li>合并能被语法分析器视为一个单独实体的任何东西。例如，如果语法分析器不在乎XML标签里的内容，词法分析器可以把尖括号中的任何东西合并成一个单独的被称为TAG的记号类型。</li>
<li>如果语法分析器需要先拆开一小块文本后才能去处理它，那么词法分析器应该传递独立的构件作为记号给语法分析器。例如，如果语法分析器需要处理一个IP地址的元素，词法分析器应该发送IP构件（整数和点）的独立的记号。</li>
</ul>

<p>想象下现在需要处理Web服务器上的日志文件，每一行表示一条记录。让我们假设每条记录都有一个请求IP地址、HTTP协议命令和结果代码。这里是一个日志条目的示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>192.168.209.85 "GET /download/foo.html HTTP/1.0" 200</span></code></pre></td></tr></table></div></figure>

<p>如果想要统计文件中有多少行，那么我们可以忽略掉任何东西除了换行字符的序列：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>file  : NL+ ;               // 匹配换行符（NL）序列的语法规则
</span><span class='line'>STUFF : ~'\n'+ -&gt; skip ;    // 匹配和丢弃除'\n'外的任何东西
</span><span class='line'>NL    : '\n' ;              // 返回NL给语法分析器或调用代码</span></code></pre></td></tr></table></div></figure>

<p>词法分析器不必识别太多的结构，语法分析器会匹配换行记号的序列。</p>

<p>接下来，我们需要从日志文件中收集一系列的IP地址。这意味着我们需要一条规则去识别IP地址的词法结构。并且我们也可以提供其它记录元素的词法规则：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>IP    : INT '.' INT '.' INT '.' INT ;    // 192.168.209.85
</span><span class='line'>INT   : [0-9]+ ;                         // 匹配IP八位组或者HTTP结果代码
</span><span class='line'>STRING: '"' .*? '"' ;                    // 匹配HTTP协议命令
</span><span class='line'>NL    : '\n' ;                           // 匹配日志文件记录终结符
</span><span class='line'>WS    : ' ' -&gt; skip ;                    // 忽略空格</span></code></pre></td></tr></table></div></figure>

<p>拥有一套完整的记号后，我们可以让语法规则匹配日志文件中的记录：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>file : row+ ;                // 匹配日志文件中行的语法规则
</span><span class='line'>row  : IP STRING INT NL ;    // 匹配日志文件记录</span></code></pre></td></tr></table></div></figure>

<p>更进一步，我们需要把文本IP地址转换成32位的数字。使用便利的库函数split(&#39;.&#39;)，我们可以把IP地址切割成字符串传递给语法分析器让它去处理。但是，更好的做法是让词法分析器匹配IP地址的词法结构，然后把匹配出的构件作为记号传递给语法分析器。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>file  : row+ ;                           // 匹配日志文件中行的语法规则
</span><span class='line'>row   : ip STRING INT NL ;               // 匹配日志文件记录
</span><span class='line'>ip    : INT '.' INT '.' INT '.' INT ;    // 在语法分析器中匹配IP地址
</span><span class='line'>INT   : [0-9]+ ;                         // 匹配IP八位组或者HTTP结果代码
</span><span class='line'>STRING: '"' .*? '"' ;                    // 匹配HTTP协议命令
</span><span class='line'>NL    : '\n' ;                           // 匹配日志文件记录终结符
</span><span class='line'>WS    : ' ' -&gt; skip ;                    // 忽略空格</span></code></pre></td></tr></table></div></figure>

<p>把词法规则IP切换成语法规则ip显示了我们可以多么轻易地移动这条分界线。</p>

<p>如果要求处理HTTP协议命令字符串的内容，我们可以遵循相同的思考过程。如果不需要检查字符串的部分，那么词法分析器可以把整个字符串作为一个单独的记号传递给语法分析器。如果我们需要抽出各种不同的部分，最好就是让词法分析器去识别那些部分后再把这些匹配出的构件传递给语法分析器。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/reading-notes-the-definitive-antlr4-reference-part18/">ANTLR 4权威参考读书笔记（18）</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-06-14T11:56:18+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>14</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>11:56 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>编程语言在词法上看起来惊人地相似，无论是函数式、过程式、声明式还是面向对象语言，看起来几乎都是一样的。这很棒，因为我们只需要学习一次如何描述标志符和整数，没有太大的变化，就可以把它们应用到大多数编程语言上。正如语法分析器以及词法分析器使用规则去描述各种语言构造体一样，我们要使用基本相同的表示法。唯一的区别是语法分析器识别在记号流中的语法结构，而词法分析器识别在字符流中的语法结构。</p>

<p>因为词法分析和语法分析有相似的结构，ANTLR允许我们把两者合并在单个语法文件中。但是因为词法分析和语法分析是语言识别的两个不同阶段，我们必须告诉ANTLR每个规则是和哪个阶段相关联的。我们可以通过以大写字母开始的词法规则名字和以小写字母开始的语法规则名字做到这点。例如，ID是一个词法规则名字，expr则是一个语法规则名字。</p>

<p>当开始构建一个新的语法时，对于那些常用的词法构造体：标志符、数字、字符串、注释以及空格等，我们可以从已经存在的语法中拷贝粘贴规则。然后，通过一些细微的调整，就可以让它运行起来。几乎所有的语言，甚至像JSON和XML这样的非编程语言，都有这些记号的变体。例如，C语言的词法分析器完全可以标记化以下的JSON代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "title":"Cat wrestling",
</span><span class='line'>  "chapters":[ {"Intro":"..."}, ... ]
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>另一个例子就是块注释。在C语言中，它们是被/* ... */括起来的。而在XML里，注释是被&lt;!-- ... --&gt;括起来的。但它们除了开始和结束符号之外，或多或少都有相同的词法构造。</p>

<p>对于关键字、运算符和标点符号，我们不需要词法规则，因为我们可以在语法分析规则中直接引用它们，用单引号括起来，就像<code>&#39;while&#39;</code>、<code>&#39;*&#39;</code>、<code>&#39;++&#39;</code>这样。有些开发者更喜欢使用像MUL而不是字面量<code>&#39;*&#39;</code>这样的词法规则引用，这些都没问题，因为它们都有相同的记号类型。</p>

<p>为了阐明词法规则看起来像什么，让我们从标志符开始构建一个常用记号的简单版本。</p>

<h4 id="匹配标志符">匹配标志符</h4>

<p>在语法伪代码中，一个基本的标志符是由大写或小写字母组成的一个非空序列。根据已经学习到的知识，我们知道需要用(...)+表示法来表示这样的序列模式。因为序列元素可以是大写或小写字母，所以在子规则中我们需要使用选择运算符：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ID : ('a'..'z'|'A'..'Z')+ ;    // 匹配一个或多个大小写字母</span></code></pre></td></tr></table></div></figure>

<p>唯一的新ANTLR表示法是范围运算符：&#39;a&#39;..&#39;z&#39;代表从a到z的任意字符。或者你也可以使用Unicode码位字面量&#39;\uXXXX&#39;，这里的XXXX是Unicode字符码位值的十六进制值。</p>

<p>作为字符集的一个简写，ANTLR支持我们使用更熟悉的正则表达式集合表示法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ID : [a-zA-Z]+ ;    // 匹配一个或多个大小写字母</span></code></pre></td></tr></table></div></figure>

<p>有时候我们会发现像下面这样的语法貌似存在冲突的现象：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enumDef : 'enum' '{' ... '}' ;
</span><span class='line'>FOR : 'for' ;
</span><span class='line'>ID : [a-zA-Z]+ ;    // 不匹配'enum'或者'for'</span></code></pre></td></tr></table></div></figure>

<p>规则ID也可以同时匹配enum和for这样的关键字，这意味着同样的字符串能被多个规则匹配。但事实上，ANTLR处理这种混合语法时会把字符串字面量以及词法规则与语法规则分隔开，像enum这样的字面量就变成了词法规则并紧随在语法规则之后和在显式的词法规则之前。</p>

<p>ANTLR词法分析器通过偏爱首先指定的规则来解决词法规则间的二义性，这意味着ID规则应该定义在所有的关键字规则之后。ANTLR把隐式的为字面量生成的词法规则放在显式的词法规则之前，因此它们总是有更高的优先级。在这里，&#39;enum&#39;被自动赋予比ID高的优先级。</p>

<p>因为ANTLR总是会重新排序词法规则并让它们在语法规则之后发生。所以上面的语法与下面的变体是相同的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>FOR : 'for' ;
</span><span class='line'>ID : [a-zA-Z]+ ;    // 不匹配'enum'或者'for'
</span><span class='line'>enumDef : 'enum' '{' ... '}' ;</span></code></pre></td></tr></table></div></figure>

<h4 id="匹配数字">匹配数字</h4>

<p>描述像10这样的整型数字非常容易，因为它只是一个数字序列。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>INT : '0'..'9'+ ;    // 匹配一个或多个数字</span></code></pre></td></tr></table></div></figure>

<p>或者</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>INT : [0..9]+ ;    // 匹配一个或多个数字</span></code></pre></td></tr></table></div></figure>

<p>浮点数要复杂的多，但如果我们忽略指数的话，可以很容易地制作一个简化版本。浮点数是数字序列后面跟着一个句点和一个可选的小数部分；或者以一个句点开始，然后是数字序列。单独一个句点是不合法的。因此我们的浮点规则使用一个选择和一些序列模式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>FLOAT: DIGIT+ '.' DIGIT*    // 匹配1. 39. 3.14159等等
</span><span class='line'>     | '.' DIGIT+           // 匹配.1 .14159
</span><span class='line'>     ;
</span><span class='line'>
</span><span class='line'>fragment
</span><span class='line'>DIGIT: [0-9] ;              // 匹配单个数字</span></code></pre></td></tr></table></div></figure>

<p>这里我们使用了一个帮助规则DIGIT，因此我们不必到处去写[0-9]。通过在规则前面加上fragment前缀，我们让ANTLR知道该规则仅被其它词法规则使用。它本身不是一个记号，这意味着我们不能在语法规则中引用它。</p>

<h4 id="匹配字符串字面量">匹配字符串字面量</h4>

<p>计算机语言中共同具有的下一个常用记号是字符串字面量，例如&quot;hello&quot;。大部分使用双引号作分隔符，有些使用单引号或者两者都使用。以双引号为分隔符而言，在语法伪代码中，一个字符串就是在双引号中的任意字符序列：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>STRING : '"' .*? '"' ;    // 匹配在双引号中的任意字符</span></code></pre></td></tr></table></div></figure>

<p>语法中的点是通配符运算符，它可以匹配任意单个字符。因此，“<code>.*</code>”是一个能够匹配任意零个或多个字符的序列的循环。当然，它也将消费字符直到文件结尾，所以不是很有用。幸运的是，ANTLR通过正则表达式表示法（?后缀）提供对非贪婪模式规则的支持。非贪婪模式意味着“直到看见在词法规则中跟在子规则后的字符时才停止吃掉字符”。更确切地说，非贪婪模式规则匹配最小数量的字符，同时仍然允许整个周围的规则被匹配。相反，“<code>.*</code>”被认为是贪婪模式，因为它贪婪地消费能够匹配循环内部的所有字符。</p>

<p>以上的STRING规则做得还不够好，因为它不允许字符串中有双引号。为了做到这点，大部分语言定义了以反斜杠开始的转义字符。在字符串中的双引号我们可以使用“\&quot;”。为支持常用的转义字符，我们需要使用以下规则：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>STRING: '"' (ESC|.)*? '"' ;
</span><span class='line'>
</span><span class='line'>fragment
</span><span class='line'>ESC : '\\"' | '\\\\' ;    // 匹配字符\"和\\</span></code></pre></td></tr></table></div></figure>

<p>ANTLR自身也需要避开转义字符，所以这里我们需要用“\”去指定反斜杠字符。</p>

<p>现在，在STRING规则中的循环既可以通过调用fragment规则ESC去匹配转义字符序列，也可以通过点通配符去匹配任意字符。当看到一个非转义双引号字符时，“<code>*?</code>”子规则运算符终止“<code>(ESC|.)*?</code>”循环。</p>

<h4 id="匹配注释和空格">匹配注释和空格</h4>

<p>词法分析器会把匹配到的记号通过记号流传递给语法分析器，然后语法分析器检查流的语法结构。但我们希望当词法分析器匹配到注释和空格时能把它们扔掉。那样，语法分析器就不必为匹配无处不在的可选的注释和空格担心。例如，当WS是一个空格的词法规则时以下的语法规则就非常尴尬和容易出错：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>assign : ID (WS|COMMENT)? '=' (WS|COMMENT)? expr (WS|COMMENT)? ;</span></code></pre></td></tr></table></div></figure>

<p>定义这些被丢弃的记号和定义非丢弃的记号一样，我们只需要使用skip指令去表明词法分析器应该扔掉它们。以下是匹配那些衍生自C的语言的单行和多行注释的语法规则：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>LINE_COMMENT : '//' .*? '\r'? '\n' -&gt; skip ;    // 匹配"//" stuff '\n'
</span><span class='line'>COMMENT      : '/*' .*? '*/'       -&gt; skip ;    // 匹配"/*" stuff "*/"</span></code></pre></td></tr></table></div></figure>

<p>在COMMENT中，“<code>.*?</code>”消费在“<code>/*</code>”和“<code>*/</code>”之间的任意字符。在LINE_COMMENT中，“<code>.*?</code>”消费“//”之后的任意字符，直到它看到一个换行符。</p>

<p>词法分析器接受若干跟随在-&gt;运算符后的指令，skip只是它们中的一个。例如，我们可以通过使用channel指令把传递给语法分析器的记号放进隐藏通道。</p>

<p>最后，让我们处理空格（换行符等也被当作空格）这个常用记号。大部分编程语言都把空格当作记号分隔符，但是另一方面又忽略它们。（Python是个例外，因为它把空格用作特殊语法目的：终止命令和缩进级别的换行符。）以下是告诉ANTLR如何扔掉空格的语法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>WS : (' '|'\t'|'\r'|'\n')+ -&gt; skip ;    // 匹配一个或多个空格但丢弃</span></code></pre></td></tr></table></div></figure>

<p>或者</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>WS : [ \t\r\n]+ -&gt; skip ;    // 匹配一个或多个空格但丢弃</span></code></pre></td></tr></table></div></figure>

<p>当换行符既是要被忽略的空格又是命令终结符时，就会有个问题。换行符是上下文有关的，在语法上下文中，我们要扔掉换行符，但在其它地方，我们需要把它传递给语法分析器以便让它知道某个命令已经结束。例如，在Python中，后面有换行符的f()会执行代码，调用f()方法，但是如果我们在括号中也插入一个额外的换行符，Python就会在执行调用前等待直到右括号后面的换行符为止。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/3">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/index.html">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/the-impact-github-is-having-on-your-software-career-right-now/">GitHub对软件职业生涯的影响</a>
      </li>
    
      <li class="post">
        <a href="/blog/how-to-modify-hosts-in-android/">如何修改Android的hosts文件</a>
      </li>
    
      <li class="post">
        <a href="/blog/chess-mess-master-development-record-part2/">象棋残局大师开发实录（2）</a>
      </li>
    
      <li class="post">
        <a href="/blog/chess-mess-master-development-record-part1/">象棋残局大师开发实录（1）</a>
      </li>
    
      <li class="post">
        <a href="/blog/the-perils-of-shared-code/">共享代码的风险</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>Recent Comments</h1>
  <div class="dsq-widget">
    <script type="text/javascript" src="http://codemany.disqus.com/recent_comments_widget.js"></script>
  </div>
</section>
<section>
  <h1>Tags</h1>
  <ul class="tag-cloud">
    <a style="font-size: 144%" href="/tags/antlr/">ANTLR</a>
<a style="font-size: 107%" href="/tags/algorithm/">Algorithm</a>
<a style="font-size: 135%" href="/tags/android/">Android</a>
<a style="font-size: 104%" href="/tags/c-plus-plus/">C++</a>
<a style="font-size: 107%" href="/tags/css/">CSS</a>
<a style="font-size: 110%" href="/tags/crack/">Crack</a>
<a style="font-size: 107%" href="/tags/database/">Database</a>
<a style="font-size: 97%" href="/tags/eclipse/">Eclipse</a>
<a style="font-size: 115%" href="/tags/git/">Git</a>
<a style="font-size: 97%" href="/tags/html/">HTML</a>
<a style="font-size: 104%" href="/tags/jbookshelf/">JBookShelf</a>
<a style="font-size: 148%" href="/tags/java/">Java</a>
<a style="font-size: 101%" href="/tags/javascript/">JavaScript</a>
<a style="font-size: 97%" href="/tags/listview/">ListView</a>
<a style="font-size: 104%" href="/tags/mysql/">MySQL</a>
<a style="font-size: 97%" href="/tags/paperclip/">Paperclip</a>
<a style="font-size: 119%" href="/tags/powerbuilder/">PowerBuilder</a>
<a style="font-size: 101%" href="/tags/powerscript/">PowerScript</a>
<a style="font-size: 117%" href="/tags/qianbao/">Qianbao</a>
<a style="font-size: 150%" href="/tags/rails/">Rails</a>
<a style="font-size: 119%" href="/tags/ruby/">Ruby</a>
<a style="font-size: 97%" href="/tags/spring/">Spring</a>
<a style="font-size: 101%" href="/tags/struts/">Struts</a>
<a style="font-size: 137%" href="/tags/translation/">Translation</a>
<a style="font-size: 97%" href="/tags/ubuntu/">Ubuntu</a>
<a style="font-size: 107%" href="/tags/windows-server-2008/">Windows Server 2008</a>
<a style="font-size: 107%" href="/tags/wxwidgets/">wxWidgets</a>

  </ul>
</section>
<section>
  <h1>Blogroll</h1>
  <ul>
    <li><a href="http://mindhacks.cn/">刘未鹏MIND HACKS</a></li>
    <li><a href="http://www.importnew.com/">ImportNew</a></li>
    <li><a href="http://ifeve.com/">并发编程网</a></li>
    <li><a href="http://codingnow.com/">云风的 BLOG</a></li>
    <li><a href="http://dbanotes.net/">DBA Notes</a></li>
    <li><a href="http://www.ruanyifeng.com/blog/">阮一峰的网络日志</a></li>
    <li><a href="http://advdbg.org/">高端调试</a></li>
    <li><a href="http://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualization</a></li>
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/dohkoos">@dohkoos</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'dohkoos',
            count: 5,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>

<section>
  <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
  <div>This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.</div>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2017 - dohkoos -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'codemany';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





</body>
</html>
