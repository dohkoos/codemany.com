
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>乐者为王</title>
  <meta name="author" content="dohkoos">

  
  <meta name="description" content="英文原文：https://www.nemil.com/musings/shinyandnew.html 有关当前最好的框架或编程语言的争论经常发生在Web开发中。就这点而言，Scribd的联合创始人Jared Friedman在2015年写了一篇文章推荐创业公司使用Node.js代替Rails。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://codemany.com/posts/2/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="乐者为王" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-46570161-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">乐者为王</a></h1>
  
    <h2>Do one thing, and do it well.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="codemany.com">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/chasing-the-shiny-and-new-in-software/">追逐时髦的技术</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2017-08-29T11:50:09+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>29</span><span class='date-suffix'>th</span>, <span class='date-year'>2017</span></span> <span class='time'>11:50 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>英文原文：<a href="https://www.nemil.com/musings/shinyandnew.html">https://www.nemil.com/musings/shinyandnew.html</a></p>

<p>有关当前最好的框架或编程语言的争论经常发生在Web开发中。就这点而言，<a href="https://www.scribd.com/">Scribd</a>的联合创始人Jared Friedman在2015年写了<a href="http://blog.jaredfriedman.com/2015/09/15/why-i-wouldnt-use-rails-for-a-new-company/">一篇文章</a>推荐创业公司使用Node.js代替Rails。</p>

<p>他提出几个关键点：</p>

<ul>
<li>Rails很慢。</li>
<li>黑客学院的毕业生都在使用Rails，贬低了它对高级工程师的价值，并减少了它的未来前景。</li>
<li>创业公司应该使用那些前瞻性工程师今后将使用的技术，以保证它们的应用不过时。</li>
<li>在Scribd，过去几年里它们已经从Prototype转换到jQuery，再到CoffeeScript，再到Angular，再到React。</li>
</ul>

<p>Node.js是创业公司的绝佳选择，但它饱受批评的两个部分令我担忧。首先，一名创业公司的工程师应该了解什么技术将会在几年后流行，以保证它们的技术栈不过时。第二，杰出的软件工程师将被时髦的技术栈吸引到创业公司，而不是有趣的技术问题。在过去我还听到过更恶劣的传闻，创业公司的开发者拒绝接受使用ES5 JavaScript编程的工作（那时CoffeeScript刚出来），Mongo发布不久工程师就执意在生产环境下使用Mongo替代Postgres，渴望用最新的前端框架不断重构项目。</p>

<p>我担心有些程序员（和他们的雇主）有这种倾向，即把注意力放在转换技术栈到最新上。他们主要基于框架选择公司，力求在工作中使用最新而不是最好的工具。他们把时间花在新的库和框架上，而不是提高他们的核心技术能力。我们把他们称为技术栈追逐者——他们奋力追求在创业公司的技术栈中使用那些对核心输出（用户重视的软件功能、开发团队的生产力）提升有限的新技术（或者他们自己喜欢的技术）。</p>

<h3 id="“时髦的”web开发">“时髦的”Web开发</h3>

<p>很同情那些在<a href="https://news.ycombinator.com/">Hacker News</a>上的时髦的Web或移动应用开发者。作为在2012年的全栈创业公司的开发者，你正在构建后端使用Ruby/Rails，前端使用Backbone/CoffeeScript/Underscore的网站，同时使用Capistrano（或相关的Python类似物）部署你的应用。到2013年，你已经将后端转换到Node/Express/Mongo，前端为Grunt/Ember。在2014年，你已经彻底切换到MEAN技术栈，但在尝试过Koa以后考虑转移到Go（在Express核心贡献者<a href="https://medium.com/@tjholowaychuk/farewell-node-js-4ba9e7f3e52b">告别Node.js转向Go</a>以后）。在2015年，你在后端使用Express/Go，前端使用Gulp/ES2015/React，使用React Native代替原生移动语言，并且慢慢地将系统转换为使用Docker的微服务。很快，你将会被转换到Phoenix，如果Angular 2是正确的选择也会转换过去——甚至可能创造一个Go可以工作在Android上以及开源Swift可以适合你的技术栈的世界。（我显然是夸大效果，尽管这是HN头条新闻流行什么的一个合理表示。）</p>

<p>有几个原因表明这可能是合理的。时髦的Web工程师需要“时尚”才能获得未来的工作或合同。雇主使用框架或语言作为过滤器，而不是测试批判性思维和技能。雇主没有意识到有实力的开发者如果有正确的支持，可以在几个星期，通常是几天内成为许多语言或者框架的专家。有时趋势是无法阻止的：Swift正在取代Objective-C，世界正在转向更薄、更小的单体后端和更重、反应更灵敏的前端。通常，转变有着巨大的优势：生产力大幅上升，或者新的用户功能突然变得可能。然而，所有的变化都不会导致早期到中期的公司不采用就死，而为了乐趣或业余项目学习技术和认为它是生产环境的关键是迥然不同的。</p>

<p>我们可以用创业公司的时髦的Web或移动开发者与我们的计算机科学家作为对比。我的一个朋友是一家顶级科技公司的计算机神经学家——跟几乎所有从事技术工作的人一样，他的世界每隔几个月就会被重塑——得益于计算能力、脑成像和深度学习算法的快速发展。基本的编程工具其实变化不大。公平地说，只有C++从 11转换到14引起了一些焦虑。还有分布式计算系统、键/值存储和其它外部服务，但这些都是使用稳定的API构建的。他的大部分时间都花在单个DSL中的架构和算法上，而不是重写功能相似的代码或者快速学习提供有争议的好处和改变的库。</p>

<h3 id="选择工具">选择工具</h3>

<p>人们可能会建议创业公司选择时髦的技术栈，因为它是招聘杰出的工程师的关键工具。我自己的观察是，杰出的工程师注重其它的东西。到目前为止，最重要的是提供有趣的问题去解决——有趣的人与他们合作。吸引力和强大的使命感是吸引优秀人才（工程师或者其他）的其它途径。</p>

<p>我并不是在抱怨技术发展太快，也不是说我们都应该用汇编语言或者C++或者Ruby编程。软件工程师清楚他们的目标——我们的领域以令人目眩的速度发展，但对于我们拥有的影响力这都是值得的，因为有10亿人上网。我认为你需要有能力快速地学会新的框架、语言或库（如何完成它的<a href="https://news.ycombinator.com/item?id=7733249">Ask HN</a>）——依靠周围那些经验丰富的工程师，你的目标应该是尽快地具有生产力。除此之外，你应该深刻理解多种语言，而不仅仅是一种（但是同样的态度，不应盲目地扩展到框架或者轻量级的DSL）。</p>

<p>对于创业公司而言，Paul Graham<a href="http://castig.org/an-interview-with-paul-graham-hackers-painters-10-years-later/">在2013年被问到关于理想的语言</a>：“我的意思是，我们有的创业公司在用PHP编写代码——这让我有点担心，但这并不像其它事情那么让我担心。”GitHub的技术主管Sam Lambert在<a href="https://medium.com/s-c-a-l-e/github-scaling-on-ruby-with-a-nomadic-tech-team-4db562b96dcd">最近的一次采访</a>中谈到，他在2013年被GitHub的CTO面试时，对GitHub的技术栈是Rails、C和Bash脚本感到惊讶：“随着面试的继续，我发现他们实际上是一群非常务实的黑客，他们只钻研Ruby和C，使用更稳定的技术栈以便花时间工作在更有趣的事情上，而不是追逐最新最酷炫的技术。”GitHub的方法在我看来是Web和移动开发者的合理的平衡：广泛地探索工具，然后务实地选择解决你所面临的问题的工具（<a href="https://martinfowler.com/bliki/Yagni.html">YAGNI</a>适用于更多的地方，而不仅仅是面向用户的功能开发）。</p>

<p>令我担心的是，某些开发者，特别是在职业生涯早期的开发者，可能会以为创业公司的工程师不是问题解决者或计算机科学家，而是一个荣誉查找表——他们的任务是每隔几个月记住一个新的DSL——只能获得有限的好处。这使我们这些早期的工程师贬值——构建人们想要的东西，从事有趣的技术问题，快速交付代码。</p>

<p>无论如何，要在额外的时间里广泛地实践。如果好处是压倒性的，则切换生产环境中的语言/框架，但要考虑是哪些好处。警惕那些追求新技术却不考虑它对团队的预期优势的人。花时间学习概念和解决有趣的技术或用户问题。如果你有正确的应用边界，并选择你有现成生产力的框架，一旦你这样做了，你将具有一定的灵活性，但需要足够坚持才能达到产品与市场的匹配和超越。</p>

<p>任何一天打开<a href="https://news.ycombinator.com/">Hacker News</a>，你都能看到有帖子诱惑你使用某个框架、语言、类库或者服务去贡献和构建应用（包括一些像Mongo这样有大笔现金的公司，因此在它们的平台后面有营销预算）。有些工具拥有改变游戏规则的能力，其余的只有一些关键的不同功能，但是它们都需要时间才能成为专家。有些工具会大声宣告它们才是未来，并且嘲笑你所学到的东西——但是它们需要你的技能和意识与现有的技术真正地竞争。你会如何选择？</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/what-should-checked-and-unchecked-translate/">checked/unchecked应该翻译成什么？</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2017-07-29T12:17:06+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>29</span><span class='date-suffix'>th</span>, <span class='date-year'>2017</span></span> <span class='time'>12:17 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>翻译有关Java异常的文章时，总是犹豫是否该把checked/unchecked也翻译过来。原因是，不是很清楚该如何优雅传神地翻译这两个单词。</p>

<p>《Java核心技术》将它们翻译成“已检查/未检查”。《Java编程思想》和《Effictive Java中文版》则翻译成“被检查的/不检查的”。至于技术文章的翻译更是花样百出，有“检测/非检测”、“可检测/非检测”、“可查/不可查”、“受查/非受查”、“检查型/非检查型”、“检查/非检查”等。</p>

<p>到底该翻译成什么呢？在回答这个问题前，让我们先确定什么是checked/unchecked异常？</p>

<p><img src="/uploads/exception-hierarchy.png" alt="exception-hierarchy"></p>

<p>上图是Java中的异常层次结构图。Java语言规范将派生自RuntimeException类和Error类的所有异常称为“unchecked异常”，其它的异常称为“checked异常”。</p>

<blockquote>
<p>The unchecked exception classes are the run-time exception classes and the error classes.</p>

<p>The checked exception classes are all exception classes other than the unchecked exception classes. That is, the checked exception classes are Throwable and all its subclasses other than RuntimeException and its subclasses and Error and its subclasses.</p>
</blockquote>

<p>并且，在编译时编译器会检查程序是否为所有的“checked异常”提供处理器。</p>

<blockquote>
<p>This compile-time checking for the presence of exception handlers is designed to reduce the number of exceptions which are not properly handled.</p>
</blockquote>

<p>从上述的描述可以得出，“checked异常”和“unchecked异常”是两种异常类型，且“checked异常”隐含有必须要检查的思想。</p>

<p>紧紧围绕这些描述，细细地思考和比较，个人认为：1. 《Java核心技术》的翻译存在问题，“已检查”和“未检查”说明的是异常的检查状态，没有表达出异常的分类这个概念。2. 《Java编程思想》和《Effictive Java中文版》的翻译则正确地表达了异常的分类，但“被检查”翻译的有点无厘头，如果能改成“要检查”则会更好，缺陷是连接“异常”这个词组后是短语，而非名词，读来费劲，也不上口；如果去掉“的”的话，后者会有歧义，听起来像是命令。3. “检测/非检测”和“检查/非检查”是同个意思。4. “可检测”这个翻译看上去似乎表示异常是可以检查的，和Java语言规范要求的该类异常必须要检查不符。5. “可查/不可查”也是如此。6. “受查/非受查”的翻译则有些莫名其妙的感觉。7. “检查型/非检查型”翻译的很好，既表达了异常的分类，也表达了一种异常是要检查的，另一种异常是不要检查的意义，只是前者还缺少点强制的意味。</p>

<p>分析到这里，结果已经是不言而明。“要检查的/不检查的”和“检查型/非检查型”是两种更好的翻译，都能把Java语言规范对checked/unchecked异常的描述尽量地表述出来。而后者在实际使用中更为简洁适宜。</p>

<p>接下来的事情就是把以前译文中未翻译的checked/unchecked修改成“检查型/非检查型”。在以后的翻译中也继续使用这个翻译结果，除非能找到更好的表述方式。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/learn-anything-faster-with-the-feynman-technique/">费曼技巧：最好的学习方法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2017-06-02T08:30:09+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2017</span></span> <span class='time'>8:30 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>英文原文：<a href="https://www.farnamstreetblog.com/2012/04/learn-anything-faster-with-the-feynman-technique/">https://www.farnamstreetblog.com/2012/04/learn-anything-faster-with-the-feynman-technique/</a></p>

<p>费曼技巧有4个简单的步骤，我将在下面解释它们：</p>

<ul>
<li>选择一个概念</li>
<li>把它教给某个小孩</li>
<li>识别薄弱环节，回到原始材料</li>
<li>回顾和简化（可选）</li>
</ul>

<p>如果你不学习就会固步自封。那么，学习新主题并识别现有知识的薄弱环节的最好方式是什么？</p>

<h3 id="两种类型的知识">两种类型的知识</h3>

<p>有<a href="https://www.farnamstreetblog.com/2015/09/two-types-of-knowledge/">两种类型的知识</a>，我们大多数人关注错误的那种。第一类知识注重知道某事物的名称。第二类注重知道某事物。它们不是一回事。著名的诺贝尔物理学奖获得者理查德·费曼（Richard Feynman）明白<a href="https://www.farnamstreetblog.com/2015/01/richard-feynman-knowing-something/">知道某事物和知道某事物的名称之间的差异</a>，这是他成功的最重要的原因之一。事实上，他创造了一个学习公式，确保他比其他人更明白某些东西。</p>

<p>这被称为费曼技巧，它将帮助你更快更明白地学到东西。最重要的是，它极其容易实现。</p>

<blockquote>
<p>一个人如果说他知道他在想些什么，却表达不出来，通常是他其实并不知道自己在想些什么。——莫提默·艾德勒</p>
</blockquote>

<h3 id="费曼技巧">费曼技巧</h3>

<p>费曼技巧有4个步骤。</p>

<h4 id="步骤1：把它教给某个小孩">步骤1：把它教给某个小孩</h4>

<p>拿出一张白纸，在顶部写下你想要学习的主题。写出你对这个主题的了解，好像你正在把它教给某个小孩。不是你聪明的成年朋友，而是一个8岁的小孩，他刚好有足够的词汇和注意力来涵盖基本的概念和关系。</p>

<p>很多人倾向于使用复杂的词汇和行话来掩盖他们不明白的东西。问题是我们仅仅愚弄自己，因为我们不知道我们不明白。另外，使用行话会掩盖周围的人对我们的误解。</p>

<p>当你自始至终都用孩子可以理解的简单的语言写出某个想法时（提示：只用最常见的单词），你迫使自己在更深的层次上去理解这个概念，并简化想法之间的关系和连接。如果你努力，你会清楚地知道自己在哪里还有薄弱环节。这种压力很好——它预示着学习的机会。</p>

<h4 id="步骤2：回顾">步骤2：回顾</h4>

<p>在第一步中，你不可避免地会遇到你的知识的薄弱环节，你忘记了某些重要的东西，或者不能解释它，或者只是很难把重要的概念联系起来。</p>

<p>这是宝贵的反馈，因为你已经发现你的知识的边缘。胜任力是知道你能力的极限，你刚刚已经识别出一个！</p>

<p>这是学习开始的地方。现在你知道在哪里会遇到困难，回到原始材料并重新学习，直到你可以用基本的术语去解释它们。</p>

<p>识别你的理解的边界也限制了你可能犯的错误，并增加了在应用知识时成功的机会。</p>

<h4 id="步骤3：整理和简化">步骤3：整理和简化</h4>

<p>现在你有一套手工制作的笔记。检查它们以确保你没有错误地从原始材料中借用任何行话。将它们组织成一个丰满的简单的故事。</p>

<p>把它们大声地朗读出来，如果解释不直白或者听起来很混乱，这表明你在该领域的理解仍需要做些工作。</p>

<h4 id="步骤4（可选）：传播">步骤4（可选）：传播</h4>

<p>如果你真的想要确保自己的理解没有任何偏差，那就把它告诉别人（理想状态是这个人对该主题知之甚少，或者就找个8岁的小孩）。对你的知识的最终考验是你将其传达给另一个人的能力。</p>

<p>这不仅是学习的一个妙诀，它也是一种不同的思维方式的窗口，允许你将想法分解，然后从头开始重建。（Elon Musk称它为<a href="https://www.farnamstreetblog.com/2015/04/elon-musk-framework-thinking/">从第一个原则思考</a>）。这会导致对想法和概念的更深入的理解。重要的是，以这种方式解决问题，你可以在别人不知道他们自己在说什么的情况下理解这个问题。</p>

<p>费曼的方法直观地认为智力是一个成长的过程，这与卡罗尔·德韦克（Carol Dweck）的工作非常吻合，卡罗尔·德韦克漂亮地描述了<a href="https://www.farnamstreetblog.com/2015/03/carol-dweck-mindset/">固定型和成长型思维之间的区别</a>。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/code-coverage-100-percent-tragedy/">100%代码覆盖率的悲剧</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2017-05-13T19:00:41+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>13</span><span class='date-suffix'>th</span>, <span class='date-year'>2017</span></span> <span class='time'>7:00 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>英文原文：<a href="http://labs.ig.com/code-coverage-100-percent-tragedy">http://labs.ig.com/code-coverage-100-percent-tragedy</a></p>

<p>有趣的是，我对测试的观点正在发生变化。十五年来，我一直在宣扬TDD（测试驱动开发，或者被称为测试先行方法），或至少让开发者写些单元测试。不过，最近我发现自己更经常地说，“你为什么要写测试？”而不是“你应该写测试”。</p>

<h3 id="怎么回事？">怎么回事？</h3>

<p>在办公室四处走走时，开发者要求我帮助他进行单元测试。看来他在使用Mockito测试以下代码时遇到了麻烦：</p>

<p><img src="/uploads/initialise-method.png" alt="initialise-method"></p>

<p>我想他是非常惊讶于我的回应：“你不需要测试。”</p>

<p>“但我不得不测啊！”他说。“否则如何知道这段代码是正常的？”</p>

<p>“这段代码很明显。没有条件，没有循环，没有转换，没有任何东西。它们只是一些普通的旧式胶水代码。”</p>

<p>“但没有测试，任何人都可以来修改和破坏这段代码呀！”</p>

<p>“看，如果那个虚构的邪恶/无知的开发者来了，破坏了这些简单的代码，如果相关的单元测试中断，你认为他会做什么？他只会删除它。”</p>

<p>“但是如果非要写测试怎么办？”</p>

<p>“在这种情况下，我将这样写测试：”</p>

<p><img src="/uploads/initialise-test.png" alt="initialise-test"></p>

<p>“但是你没有使用Mockito啊！”</p>

<p>“那又怎么样呢？Mockito没有帮助你。恰恰相反：它会妨碍你，并且它也不会使测试变得更易读或更简单。”</p>

<p>“但是我们决定使用Mockito进行所有测试！”</p>

<p>我：“……”</p>

<p>后来我碰到他，他自豪地说，他已经设法用Mockito写了测试。我明白让测试代码正常运行的心理满足感，但尽管如此，这种解决方案让我难过。</p>

<h3 id="另一个例子">另一个例子</h3>

<p>我加入的某个开发团队，他们对新应用程序的高代码覆盖率以及对BDD（行为驱动设计）的新发现感到兴奋。查看代码，可以发现如下的Cucumber测试：</p>

<p><img src="/uploads/cucumber-test.png" alt="cucumber-test"></p>

<p>如果你以前使用过Cucumber，你就不会震惊于它所需的支持代码的数量：</p>

<p><img src="/uploads/cucumber-support.png" alt="cucumber-support"></p>

<p><img src="/uploads/cucumber-support2.png" alt="cucumber-support2"></p>

<p>和所有要测试的代码：</p>

<p><img src="/uploads/cucumber-code.png" alt="cucumber-code"></p>

<p>是的，一个简单的地图查找。我和这个开发者有足够的信任去直言不讳地说，“这是在浪费时间。”</p>

<p>“但我的老板希望我能为所有的类写测试，”他回答。</p>

<p>“代价是什么？”</p>

<p>“费用？”</p>

<p>“无论如何，这些测试与BDD无关。”</p>

<p>“我知道，但是我们决定使用Cucumber进行所有测试”</p>

<p>我：“……”</p>

<p>我明白按照自己意愿改造工具的心理满足感，但尽管如此，这种解决方案让我难过。</p>

<h3 id="悲剧在哪里？">悲剧在哪里？</h3>

<p>悲剧是两位聪明的开发者（我需要带他们去团队面试）浪费时间写那种测试，测试是毫无意义的，但需要后来的IG开发者维护。</p>

<p>悲剧是不使用正确的工具，因为没有特别好的理由，我们决定坚持不懈地使用错误的工具。</p>

<p>悲剧是一旦某个“良好实践”成为主流，我们似乎就忘记它是怎么来的，它的好处是什么，最主要的是，使用它的代价是什么。</p>

<p>如果我们只是机械地应用它而没有太多的思考，这通常意味着我们最终得到最平庸的结果，失去大部分的好处，但支付所有（甚至更多）的成本。根据我的经验，编写好的单元测试并非易事。</p>

<h3 id="那么100-的代码覆盖率值得追求吗？">那么100%的代码覆盖率值得追求吗？</h3>

<p>是的，每个人都应该实现它……在一个项目中。我认为你必须用极端的手段去了解限制是什么。</p>

<p>我们已经有了一个极端的大量经验：0个单元测试的项目，所以我们知道在这上面工作的痛苦。我们通常缺乏的是在另一个极端的经验：强制100%代码覆盖率和一切都是TDD的项目。单元测试（尤其是测试先行方法）是一个非常好的实践，但我们应该学习哪些测试是有用的，哪些是适得其反的。</p>

<p>要记住没有什么是免费的，没有什么是银弹。使用工具前请停下来想一想。</p>

<h4 id="关于作者">关于作者</h4>

<p>Daniel Lebrero在IG的大数据团队担任技术架构师。拥有超过15年的Java经验和4年的Clojure经验，他现在是函数式编程的大力倡导者。可以在<a href="https://twitter.com/DanLebrero">Twitter</a>，<a href="https://www.linkedin.com/in/daniel-lebrero-4729906">LinkedIn</a>或者他的个人<a href="http://danlebrero.com/">博客</a>找到他。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/unconventional-way-of-learning-a-new-programming-language/">学习新编程语言的非传统方式</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2017-04-08T09:23:59+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2017</span></span> <span class='time'>9:23 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>英文原文：<a href="https://hackernoon.com/unconventional-way-of-learning-a-new-programming-language-e4d1f600342c">https://hackernoon.com/unconventional-way-of-learning-a-new-programming-language-e4d1f600342c</a></p>

<p>现在已经有500多种编程语言。因此，开始学习新的编程语言对你来说是很正常的。你可能知道C++和Java，但是你的工作需要Python；或者你精通Python，但是需要用Java编写代码；或者也许你想要学习这种很酷的语言只是为了扩展你的编程技能。</p>

<p>如果你想学习新的编程语言，你会选择哪种方式？</p>

<ul>
<li>从若干在线教程中学习</li>
<li>或者从若干在线课程（MOOC）中学习</li>
</ul>

<p>有些人甚至可能认为，学习新语言的最佳方式应该是这样的：</p>

<ul>
<li>学习这门新的编程语言的语法</li>
<li>再用这门语言构建一些个人项目</li>
</ul>

<p>有道理！这样可以确保你能够应用学习语言的语法而获得的知识。</p>

<p>我开发过20多个迷你项目，同时学习不同的语言。相信我，当你为个人项目编写代码的时候，不管这些项目是周末项目还是紧急快速补丁，你编写代码都只是为了完成任务。你只会关注——“我的代码是否工作？”你几乎不关心代码的质量。</p>

<blockquote>
<p>任何傻瓜都能写出计算机可以理解的代码。好的程序员能写出人类可以理解的代码。——Martin Fowler</p>
</blockquote>

<p>那么，你是如何学习你正在尝试学习的新的编程语言的良好实践呢？</p>

<h3 id="向该语言的开源项目贡献代码">向该语言的开源项目贡献代码</h3>

<p>惊讶吗？有些人可能在想——“等等，开源是很难的。只有当我们是该语言的专家时，我们才能为开源项目贡献代码，对吗？”答案是不。</p>

<p>让我给你们讲个故事。</p>

<p>去年，我收到Booking.com全职工作的邀请，而且我知道我将使用Perl（这是该公司后端使用的主要语言）工作。2016年6月，当我完成大学学位后，我开始学习Perl，以便为自己在大学毕业后的首份工作做准备。因为我会在7月的第二周入职，所以我差不多有1个月的时间。</p>

<p>我开始阅读Perl的语法，并开始理解这门语言的一些常见模式。现在，我真的想使用Perl构建一些东西，以便我可以应用我的这门语言的知识和实践这门语言的各种概念。当我在寻找使用Perl构建某些东西的想法时，我在GitHub偶遇DuckDuckGo的开源组织。我注意到这个组织的某些开放项目是用Perl写的。我浏览这些项目的Issues发现有很多“新手”问题。我立即开始去解决它们，并提交了几个pull request。到今天为止，我已经是该组织的几个开放项目的主要贡献者之一，也是DuckDuckGo的20个开源社区领袖之一。</p>

<blockquote>
<p>故事的寓意——通过向用Perl编写的开源项目贡献代码我学会了Perl。</p>
</blockquote>

<h3 id="为什么这种方法奏效呢？">为什么这种方法奏效呢？</h3>

<p>就在我学会Perl的语法之后，我开始向开源项目贡献代码。当这样做的时候，我总是习惯看看现有的模块。我经常留意在Perl中使用的模式。此后，我开始在自己的代码中吸收这些良好的实践，它帮助我学习如何使用Perl编写好的代码。</p>

<p>这并不是偶然。让我给你们讲个另外类似的故事。</p>

<p>最近，当我在Booking.com工作的时候，我挑选了一些任务，包括给用Go语言编写的服务之一添加新功能。以下是我和队友的对话：</p>

<blockquote>
<p>我：我真的喜欢这项任务。我想做它。你怎么看？</p>

<p>他：是的，它的确很有意思。但是，它需要Go的知识。你知道Go吗？</p>

<p>我：不知道。</p>

<p>他：你想学习Go吗？</p>

<p>我：是的！</p>

<p>他：&#x1f60a; 那就去吧！</p>
</blockquote>

<p>我去了，那也是我学习另外一门编程语言——Go的起点！</p>

<p>我开始阅读Go的语法，并在它的官方网站上发现了一个非常棒的初学者语言教程。它足以让我熟悉该语言的所有基本概念。</p>

<p>再次地，我开始寻找含有“新手”或“易于修复”问题的Go开源项目。我发现了一个Google的项目，它基本上是GitHub的REST API的Go包装器。</p>

<p>在我开始学习Go的2天后，我有了这个项目的第一个PR。下图是我过去1年的<a href="https://github.com/sahildua2305">贡献图表</a>：</p>

<p><img src="/uploads/contribution-graph.png" alt="contribution-graph"></p>

<h3 id="开源是如何帮助的？">开源是如何帮助的？</h3>

<p>现在你可能会疑惑给开源贡献代码如何帮助你学习一门语言的良好实践。它有多个方面。让我们来逐个讨论。</p>

<h4 id="代码质量">代码质量</h4>

<p>大多数良好的开源项目都有严格的编码指导原则，你必须遵守它们才能使你的代码被合并。参与开源将帮助你适应这些指导原则，从而编写优质的代码，即使你只是在学习这门语言。</p>

<p>不仅如此，你还有机会查看其余的代码，学习别人是如何写代码和/或写文档的。</p>

<h4 id="代码审查">代码审查</h4>

<p>给开源贡献代码的最好部分是代码审查。当你推送代码时，你将获得与该项目相关的专家的反馈，因此可以让你有机会提升对语言的理解。</p>

<p>这就像获得了关于如何编写好代码的一次免费的个人指导。</p>

<h4 id="赞赏">赞赏</h4>

<p>下图是我在Go语言上的第一个PR的首个<a href="https://github.com/google/go-github/pull/497">评论</a>：</p>

<p><img src="/uploads/go-appreciation-comment.png" alt="go-appreciation-comment"></p>

<p>作为软件开发者，我们的工作真的需要得到赞赏。而开源社区能够确保这些。在我的整个开源贡献经历中，我从来没有收到过甚至一条侮辱或者挫伤的评论。每个人都善于鼓舞和乐于助人。</p>

<p>下图是DuckDuckGo社区中另个人的评论：</p>

<p><img src="/uploads/duckduckgo-appreciation-comment.png" alt="duckduckgo-appreciation-comment"></p>

<p>所以，下次你想学习一门新语言，只管去学！找个开源项目贡献代码，在学习这门语言和它微妙之处的道路上奋勇前进吧;)</p>

<p>务必让我知道这种非传统方式是否对你有效。另外，如果你认为这种方式对某人有用，请推荐（&#10084;）这篇文章。</p>

<p>如果有任何其它有效的方法也请告诉我。可以在Twitter上关注我<a href="https://twitter.com/sahildua2305">@sahildua2305</a>。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/the-impact-github-is-having-on-your-software-career-right-now/">GitHub对软件职业生涯的影响</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2017-03-20T20:50:30+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2017</span></span> <span class='time'>8:50 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>英文原文：<a href="https://medium.com/@sitapati/the-impact-github-is-having-on-your-software-career-right-now-6ce536ec0b50">https://medium.com/@sitapati/the-impact-github-is-having-on-your-software-career-right-now-6ce536ec0b50</a></p>

<p>在未来的12-24个月里——换句话说，即2018到2019年间——程序员的聘用方式将彻底改变。</p>

<p>2004-2014年间，我任职于Red Hat，世界上最大的开源软件工程公司。2004年7月，在我工作的第一天，我的上司Marty Messer对我说：“你在这里所做的一切工作都是开源的。在将来，你不再需要简历，人们可以直接Google你。”</p>

<p>在那时，它是在Red Hat工作的一个独特之处：我们有机会在开源社区创立自己的个人品牌和声誉。我们通过邮件列表、缺陷追踪器以及提交源代码到Mercurial、Subversion和CVS版本库
来和其他软件工程师进行交流。所有这些都是公开的，并且可以被Google索引。</p>

<p>快进到2017，我们生活的这个世界已经被开源软件所吞噬。</p>

<p>有两个因素可以让你真切地感受到开源时代的到来：</p>

<ol>
<li>微软——曾经是闭源私有软件的典型代表和反对开源的圣战士——已经全心全意地拥抱开源软件，成立.NET基金会（Red Hat是其中的一员）和加入Linux基金会。现在.NET已经作为开源项目进行开发。</li>
<li>GitHub已经成为一个奇特的社交网络，它把问题追踪和分布式代码控制捆绑在一起。</li>
</ol>

<p>对于来自主要是闭源背景的软件开发者来说，刚刚发生了什么还不是很清楚。对他们来说，开源等于“在业余时间免费工作”。</p>

<p>然而，对于我们这些在过去10年里建成一个10亿美元开源软件公司的人来说，为开源工作没有什么免费或业余时间。并且，为开源工作的好处和结果是显而易见的：你的声誉是你的，而且在公司间是可携带的。GitHub是一个社交网络，在那里，你的社会资本，通过你的提交和对你正在工作的任何技术的全球交流的贡献创造的，是你的——不会绑定到你正在临时工作的公司。</p>

<p>聪明人会利用这个优势——他们会向他们日常工作中使用的语言和框架贡献补丁、问题和评论——TypeScript、.NET、Redux。</p>

<p>他们同样会提倡并创造性地安排他们的工作尽可能地以公开的方式完成——即使那只是他们对私有版本库的贡献图。</p>

<p>GitHub是一个很好的均衡器。你可能不能从印度找到一份澳大利亚的工作，但没有什么阻止你在印度利用GitHub与澳大利亚人进行合作。</p>

<p>在过去的十年里，从Red Hat获取一份工作的方式是显而易见的。你只要开始与Red Hat的工程师一起协作开发他们的一些开源项目，然后作出有价值的贡献并且得到他们的认可，你就可以申请一份工作。或者他们会找你。</p>

<p>现在，同样的途径对每个人都开放，不过仅限于技术职位。随着世界被开源所吞噬，同样的求职方式在各个地方开始流行起来。</p>

<p>在<a href="http://www.theregister.co.uk/2017/02/15/think_different_shut_up_and_work_harder_says_linus_torvalds/">最近的访谈</a>中，Linux和Git的发明者Linus Torvalds（在GitHub上有4.9万关注者）这样说道：</p>

<blockquote>
<p>你提交大量的小补丁，直到项目的维护者信任你，到那时你会成为信任网络的一部分，而不仅仅是个发送补丁的家伙。</p>
</blockquote>

<p>你的声誉是你在信任网络中的定位。当你换公司时，它们会减弱并且有所丢失。如果你生活在一个小镇，并且已经在那里很长一段时间，那么小镇里所有的人都了解你。如果你去了其他国家，那么你最终到了一个没人了解你的地方——更糟糕的是，没人知道有谁了解你。</p>

<p>你已经丢失了你的第一度和第二度，甚至可能是第三度连接（译者：不明白什么是“度”的可以搜索六度分隔理论）。除非你已经通过在会议上演讲或者其它一些重要的事情建立品牌，否则你通过与其他人合作以及给企业内部版本库提交代码建立的信任将会不复存在。</p>

<p>但是，如果这些工作一直都在GitHub上完成，它就不会消失。它是可见的。它连接到了一个可见的信任网络。</p>

<p>首先发生的事情之一是弱势群体将开始利用这个优势。学生、新毕业生、移民，他们将利用这个优势搬到澳大利亚。</p>

<p>并且这也将改变整个软件开发的生态环境。以前的特权开发者会突然发现他们的网络被破坏了。开源的原则之一是精英政治——最好的想法胜出，最多的提交胜出，通过测试最多的胜出，最好的实现胜出，等等。</p>

<p>它并不完美（没有什么是完美的）。并且它不会让成为一个好同事的努力废除或打折。在Red Hat，我们解雇过一些摇滚明星工程师，他们只是不能很好地与其他人一起工作——这样的事情不会出现在GitHub，因为大部分开发者都在与其他贡献者互动。</p>

<p>正如有些人用稻草人谬误描述它一样，GitHub不仅仅是代码版本库和原始提交数字的列表。它是一个社交网络。这么说吧：</p>

<blockquote>
<p>它不是你的代码在GitHub上的计数——它是其他人在GitHub上谈及你的代码的计数。</p>
</blockquote>

<p>那是你的可携带声誉。在未来的12-24个月里，由于一些开发者开发这种声誉而其他开发者不，它将成为一个鲜明的区分因素。就像有电子邮箱和没电子邮箱（现在每个人都有电子邮箱）、有蜂窝电话和没蜂窝电话（现在每个人都有蜂窝电话）。最终绝大多数将会以开源的方式工作，它将再次是区别于其它因素的一个公平竞争的领域。</p>

<p>但现在，开发者的职业生涯空间正在被GitHub破坏。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/how-to-modify-hosts-in-android/">如何修改Android的hosts文件</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2017-02-16T11:52:56+08:00'><span class='date'><span class='date-month'>Feb</span> <span class='date-day'>16</span><span class='date-suffix'>th</span>, <span class='date-year'>2017</span></span> <span class='time'>11:52 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>由于「你懂的」的原因，某些时候我们需要修改Android的hosts文件。Android的hosts文件路径是/system/etc/hosts，在修改该文件前首先需要Android手机获取root权限。至于如何root你的手机，这里就不加详述，可以自行在网络上查找，很多也很简单。</p>

<p>本文将要阐述的是如何在命令行下通过adb程序访问root过的手机，把hosts拖到电脑上修改，然后再复制回手机来实现修改hosts的方法。</p>

<p>下面就开始具体的步骤：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>C:\tools&gt;adb pull /system/etc/hosts hosts.mod
</span><span class='line'>[100%] /system/etc/hosts</span></code></pre></td></tr></table></div></figure>

<p>上面的命令是把手机上的hosts文件拖到电脑上，[100%]表明文件已经传输完成，可以修改hosts文件了。在修改完成后就使用以下命令上传到手机：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>C:\tools&gt;adb push hosts.mod /system/etc/hosts
</span><span class='line'>adb: error: failed to copy 'hosts.mod' to '/system/etc/hosts': Read-only file system</span></code></pre></td></tr></table></div></figure>

<p>从回显的消息可以看到，文件系统是只读的，所以不能直接上传。</p>

<p>试试以下的命令看能不能成功？！</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>C:\tools&gt;adb root  # 帮助文档说该命令可以让adbd守护进程获得root权限
</span><span class='line'>C:\tools&gt;adb push hosts.mod /system/etc/hosts
</span><span class='line'>adb: error: failed to copy 'hosts.mod' to '/system/etc/hosts': Read-only file system</span></code></pre></td></tr></table></div></figure>

<p>还是不行，看来要重新挂载/system目录才可以。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>C:\tools&gt;adb remount
</span><span class='line'>remount failed: Operation not permitted</span></code></pre></td></tr></table></div></figure>

<p>没有权限？这是必须祭起shell大法的节奏啊！</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>C:\tools&gt;adb shell
</span><span class='line'>* daemon not running. starting it now on port 5037 *
</span><span class='line'>* daemon started successfully *
</span><span class='line'>shell@maguro:/ $ ls -al /system/etc/hosts
</span><span class='line'>-rw-r--r-- root     root           25 2013-08-14 07:00 hosts</span></code></pre></td></tr></table></div></figure>

<p>从上面最后一行可以看出hosts这个文件只有它的拥有者能写入，对于其他人来说都是只读的。要想让其他人也能做修改，必须使用以下命令进行提权，再改变hosts文件的属性才行。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>shell@maguro:/ $ su</span></code></pre></td></tr></table></div></figure>

<p>如果是第一次执行这个命令，手机会亮起，SuperSU应用会提示你是否同意权限的分配。这里当然是要同意的！接着你就可以看到终端下的提示符从$变成了#，@前的字符也由shell变成了root。然后我们就可以修改hosts文件的权限属性了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@maguro:/ # chmod +666 /system/etc/hosts
</span><span class='line'>Bad mode
</span><span class='line'>root@maguro:/ # chmod 666 /system/etc/hosts
</span><span class='line'>Unable to chmod /system/etc/hosts: Read-only file system</span></code></pre></td></tr></table></div></figure>

<p>又是Read-only file system！输入以下命令看看/system目录的文件系统详情呢。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@maguro:/ # mount | grep system
</span><span class='line'>/dev/block/platform/omap/omap_hsmmc.0/by-name/system /system ext4 ro,seclabel,relatime...</span></code></pre></td></tr></table></div></figure>

<p>看到ext4后面的ro了吗？它是read only的缩写，即只读的意思。这说明/system目录是只读的。接下来我们要把它改成可以读写。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@maguro:/ # mount -o rw,remount /system</span></code></pre></td></tr></table></div></figure>

<p>上面的-o用于指定加载文件系统时的选项。这些选项包括：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>remount 重新加载设备。通常用于改变设备的设置状态。
</span><span class='line'>ro 以只读模式加载。
</span><span class='line'>rw 以可读写模式加载。</span></code></pre></td></tr></table></div></figure>

<p>再次查看，可以看到原来ro的位置已经变成rw了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@maguro:/ # mount | grep system
</span><span class='line'>/dev/block/platform/omap/omap_hsmmc.0/by-name/system /system ext4 rw,seclabel,relatime...</span></code></pre></td></tr></table></div></figure>

<p>不过到这里我们还不能向手机拷贝hosts文件，因为hosts文件的权限属性还没被改过，如果强行上传的话，会得到如下的错误消息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>C:\tools&gt;adb push hosts.mod /system/etc/hosts
</span><span class='line'>adb: error: failed to copy 'hosts.mod' to '/system/etc/hosts': Permission denied</span></code></pre></td></tr></table></div></figure>

<p>运行以下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@maguro:/ # chmod 666 /system/etc/hosts</span></code></pre></td></tr></table></div></figure>

<p>然后查看hosts文件的属性。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@maguro:/ # ls -al /system/etc/hosts
</span><span class='line'>-rw-rw-rw- root     root           25 2013-08-14 07:00 hosts</span></code></pre></td></tr></table></div></figure>

<p>可以看到所有人都可以读写hosts文件了。</p>

<p>既然一切都准备就绪，那就再来试试上传修改后的hosts文件吧。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>C:\tools&gt;adb push hosts.mod /system/etc/hosts
</span><span class='line'>adb: error: failed to copy 'hosts.mod' to '/system/etc/hosts': Read-only file system</span></code></pre></td></tr></table></div></figure>

<p>怎么回事，为什么还是拷贝失败呢？不是已经把文件系统改为可读写了吗？</p>

<p>并且在查找原因的过程中还发现一个奇怪的事情。在root模式下/system目录是可读写的，但在shell模式下/system却是只读的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@maguro:/ # mount | grep system
</span><span class='line'>/dev/block/platform/omap/omap_hsmmc.0/by-name/system /system ext4 rw,seclabel,relatime...
</span><span class='line'>root@maguro:/ # exit
</span><span class='line'>shell@maguro:/ # mount | grep system
</span><span class='line'>/dev/block/platform/omap/omap_hsmmc.0/by-name/system /system ext4 ro,seclabel,relatime...</span></code></pre></td></tr></table></div></figure>

<p>而且在手机上的Terminal Emulator中把/system目录mount成可读写之后，在adb shell的root模式下查看/system的状态仍然显示为只读。</p>

<p>在网上找啊找啊找啊，都快要绝望了，终于找到可能之问题所在。就是这个帖子：<a href="http://android.stackexchange.com/questions/142271/mount-in-shell-as-user-or-root-with-different-output">mount in shell as user or root with different output</a>。有个回答提到mount namespace这样东西。然后才知道：</p>

<blockquote>
<p>A mount namespace is the set of filesystem mounts that are visible to a process.</p>
</blockquote>

<p>每个进程的挂载点对其它进程是不可见的。Terminal Emulator中mount后的挂载点属于该进程，而adb shell中shell模式和root模式的挂载点分别属于各自的进程。这就是前面root模式下修改/system目录为可读写后在shell模式下仍显示为只读的原因。</p>

<p>知道问题的原因了，那如何解决呢？</p>

<p>在SuperSu应用的设置中有个mount namespace separation的选项，如下图所示：</p>

<p><img src="/uploads/mount-namespace-separation.png" alt="mount-namespace-separation"></p>

<p>把勾选取消，然后mount的挂载点就是全局性的了，不再为mount它们的进程所独有。不过要记住的是，只有在重启手机后该修改才有效。</p>

<p>下面是取消mount namespace separation后在上传的结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>C:\tools&gt;adb push hosts.mod /system/etc/hosts
</span><span class='line'>[100%] /system/etc/hosts</span></code></pre></td></tr></table></div></figure>

<p>可以看到[100%]的回显，说明文件已经上传完成。</p>

<p>查看hosts文件的属性：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@maguro:/ # ls -al /system/etc/hosts
</span><span class='line'>-rw-rw-rw- root     root       137679 2017-02-16 00:20 hosts</span></code></pre></td></tr></table></div></figure>

<p>文件的大小已经由25变成137679，说明文件已经替换完成。</p>

<p>下面就是恢复手机到原先的状态：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@maguro:/ # chmod 644 /system/etc/hosts
</span><span class='line'>root@maguro:/ # ls -al /system/etc/hosts
</span><span class='line'>-rw-r--r-- root     root       137679 2017-02-16 00:20 hosts
</span><span class='line'>root@maguro:/ # mount -o ro,remount /system</span></code></pre></td></tr></table></div></figure>

<p>至此，修改hosts文件的工作就算大功告成。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/the-perils-of-shared-code/">共享代码的风险</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-25T18:51:10+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>6:51 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>英文原文：<a href="https://www.innoq.com/en/blog/the-perils-of-shared-code/">https://www.innoq.com/en/blog/the-perils-of-shared-code/</a></p>

<p>通往地狱的道路往往是由良好的意愿铺就。在各种软件项目中，我看到人们走在这样的道路上，他们在微服务之间借助库共享代码。在几乎每个组织支持微服务架构的项目中，各个团队和开发者都期望以某些核心库为基础构建他们的微服务。显然，即使可能带来的问题已经被知道很长时间了，很多人仍然不知道它们。在这篇博文中，我想研究为什么使用这样的库可能起初听起来有吸引力，为什么可能会出现问题，以及如何能够减轻这些问题。</p>

<h3 id="共享代码的目的">共享代码的目的</h3>

<p>通过库来共享代码有两个主要目的：共享领域逻辑和共享基础设施层中的抽象。</p>

<ol>
<li><p><em>共享的领域模型：</em>领域模型的特定部分在两个或多个有界上下文之间是共同的，因此，作为三番五次实现它的替换，你消除了重复的需要和引入该领域逻辑的不一致实现的可能性。通常，人们想要像那样共享的领域模型的部分是核心领域或一个或多个通用子领域。在领域驱动设计的行话中，这也被称为共享内核。通常，你可以在这里找到像会话和身份验证逻辑这样的概念，但不限于此。一套相关的方法是规范数据模型。</p></li>
<li><p><em>基础设施层抽象：</em>你想避免一次又一次地实现基础设施层的有用抽象，因此你把它们放进一个库里。通常，这些库在数据库访问、消息传递和序列化等方面提供一套统一的方法。</p></li>
</ol>

<p>两者的动机是相同的——避免重复，也就是说，遵循DRY原则（Don’t repeat yourself!）。一旦实现这些逻辑有几个好处：</p>

<blockquote>
<p>你不需要花费宝贵的时间致力于那些已经被解决的问题。</p>

<p>有一套统一的方式做消息传递、数据库访问等。这意味着，当开发者需要去阅读和修改其他开发者最初创建的微服务中的代码时，他们很容易找到他们的方式。</p>

<p>关于彼此行为略有不同的业务逻辑或基础设施关注点，你不想有不同的实现。取而代之的是，有一套做正确事情的规范实现。</p>
</blockquote>

<h3 id="共享代码的问题">共享代码的问题</h3>

<p>在理论上听起来很棒的东西不会没有自己的问题，而且这些问题可能比你试图用你的库解决的问题更令人痛苦。Stefan Tilkov已经详细解释了<a href="https://www.innoq.com/en/blog/thoughts-on-a-canonical-data-model/">为什么你应该避免规范的数据模型</a>。除此之外，让我指出一些其它的问题。</p>

<h4 id="分布式单体">分布式单体</h4>

<p>通常，似乎存在一个隐含的假设，将东西放入库意味着你永远不必担心使用错误或过时的实现构成的服务，因为他们只需要更新其对库的依赖关系到最新版本。</p>

<p>每当你依靠通过将所有的微服务更新到同样的新版本库，来对所有微服务的某些行为作出一致的改变时，你就会在它们之间引入强耦合。你失去了微服务的一个主要优点，即它们彼此独立地演进和部署的能力。</p>

<p>我见过这样的案例，所有的服务必须同时部署，以便服务仍能正常工作。如果你达到这种状态，不可否认，你实际上构建了一个分布式的单体。</p>

<p>一个流行的示例是使用代码生成，例如，基于服务API的Swagger描述，以便为你的服务提供一个客户端库。比你想象的更多，开发者可能会滥用此种方式进行重大变更，因为依赖服务“只”需要使用新版本的客户端库。这不是你如何<a href="http://olivergierke.de/2016/10/evolving-distributed-systems/">演进一个分布式系统</a>。</p>

<h4 id="依赖地狱">依赖地狱</h4>

<p>库，尤其是那些旨在为基础设施关注点提供通用解决方案的库，往往有个额外的问题：它们会附上它们依赖的一整套额外的库。你的库的传递依赖树越大，它导致俗称为依赖地狱的噩梦的可能性就越高。因为你的微服务可能需要自己的额外的依赖，它们同样具有传递依赖性，直到它们中的某些库间接地拉进一些库的冲突版本，这只是个时间问题，只在不同版本之间选择是不可能的，因为它们是二进制不兼容的。</p>

<p>当然，你的解决方案也许只是提供微服务可能需要的所有库作为你的核心库的依赖。那仍然意味着你的微服务不能独立地演进，例如通过升级到它们依赖的唯一的特定库的更高版本——它们都与核心库的发布周期步调一致。除此之外，为什么你要强制每个服务接受一整堆的依赖，当它们实际上可能只需要依赖中的一些时？</p>

<h4 id="自顶而下的库设计">自顶而下的库设计</h4>

<p>通常情况下，我见过的库被一个或多个架构师强加于开发者，采用自顶而下的方法进行库设计。</p>

<p>通常，在这种情况下发生的是，由库暴露的API太受限制和不灵活，或者使用了错误的抽象级别，因为它们是由不够熟悉广泛的不同的真实世界用例的人设计的。这样的库经常导致不得不使用它的开发者遭受挫折，以及导致人们试图绕过库的限制。</p>

<h4 id="单语言解决一切">单语言解决一切</h4>

<p>强制使用库的最明显的缺陷之一是，这使得它更难以切换到不同的编程语言（或者平台，比如JVM或.NET），再次失去了微服务架构的一个优势，即选择最适合给定问题的技术的能力。如果你后来意识到，你终究需要这种语言或者平台的多样性，你必须创造各种奇怪的支持。例如，Netflix提出的<a href="https://github.com/Netflix/Prana">Prana</a>，一个同时运行非JVM服务的附加件，为他们提供到Netflix技术栈的一套HTTP API。</p>

<h3 id="我们能不能做得更好？">我们能不能做得更好？</h3>

<p>由于所有的问题都是通过库共享代码引入的，最极端的解决方案是根本没有这样的库。如果你这样做，你将不得不做一些复制和粘贴或者为新的微服务提供一个模板项目，以便从前面所述的步调一致中释放你的服务。基础设施代码以及领域模型的共享内核中都可以这么做。事实上，Eric Evans在他的关于领域驱动设计的经典蓝皮书中提到，“通常各个团队只是在各自的内核备份上改动，每隔一定时间才会与其他团队集成”[1]。共享内核不一定要是库。</p>

<p>如果你不喜欢复制和粘贴的想法，那也很好。毕竟，如上所述，通过库共享代码有一定的优势。在这种情况下，这里有一些重要的事情需要考虑：</p>

<h4 id="最少依赖的小型库">最少依赖的小型库</h4>

<p>尝试将大的共享库分成一组非常小的、高度集中的库，每个库解决一个特定的问题。试着让这些库成为零依赖库，只依靠语言的标准库。是的，仅仅针对语言的标准库来编程并不总是令人愉快的，但是对于你公司的所有团队的巨大好处（甚至超出你的公司，如果你的馆是开源的）显然大于这个微小的不便。</p>

<p>当然，零依赖并不总是可能的，特别是对于基础设施关注点。对于这些，通过你的每个小型库最小化所需的依赖。另外，有时可以独立于库的核心，提供与别的库的绑定或集成作为单独的工件。</p>

<h4 id="留下选择余地">留下选择余地</h4>

<p>不要指望服务将在特定时间点更新到共享库的最新版本的事实。换句话说，不要强制团队进行库更新，而是让他们可以按照自己的节奏自由更新。这可能需要你以向后和向前兼容的方式修改库，但它会解耦你的服务，不仅给你微服务架构的运营成本，而且还有一些优势。</p>

<p>如果可能，不仅要避免强制库更新，还要使库本身的使用可选。</p>

<h4 id="自底而上的库设计">自底而上的库设计</h4>

<p>最后，如果你想拥有共享库，我见过的获得成功的项目是使用自底而上的方法。让你的团队实现他们的微服务，而不是让象牙塔架构师设计在现实世界中几乎不可用的库，而当在多个服务的生产中已经证明它们自己的一些常见模式出现时，将它们提取到库中。</p>

<p>[1] Evans, Eric: Domain-Driven Design: Tackling Complexity in the Heart of Software, p. 355</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/the-power-of-protocol-analyzers/">协议分析器的威力</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-09-20T18:06:40+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>6:06 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>英文原文：<a href="http://arstechnica.com/information-technology/2016/09/the-power-of-protocol-analyzers/">http://arstechnica.com/information-technology/2016/09/the-power-of-protocol-analyzers/</a></p>

<p>问题发生在错综复杂的网络世界里。但要在一时激动之下确定一种新型问题的确切原因变得有些冒险。在这种情况下，当Google-fu耗尽的时候甚至其他能干的工程师也可能会被迫去依赖试错法。</p>

<p>幸运的是，有个秘密武器等待乐意的工程师去部署——协议分析器。该工具允许你明确地确定几乎任何错误的根源，给你提供在底层协议上自我学习的能力。现在唯一的问题是，许多工程师因为（毫无根据的）恐惧而完全回避它。</p>

<h3 id="什么是协议分析器？">什么是协议分析器？</h3>

<p>协议分析器，或者数据包嗅探器，是一个用于拦截通信量，存储它们，并以一个已解码的、人类可读的状态呈现它们的工具。现代协议分析器比如Wireshark甚至可以靠自己发现基本的问题，然后使用捕获的数据执行统计分析。</p>

<p>不理会特性，数据包嗅探器都以基本相同的方式工作。它们把自己插入到网络堆栈中，把所有通信量复制到一个缓冲区或文件。大部分还会将网络驱动置于“混杂模式”，该模式从根本上说允许这些工具取回所有进入网络堆栈的通信量，而不是只采集前往系统本身的通信量。</p>

<h3 id="协议分析仪如何帮助">协议分析仪如何帮助</h3>

<p>在很多情况下，解决一个困难的网络问题的最难部分是找到和理解问题的根源。这种困难的部分源于这样的事实，你对大多数问题使用的工具不是正确的对底层问题的工具。</p>

<p>如果你是一个系统管理员，很有可能你经常用于数据采集的工具是某种日志和错误消息。通常，这些都是解释工具。这些实体试图把原始数据总结为对非开发者或非工程师有意义的东西。因为解释工具是从应用层的视角提供问题的汇总数据，它们往往不能帮助你解决底层的问题。</p>

<p>例如，一条事件日志消息可以告诉你应用程序无法连接到服务器。它甚至可以告诉你根本原因是超时。但这条消息不大可能告诉你超时是由一个黑洞路由器丢弃一个大帧引起。它不能，因为事件日志消息服务不知道错误为何发生。为了使工具知道那个，它需要预测（不解释）这个非常问题，在MTU稳步减少的情况下发送数据包，直到一个通过。如果一个事件日志消息服务早就被编写好要做那件事，从一开始你就不会有这个问题。</p>

<p>当使用错误的工具时，你可能会在某处花上几个小时甚至几周的时间，直到你侥幸得到解决方案。然而，通过使用协议分析器和历久弥新的ping命令，你可以非常容易地在大约5分钟内诊断这个问题。就像早在高中时我的汽车技术辅导员就告诉我的，它全都是关于对任务使用恰当的工具。</p>

<p>除了确定错误，协议分析器提供为数不多的方法之一去证实问题的根源。以前我在微软的时候，棘手问题在团队间来回穿梭是很常见的，因为每个组误解由解释工具提供的数据。首先，问题可能被发送到Exchange团队，接着它可能被穿梭到Active Directory团队，然后最后到Networking团队。</p>

<p>通常，这是因为在其它团队的能力范围之内一个问题好像是合理的。然而，烫手山芋的游戏往往停止在Networking团队。为什么？因为Networking团队的头号工具是证实问题根源的救世主。</p>

<p>网络，像所有的计算，其核心是完全合乎逻辑的。一旦你了解它在幕后是如何工作的，你就有能力在底层确定问题，不论问题是多么独特。作为协议分析的一个伟大副作用，你也将学到很多关于网络的知识，它们将帮助你解决各种各样的网络问题（即使那些不需要协议分析）。</p>

<h3 id="wireshark基础">Wireshark基础</h3>

<p>现在，有各种各样的协议分析器可供选择，从免费的和相当功能的微软消息分析器到特性极其丰富但十分昂贵的Savvius Omnipeek。多年来我已经使用过大量的分析器，但我最喜欢的用于常规故障排除的协议分析器是Wireshark。它是免费的，开源的，多平台的具有很多特性的分析器。有个充满活力的社区站在它背后，而且Wireshark也相当容易习惯。这让它成为一个很好的开始的地方。</p>

<p>你可以从 <a href="https://www.wireshark.org/">https://www.wireshark.org/</a> 下载用于你操作系统的Wireshark。安装它没有什么特别的，但如果你是安装在Windows上，确保也安装了捆绑的WinPCAP驱动程序。这允许Wireshark实际上捕获数据包（没有它，你只能观看存档的数据包）。</p>

<p>Wireshark通常将你的NIC置于混杂模式。正常情况下，你的NIC只会保留前往你的MAC或者广播MAC（FF-FF-FF-FF-FF-FF）的帧。启用混杂模式后，不管怎样，你的NIC保留所有它听到的帧。</p>

<p>从理论上讲，这意味着你应该接收所有的在你Ethernet段上的数据包。不过，实际上如今几乎所有的Ethernet网络都是交换网络。如果你想接收所有的通信量，必须多做些工作。</p>

<p>一旦你已经安装了Wireshark，使用它是相当简单的。把它打开，你将看到如下显示的屏幕：</p>

<p><img src="/uploads/wireshark-network-analyzer.png" alt="wireshark-network-analyzer"></p>

<p>这个屏幕给你展示选择一个在它上面捕获数据包的NIC的选项和输入一个用于只捕获一部分入站数据包的过滤器的选项。如果你选择一个NIC然后点击在文件菜单下面的小鱼翅图标，Wireshark将立即开始捕获数据包。</p>

<p>随着数据包被捕获，Wireshark在主界面中实时地显示它们。当你准备停止时，你只需点击在鱼翅图标旁边的小红方块。</p>

<p><img src="/uploads/wireshark-main-interface.png" alt="wireshark-main-interface"></p>

<p>数据包列表部分显示在这个点捕获的每件事物，按它们被捕获的顺序排序（默认）。（你可以通过点击要作为排序依据的标题任意地排序这些数据包。）</p>

<p>数据包细节部分显示Wireshark解码的在数据包中的每个报头。基本上，Wireshark有几乎今天在用的每个协议的解码器，并且为了显示分成字段的数据，解码器工具自动应用到每个数据包。</p>

<p>举例来说，如下，我已经为一个典型的HTTP数据包增加了Ethernet II报头。</p>

<p><img src="/uploads/wireshark-http-header.png" alt="wireshark-http-header"></p>

<p>你可以清楚地看到Wireshark已经析出了Destination和Source的MAC地址，以及Type字段，它是0x0800。Type字段指出下个报头应该是一个IPv4报头，Wireshark很方便告诉你这个。</p>

<p>这个解码特性使你不必自己计算字节和解码它（不过，如果你愿意，你仍然还可以在原始字节部分做）。如果对原始字节部分有兴趣：Wireshark同时为所有数据提供ASCII转换，它有时提供令人惊讶的数据。在下图，你可以在ASCII视图里的这个数据包中清楚地看到HTTP请求发送的细节。</p>

<p><img src="/uploads/wireshark-ascii-view.png" alt="wireshark-ascii-view"></p>

<p>Wireshark同时也提供一些非常实用的分析和统计特性，包括测量响应时间和往返时间的能力。但到目前为止，最有用的特性是过滤功能。</p>

<p>在数据包列表直接的上方是一个文本框，那里你可以输入显示过滤器。默认不使用过滤器，意味着显示被捕获的所有数据包。然而，你经常最后得到信息过载，而过滤掉噪音是数据包分析的一个非常重要的部分。</p>

<p>Wireshark中的过滤器按照一门简单的语言结合协议字段、比较运算符和逻辑运算符以便过滤掉不匹配条件的数据包。例如，过滤器http将只显示HTTP通信量，而过滤器ip.addr == 192.168.1.10将只显示源或目标的IP地址是192.168.1.10的数据包。</p>

<p>当你是第一次开始的时候，过滤可能会有点令人生畏，但通常在Wireshark中学习过滤器的最简单的方法是使用内建的表达式工具。可以通过点击过滤器文本框右边的Expression按钮访问它。</p>

<p>这个工具允许你寻遍Wireshark本身支持的所有协议，挑选你想过滤的字段而不需要知道过滤器动词或语法。只需选择协议，填写呈现的字段，然后过滤器将会为你而建。这里，我使用表达式工具构建一个仅查找Ethernet广播的过滤器。</p>

<p><img src="/uploads/wireshark-filter-expression.png" alt="wireshark-filter-expression"></p>

<p>注意工具如何在底部的绿框中显示最终的过滤器语法。通过注意这个字段，你将最终变得熟悉你的最常用的过滤器。</p>

<p>然而，你不能用表达式工具做的一件事是把过滤器串起来。因为那个原因，你需要学习一些逻辑运算符。Wireshark的基本逻辑运算符是and（&amp;&amp;）、or（||）和not（!）。</p>

<p>and被用于结合过滤器，只有满足所有条件的数据包会被显示。例如，过滤器http &amp;&amp; ip.addr == 192.168.1.10将只显示在第7层报头中的HTTP协议和在IP报头中的IP地址192.168.1.10两者都包括的数据包。</p>

<p>or被用于查找两者中的任何一个过滤器，因此满足你输入的任何条件的数据包都会被显示。举例来说，过滤器http || ip.addr == 192.168.1.10将显示在第7层报头中的HTTP协议或在IP报头中的IP地址192.168.1.10的数据包。</p>

<p>not被用于从结果中过滤掉一些东西。例如，过滤器ip.addr == 192.168.1.10 ! http将显示有在IP报头中的IP地址192.168.1.10但没有在第7层报头中的HTTP协议的数据包。</p>

<p>关于基本的Wireshark功能最后要注意的事是，除保存你的原始捕获外，你也有多种多样的选项导出捕获。</p>

<p>首先，你导出当前选择的数据包、所有数据包、你标记的数据包或者一段范围的数据包。在这些选项的每一个中，你可以选择导出所有被捕获的数据包或只是被显示的数据包（考虑当前应用的过滤器）。这些选项让你非常具体地知道你想导出哪些数据包。</p>

<p><img src="/uploads/wireshark-export-packets.png" alt="wireshark-export-packets"></p>

<p>此外，你可以把数据包导出成几乎任何常用的格式。在Wireshark中用于文档和电子邮件转出的最好的特性之一是以纯文本或CSV格式导出解剖数据包（完整的数据包解码）的能力。要做到这个，只需从文件菜单里选择“Export Packet Dissections”。</p>

<h3 id="理解你所看到的">理解你所看到的</h3>

<p>尽管所有这些功能都很好，底线是如果你不明白在每个报头中字段的目的它们都是无用的。幸运的是，除了少量专有协议，你遇到的几乎每个协议的规格说明都是免费在线的。</p>

<p>例如：Ethernet，你可以直接到IEEE下载标准；802.3标准可以在 <a href="http://standards.ieee.org/about/get/802/802.3.html">http://standards.ieee.org/about/get/802/802.3.html</a> 获得。它是免费的直接来自权威人士。如果你在查找802.3 Ethernet帧格式，你将发现真的只有3个感兴趣的字段：目标MAC地址、源MAC地址和类型/长度字段。下图中在Wireshark解剖体左边的是来自IEEE 802.3规格说明Section 1中Part 3.1.1的Figure 3-1：</p>

<p><img src="/uploads/wireshark-packet-format.png" alt="wireshark-packet-format"></p>

<p>如果你想知道preamble和SFD发生了什么，它们在帧从NIC到Wireshark向上传递给栈之前被移除。同样地，你通常不会在末尾看到FCS，因为它在向上传递帧之前被剥去。</p>

<p>在第2层上面，所有TPCTCP/IP协议由IETF管理和由RFCs（请求评论）定义。所有这些RFCs可以在站点 <a href="https://www.rfc-editor.org/">https://www.rfc-editor.org/</a> 上即刻地免费地获得。虽然它们有点简洁（并且因为这个原因有时难以理解），它们总是正确的，具体问题的澄清可以使用Google快速搜索获得。</p>

<p>举例来说，通常混淆新手的事情之一是大量TCP重置，或者在TCP报头中数据包有打开的RST标记。浏览RFC 793（TCP），你可能会得到RST总是用信号告知一些坏事情的印象。几乎所有的35个左右提到的RST与某种错误条件有关联。</p>

<p>然而，使用关键词“tcp rst from client”的Google快速搜索将让你得到大量的关于这个现象的很好的讨论。也许最好的是来自Wireshark论坛，在那里他们解释说这很平常，因为客户端应用仅仅被编码去重置链接而不是优雅地关闭它。在这种情况下，服务端已经发送一个FIN。作为回复一个FIN/ACK并等待最终的ACK的替换，客户端只需通过发送一个RST并中止会话来优化过程。在下面的示例中这可以清楚地被看到。</p>

<p><img src="/uploads/wireshark-pcap-example.png" alt="wireshark-pcap-example"></p>

<p>除了规格说明和Google，另一个学习协议通常如何运转的良好来源是示例跟踪的资料库。这些示例跟踪允许你去查看相当典型的既常见又晦涩的协议操作，以及一些十分罕见的平常可能不会碰到的错误。</p>

<p>一个很好的起点是Wireshark Wiki上的样板捕获：<a href="https://wiki.wireshark.org/SampleCaptures">https://wiki.wireshark.org/SampleCaptures</a> 。在这里有大量非常有用的捕获让你去下载以及用过滤和其它Wireshark特性做实验，包括像广播风暴、病毒和攻击套装这样有意思的错误。如果这些还不够，在这个页面上还有一些其它资源的链接去协助你。但是毫无疑问地，变得擅长协议分析的最快方式是仔细观看大量的捕获并试图理解被使用的协议。</p>

<h3 id="如何得到好的捕获">如何得到好的捕获</h3>

<p>如果不能捕获正确的数据，世界上所有的领悟都无济于事。在最基本的层面，目标是只捕获涉及你试图解决的问题的数据包，有效减少你跟踪里的噪音。</p>

<p>为了做到这点，你可以使用一个捕获过滤器去从捕获中排除那些匹配过滤器外的所有数据。如果你确切地知道你在寻找什么这会工作的很好，但往往这种方法会导致你不能觉察一些重要的事情。大多数时候你只有一个问题是什么的粗略想法，或者你忘了一些潜在的找到错误的关键的过程。如果这种情况发生，使用捕获过滤器就没那么幸运，而且你不能返回和没重设置它就不过滤捕获。</p>

<p>例如，在诊断一个网站的性能问题时，你可能决定使用一个捕获过滤器集从Web服务器自身取得捕获，以便只捕获在其与客户端系统和后台SQL服务器之间往返的数据。然而，这个问题实际上可能仅仅是Web服务器使用的身份验证服务器过载，等待身份验证才是引起整个性能问题的原因。使用你选择的捕获过滤器你将永远不会发现这个问题。</p>

<p>这是我倾向于捕获所有数据并且使用显示过滤器去减少跟踪里的噪音的原因。这不是说捕获过滤器完全不必要。捕获过滤器的一个常见用途是当你有一个非常繁忙的你正在捕获的千兆或万兆连接的时候，捕获过滤器变得有用仅仅是因为大量的数据。不过，你始终需要牢记过滤器的限制。</p>

<p>得到一个好的捕获的第二部分是正确识别你需要捕获的系统。举例来说，在前面关于Web服务器性能问题的例子中，我可能首先会从Web服务器和Web客户端两者取得同时发生的捕获。这样你可以看到两边的正常预期行为的任何偏差，这有助于你将问题隔离到服务器或客户端。</p>

<p>一旦查明延迟是一个与身份验证有关的服务端问题，然后我会从Web服务器和身份验证服务器两者取得其它的跟踪。这样，我可以看到是本地到身份验证服务器的问题还是等待像DNS这样其它服务的问题或者Global Catalog是实际上的罪魁祸首。</p>

<p>得到一个好的捕获的第三步是在成功和失败条件中都使用捕获。举例来说，如果你有一个间歇性的Web服务器性能问题，设法在站点正常和不正常工作时都得到跟踪。这能给你一个好的和坏的比较跟踪，可以使用它去隔离问题。</p>

<p>最后，当处理一个间歇性的问题时，你会发现很难得到一个失败捕获。在这种情况下，Wireshark有一个很重要的特性被称为环形缓冲区，它允许你持续地捕获。</p>

<p>通常，特别在一个繁忙的网络上，持续的捕获将冒填满磁盘的风险。但有了环形缓冲区，Wireshark会写入文件直到它达到指定大小或者经过一段时间，然后它会切换到一个新文件。一旦指定数量的文件已经被写入，程序删除最旧的文件。例如，看看下面我已经定义的设置：</p>

<p><img src="/uploads/wireshark-capture-interfaces.png" alt="wireshark-capture-interfaces"></p>

<p>这个配置告诉Wireshark不管文件大小每10分钟创建一个新文件，并且确保程序保留总计3个文件，根据需要删除最旧的。这确保从错误被通知的时间起我有30分钟去停止捕获。这是一个非常有用的技术用于捕获极其间歇性的问题。</p>

<p>这些是你需要的以便用Wireshark开始故障排除的所有基本技术。使用这些技术和资源，你会发现你经常能用比几乎任何其它技术更短的时间找到和验证网络问题的原因。快乐的故障排除。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/how-to-create-effective-icons/">如何创建有效的图标</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-08-06T12:43:17+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>6</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>12:43 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>英文原文：<a href="http://www.awwwards.com/how-to-create-effective-icons.html">http://www.awwwards.com/how-to-create-effective-icons.html</a></p>

<p>我可能就是你所说的图标爱好者。我喜欢图标，而且我更加喜欢制作它们！作为一个艺术家，我的背景在很大程度上是绘画——我喜欢绘画，并且我已经画了一辈子（甚至远远早于我知道什么是图形设计）。我想，这是我理解创建图标的一个关键。绘画教你看——然后把你所看到的转化成纸上的线条和图形——而这正是如何创建有效的图标。</p>

<h3 id="几何图形">几何图形</h3>

<p>因此，对初学者而言，基本上任何东西都可以用这四种图形组合而成：</p>

<p><img src="/uploads/effective-icons-1.png" alt="effective-icons-1"></p>

<p>当我想把某事物转换成一个图标时，我观察它然后尽可能地将其拆分为最简单的图形。例如，水滴可以用一个三角形和一个圆形组成。</p>

<p><img src="/uploads/effective-icons-2.png" alt="effective-icons-2"></p>

<p>心形图标可以由两个圆形和一个三角形构成。</p>

<p><img src="/uploads/effective-icons-3.png" alt="effective-icons-3"></p>

<p>我每次都是在Adobe Illustrator中创建这些图形。使用矢量图形可以让我控制线条的粗细，以及图形和其锚点的相互作用。Illustrator也可以让我自由地把线条转换成图形，反之亦然。这一切也许看起来十分基础，但它是我用于创建最复杂图标的同样的方法。下面是我最近在做的一个略微更加复杂些的《权利法案》图标的示例，在这里我应用了同样的原则。</p>

<p><img src="/uploads/effective-icons-4.png" alt="effective-icons-4"></p>

<h3 id="界面图标">界面图标</h3>

<p>我最近有机会为一款超赞的iPhone应用Parker Planner制作一组图标。我很喜欢做这个项目，这个项目其中最重要的一个方面是创建一组易懂的、私有的、实用的和美观的用户界面图标，可以帮助用户浏览操作这款略微复杂的计划应用。</p>

<p><img src="/uploads/effective-icons-5.png" alt="effective-icons-5"></p>

<p>让我们选取这些图标的其中之一分解看看我如何创建它。例如，垃圾桶图标是由三个圆角矩形和三条线构成。</p>

<p>1、选择圆角矩形工具。</p>

<p><img src="/uploads/effective-icons-6.png" alt="effective-icons-6"></p>

<p>2、拖动出一个图形。</p>

<p><img src="/uploads/effective-icons-7.png" alt="effective-icons-7"></p>

<p>3、调整笔划宽度直到你满意。</p>

<p><img src="/uploads/effective-icons-8.png" alt="effective-icons-8"></p>

<p>我通常选择在整组图标中使用一到两种笔划宽度。</p>

<p><img src="/uploads/effective-icons-9.png" alt="effective-icons-9"></p>

<p>这使它们看起来更一致和感觉更有整体性。</p>

<p>4、用另一个圆角矩形创建盖子。</p>

<p><img src="/uploads/effective-icons-10.png" alt="effective-icons-10"></p>

<p>5、再一个圆角矩形创建盖子的把手。</p>

<p><img src="/uploads/effective-icons-11.png" alt="effective-icons-11"></p>

<p>6、擦除圆角矩形的下半部分。</p>

<p><img src="/uploads/effective-icons-12.png" alt="effective-icons-12"></p>

<p>7、现在，通过添加三条竖线到桶身上给桶添加条纹。</p>

<p><img src="/uploads/effective-icons-13.png" alt="effective-icons-13"></p>

<p>8、然后你就获得了它！一个垃圾桶图标……如果你喜欢，你可以用颜色或线条宽度做进一步调整。</p>

<p><img src="/uploads/effective-icons-14.png" alt="effective-icons-14"></p>

<p>我在创建图标时经常使用的一些其它真正有用的工具是Pathfinder，我使用它来剪切、连接和挖空图形。</p>

<p><img src="/uploads/effective-icons-15.png" alt="effective-icons-15"></p>

<p>Stroke/Fill工具，它帮助你将图形在填满和笔划间切换。</p>

<p><img src="/uploads/effective-icons-16.png" alt="effective-icons-16"></p>

<p>以及我非常喜欢的工具Stroke Panel，它帮助你将拐角和线的末端从直角转换到圆角。</p>

<p><img src="/uploads/effective-icons-17.png" alt="effective-icons-17"></p>

<p>当我完成一组图标，我通常将它们全体紧挨着排成一排，看看是否有哪个看起来很奇怪或不到位。然后我会做任何必要的修改。</p>

<p><img src="/uploads/effective-icons-18.png" alt="effective-icons-18"></p>

<p>最后，我总是在应用中测试它们以确保它们感觉正确和功能良好。</p>

<p><img src="/uploads/effective-icons-19.png" alt="effective-icons-19"></p>

<p>最终，我想说创建优秀图标的方法不仅仅是学习Illustrator技巧，尽管它们也是必需的。最好的做法是练习把你周围看到的事物分解成简单图形。你在这点上越是变得更好，你越是能够成为更高超的图标设计师！加油！</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/3">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/index.html">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/super-reading-method/">《超级阅读术》读书笔记</a>
      </li>
    
      <li class="post">
        <a href="/blog/rnn-effectiveness/">循环神经网络不可思议的效用</a>
      </li>
    
      <li class="post">
        <a href="/blog/how-to-verify-mailbox-exist/">如何验证邮箱是否存在？</a>
      </li>
    
      <li class="post">
        <a href="/blog/crawl-novel-with-scrapy-part6/">使用Scrapy爬取小说（6）</a>
      </li>
    
      <li class="post">
        <a href="/blog/crawl-novel-with-scrapy-part5/">使用Scrapy爬取小说（5）</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>Tags</h1>
  <ul class="tag-cloud">
    <a style="font-size: 106%" href="/tags/algorithm/">Algorithm</a>
<a style="font-size: 128%" href="/tags/android/">Android</a>
<a style="font-size: 96%" href="/tags/c-plus-plus/">C++</a>
<a style="font-size: 106%" href="/tags/css/">CSS</a>
<a style="font-size: 91%" href="/tags/crack/">Crack</a>
<a style="font-size: 96%" href="/tags/crawler/">Crawler</a>
<a style="font-size: 96%" href="/tags/database/">Database</a>
<a style="font-size: 100%" href="/tags/html/">HTML</a>
<a style="font-size: 86%" href="/tags/heroku/">Heroku</a>
<a style="font-size: 103%" href="/tags/jbookshelf/">JBookShelf</a>
<a style="font-size: 136%" href="/tags/java/">Java</a>
<a style="font-size: 100%" href="/tags/javascript/">JavaScript</a>
<a style="font-size: 96%" href="/tags/listview/">ListView</a>
<a style="font-size: 96%" href="/tags/mysql/">MySQL</a>
<a style="font-size: 103%" href="/tags/paperclip/">Paperclip</a>
<a style="font-size: 96%" href="/tags/python/">Python</a>
<a style="font-size: 116%" href="/tags/qianbao/">Qianbao</a>
<a style="font-size: 150%" href="/tags/rails/">Rails</a>
<a style="font-size: 118%" href="/tags/ruby/">Ruby</a>
<a style="font-size: 96%" href="/tags/scrapy/">Scrapy</a>
<a style="font-size: 91%" href="/tags/spring/">Spring</a>
<a style="font-size: 100%" href="/tags/struts/">Struts</a>
<a style="font-size: 147%" href="/tags/translation/">Translation</a>
<a style="font-size: 91%" href="/tags/ubuntu/">Ubuntu</a>
<a style="font-size: 100%" href="/tags/windows-server-2008/">Windows Server 2008</a>
<a style="font-size: 86%" href="/tags/restful-authentication/">restful_authentication</a>
<a style="font-size: 96%" href="/tags/wxwidgets/">wxWidgets</a>

  </ul>
</section>
<section>
  <h1>Blogroll</h1>
  <ul>
    <li><a href="http://mindhacks.cn/">刘未鹏MIND HACKS</a></li>
    <li><a href="http://www.importnew.com/">ImportNew</a></li>
    <li><a href="http://ifeve.com/">并发编程网</a></li>
    <li><a href="http://codingnow.com/">云风的 BLOG</a></li>
    <li><a href="http://dbanotes.net/">DBA Notes</a></li>
    <li><a href="http://www.ruanyifeng.com/blog/">阮一峰的网络日志</a></li>
    <li><a href="http://advdbg.org/">高端调试</a></li>
    <li><a href="http://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualization</a></li>
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/dohkoos">@dohkoos</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'dohkoos',
            count: 5,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>

<section>
  <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
  <div>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.</div>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2019 - dohkoos -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  





</body>
</html>
