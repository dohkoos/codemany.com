<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[乐者为王]]></title>
  <link href="http://codemany.com/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2015-10-11T11:02:43+00:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[对抗完美]]></title>
    <link href="http://codemany.com/blog/fighting-perfection/"/>
    <updated>2015-10-10T23:43:24+00:00</updated>
    <id>http://codemany.com/blog/fighting-perfection</id>
    <content type="html"><![CDATA[<p>英文原文：<a href="http://usabilitypost.com/2008/10/08/fighting-perfection/">http://usabilitypost.com/2008/10/08/fighting-perfection/</a></p>

<p>如果你像我一样，你可能经常会发现自己从来没有完全满意你的工作——总是做出调整和修改，总是找到你不太喜欢的事情然后改进他们。这适用于很多创造性的努力——或许你正在为你的博客加工一篇文章，整理一份报告或者写一封重要的电子邮件。</p>

<p>问题是，即使在作出修改后，仍然有一些事情你可以调整，事情仍然不是相当完美。</p>

<p>这当然是很好的，你给自己设置了一个高标准。如果你不满意你的工作，那么为什么你的访客或客户就要满意呢？</p>

<h3 id="追求完美是件好事">追求完美是件好事</h3>

<blockquote>
<p>一个建筑师拥有的两个最重要的工具是绘图室的橡皮擦和工地的大铁锤。</p>

<p>Frank Lloyd Wright</p>
</blockquote>

<p>Steve Jobs不满意iPhone的第一个版本。他做了一个艰难的决定去放弃最初的设计，因为他不喜欢它；他觉得这不是Apple能做到的最好的。这引起了很多问题给开发团队，因为他们必须在很短的时间范围内整理出一份全新的设计。</p>

<p>新版本获得了成功，要是他没有做出这个艰难的决定，iPhone将不会成为手机行业的大标志，这在一定程度上要归功于它的标志性设计。</p>

<p>但是……</p>

<h3 id="完美是困难的和费时的">完美是困难的和费时的</h3>

<p>完美可以是危险的和误导的。什么时候足够好？什么时候你可以前进，释放你应用的新版本或发布你的新文章？完美是太高的一个目标，因为它简直太难和太费时去实现。</p>

<p>如果你成了完美的奴隶，你会发现你所有的时间被耗尽。你会不停地做修改调整调整修改——事情却没有按时做完。</p>

<h3 id="如何对抗完美">如何对抗完美?</h3>

<p>考虑优先级——什么是真正要紧的事？对于一个非常大的公司，类似iPhone的东西是一个关键的产品；如果你搞砸了，它能造成严重损失。把产品做正确是至关重要的。设定一个非常高的标准在这里将是一个不错的主意。</p>

<p>那么更小的事情像是博客的设计呢？最终，它通常并不重要，除非这个博客是你的主要业务。在这里简单是你的盟友。简单的东西很难被搞砸，因此创建简单的事情然后把工作做完。</p>

<p>你最宝贵的资源是你的时间。为了对抗完美你必须将时间排出优先次序，并专注于那些要紧的事情。如果你正在做的和改进的事情没有那么重要，那么这些事情就不应该去做。</p>

<h3 id="把事情做完">把事情做完</h3>

<blockquote>
<p>做完。开始把它当作一个咒语。当你去做完它时意味着某些事情已经被完成。决定已经做出，你可以继续前进。做完意味着你正在累积动力。</p>

<p>37signals, <a href="http://gettingreal.37signals.com/ch06_Done.php">Getting Real</a></p>
</blockquote>

<p>执行比想法更重要。把足够好的东西释放出来比做完美但从未完成的东西更好。不要在你做的每件事情上寻求完美——除了那些真正要紧的事情。驯服完美——更快地做完其它的每件事情，把节省下来的时间用在你最重要的项目上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elasticsearch的RESTful API]]></title>
    <link href="http://codemany.com/blog/elasticsearch-restful-api/"/>
    <updated>2015-02-14T01:31:14+00:00</updated>
    <id>http://codemany.com/blog/elasticsearch-restful-api</id>
    <content type="html"><![CDATA[<p>CURD的URL格式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>http://localhost:9200/&lt;index&gt;/&lt;type&gt;/[&lt;id&gt;]
</span></code></pre></td></tr></table></div></figure>

<p>id是可选的，不提供的话Elasticsearch会自动生成。index和type将信息进行分层，便于管理。可以将index理解为数据库，type理解为数据表。</p>

<p>创建</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># 使用自动生成ID的方式新建纪录
</span><span class='line'>curl -XPOST localhost:9200/&lt;index&gt;/&lt;type&gt; -d '{ "tag" : "bad" }'
</span><span class='line'>
</span><span class='line'># 使用指定的ID新建记录
</span><span class='line'>curl -XPOST localhost:9200/&lt;index&gt;/&lt;type&gt;/3 -d '{ "tag" : "bad" }'
</span></code></pre></td></tr></table></div></figure>

<p>查询</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># 查询所有的index和type的记录
</span><span class='line'>curl -XGET localhost:9200/_search?pretty
</span><span class='line'>
</span><span class='line'># 查询某个index下所有type的记录
</span><span class='line'>curl -XGET localhost:9200/&lt;index&gt;/_search?pretty
</span><span class='line'>
</span><span class='line'># 查询某个index下某个type下所有的记录
</span><span class='line'>curl -XGET localhost:9200/&lt;index&gt;/&lt;type&gt;/_search?pretty
</span><span class='line'>
</span><span class='line'># 使用参数查询所有的记录
</span><span class='line'>curl -XGET localhost:9200/_search?q=tag:bad&pretty
</span><span class='line'>
</span><span class='line'># 使用参数查询某个index下的所有记录
</span><span class='line'>curl -XGET localhost:9200/&lt;index&gt;/_search?q=tag:bad&pretty
</span><span class='line'>
</span><span class='line'># 使用参数查询某个index下某个type下所有的记录
</span><span class='line'>curl -XGET localhost:9200/&lt;index&gt;/&lt;type&gt;/_search?q=tag:bad&pretty
</span><span class='line'>
</span><span class='line'># 使用JSON参数查询所有的记录，-d代表一个JSON格式的对象
</span><span class='line'>curl -XGET localhost:9200/_search?pretty -d '{ "query" : { "term" : { "tag" : "bad" } } }'
</span><span class='line'>
</span><span class='line'># 使用JSON参数查询某个index下的所有记录
</span><span class='line'>curl -XGET localhost:9200/&lt;index&gt;/_search?pretty -d '{ "query" : { "term" : { "tag" : "bad" } } }'
</span><span class='line'>
</span><span class='line'># 使用JSON参数查询某个index下某个type下所有的记录
</span><span class='line'>curl -XGET localhost:9200/&lt;index&gt;/&lt;type&gt;/_search?pretty -d '{ "query" : { "term" : { "tag" : "bad" } } }'
</span></code></pre></td></tr></table></div></figure>

<p>更新</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl -XPUT localhost:9200/&lt;index&gt;/&lt;type&gt;/3 -d '{ "tag" : "good" }'
</span></code></pre></td></tr></table></div></figure>

<p>删除</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl -XDELETE localhost:9200/&lt;index&gt;
</span></code></pre></td></tr></table></div></figure>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elasticsearch安装]]></title>
    <link href="http://codemany.com/blog/elasticsearch-installation/"/>
    <updated>2015-02-10T15:50:34+00:00</updated>
    <id>http://codemany.com/blog/elasticsearch-installation</id>
    <content type="html"><![CDATA[<p><a href="http://elastic.co/">Elasticsearch</a>是一款基于<a href="http://lucene.apache.org/">Lucene</a>构建的开源分布式全文检索服务器。提供RESTful API，采用多shard的方式保证数据安全，提供自动resharding的功能，能够很轻松地进行大规模的横向扩展，以支撑PB级的结构化和非结构化海量数据的处理。</p>

<p>安装Java 1.7</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mkdir /usr/java
</span><span class='line'>cd /usr/java
</span><span class='line'>wget --no-check-certificate --no-cookies --header "Cookie: oraclelicense=accept-securebackup-cookie" http://download.oracle.com/otn-pub/java/jdk/7u67-b01/jdk-7u67-linux-x64.rpm
</span><span class='line'>rpm -ivh jdk-7u67-linux-x64.rpm
</span><span class='line'>java -version
</span><span class='line'>echo $JAVA_HOME
</span></code></pre></td></tr></table></div></figure>

<p>安装Elasticsearch 1.4.1</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mkdir /usr/elasticsearch
</span><span class='line'>cd /usr/elasticsearch
</span><span class='line'>wget https://download.elastic.co/elasticsearch/elasticsearch/elasticsearch-1.4.1.tar.gz
</span><span class='line'>tar -xvf elasticsearch-1.4.1.tar.gz
</span><span class='line'>cd elasticsearch-1.4.1
</span><span class='line'>./bin/elasticsearch
</span></code></pre></td></tr></table></div></figure>

<p>然后访问<code>http://localhost:9200/?pretty</code>就可以看到类似下面的返回：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "status" : 200,
</span><span class='line'>  "name" : "Powerpax",
</span><span class='line'>  "cluster_name" : "elasticsearch",
</span><span class='line'>  "version" : {
</span><span class='line'>    "number" : "1.4.1",
</span><span class='line'>    "lucene_version" : "4.10.2"
</span><span class='line'>  },
</span><span class='line'>  "tagline" : "You Know, for Search"
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>

<p>只是运行起来是不够的，通常我们需要将Elasticsearch安装成服务，设置成开机自启动什么的。这要用到<a href="https://github.com/elasticsearch/elasticsearch-servicewrapper">elasticsearch-servicewrapper</a>了。下载解压后把service文件夹拷贝到elasticsearch-1.4.1/bin目录下。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>./bin/service/elasticsearch install  # 安装服务
</span><span class='line'>./bin/service/elasticsearch start  # 运行服务
</span></code></pre></td></tr></table></div></figure>

<p>其它参数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>console 以前台方式运行Elasticsearch
</span><span class='line'>stop 停止Elasticsearch
</span><span class='line'>remove 移除系统启动中的Elasticsearch服务（init.d/service）
</span></code></pre></td></tr></table></div></figure>

<p>需要注意的是，在小内存机器上运行时，需要限制下内存大小，否则服务会无法启动，出现如下警告信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Starting Elasticsearch...
</span><span class='line'>Waiting for Elasticsearch......................
</span><span class='line'>WARNING: Elasticsearch may have failed to start.
</span></code></pre></td></tr></table></div></figure>

<p>打开bin/service/elasticsearch.conf文件，设置Elasticsearch能够分配的JVM内存大小。一般情况下，设置成总内存的50%比较好。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>set.default.ES_HEAP_SIZE=512
</span></code></pre></td></tr></table></div></figure>

<p>如果要限制ES_MIN_MEM和ES_MAX_MEM，建议设置成一样大，避免出现频繁的内存分配。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为什么我们不能用估算房屋同样的方法估算软件项目]]></title>
    <link href="http://codemany.com/blog/why-we-cant-estimate-software-project-the-same-way-we-estimate-houses/"/>
    <updated>2015-01-10T01:33:48+00:00</updated>
    <id>http://codemany.com/blog/why-we-cant-estimate-software-project-the-same-way-we-estimate-houses</id>
    <content type="html"><![CDATA[<p>英文原文：<a href="http://www.summa-tech.com/blog/2009/01/28/why-we-cant-estimate-software-project-the-same-way-we-estimate-houses">http://www.summa-tech.com/blog/2009/01/28/why-we-cant-estimate-software-project-the-same-way-we-estimate-houses</a></p>

<p>把构造软件类比成建造房屋是非常有用的，但也有缺陷。</p>

<p>尽管软件建设和住宅建设都是工程实践，但比起软件，我们在估算建造房屋的成本和精力方面更成功。</p>

<h3 id="词汇障碍">词汇障碍</h3>

<p>因为我们大多数人一生都住在房子里，我们开发了一套定义良好的、可以理解的、几乎通用的词汇来描述和讨论关于我们称之为家的地方。当被问及我们的房子是什么样子的，我们可以很容易地回答。当计划一所新房子时，我们可以极其肯定地讨论我们想要什么，并确信建筑师和工程师会明白我们谈论的，反之亦然。我们可能不明白水管设施和电气细节，但我们知道电源插座要放在哪里，知道房间的大小，知道要有多少车库门。</p>

<p>当我们谈论软件时，就不是那么有效了。有太多来自业务和技术方面的新术语，我们需要依赖于现实世界中的类比去解释他们。不仅发生在业务和技术人员之间，甚至还发生在业务人员和业务人员，技术人员和技术人员之间。我们不习惯于去描述软件需求因为所有软件的抽象，在估算时沟通经常受到噪音、误解、缺乏眼界的影响，增加了真正需要构建的不确定性。</p>

<h3 id="物理">物理</h3>

<p>现实世界有非常强大和稳定的规则，比如重力，这些规则会在盖房子的时候施加约束。我们知道我们必须在构建二楼前先完成地下室。我们不能在地基完成后增加层的数量。在水管设施铺设后更改浴室的位置将会是非常非常昂贵的。</p>

<p>在软件项目中，我们生活在一个较少规则的世界里，就像《黑客帝国》。从技术上讲，我们可以在同一时间构造所有的应用层。它可以被设计成使用不同的数据库，运行在不同的服务器，或支持不同的语言。它可以通过浏览器、手机、或其它无线设备访问。选项几乎是无穷无尽的。</p>

<p>正是这种自由和灵活性，在过去的40年里驱动了软件的巨大的进步，但在同时，它也是无数软件项目失败的原因。至关重要的是需求要面对现实，让它们遵守一些基本规则，即使它们不受宇宙物理规律的约束。</p>

<h3 id="程序">程序</h3>

<p>物理和几千年建设的结合已经带来了如何去建造一座房子的一套可靠的程序，虽然总是会有新的材料和改进的技术，核心概念都是相同的。油漆房子的过程几百年来几乎没有变化。</p>

<p>我们仍然处于软件工程的早期阶段。大量的“直觉”仍在估算软件时使用，实际情况是直觉还没有被证明非常有效。</p>

<h3 id="材料和标准">材料和标准</h3>

<p>只有数量有限的材料能被实际地用在建造房屋上。从技术上来讲，可能有成千上百的选项去建造一堵墙：夹板、混凝土、钢铁、沙子、玻璃，但在家具建材零售店里这些选项是非常有限的。涂料的类型，门窗的模型很多但有限。当购买一个水槽时，它很容易兼容已有的水管设施的几率非常高。电器有着相同的电压，灯泡也是兼容的。计划建造一所房子的一切都是兼容的，材料更是普及的，把不确定性降低到了非常小的水平，提高了估算的准确性。</p>

<p>软件行业确实有一些标准，但是它们处于层的最低水平，例如网络协议和文件系统。服务器和产品的集成仍处于布线阶段，XML和Web Service还有很长的路要走，在它们和建筑业达到相同级别的兼容性前，如果这是可能的。</p>

<p>各种各样连接到数据库和构建软件的选项和方法增加了复杂性，提高了每个人参与软件构建工作的学习曲线。我不是说所有这些选项都是不好的，但它确实给估算阶段增加了不确定性，所以产生了复杂性。</p>

<h3 id="角色">角色</h3>

<p>每次我路过建筑工地，都会看到很多帽子，一些在积极工作，一些在等待时机采取行动。但最好的部分是我从来没有见过有人同时戴两顶帽子。角色界定的很明确，工人们专业从事于非常具体的领域。</p>

<p>在大型软件项目中也有一些角色被定义，但还远远没有达到建筑业相同级别的专业化。通常团队成员需要戴上很多帽子，结果是，有时候他们会执行那些他们不是专家的任务，这就增加了他们提供的估算的不确定性。</p>

<p>“很多帽子”现象的一个很好例子是“Webmaster”，该角色用于描述那个做网页设计、创建动画图片、编写HTML和Perl代码、配置数据库、管理网络和邮件服务器的家伙。幸运的是现在Webmaster是个很少使用的术语，因为所有这些活动现在都分配给了不同的角色，像网页设计师、DBA，程序员和系统管理员。我们确实在走向专业化，但还是有很长的路要走。</p>

<p>我并不是建议我们停止使用“让我们像建造房屋那样构造软件”的类比，但我们必须意识到这个比喻的局限性。一旦我们知道局限性我们将能更好地定位讨论这一差异，以及提供建议如何解决它们。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TabActivity is deprecated]]></title>
    <link href="http://codemany.com/blog/tabactivity-is-deprecated/"/>
    <updated>2014-12-05T11:29:10+00:00</updated>
    <id>http://codemany.com/blog/tabactivity-is-deprecated</id>
    <content type="html"><![CDATA[<p>最近在整理<a href="http://codemany.com/blog/summary-of-android-tab-navigation/">Android Tab导航总结</a>的代码时发现
TabActivity在API 13中被标记为过期了，所以就去寻找它的替换类，能尽量满足最小修改的要求。发现可以使用FragmentActivity来替代，Fragment组件作为标签页添加。</p>

<p>Fragment是Android 3.0引入的一个新概念，主要是为了适应各种不同的屏幕大小，它非常类似于Activity，可以像Activity一样包含布局，但是不能单独存在，只能存在于Activity中。下图是Fragment在不同屏幕上的显示以及Fragment与所在Activity的关系：</p>

<p><img src="http://codemany.com/uploads/android-fragments.png" title="android-fragments" ></p>

<p>重构前的布局：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>MainActivity extends TabActivity
</span><span class='line'>    TabHost - tabhost
</span><span class='line'>        LinearLayout
</span><span class='line'>            TabWidget - tabs
</span><span class='line'>            FrameLayout - tabcontent
</span><span class='line'>                TabSpec (Activity)
</span><span class='line'>                ...
</span><span class='line'>                TabSpec (Activity)
</span></code></pre></td></tr></table></div></figure>

<p>重构后的布局：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>MainActivity extends FragmentActivity
</span><span class='line'>    TabHost - tabhost
</span><span class='line'>        LinearLayout
</span><span class='line'>            TabWidget - tabs
</span><span class='line'>            FrameLayout - tabcontent
</span><span class='line'>                TabSpec (Fragment)
</span><span class='line'>                ...
</span><span class='line'>                TabSpec (Fragment)
</span></code></pre></td></tr></table></div></figure>

<p>把TabLeftActivity和TabRightActivity分别改成LeftFragment和RightFragment：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class LeftFragment extends Fragment {
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    public View onCreateView(LayoutInflater inflater, ViewGroup container,
</span><span class='line'>            Bundle savedInstanceState) {
</span><span class='line'>        rootView = inflater.inflate(R.layout.tab_left, container, false);
</span><span class='line'>
</span><span class='line'>        // do something
</span><span class='line'>        // 不能直接使用findViewById()方法，必须加上rootView前缀
</span><span class='line'>        // 如果要引用当前绑定的Activity实例，使用getActivity()方法
</span><span class='line'>
</span><span class='line'>        return rootView;
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>

<p>然后在main.xml中的FrameLayout里添加两个Fragment组件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;fragment android:name="com.example.fragments.LeftFragment"
</span><span class='line'>    android:id="@+id/fragment_left"
</span><span class='line'>    android:layout_width="match_parent"
</span><span class='line'>    android:layout_height="match_parent" /&gt;
</span><span class='line'>
</span><span class='line'>&lt;fragment android:name="com.example.fragments.RightFragment"
</span><span class='line'>    android:id="@+id/fragment_right"
</span><span class='line'>    android:layout_width="match_parent"
</span><span class='line'>    android:layout_height="match_parent" /&gt;
</span></code></pre></td></tr></table></div></figure>

<p>把MainActivity改成从FragmentActivity继承。这里不能像TabActivity一样直接用getTabHost()，需要改成如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>TabHost tabHost = (TabHost)findViewById(android.R.id.tabhost);
</span><span class='line'>tabHost.setup();
</span></code></pre></td></tr></table></div></figure>

<p>到这边就已经完成了，其它tabHost.addTab的使用方式一模一样。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[根据Exif时间信息归类照片]]></title>
    <link href="http://codemany.com/blog/move-photos-to-folders-based-on-exif-date/"/>
    <updated>2014-11-20T14:52:37+00:00</updated>
    <id>http://codemany.com/blog/move-photos-to-folders-based-on-exif-date</id>
    <content type="html"><![CDATA[<p>先要把Exif中的信息解析出来，得到其中的时间，有个<a href="https://github.com/remvee/exifr">exif</a>的gem很不错。然后再根据时间创建目录，把照片移动到对应的目录中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>require 'rubygems'
</span><span class='line'>require 'exifr'
</span><span class='line'>require 'fileutils'
</span><span class='line'>
</span><span class='line'>root = ARGV[0] || Dir.pwd
</span><span class='line'>
</span><span class='line'>Dir.foreach(root) do |file|
</span><span class='line'>  next if File.extname(file) != '.jpg'
</span><span class='line'>
</span><span class='line'>  obj = EXIFR::JPEG.new(file)
</span><span class='line'>  date_time_original = obj.exif.date_time_original if obj.exif?
</span><span class='line'>  next if date_time_original.nil?
</span><span class='line'>
</span><span class='line'>  dir = date_time_original.year.to_s
</span><span class='line'>  Dir.mkdir(dir) unless Dir.exist?(dir)
</span><span class='line'>  FileUtils.move(file, dir)
</span><span class='line'>end
</span></code></pre></td></tr></table></div></figure>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重构Rails代码]]></title>
    <link href="http://codemany.com/blog/refactoring-rails-code/"/>
    <updated>2014-11-18T11:42:59+00:00</updated>
    <id>http://codemany.com/blog/refactoring-rails-code</id>
    <content type="html"><![CDATA[<p>在以前写的博文<a href="http://codemany.com/blog/problem-when-deploying-application-to-heroku/">部署应用到Heroku时的问题</a>里有这么一段话：</p>

<blockquote>
<p>股票功能需要导入交割单文件，因为导入后的文本文件不再使用，可以把上传路径由public/uploads改为tmp，这样就避免了Heroku不能写文件的问题。</p>
</blockquote>

<p>下面是那时候写的导入代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class StocksController &lt; ApplicationController
</span><span class='line'>  UPLOADS_DIRECTORY = File.join("#{Rails.root}", "public/uploads")
</span><span class='line'>
</span><span class='line'>  def import
</span><span class='line'>    filename = upload_file(params[:file])
</span><span class='line'>    lines = File.readlines("#{UPLOADS_DIRECTORY}/#{filename}")
</span><span class='line'>    lines.each do |line|
</span><span class='line'>      # do something
</span><span class='line'>    end
</span><span class='line'>    redirect_to stocks_url
</span><span class='line'>  end
</span><span class='line'>
</span><span class='line'>  protected
</span><span class='line'>    def upload_file(file)
</span><span class='line'>      if !file.original_filename.empty?
</span><span class='line'>        @filename = get_file_name(file.original_filename)
</span><span class='line'>        Dir.mkdir("#{UPLOADS_DIRECTORY}") unless Dir.exist?("#{UPLOADS_DIRECTORY}")
</span><span class='line'>        File.open("#{UPLOADS_DIRECTORY}/#{@filename}", "wb") do |f|
</span><span class='line'>          f.write(file.read)
</span><span class='line'>        end
</span><span class='line'>        return @filename
</span><span class='line'>      end
</span><span class='line'>    end
</span><span class='line'>
</span><span class='line'>    def get_file_name(filename)
</span><span class='line'>      if !filename.nil?
</span><span class='line'>        # does not support chinese filename?
</span><span class='line'>        Time.now.strftime("%Y%m%d%H%M%S") + '.txt'
</span><span class='line'>      end
</span><span class='line'>    end
</span><span class='line'>end
</span></code></pre></td></tr></table></div></figure>

<p>这里的实现方法是先将上传文件保存到服务器上应用的public/uploads目录中，然后再读取和处理。</p>

<p>其实根本不需要写的这么复杂，因为导入的文件被读取一次后就不再使用了。所以在当时写代码的时候一直有这样的想法，如果能直接获得上传文件的数据，那么就不需要再另外去写保存和读取文件的代码了。</p>

<p>事实也是如此。通过表单提交的file数据会首先在服务器上形成临时文件，这时其实可以通过临时文件的路径来读取上传文件的数据。</p>

<p>根据该想法重构后的代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class StocksController &lt; ApplicationController
</span><span class='line'>  def import
</span><span class='line'>    lines = File.readlines(params[:file].tempfile.to_path.to_s)
</span><span class='line'>    lines.each do |line|
</span><span class='line'>      # do something
</span><span class='line'>    end
</span><span class='line'>    redirect_to stocks_url
</span><span class='line'>  end
</span></code></pre></td></tr></table></div></figure>

<p>重构后的代码果然清爽多了，不过还是有改进的空间。</p>

<p>作为控制器，controller只是负责接收request，并返回response。而具体的业务逻辑，则应该交由model去完成。下面是依照该理念再次重构后的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class StocksController &lt; ApplicationController
</span><span class='line'>  def import
</span><span class='line'>    Stock.import(params[:file])
</span><span class='line'>    redirect_to stocks_url
</span><span class='line'>  end
</span><span class='line'>end
</span><span class='line'>
</span><span class='line'>class Stock &lt; ActiveRecord::Base
</span><span class='line'>  def self.import(file)
</span><span class='line'>    lines = File.readlines(file.tempfile.to_path.to_s)
</span><span class='line'>    lines.each do |line|
</span><span class='line'>      # do something
</span><span class='line'>    end
</span><span class='line'>  end
</span><span class='line'>end
</span></code></pre></td></tr></table></div></figure>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[打错multipart引发的血案]]></title>
    <link href="http://codemany.com/blog/multipart-misspelling-cause-bug/"/>
    <updated>2014-11-13T01:27:17+00:00</updated>
    <id>http://codemany.com/blog/multipart-misspelling-cause-bug</id>
    <content type="html"><![CDATA[<p>浪费几个小时，杀死无数脑细胞，最终发现是单词打错了。不过错有错招，这个问题也让我重新温习了一遍关于form数据编码的知识。</p>

<p>在做上传表单时，一直报告如下错误：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>undefined method 'original_filename' for "example.csv":String
</span></code></pre></td></tr></table></div></figure>

<p>在 <a href="http://guides.rubyonrails.org/form_helpers.html#what-gets-uploaded">http://guides.rubyonrails.org/form_helpers.html#what-gets-uploaded</a> 有这样一段文字：</p>

<blockquote>
<p>The object in the params hash is an instance of a subclass of IO. Depending on the size of the uploaded file it may in fact be a StringIO or an instance of File backed by a temporary file. In both cases the object will have an original_filename attribute containing the name the file had on the user&#39;s computer and a content_type attribute containing the MIME type of the uploaded file.</p>
</blockquote>

<p>说明example.csv应该是IO类型的，这里怎么显示是String呢？</p>

<p>表单代码为</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;%= form_tag import_stocks_path, mutlipart: true do %&gt;
</span></code></pre></td></tr></table></div></figure>

<p>或</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;%= form_tag import_stocks_path, method: :post, mutlipart: true do %&gt;
</span></code></pre></td></tr></table></div></figure>

<p>生成后的HTML代码都是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;form action="/stocks/import" method="post" mutlipart="true"&gt;
</span></code></pre></td></tr></table></div></figure>

<p>正确的HTML代码应该是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;form action="/stocks/import" method="post" enctype="multipart/form-data"&gt;
</span></code></pre></td></tr></table></div></figure>

<p>使用HttpFox工具抓取表单提交信息如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>POST /stocks/import HTTP/1.1
</span><span class='line'>Host localhost:3000
</span><span class='line'>Referer   http://localhost:3000/stocks/import
</span><span class='line'>Connection keep-alive
</span><span class='line'>Content-Type application/x-www-form-urlencoded
</span><span class='line'>Content-Length 112
</span></code></pre></td></tr></table></div></figure>

<p>什么是application/x-www-form-urlencoded？含有file类型字段的表单编码不应该是multipart/form-data吗。</p>

<p>form的enctype属性通常有两种：application/x-www-form-urlencoded和multipart/form-data，默认为前者。当method=get时，浏览器用application/x-www-form-urlencoded编码方式把form数据转换成一个字串（name1=value1&amp;name2=value2...），然后把这个字串附加到url后面，用?分割。当method=post的时候，浏览器把form数据封装到post-body中。如果没有type=file的控件，就用默认的application/x-www-form-urlencoded编码。但是如果有type=file的话，就要用到multipart/form-data了。浏览器会把整个表单以控件为单位分割，并为每个部分加上Content-Disposition（form-data或者file），Content-Type（默认为text/plain），name等信息，并加上分割边界（boundary）。</p>

<p>这时才发现原来是把multipart打错成mutlipart了，真是惨痛的教训啊！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何禁止VirtualBox虚拟机和物理机之间的时间同步]]></title>
    <link href="http://codemany.com/blog/how-to-disable-virtualbox-time-sync-between-host-and-guest/"/>
    <updated>2014-11-02T02:03:29+00:00</updated>
    <id>http://codemany.com/blog/how-to-disable-virtualbox-time-sync-between-host-and-guest</id>
    <content type="html"><![CDATA[<p>主机是Windows Server 2008，虚拟机Windows XP，VirtualBox的版本为4.3.6。</p>

<p>因为某种原因，需要修改XP系统的时间设置。但在设置后不到10秒钟就又和主机的时间自动同步了。</p>

<p>实时同步时间功能是由Guest Additions提供的，把它卸载就可以修改时间，不过这不是好的解决方法。</p>

<p>翻阅<a href="http://www.virtualbox.org/manual/">VirtualBox User Manual</a>，找到“Disabling the Guest Additions time synchronization”章节，说明如何能把时间同步给禁止掉。在主机环境执行以下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>VBoxManage setextradata "YOUR_VM_NAME" "VBoxInternal/Devices/VMMDev/0/Config/GetHostTimeDisabled" 1
</span></code></pre></td></tr></table></div></figure>

<p>YOUR_VM_NAME是你的虚拟机名字，可以通过VBoxManage list vms命令查询到。</p>

<p>还有种方法是修改虚拟机的注册表，把HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\VBoxService项下ImagePath值改为system32\VBoxService.exe --disable-timesync，禁止Guest Additions启动时间同步。修改好后重启虚拟机就可以了。</p>

<p>另外就是虚拟机冷启动时都会和主机时间同步先，这意味着关机再开机的话上次的时间修改就失效了，必须再次手动调整。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git笔记之rebase --onto]]></title>
    <link href="http://codemany.com/blog/git-notes-rebase-onto/"/>
    <updated>2014-10-26T05:41:19+00:00</updated>
    <id>http://codemany.com/blog/git-notes-rebase-onto</id>
    <content type="html"><![CDATA[<p>有的时候，可能需要修改某个已提交commit。如果是修改最近提交的commit，可以使用git commit --amend命令；如果是修改更早提交的commit，可以使用git rebase -i HEAD~n。不过这个命令有个缺陷，就是不能修改最早提交的那个commit。假设有如下提交历史：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>A - B - C - D
</span></code></pre></td></tr></table></div></figure>

<p>要修改D可以使用git commit --amend；要修改B、C或D可以使用git rebase -i HEAD~n；但是如果要修改A呢？这就需要rebase --onto出场了。下面就来实例讲解如何使用rebase --onto命令。</p>

<p>因为要修改A这个commit，所以先在它之上创建临时分支v1：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git checkout -b v1 A
</span></code></pre></td></tr></table></div></figure>

<p>然后就可以在v1分支上做想要的修改了，改完之后用下面的命令提交更改的内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git commit -a --amend
</span></code></pre></td></tr></table></div></figure>

<p>这时查看v1分支的提交历史，可以发现SHA1值已经发生了变化（master分支的SHA1值仍然不变）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>A'
</span></code></pre></td></tr></table></div></figure>

<p>接着可以把修改后的内容和master分支合并：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git rebase --onto v1 A master
</span></code></pre></td></tr></table></div></figure>

<p>表示把master分支上从A之后的所有提交重新apply到v1分支最新的commit之后。</p>

<p>这里有两点要注意：一个是A处的开闭问题，rebase --onto的机制是左开右闭，也就是说上述命令只会apply三个提交B、C、D；第二是rebase --onto之后v1分支的提交历史没有改变，还是只有一个提交A’，当前活动分支切换到了master，并且所有commit的SHA1值都发生了改变。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>A' - B' - C' - D'
</span></code></pre></td></tr></table></div></figure>

<p>最后就是正常的rebase --continue流程了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby中读二进制文件时大小错误]]></title>
    <link href="http://codemany.com/blog/read-binary-file-give-wrong-size-in-ruby/"/>
    <updated>2014-10-09T15:37:59+00:00</updated>
    <id>http://codemany.com/blog/read-binary-file-give-wrong-size-in-ruby</id>
    <content type="html"><![CDATA[<p>经常会遇到这类场景，要把文件内容一次性全部读取出来。使用IO.read(&#39;example.bin&#39;)读取二进制文件时，发现读出来的大小与实际结果不符合。原来默认不加参数时仅限于读文本文件，需要指定mode为b。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>IO.read('example.bin', { mode: 'rb' })
</span></code></pre></td></tr></table></div></figure>

<p>还有种简洁的读取方式是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>File.open('example.bin', 'rb').readlines.join
</span></code></pre></td></tr></table></div></figure>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress 2.0使用技巧]]></title>
    <link href="http://codemany.com/blog/tricks-and-tips-for-octopress/"/>
    <updated>2014-09-15T05:16:30+00:00</updated>
    <id>http://codemany.com/blog/tricks-and-tips-for-octopress</id>
    <content type="html"><![CDATA[<p>Octopress 2.0带的RDiscount支持表格等Markdown扩展语法了。具体语法看 <a href="https://michelf.ca/projects/php-markdown/extra/#table">https://michelf.ca/projects/php-markdown/extra/#table</a> 。不过默认表格是不具有边框的，在显示数据时会很难看。<a href="http://programus.github.io/blog/2012/03/07/add-table-data-css-for-octopress/">http://programus.github.io/blog/2012/03/07/add-table-data-css-for-octopress/</a> 修复了这个问题，只是它的修改有些复杂，其实只要把data-table.css的内容粘贴到sass/custom/_styles.scss里就出效果了。</p>

<p>还有就是Octopress中的列表项应该是右移的，实际左移了。可以在sass/custom/_styles.scss添加以下代码解决：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>article {
</span><span class='line'>  ol, ul {
</span><span class='line'>    padding-left: 3em;
</span><span class='line'>  }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>

<p>更简单的办法是把sass/custom/_layout.scss中被注释的这行代码打开：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//$indented-lists: true;
</span></code></pre></td></tr></table></div></figure>

<p>列表、表格前要有空行，例如</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>List
</span><span class='line'>* item
</span><span class='line'>* item
</span><span class='line'>* item
</span><span class='line'>
</span><span class='line'>Table
</span><span class='line'>column | column
</span><span class='line'>------ | ------
</span><span class='line'>value  | value
</span><span class='line'>value  | value
</span></code></pre></td></tr></table></div></figure>

<p>不会正常显示，必须在List和Table后空一行才行。就像下面这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>List
</span><span class='line'>
</span><span class='line'>* item
</span><span class='line'>* item
</span><span class='line'>* item
</span><span class='line'>
</span><span class='line'>Table
</span><span class='line'>
</span><span class='line'>column | column
</span><span class='line'>------ | ------
</span><span class='line'>value  | value
</span><span class='line'>value  | value
</span></code></pre></td></tr></table></div></figure>

<p>如果你已经发表了许多的文章，Octopress站点的生成速度将会非常之慢，解决方式是使用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake isolate['title']
</span></code></pre></td></tr></table></div></figure>

<p>隔离你所工作的文章（使用此命令前请确保该文章已经存在）。</p>

<p>现在使用以下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake generate
</span><span class='line'>rake preview
</span></code></pre></td></tr></table></div></figure>

<p>将会仅工作在被隔离的文章上。</p>

<p>解除文章的隔离可以使用以下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake integrate
</span></code></pre></td></tr></table></div></figure>

<p>如果想在rake new_post/page后使用指定编辑器自动打开生成的文件，可以编辑Rakefile，在Misc Configs段中添加以下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>editor="open"
</span><span class='line'># open，使用系统默认编辑器
</span><span class='line'># open -a Mou，使用Mou打开
</span><span class='line'># open -a Byword，使用Byword打开
</span><span class='line'># subl，使用Sublime Text2打开
</span></code></pre></td></tr></table></div></figure>

<p>然后在task :new_post和task :new_page的末尾添加如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if #{editor}
</span><span class='line'>  system "sleep 1; #{editor} #{filename}"
</span><span class='line'>end
</span></code></pre></td></tr></table></div></figure>

<p>在rake preview后自动打开浏览器，也可以编辑Rakefile，在task :preview任务中添加：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>system "sleep 2; open http://localhost:#{server_port}/"
</span></code></pre></td></tr></table></div></figure>

<p>如果日后Octopress有新版本发布，可以使用以下指令升级：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git remote add octopress git://github.com/imathis/octopress.git
</span><span class='line'>git pull octopress master  # Get the latest Octopress
</span><span class='line'>bundle install             # Keep gems updated
</span><span class='line'>rake update_source         # update the template's source
</span><span class='line'>rake update_style          # update the template's style
</span></code></pre></td></tr></table></div></figure>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Wordpress迁移到Octopress]]></title>
    <link href="http://codemany.com/blog/migrating-wordpress-to-octopress/"/>
    <updated>2014-08-05T11:15:03+00:00</updated>
    <id>http://codemany.com/blog/migrating-wordpress-to-octopress</id>
    <content type="html"><![CDATA[<p>GitHub Pages提供免费的静态站点托管服务，有两种类型：User/Organization Pages和Project Pages。前者是用户/组织的主页，一个用户/组织仅有一个；后者是每个项目的主页。</p>

<p>安装Octopress时，rake setup_github_pages会要求输入GitHub Pages项目的URL，根据URL判断是哪种服务。如果是前者，会在新建的<code>_deploy</code>目录上创建master分支，用于存放发布的静态文件，并把原master分支改为source分支；后者则仅在<code>_deploy</code>目录上创建gh-pages分支。</p>

<p>Octopress默认的permalink是/blog/:year/:month/:day/:title/，想把它改成/:title/这种格式。修改后，发现生成的文章都跑到了public目录下，默认应该是在public/blog目录里的。为保持目录的简洁，把它改成了/blog/:title/，这样虽然生成的文章没有按年月日分目录，但是用户在访问系列文章时就可以只修改相应数字，不然必须得记住几乎不可能知道的文章的发布年月日。</p>

<p>至于评论的迁移，不想费过多的手脚，直接使用Octopress自带的Disqus。在Wordpress中安装好Disqus插件，通过插件设置将现有的评论内容导入Disqus。不过Disqus处理导入数据的时间有点长，需要等待一段时间，可以在 <a href="http://import.disqus.com">http://import.disqus.com</a> 查看导入进度。导入完成后，把Wordpress文章的permalink改成和Octopress相同，登录Disqus后台，找到Migrate Threads栏目，在Domain Migration Wizard里把旧域名改成新域名，然后一路Next就大功告成了。</p>

<p>不过在实践中碰到了问题，打开某篇有评论的文章，发现只有评论框，没有评论。搞不明白是怎么回事。后来受到 <a href="http://www.ducea.com/2012/11/12/disqus-comments-not-visible-in-octopress/">http://www.ducea.com/2012/11/12/disqus-comments-not-visible-in-octopress/</a> 的启发，原来是<code>_config.yml</code>中的URL还是生成项目时的，与CNAME中配置的域名不一致，修改后就没问题了。</p>

<p>在侧边栏显示最新评论也很简单，添加recent_comments.html到source/_includes/custom/asides目录下，在<code>_config.yml</code>的default_asides做好配置，最新评论内容就会出现在侧边栏中了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;section&gt;
</span><span class='line'>  &lt;h1&gt;Recent Comments&lt;/h1&gt;
</span><span class='line'>  &lt;div class="dsq-widget"&gt;
</span><span class='line'>    &lt;script type="text/javascript" src="http://codemany.disqus.com/recent_comments_widget.js"&gt;&lt;/script&gt;
</span><span class='line'>  &lt;/div&gt;
</span><span class='line'>&lt;/section&gt;
</span></code></pre></td></tr></table></div></figure>

<p>在侧边栏显示Tag Cloud参照了 <a href="http://codemacro.com/2012/07/18/add-tag-to-octopress/">http://codemacro.com/2012/07/18/add-tag-to-octopress/</a> 教程，没几分钟就搞定了。</p>

<p>分享使用的是JiaThis，只要把source/_includes/post/sharing.html中的代码替换成以下代码就可以：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;div id="jiathis_style_32x32"&gt;
</span><span class='line'>  &lt;a class="jiathis_button_qzone"&gt;&lt;/a&gt;
</span><span class='line'>  &lt;a class="jiathis_button_tsina"&gt;&lt;/a&gt;
</span><span class='line'>  &lt;a class="jiathis_button_tqq"&gt;&lt;/a&gt;
</span><span class='line'>  &lt;a class="jiathis_button_weixin"&gt;&lt;/a&gt;
</span><span class='line'>  &lt;a class="jiathis_button_renren"&gt;&lt;/a&gt;
</span><span class='line'>  &lt;a href="http://www.jiathis.com/share/" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"&gt;&lt;/a&gt;
</span><span class='line'>  &lt;a class="jiathis_counter_style"&gt;&lt;/a&gt;
</span><span class='line'>&lt;/div&gt;
</span><span class='line'>&lt;script type="text/javascript" src="http://v2.jiathis.com/code/jia.js" charset="utf-8"&gt;&lt;/script&gt;
</span></code></pre></td></tr></table></div></figure>

<p>相关文章本想用Octopress自带的lsi模块实现，只是当文章较多时生成速度实在是巨慢，按照推荐安装gsl模块，结果在Windows Server 2008系统上死活装不上，采用手动编译方式也总是死在rb-gsl的安装上。失望之余找到 <a href="https://github.com/LawrenceWoodman/related_posts-jekyll_plugin">https://github.com/LawrenceWoodman/related_posts-jekyll_plugin</a> 这个插件，它使用起来非常简单，只需将related_posts.rb放到自己的plugins文件夹中，然后在source/<u>includes/post中新建related</u>posts.html文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{ % if site.related_posts % }
</span><span class='line'>  &lt;h3&gt;Related posts&lt;/h3&gt;
</span><span class='line'>  &lt;ul class="posts"&gt;
</span><span class='line'>  { % for post in site.related_posts limit:3 % }
</span><span class='line'>    &lt;li class="related"&gt;
</span><span class='line'>      &lt;a href=""&gt;&lt;/a&gt;
</span><span class='line'>    &lt;/li&gt;
</span><span class='line'>  { % endfor % }
</span><span class='line'>  &lt;/ul&gt;
</span><span class='line'>{ % endif % }
</span></code></pre></td></tr></table></div></figure>

<p>修改source/_layouts/post.html，在</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{ % include post/author.html % }
</span><span class='line'>{ % include post/date.html % }{ % if updated % }{ % else % }{ % endif % }
</span><span class='line'>{ % include post/categories.html % }
</span></code></pre></td></tr></table></div></figure>

<p>后面添加</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{ % include post/related_posts.html % }
</span></code></pre></td></tr></table></div></figure>

<p>就可以了。使用这个插件会有个小问题，就是它和Jekyll 2.1不兼容，rake generate时会报错，可以使用jumanji27提供的<a href="https://github.com/jumanji27/related_posts-jekyll_plugin">fork版本</a>。</p>

<p>在Wordpress的Tools/Export页面选择导出文章内容，保存为wordpress.xml文件。然后使用工具把它转换成markdown格式。这里使用了YORKXIN的<a href="https://gist.github.com/chitsaou/1394128" title="wordpressdotcom.rb">修改版本</a>，将脚本和wordpress.xml放到Octopress根目录下，然后运行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ruby -r ./wordpressdotcom.rb -e Jekyll::WordpressDotCom.process
</span></code></pre></td></tr></table></div></figure>

<p>会把转换好的文章都放到source/_posts目录下，文件后缀名是html，直接改成markdown就是。</p>

<p>最后就是苦力活：修改文中的站内链接、上传的图片路径以及代码高亮语法等。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nokogiri抓取页面URL含有中文参数的问题]]></title>
    <link href="http://codemany.com/blog/problem-with-nokogiri-when-url-containing-chinese-character/"/>
    <updated>2014-07-17T14:48:00+00:00</updated>
    <id>http://codemany.com/blog/problem-with-nokogiri-when-url-containing-chinese-character</id>
    <content type="html"><![CDATA[<p>使用Nokogiri抓取某网站的长江现货数据，被抓取页面的URL中含有中文参数，使用以下的代码抓取数据失败：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>url = 'http://example.com/search.asp?type=长江有色&sort=asc'
</span><span class='line'>doc = Nokogiri::HTML(open(url))
</span></code></pre></td></tr></table></div></figure>

<p>据 <a href="http://dingr.iteye.com/blog/647244">http://dingr.iteye.com/blog/647244</a> 讲是因为浏览器给服务器发送参数的时候是经过编码的，按照该文的意思试着也给URL里的中文编了下码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>url = 'http://example.com/search.asp?type=长江有色&sort=asc'
</span><span class='line'>url = URI.escape(url)
</span><span class='line'>doc = Nokogiri::HTML(open(url))
</span></code></pre></td></tr></table></div></figure>

<p>结果还是抓取失败。查看URL的编码信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>puts url.encoding  # 输出utf-8
</span></code></pre></td></tr></table></div></figure>

<p>网站页面采用的是GB2132编码，猜测网站后台处理数据时很有可能也是采用的GB2132。做个实验就清楚了，将URL转成GB2132后再编码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>url = 'http://example.com/search.asp?type=长江有色&sort=asc'
</span><span class='line'>url = url.encode('gbk', 'utf-8')
</span><span class='line'>url = URI.escape(url)
</span><span class='line'>doc = Nokogiri::HTML(open(url))
</span></code></pre></td></tr></table></div></figure>

<p>发现果然OK了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[逻辑题-几条病狗]]></title>
    <link href="http://codemany.com/blog/logic-problems-how-many-sick-dogs/"/>
    <updated>2014-07-09T11:35:00+00:00</updated>
    <id>http://codemany.com/blog/logic-problems-how-many-sick-dogs</id>
    <content type="html"><![CDATA[<p>村子中有50个人，每人有一条狗，在这50条狗中有病狗（这种病不会传染），于是人们就要找出病狗，每个人可以观察其他49条狗，以判断它们是否生病，只有自己的狗不能看。观察后得到的结果不得交流，也不能通知病狗的主人。主人一旦推算出自己家的是病狗就要枪毙自己的狗，而且每个人只有权利枪毙自己的狗，没有权利打死其他人的狗。第一天，第二天都没有枪响，到了第三天传来一阵枪响，问有几条病狗？</p>

<p>推论：</p>

<p>A、假设有1条病狗，病狗的主人会看到其他狗都没有病，那么就知道自己的狗有病，所以第一天晚上就会有枪响。因为没有枪响，说明病狗数大于1。</p>

<p>B、假设有2条病狗，病狗的主人会看到有1条病狗，因为第一天没有听到枪响，是病狗数大于1，所以病狗的主人会知道自己的狗是病狗，因而第二天会有枪响。既然第二天也没有枪响，说明病狗数大于2。</p>

<p>由此推理，如果第三天枪响，则有3条病狗，第n天枪响，则有n条病狗。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Pry调试Rails应用]]></title>
    <link href="http://codemany.com/blog/debugging-rails-application-with-pry/"/>
    <updated>2014-07-07T15:26:08+00:00</updated>
    <id>http://codemany.com/blog/debugging-rails-application-with-pry</id>
    <content type="html"><![CDATA[<p>调试Rails程序有更新更好的工具了，这就是Pry，它是一套全新的IRB取代方案。</p>

<p>首先，在Gemfile中申明gem包：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gem 'pry', group: :development
</span></code></pre></td></tr></table></div></figure>

<p>然后执行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bundle install
</span></code></pre></td></tr></table></div></figure>

<p>想用Pry代替IRB，可以直接运行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pry
</span></code></pre></td></tr></table></div></figure>

<p>调试Rails项目时，在需要调试的地方添加binding.pry，当程序运行到这行代码时会打开一个Pry窗口，可以在这里操作当前代码的上下文变量。退出调试用exit-all。例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def index
</span><span class='line'>  @articles = Article.all
</span><span class='line'>  binding.pry
</span><span class='line'>end
</span></code></pre></td></tr></table></div></figure>

<p>可以使用exit-program命令无条件地退出循环。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(1..100).each do |i|
</span><span class='line'>  binding.pry
</span><span class='line'>  puts i
</span><span class='line'>end
</span></code></pre></td></tr></table></div></figure>

<p>Pry默认是没有调试中经常用到的上一步，下一步等命令的，可以安装pry-nav，然后就可以使用step, next, continue跳来跳去了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Raspberry Pi上使用无线网卡]]></title>
    <link href="http://codemany.com/blog/using-wifi-on-raspberry-pi/"/>
    <updated>2014-07-06T12:25:08+00:00</updated>
    <id>http://codemany.com/blog/using-wifi-on-raspberry-pi</id>
    <content type="html"><![CDATA[<p>使用的是EDUP EP-N1556这款无线网卡，体积小巧，支持300M速率，买回来插在RPi上直接就能识别了。</p>

<p>输入lsusb命令，可以见到设备列表中有RTL8192CU 802.11n WLAN Adapter字样，说明网卡已经被系统识别，芯片是RTL8192。</p>

<p>下面就给无线网卡设置静态IP地址：</p>

<p>修改/etc/wpa_supplicant/wpa_supplicant.conf</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
</span><span class='line'>update_config=1
</span><span class='line'>
</span><span class='line'>network={
</span><span class='line'>  ssid="NETGEAR"
</span><span class='line'>  psk="12345678"
</span><span class='line'>  proto=RSN  # 也可以写成WPA2
</span><span class='line'>  key_mgmt=WPA-PSK  # 一定不要写成WPA2-PSK
</span><span class='line'>  id_str="edup1556"
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>

<p>修改/etc/network/interfaces</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>auto lo
</span><span class='line'>
</span><span class='line'>iface lo inet loopback
</span><span class='line'>
</span><span class='line'>iface eth0 inet static
</span><span class='line'>  address 192.168.0.100
</span><span class='line'>  netmask 255.255.255.0
</span><span class='line'>  gateway 192.168.0.1
</span><span class='line'>  dns-nameservers 8.8.8.8
</span><span class='line'>
</span><span class='line'>allow-hotplug wlan0
</span><span class='line'>iface wlan0 inet manual
</span><span class='line'>  wpa-roam /etc/wpa_supplicant/wpa_supplicant.conf
</span><span class='line'>iface edup1556 inet static
</span><span class='line'>  address 192.168.0.200
</span><span class='line'>  netmask 255.255.255.0
</span><span class='line'>  gateway 192.168.0.1
</span><span class='line'>  dns-nameservers 8.8.8.8
</span><span class='line'>
</span><span class='line'>iface default inet dhcp
</span></code></pre></td></tr></table></div></figure>

<p>然后用ifconfig命令列出所有的网络设备，可以看到wlan0的IP是192.168.0.200了。</p>

<p>你的树莓派自由了，不再需要网线拖着了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我是如何让Ruby脚本速度提升156倍的]]></title>
    <link href="http://codemany.com/blog/how-i-made-ruby-script-156x-faster/"/>
    <updated>2014-06-28T05:04:08+00:00</updated>
    <id>http://codemany.com/blog/how-i-made-ruby-script-156x-faster</id>
    <content type="html"><![CDATA[<p>以前写过<a href="http://codemany.com/blog/using-ruby-to-batch-rename-filename-from-traditional-to-simplified/">使用Ruby批量修改繁体文件名为简体</a>，可惜脚本的性能很有问题，批量重命名时运行速度非常慢。这次准备优化下代码，提升脚本的执行效率。</p>

<p>profile.rb是为Ruby程序准备的profiler，它可以统计并输出各方法的运行时间，以便于找到程序执行的性能瓶颈。这次就用它来剖析脚本的运行时间。使用方法很简单，加上命令行选项-r profile就可以：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ruby -r profile rename.rb
</span></code></pre></td></tr></table></div></figure>

<p>运行结束后，会把统计信息输出到标准错误输出中。如下图所示：</p>

<p><img src="http://codemany.com/uploads/profile-before-tuning.png" title="profile-before-tuning" ></p>

<p>profile统计的是各方法的运行时间，分为两类。一类是计算的是从方法调用到方法返回之间的时间，称为整体时间；另一类则是从整体时间中扣除在该方法中调用其它方法所耗费时间之后得到的时间，称为实际时间。</p>

<p>上图输出信息每行中各字段含义如下（从左到右）：</p>

<ul>
<li>该方法执行时间占整体时间的百分比，比例越高越说明这行代码可能需要优化</li>
<li>整体时间的总和</li>
<li>实际时间的总和</li>
<li>被调用的次数</li>
<li>每次调用的平均实际时间（毫秒）</li>
<li>每次调用的平均整体时间（毫秒）</li>
<li>方法名</li>
</ul>

<p>由上图可以看出，脚本执行的时间大部分耗在了循环上。解决方法有两个：消除循环或减少循环次数。前者很难实现，暂且还没有想到办法，也许根本就没有可能。脚本中mapping的大小为2685，所以每修改一个文件名需要执行2685次循环，且循环中的encode和gsub!都是耗时操作。通常文件名的长度不超过30个字符，通过遍历文件名中每个字符的方式重命名就可以把循环次数缩减到不超过30次。</p>

<p>修改代码后重新执行分析命令，得到的结果是脚本运行时间从379395秒变成2418秒，性能整整提升了156倍，达到2个数量级的效果。</p>

<p><img src="http://codemany.com/uploads/profile-after-tuning.png" title="profile-after-tuning" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Raspberry Pi监控室内温湿度]]></title>
    <link href="http://codemany.com/blog/using-raspberry-pi-to-monitor-home-humiture/"/>
    <updated>2014-06-24T06:19:44+00:00</updated>
    <id>http://codemany.com/blog/using-raspberry-pi-to-monitor-home-humiture</id>
    <content type="html"><![CDATA[<p>机房没有温湿度监控系统，只有温湿度计，还不是数字的，只能得到个大概的读数，不是非常精确。怎么办？自己动手DIY个在线的温湿度监控系统吧！</p>

<p>物品清单：</p>

<ul>
<li>金士顿16G的SDHC卡1张</li>
<li>SDHC读卡器1个（可选）</li>
<li>网线1条</li>
<li>手机充电器（5V/1A）1个</li>
<li>MicroUSB数据线1条</li>
<li>电脑1台</li>
<li>1P-1P双头母杜邦线3条</li>
<li>10K电位器一个</li>
<li>DHT11或DHT22温湿度传感器一个（可以购买已经焊好电阻的传感器模块）</li>
</ul>

<h3 id="让树莓派（raspberry-pi）工作起来">让树莓派（Raspberry Pi）工作起来</h3>

<p>从 <a href="http://www.raspberrypi.org/downloads">http://www.raspberrypi.org/downloads</a> 下载基于debian的wheezy镜像Raspbian。如果使用Windows系统，官方建议使用<a href="http://sourceforge.net/projects/win32diskimager/">Win32DiskImager</a>来复制image文件到SD卡（如果是Linux系统可以用工具dd）。写入系统后，把卡插到板子上，接上网线、电源，然后就启动了。等个20多秒，板上3个小灯都亮了，表明系统已经启动成功。</p>

<p>登录路由器后台找到raspberrypi设备分配到的IP。然后使用SSH或VNC（前者是命令行界面，后者是图形界面）连接刚才从路由器找到的IP地址。登录的默认账号是pi，密码是raspberry。登录RPi之后输入ping qq.com测试上网是否正常。</p>

<h3 id="使用固定的ip访问rpi">使用固定的IP访问RPi</h3>

<p>默认情况下RPi使用的是自动分配的IP地址，每次登录都需要在路由器中查找对应IP，实在太麻烦，可以把它设置成静态的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo vi /etc/network/interfaces
</span></code></pre></td></tr></table></div></figure>

<p>打开配置文件，看到如下内容</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>auto lo
</span><span class='line'>
</span><span class='line'>iface lo inet loopback
</span><span class='line'>iface eth0 inet dhcp
</span><span class='line'>
</span><span class='line'>allow-hotplug wlan0
</span><span class='line'>iface wlan0 inet manual
</span><span class='line'>wpa-roam /etc/wpa_supplicant/wpa_supplicant.conf
</span><span class='line'>iface default inet dhcp
</span></code></pre></td></tr></table></div></figure>

<p>将之修改成</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>auto lo
</span><span class='line'>
</span><span class='line'>iface lo inet loopback
</span><span class='line'>
</span><span class='line'>iface eth0 inet static
</span><span class='line'>  address 192.168.0.100
</span><span class='line'>  netmask 255.255.255.0
</span><span class='line'>  gateway 192.168.0.1
</span><span class='line'>  dns-nameservers 8.8.8.8
</span><span class='line'>
</span><span class='line'>allow-hotplug wlan0
</span><span class='line'>iface wlan0 inet manual
</span><span class='line'>  wpa-roam /etc/wpa_supplicant/wpa_supplicant.conf
</span><span class='line'>
</span><span class='line'>iface default inet dhcp
</span></code></pre></td></tr></table></div></figure>

<p>然后存盘退出。以后就可以通过192.168.0.100来登录RPi了。</p>

<h3 id="把温湿度传感器接到rpi上">把温湿度传感器接到RPi上</h3>

<p><img src="http://codemany.com/uploads/rpi-dht22.png" title="rpi-dht22" ></p>

<p>DHT11/DHT22共有4根引脚：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1 -&gt; 3.3v 接左边第1个GPIO针脚
</span><span class='line'>2 -&gt; GPIO 数据接口，可随意连接1个GPIO针脚（第7个针脚对应的是GPIO Pin #4）
</span><span class='line'>3 -&gt; NC 不接
</span><span class='line'>4 -&gt; GND 接地（第14个针脚）
</span></code></pre></td></tr></table></div></figure>

<p>注意：在1脚和2脚间还需要并联10K的电阻，以保持读数稳定。</p>

<p>安装好的样子：</p>

<p><img src="http://codemany.com/uploads/rpi-actual.png" title="rpi-actual" ></p>

<h3 id="用c代码读取当前的温度和湿度值">用C代码读取当前的温度和湿度值</h3>

<p>用的是树莓派2红色B型，它采用Broadcom BCM2835 (CPU, GPU, DSP, and SDRAM)芯片。所以读取GPIO口需要到 <a href="http://www.open.com.au/mikem/bcm2835/index.html">http://www.open.com.au/mikem/bcm2835/index.html</a> 获取最新的BCM2835 C语言库，然后下载，编译和安装。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>wget http://www.open.com.au/mikem/bcm2835/bcm2835-1.36.tar.gz
</span><span class='line'>tar -zxvf bcm2835-1.36.tar.gz
</span><span class='line'>cd bcm2835-1.36
</span><span class='line'>./configure
</span><span class='line'>make
</span><span class='line'>sudo make install
</span></code></pre></td></tr></table></div></figure>

<p>从GitHub库中获取DHT11/DHT22温湿度程序，编译测试。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd /home/pi
</span><span class='line'>git clone https://github.com/dohkoos/Raspberry-Pi-Code.git
</span><span class='line'>cd Raspberry-Pi-Code/DHT22
</span><span class='line'>make
</span><span class='line'>sudo ./dht 22 4 # 数据接口接在第7针脚，所以这里是4
</span></code></pre></td></tr></table></div></figure>

<h3 id="记录曲线图到云端">记录曲线图到云端</h3>

<p>这里使用<a href="http://www.yeelink.net/">Yeelink</a>的服务，Yeelink是国内比较知名的免费物联网数据平台。根据它的API规则，提交的数据必须为JSON格式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{"timestamp": "2012-03-15 16:13:14", "value": 294.34}
</span></code></pre></td></tr></table></div></figure>

<p>将温湿度值提交到Yeelink的Ruby代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># Capture temperature & humidity value from the console
</span><span class='line'>output = `sudo ./dht 22 4`
</span><span class='line'>mt = /Temp =\s+([0-9.]+)/.match(output)
</span><span class='line'>temperature = mt[1]
</span><span class='line'>
</span><span class='line'>mt = /Hum =\s+([0-9.]+)/.match(output)
</span><span class='line'>humidity = mt[1]
</span><span class='line'>
</span><span class='line'># Combined temperature & humidity value into json format
</span><span class='line'>json_temperature = %Q[{\\"timestamp\\": \\"#{Time.now}\\", \\"value\\": #{temperature}}]
</span><span class='line'>json_humidity = %Q[{\\"timestamp\\": \\"#{Time.now}\\", \\"value\\": #{humidity}}]
</span><span class='line'>
</span><span class='line'># Post json data to Yeelink
</span><span class='line'>`curl -X POST -d "#{json_temperature}" -H "Content-Type: application/json" -H "U-ApiKey:XXXXXXXXXXXXXXXX" http://api.yeelink.net/v1.0/device/&lt;device_id&gt;/sensor/&lt;sensor_id&gt;/datapoints`
</span><span class='line'>`curl -X POST -d "#{json_humidity}" -H "Content-Type: application/json" -H "U-ApiKey:XXXXXXXXXXXXXXXX" http://api.yeelink.net/v1.0/device/&lt;device_id&gt;/sensor/&lt;sensor_id&gt;/datapoints`
</span></code></pre></td></tr></table></div></figure>

<p>将U-ApiKey:XXXXXXXXXXXXXXXX替换为自已账户的API Key，后面的URL也需要替换为自己申请的传感器URL。</p>

<h3 id="添加到计划任务">添加到计划任务</h3>

<p>使用crontab命令将以下内容添加到计划任务中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># m h dom mon dow command
</span><span class='line'>*/10 * * * * cd /home/pi/Raspberry-Pi-Code/DHT22/ && ruby yeelink.rb
</span></code></pre></td></tr></table></div></figure>

<p>重启计划任务，然后每隔10分钟就会上传一次数据到云端。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo /etc/init.d/cron restart
</span></code></pre></td></tr></table></div></figure>

<p>下面是我的曲线图：</p>

<p><img src="http://codemany.com/uploads/rpi-yeelink.png" title="rpi-yeelink" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用响应式设计改造电子书网站]]></title>
    <link href="http://codemany.com/blog/rebuild-ebook-website-with-responsive-design/"/>
    <updated>2014-06-19T03:55:16+00:00</updated>
    <id>http://codemany.com/blog/rebuild-ebook-website-with-responsive-design</id>
    <content type="html"><![CDATA[<p>因为要在其它设备上测试响应式设计的效果，需要先对开发环境做些简单的配置。</p>

<p>启动服务器时需加上本机的IP地址和访问端口（通常是80）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rails s -b 192.168.0.100 -p 80
</span></code></pre></td></tr></table></div></figure>

<p>配置Windows系统的内置防火墙，开启80端口以供其它设备访问：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>netsh advfirewall firewall add rule name="Open Port 80" dir=in action=allow protocol=TCP localport=80
</span></code></pre></td></tr></table></div></figure>

<p>查看和删除防火墙规则的命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>netsh advfirewall firewall delete rule name="Open Port 80" protocol=TCP localport=80
</span><span class='line'>netsh advfirewall firewall show rule name="Open Port 80"
</span></code></pre></td></tr></table></div></figure>

<p>响应式设计的优缺点就不多说了，已经有太多的文章讲过这些。这里主要讲如何使用响应式设计改造现有的电子书网站。</p>

<p>首先，需要使用viewport标签设置屏幕宽度为设备宽度，使网站内容可以适应响应式变化。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt;
</span></code></pre></td></tr></table></div></figure>

<p>因为这是一个非常简陋，并且以内容为主的网站。在上述设置后几乎不用再修改就能适应不同屏幕分辨率下的信息呈现，除了导航栏因为导航选项较多，在手机等设备上打开会出现后面部分选项被挤下去。抽屉样式的导航是解决这个问题的好方法。在网上找到一个横向导航栏切换成抽屉式导航栏的库<a href="http://srobbin.github.io/jquery-pageslide/">jQuery PageSlide</a>，它使用图片实现三明治图标，所以对它做了些修改，用标签来实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;ul class="burger"&gt;
</span><span class='line'>  &lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;
</span><span class='line'>&lt;/ul&gt;
</span></code></pre></td></tr></table></div></figure>

<p>对应的CSS代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.burger {
</span><span class='line'>  li {
</span><span class='line'>    height: 4px;
</span><span class='line'>    width: 30px;
</span><span class='line'>    background: #000;
</span><span class='line'>    border-radius: 3px;
</span><span class='line'>    margin: 5px 0;
</span><span class='line'>  }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>

<p>要实现响应式的话，只要让它在正常情况下隐藏，屏幕变小时显现即可：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.burger {
</span><span class='line'>  display: none;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@media screen and (max-width: 480px) {
</span><span class='line'>  .burger {
</span><span class='line'>    display: block;
</span><span class='line'>  }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>

<p>还需要在application.html.erb的底部开启点击三明治图标时的响应事件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;%= javascript_include_tag "jquery.pageslide", "data-turbolinks-track" =&gt; true %&gt;
</span><span class='line'>&lt;script&gt;
</span><span class='line'>  $(".burger").pageslide();
</span><span class='line'>&lt;/script&gt;
</span></code></pre></td></tr></table></div></figure>
  

<p>导航条的CSS也需要做些修改，使之能在屏幕变小时转换成抽屉式导航条：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@media screen and (max-width: 480px) {
</span><span class='line'>  nav ul {
</span><span class='line'>    display: none;
</span><span class='line'>  }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>

<p>至此，网站的响应式改造就基本完成了。如果您觉得对你有所帮助，请将此文发送给你的朋友，如果你还有更好的建议也可以在下面的评论中分享你的经验。</p>
]]></content>
  </entry>
  
</feed>
