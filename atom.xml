<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[乐者为王]]></title>
  <link href="http://codemany.com/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2017-10-15T18:48:18+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[test]]></title>
    <link href="http://codemany.com/blog/test/"/>
    <updated>2017-10-15T07:57:47+08:00</updated>
    <id>http://codemany.com/blog/test</id>
    <content type="html"><![CDATA[]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[test]]></title>
    <link href="http://codemany.com/blog/test/"/>
    <updated>2017-10-14T07:16:16+08:00</updated>
    <id>http://codemany.com/blog/test</id>
    <content type="html"><![CDATA[]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[test]]></title>
    <link href="http://codemany.com/blog/test/"/>
    <updated>2017-10-08T09:05:26+08:00</updated>
    <id>http://codemany.com/blog/test</id>
    <content type="html"><![CDATA[]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[test]]></title>
    <link href="http://codemany.com/blog/test/"/>
    <updated>2017-10-02T07:35:50+08:00</updated>
    <id>http://codemany.com/blog/test</id>
    <content type="html"><![CDATA[]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[test]]></title>
    <link href="http://codemany.com/blog/test/"/>
    <updated>2017-10-01T08:37:09+08:00</updated>
    <id>http://codemany.com/blog/test</id>
    <content type="html"><![CDATA[]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件版本号的思考]]></title>
    <link href="http://codemany.com/blog/thinking-on-software-version/"/>
    <updated>2017-09-30T07:45:55+08:00</updated>
    <id>http://codemany.com/blog/thinking-on-software-version</id>
    <content type="html"><![CDATA[<p><img src="http://codemany.com/uploads/software-version.png" title="software-version" ></p>

<p>产品的名称用来表明产品目的，通常在产品的整个生命周期中都使用它。软件产品的版本号则用来表明产品在特定时间段内所拥有的功能集。它们关注的是以何种方式对提供给用户的软件版本进行识别。</p>

<p>版本号用于捕获相关产品修订和变种（通常与可移植性、国际化或者性能特征相关）的信息。目标是采用尽量少的标识符去收集所有信息。遗憾的是，在工业生产中还没有一种标准的版本编号机制，或者说，不存在单一的、通用的算法。更多情况是，需要你针对发布的内容和目标群体做些细微不同的调整。</p>

<p>但不管你的目标群体是什么，完全发布最好通过以下方式进行标识。这是经过不断地反复实践，被各种封闭、开源软件所广泛使用的惯例。</p>

<ul>
<li>软件的名称。</li>
<li>用x.y.z.build四位元组去捕捉修订信息。</li>
<li>根据需要生成的任意变种信息。</li>
</ul>

<p>版本编号中的元组定义：</p>

<table><thead>
<tr>
<th>元组</th>
<th>定义</th>
</tr>
</thead><tbody>
<tr>
<td>x</td>
<td>主版本号。表示产品的当前主要版本。用来表示提供给客户的产品功能的主要增强。在一个极端的例子中，主版本号的增加用来说明产品现在已经拥有一个全新的功能类。</td>
</tr>
<tr>
<td>y</td>
<td>次版本号。表示给产品新增了一些特征，或者是在原来文档中描述的特征上做了重要的修改。用来确定次版本号什么时候需要修改的一个衡量标准就是产品功能说明书。</td>
</tr>
<tr>
<td>z</td>
<td>修订版本号。用来表示给产品所做的缺陷维护行为的等级。产品缺陷是在产品的功能说明书中没有定义，并且已经或者可能对产品的使用者造成不利影响的任何行为。缺陷维护可以看作是支持该版本功能说明的一切活动。</td>
</tr>
<tr>
<td>build</td>
<td>构建版本号。一般是编译器在编译过程中自动生成。</td>
</tr>
</tbody></table>

<p>除z和build的意义比较明确外，对x和y的解释都太笼统。我们需要更加详细的说明以指导我们的开发工作。</p>

<p>修订过的版本编号中的元组定义：</p>

<table><thead>
<tr>
<th>元组</th>
<th>定义</th>
</tr>
</thead><tbody>
<tr>
<td>x</td>
<td>主版本号。用于有扩展性的、客户可见的架构上或特性上的改变。以一个管理大型数据库的系统为例，你可能在以下情况时需要定义一个主要的版本发布：</td>
</tr>
<tr>
<td></td>
<td>* 改变数据库的结构，导致单纯的升级系统对客户产生比较严重的影响。</td>
</tr>
<tr>
<td></td>
<td>* 改变已经发布的API，导致它与前一版本不兼容。</td>
</tr>
<tr>
<td></td>
<td>* 删除功能（好的架构师应该删除一些不需要的功能）。</td>
</tr>
<tr>
<td></td>
<td>* 持续增加新的功能，例如对新的操作系统的支持。</td>
</tr>
<tr>
<td></td>
<td>x的增加也可以是出于纯粹的商业理由。例如，客户的技术支持合同标明，在下个主要版本发布以后，软件可以得到18个月的技术支持。通过增加x，你将强迫客户去升级。</td>
</tr>
<tr>
<td>y</td>
<td>次版本号。通常与期望的功能或其它改进措施相关。当市场部门认为这个版本的一系列特性已经通过证实，次要版本号就会增加。决定增加x或y可能会比较随意。市场架构师应该定义触发任何一个增加的事件（定义与x相关的触发事件比定义y要更容易）。</td>
</tr>
<tr>
<td>z</td>
<td>修订版本号。主要版本号和次要版本号都相同的维护版本应该彼此兼容。</td>
</tr>
<tr>
<td>build</td>
<td>构建版本号。一般是编译器在编译过程中自动生成。</td>
</tr>
</tbody></table>

<p>注意：这里的版本编号规则仅适用于发布周期较长的软件产品。如果发布周期很短，像Chrome和Firefox那样，可能就不太适用。</p>

<h3 id="参考资料">参考资料</h3>

<ul>
<li><a href="http://semver.org/">语义化版本</a></li>
<li>《软件发布方法》</li>
<li>《超越软件架构：创建和维护优秀解决方案》</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[test]]></title>
    <link href="http://codemany.com/blog/test/"/>
    <updated>2017-09-24T08:31:02+08:00</updated>
    <id>http://codemany.com/blog/test</id>
    <content type="html"><![CDATA[<p>本文的目的：找到或者设计一种版本号更新的标准机制，让以后的版本号迭代不那么纠结。
当前什么状况？
为什么是这样？免费/在线更新
解决方案</p>

<p>功能和特征/特性的区别？《现代汉语词典》
特征：可以作为事物特点的征象、标志等。  一事物区别于其它事物的特别显著的征象、标志。
特性：某人或某事物所特有的性质。
功能：事物或方法所发挥的有利的作用；效能。 功效；作用</p>

<p>产品的名称用来表明产品目的，通常在产品的整个生命周期中都使用它。软件产品的版本号则用来表明产品在特定时间段内所拥有的功能集。它们关注的是以何种方式对提供给用户的软件版本进行识别。</p>

<p>版本号用于捕获相关产品修订和变种的信息。目标是采用尽量少的标识符去收集所有信息。遗憾的是，在工业生产中还没有一种标准的版本编号机制，或者说，不存在单一的、通用的算法。更多情况是，需要你针对发布的内容和目标群体做些细微不同的调整。</p>

<p>但不管你的目标群体是什么，完全发布最好通过以下方式进行标识：</p>

<ul>
<li>产品的名称。</li>
<li>用x.y.z.build四位元组去捕捉修订信息。</li>
<li>根据产品需要生成的任意变种信息。</li>
</ul>

<p>这也是经过不断地反复实践，被各种封闭、开源软件所广泛使用的惯例。</p>

<p>版本编号中的元组定义如下所示：</p>

<table><thead>
<tr>
<th>元组</th>
<th>定义</th>
</tr>
</thead><tbody>
<tr>
<td>x</td>
<td>主版本号。用于有扩展性的、客户可见的架构上或特性上的改变。以一个管理大型数据库的系统为例，你可能在以下情况时需要定义一个主要的版本发布：</td>
</tr>
<tr>
<td></td>
<td>* 改变数据库的结构，导致单纯的升级系统对客户产生比较严重的影响。</td>
</tr>
<tr>
<td></td>
<td>* 改变已经发布的API，导致它与前一版本不兼容。</td>
</tr>
<tr>
<td></td>
<td>* 删除功能（好的架构师应该删除一些不需要的功能）。</td>
</tr>
<tr>
<td></td>
<td>* 持续增加新的功能，例如对新的操作系统的支持。</td>
</tr>
<tr>
<td></td>
<td>x的增加也可以是出于纯粹的商业理由。例如，客户的技术支持合同标明，在下个主要版本发布以后，软件可以得到18个月的技术支持。通过增加x，你将强迫客户去升级。</td>
</tr>
<tr>
<td>y</td>
<td>次版本号。通常与期望的功能或其它改进措施相关。当市场部门认为这个版本的一系列特性已经通过证实，次要版本号就会增加。决定增加x或y可能会比较随意。市场架构师应该定义触发任何一个增加的事件（定义与x相关的触发事件比定义y要更容易）。</td>
</tr>
<tr>
<td>z</td>
<td>修订版本号。主要版本号和次要版本号都相同的维护版本应该彼此兼容。</td>
</tr>
<tr>
<td>build</td>
<td></td>
</tr>
</tbody></table>

<p>修复问题但不影响API 时，递增修订号；API 保持向下兼容的新增及修改时，递增次版本号；进行不向下兼容的修改时，递增主版本号。</p>

<blockquote>
<p>在x.y.z的三级混合编号中，3个区域分别表示产品的当前主要版本号（主版本号）、给新的主版本增加的新功能（特征版本号）、以及出于缺陷修复目的考虑的版本号（缺陷修复版本号）。
  * 主版本号用来表示提供给客户的产品功能的主要增强。极端情况是，主版本号的迭代用来说明产品现在已经拥有一个全新的功能类。
  * 特征版本号的迭代用来表示产品新增了一些特征，或者是在原来文档中描述的特征上做了重要的修改。用来确定特征版本号什么时候需要修改的一个衡量标准就是产品功能说明书。
  * 缺陷修复版本号用来表示在该版本上所做的缺陷维护行为的等级。</p>
</blockquote>

<p>产品功能说明书应该是用来衡量主版本号而不是特征版本号什么时候修改的标准。</p>

<p>但除z的意义比较明确外，缺陷修复，对于x和y的解释都各有各的不同。甚至有的对z乃至整个版本号都不在意。
产品缺陷是在产品的功能说明书中没有定义，并且已经或者可能对产品的使用者造成不利影响的任何行为。</p>

<blockquote>
<p>版本编号中的数字并不是非得要达到它的最大值以后才可以回复到0。习惯上，版本编号的主版本号从1开始，功能版本号和缺陷修复版本号的初始值都是0，这样首个新的版本号就是1.0.0。当我们需要迭代主版本号的时候，特征版本号和缺陷修复版本号就都重置为0。当迭代特征版本号的时候，就要把缺陷修复版本号重置为0。</p>
</blockquote>

<p>Linux Kernel的上一个版本是2.6.39，也是2.6系列的第39次升级维护。从改进幅度上看，Linux Kernel 3.0其实完全可以叫做2.6.40，但这年头版本号为王，3.0要好看得多。</p>

<p>数字视频录像机和媒体中心软件 MythTV 发布了 29.0 版。MythTV 改变了版本号命名方案，它的上一个大版本号是 0.28。
新版的主要新功能包括：后端现在能监听所有 IP 地址，新的 MythTV 启动页，mythtv-setup 现在使用 MythUI，支持本地 IPV6 地址，FFmpeg 更新到 3.2，等等。
MythTV 用户可以直接从 0.22 版升级到 29.0 版，但更老的版本就不再支持直接升级了，需要先升级到 0.22 或 0.23。</p>

<p>Chrome 每六周就会跨版本更新一次，所以每次更新之后并不会有太多的功能加入，比如 Chrome 7 除了修复了上百个 Bug 之外基本上没什么值得一提的。</p>

<p>之所以会出现版本号的更新（如从Firefox 10到Firefox 11)，这是因为新版本有无法向后兼容的API，此外，新版本的出现也表明这不是一次维护性更新或小幅升级，而是一次重大升级。</p>

<p>Alpha版本的软件是指那些处于研发初期刚进入可以运行阶段的软件。处于这个阶段的软件虽然拥有了该软件最终版本的一些核心功能，但并不拥有最终版本的全部功能。Alpha版软件的测试通常只在研发者圈内进行。
Beta版本的软件是指软件产品正式上市前处于最后测试阶段的那些软件。处于这个阶段的软件已经拥有了该软件最终版本的一切功能，Beta测试的目的在于验证软件的稳定性和兼容性，发掘一些微小的错误</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[test]]></title>
    <link href="http://codemany.com/blog/test/"/>
    <updated>2017-09-23T07:07:54+08:00</updated>
    <id>http://codemany.com/blog/test</id>
    <content type="html"><![CDATA[]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[test]]></title>
    <link href="http://codemany.com/blog/test/"/>
    <updated>2017-09-17T09:07:59+08:00</updated>
    <id>http://codemany.com/blog/test</id>
    <content type="html"><![CDATA[<p>我在以前的文章<a href="http://codemany.com/blog/decompile-android-apk-file/">反编译Android APK文件</a>中简单介绍过几种反汇编/编译APK文件的工具。因为JD-GUI的开发者已经不再维护的关系，推荐同学们使用jadx作为dex2jar + JD-GUI组合的替代。以及jadx。对比使用后的感觉，后者明显比前者要强。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[test]]></title>
    <link href="http://codemany.com/blog/test/"/>
    <updated>2017-09-16T08:00:11+08:00</updated>
    <id>http://codemany.com/blog/test</id>
    <content type="html"><![CDATA[]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[test]]></title>
    <link href="http://codemany.com/blog/test/"/>
    <updated>2017-09-12T21:49:57+08:00</updated>
    <id>http://codemany.com/blog/test</id>
    <content type="html"><![CDATA[]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[test]]></title>
    <link href="http://codemany.com/blog/test/"/>
    <updated>2017-09-03T14:28:50+08:00</updated>
    <id>http://codemany.com/blog/test</id>
    <content type="html"><![CDATA[]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[test]]></title>
    <link href="http://codemany.com/blog/test/"/>
    <updated>2017-09-02T13:39:13+08:00</updated>
    <id>http://codemany.com/blog/test</id>
    <content type="html"><![CDATA[]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[追逐时髦的技术]]></title>
    <link href="http://codemany.com/blog/chasing-the-shiny-and-new-in-software/"/>
    <updated>2017-08-29T11:50:09+08:00</updated>
    <id>http://codemany.com/blog/chasing-the-shiny-and-new-in-software</id>
    <content type="html"><![CDATA[<p>英文原文：<a href="https://www.nemil.com/musings/shinyandnew.html">https://www.nemil.com/musings/shinyandnew.html</a></p>

<p>有关当前最好的框架或编程语言的争论经常发生在Web开发中。就这点而言，<a href="https://www.scribd.com/">Scribd</a>的联合创始人Jared Friedman在2015年写了<a href="http://blog.jaredfriedman.com/2015/09/15/why-i-wouldnt-use-rails-for-a-new-company/">一篇文章</a>推荐创业公司使用Node.js代替Rails。</p>

<p>他提出几个关键点：</p>

<ul>
<li>Rails很慢。</li>
<li>黑客学院的毕业生都在使用Rails，贬低了它对高级工程师的价值，并减少了它的未来前景。</li>
<li>创业公司应该使用那些前瞻性工程师今后将使用的技术，以保证它们的应用不过时。</li>
<li>在Scribd，过去几年里它们已经从Prototype转换到jQuery，再到CoffeeScript，再到Angular，再到React。</li>
</ul>

<p>Node.js是创业公司的绝佳选择，但它饱受批评的两个部分令我担忧。首先，一名创业公司的工程师应该了解什么技术将会在几年后流行，以保证它们的技术栈不过时。第二，杰出的软件工程师将被时髦的技术栈吸引到创业公司，而不是有趣的技术问题。在过去我还听到过更恶劣的传闻，创业公司的开发者拒绝接受使用ES5 JavaScript编程的工作（那时CoffeeScript刚出来），Mongo发布不久工程师就执意在生产环境下使用Mongo替代Postgres，渴望用最新的前端框架不断重构项目。</p>

<p>我担心有些程序员（和他们的雇主）有这种倾向，即把注意力放在转换技术栈到最新上。他们主要基于框架选择公司，力求在工作中使用最新而不是最好的工具。他们把时间花在新的库和框架上，而不是提高他们的核心技术能力。我们把他们称为技术栈追逐者——他们奋力追求在创业公司的技术栈中使用那些对核心输出（用户重视的软件功能、开发团队的生产力）提升有限的新技术（或者他们自己喜欢的技术）。</p>

<h3 id="“时髦的”web开发">“时髦的”Web开发</h3>

<p>很同情那些在<a href="https://news.ycombinator.com/">Hacker News</a>上的时髦的Web或移动应用开发者。作为在2012年的全栈创业公司的开发者，你正在构建后端使用Ruby/Rails，前端使用Backbone/CoffeeScript/Underscore的网站，同时使用Capistrano（或相关的Python类似物）部署你的应用。到2013年，你已经将后端转换到Node/Express/Mongo，前端为Grunt/Ember。在2014年，你已经彻底切换到MEAN技术栈，但在尝试过Koa以后考虑转移到Go（在Express核心贡献者<a href="https://medium.com/@tjholowaychuk/farewell-node-js-4ba9e7f3e52b">告别Node.js转向Go</a>以后）。在2015年，你在后端使用Express/Go，前端使用Gulp/ES2015/React，使用React Native代替原生移动语言，并且慢慢地将系统转换为使用Docker的微服务。很快，你将会被转换到Phoenix，如果Angular 2是正确的选择也会转换过去——甚至可能创造一个Go可以工作在Android上以及开源Swift可以适合你的技术栈的世界。（我显然是夸大效果，尽管这是HN头条新闻流行什么的一个合理表示。）</p>

<p>有几个原因表明这可能是合理的。时髦的Web工程师需要“时尚”才能获得未来的工作或合同。雇主使用框架或语言作为过滤器，而不是测试批判性思维和技能。雇主没有意识到有实力的开发者如果有正确的支持，可以在几个星期，通常是几天内成为许多语言或者框架的专家。有时趋势是无法阻止的：Swift正在取代Objective-C，世界正在转向更薄、更小的单体后端和更重、反应更灵敏的前端。通常，转变有着巨大的优势：生产力大幅上升，或者新的用户功能突然变得可能。然而，所有的变化都不会导致早期到中期的公司不采用就死，而为了乐趣或业余项目学习技术和认为它是生产环境的关键是迥然不同的。</p>

<p>我们可以用创业公司的时髦的Web或移动开发者与我们的计算机科学家作为对比。我的一个朋友是一家顶级科技公司的计算机神经学家——跟几乎所有从事技术工作的人一样，他的世界每隔几个月就会被重塑——得益于计算能力、脑成像和深度学习算法的快速发展。基本的编程工具其实变化不大。公平地说，只有C++从 11转换到14引起了一些焦虑。还有分布式计算系统、键/值存储和其它外部服务，但这些都是使用稳定的API构建的。他的大部分时间都花在单个DSL中的架构和算法上，而不是重写功能相似的代码或者快速学习提供有争议的好处和改变的库。</p>

<h3 id="选择工具">选择工具</h3>

<p>人们可能会建议创业公司选择时髦的技术栈，因为它是招聘杰出的工程师的关键工具。我自己的观察是，杰出的工程师注重其它的东西。到目前为止，最重要的是提供有趣的问题去解决——有趣的人与他们合作。吸引力和强大的使命感是吸引优秀人才（工程师或者其他）的其它途径。</p>

<p>我并不是在抱怨技术发展太快，也不是说我们都应该用汇编语言或者C++或者Ruby编程。软件工程师清楚他们的目标——我们的领域以令人目眩的速度发展，但对于我们拥有的影响力这都是值得的，因为有10亿人上网。我认为你需要有能力快速地学会新的框架、语言或库（如何完成它的<a href="https://news.ycombinator.com/item?id=7733249">Ask HN</a>）——依靠周围那些经验丰富的工程师，你的目标应该是尽快地具有生产力。除此之外，你应该深刻理解多种语言，而不仅仅是一种（但是同样的态度，不应盲目地扩展到框架或者轻量级的DSL）。</p>

<p>对于创业公司而言，Paul Graham<a href="http://castig.org/an-interview-with-paul-graham-hackers-painters-10-years-later/">在2013年被问到关于理想的语言</a>：“我的意思是，我们有的创业公司在用PHP编写代码——这让我有点担心，但这并不像其它事情那么让我担心。”Github的技术主管Sam Lambert在<a href="https://medium.com/s-c-a-l-e/github-scaling-on-ruby-with-a-nomadic-tech-team-4db562b96dcd">最近的一次采访</a>中谈到，他在2013年被Github的CTO面试时，对Github的技术栈是Rails、C和Bash脚本感到惊讶：“随着面试的继续，我发现他们实际上是一群非常务实的黑客，他们只钻研Ruby和C，使用更稳定的技术栈以便花时间工作在更有趣的事情上，而不是追逐最新最酷炫的技术。”Github的方法在我看来是Web和移动开发者的合理的平衡：广泛地探索工具，然后务实地选择解决你所面临的问题的工具（<a href="http://martinfowler.com/bliki/Yagni.html">YAGNI</a>适用于更多的地方，而不仅仅是面向用户的功能开发）。</p>

<p>令我担心的是，某些开发者，特别是在职业生涯早期的开发者，可能会以为创业公司的工程师不是问题解决者或计算机科学家，而是一个荣誉查找表——他们的任务是每隔几个月记住一个新的DSL——只能获得有限的好处。这使我们这些早期的工程师贬值——构建人们想要的东西，从事有趣的技术问题，快速交付代码。</p>

<p>无论如何，要在额外的时间里广泛地实践。如果好处是压倒性的，则切换生产环境中的语言/框架，但要考虑是哪些好处。警惕那些追求新技术却不考虑它对团队的预期优势的人。花时间学习概念和解决有趣的技术或用户问题。如果你有正确的应用边界，并选择你有现成生产力的框架，一旦你这样做了，你将具有一定的灵活性，但需要足够坚持才能达到产品与市场的匹配和超越。</p>

<p>任何一天打开<a href="https://news.ycombinator.com/">Hacker News</a>，你都能看到有帖子诱惑你使用某个框架、语言、类库或者服务去贡献和构建应用（包括一些像Mongo这样有大笔现金的公司，因此在它们的平台后面有营销预算）。有些工具拥有改变游戏规则的能力，其余的只有一些关键的不同功能，但是它们都需要时间才能成为专家。有些工具会大声宣告它们才是未来，并且嘲笑你所学到的东西——但是它们需要你的技能和意识与现有的技术真正地竞争。你会如何选择？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[test]]></title>
    <link href="http://codemany.com/blog/test/"/>
    <updated>2017-08-26T14:40:24+08:00</updated>
    <id>http://codemany.com/blog/test</id>
    <content type="html"><![CDATA[]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[test]]></title>
    <link href="http://codemany.com/blog/test/"/>
    <updated>2017-08-20T07:54:17+08:00</updated>
    <id>http://codemany.com/blog/test</id>
    <content type="html"><![CDATA[]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[test]]></title>
    <link href="http://codemany.com/blog/test/"/>
    <updated>2017-08-19T12:30:50+08:00</updated>
    <id>http://codemany.com/blog/test</id>
    <content type="html"><![CDATA[]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[test]]></title>
    <link href="http://codemany.com/blog/test/"/>
    <updated>2017-08-18T20:56:48+08:00</updated>
    <id>http://codemany.com/blog/test</id>
    <content type="html"><![CDATA[]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[test]]></title>
    <link href="http://codemany.com/blog/test/"/>
    <updated>2017-08-13T08:53:58+08:00</updated>
    <id>http://codemany.com/blog/test</id>
    <content type="html"><![CDATA[]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[test]]></title>
    <link href="http://codemany.com/blog/test/"/>
    <updated>2017-08-12T16:01:22+08:00</updated>
    <id>http://codemany.com/blog/test</id>
    <content type="html"><![CDATA[]]></content>
  </entry>
  
</feed>
