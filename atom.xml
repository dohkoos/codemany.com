<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[乐者为王]]></title>
  <link href="http://codemany.com/atom.xml" rel="self"/>
  <link href="http://codemany.com/"/>
  <updated>2018-03-01T12:15:04+08:00</updated>
  <id>http://codemany.com/</id>
  <author>
    <name><![CDATA[dohkoos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[从零开始构建TimeLog（1）]]></title>
    <link href="http://codemany.com/blog/build-timelog-from-scratch-part1/"/>
    <updated>2018-02-22T16:20:28+08:00</updated>
    <id>http://codemany.com/blog/build-timelog-from-scratch-part1</id>
    <content type="html"><![CDATA[<p>想做时间管理，首先要知道自己的时间是如何被用掉的。这需要记录自己每天每刻的时间开销。睡眠、就餐、运动、工作、与家人谈话……分别要花费多少时间。只有了解自己对时间的使用过程，才能分析其使用的是否合理。养成记录时间的习惯可以调整你对时间的感知，有助于你更高效正确地管理自己的时间。</p>

<p>不过每天用纸笔记录时间太过麻烦。现在手机已是身边必备物品，因此写个应用来记录自己的时间再方便不过。这也是开发TimeLog应用的起因。</p>

<p>TimeLog是一个功能比较简单的应用，只需要支持如下功能：</p>

<ul>
<li>时间记录</li>
<li>时间分类的增删改查</li>
<li>时间统计</li>
</ul>

<p>我用过多款时间记录应用。它们的“时间分类”都是开发者预先设定的，不能增加，也无法修改，而且没有“编程”等分类。这让作为有轻微强迫症的程序员的我实在不能忍受。所以TimeLog必须要实现时间分类增删改的功能。</p>

<p>程序员的进步离不开开源，所以「TimeLog」也是全部开源的。这里是<a href="https://github.com/dohkoos/TimeLog">传送门</a>，欢迎大家star和fork。如果有什么想法或者建议，也欢迎来讨论。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[循环神经网络不可思议的效用]]></title>
    <link href="http://codemany.com/blog/rnn-effectiveness/"/>
    <updated>2018-01-07T09:44:50+08:00</updated>
    <id>http://codemany.com/blog/rnn-effectiveness</id>
    <content type="html"><![CDATA[<p>英文原文：<a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/">http://karpathy.github.io/2015/05/21/rnn-effectiveness/</a></p>

<p>循环神经网络（RNN）有些神奇的地方。我仍然记得我为<a href="http://cs.stanford.edu/people/karpathy/deepimagesent/">图像标注</a>而训练我的首个循环网络的情景。我的第一个幼稚模型（带有相当随意选择的超参数）在经过几十分钟的训练后就开始在图像的有意义的边缘产生非常漂亮的描述。有时候，模型的简单与你从中得到的结果的质量之间的比例超过你的预期，这次就是一个例子。为什么当时这个结果如此令人震惊？普遍的看法是，RNN应该是很难训练的（随着更多的实践，我实际上得到了相反的结论）。在这之后的1年：我一直在训练RNN，并多次见证它的能力和健壮性，但它的神奇输出仍然让我感到有趣。这篇文章将与你分享一些RNN的魔法。</p>

<blockquote>
<p>我们将训练RNN让它一个字符一个字符地生成文本，然后思考“这怎么可能？”</p>
</blockquote>

<p>顺便说一句，我会把这篇文章涉及的<a href="https://github.com/karpathy/char-rnn">代码</a>发布到GitHub上，它可以让你基于多层LSTM来训练字符级别的语言模型。你给它输入大量的文本，它将学会生成类似的文本。你也可以用它来复现我下面的实验。那么RNN究竟是什么呢？</p>

<h3 id="循环神经网络">循环神经网络</h3>

<p>序列。Vanilla神经网络（还有卷积网络）最大的局限性在于它的API太受约束：它接受固定大小的向量作为输入（例如图像），然后产生固定大小的向量作为输出（例如不同分类的概率）。不仅如此：这些模型使用固定数量的计算步骤（例如模型中的层数）执行这种映射。循环神经网络如此令人兴奋的主要原因是它允许我们对向量的序列进行操作：输入中的序列、输出中的序列、或者最普遍情况下的输入输出序列。下面是几个具体的示例：</p>

<p><img src="http://codemany.com/uploads/diags.jpg" alt="diags"></p>

<p>每个矩形都是一个向量，箭头代表函数（例如矩阵乘法）。输入向量为红色，输出向量为蓝色，绿色向量是RNN的状态。从左到右是：</p>

<ol>
<li>没有RNN的Vanilla处理模式，从固定大小的输入到固定大小的输出（例如图像分类）。</li>
<li>序列输出（例如图像标注，输入图像然后输出一段文字序列）。</li>
<li>序列输入（例如情感分析，给定的文字被分类为表达正面或者负面情感）。</li>
<li>序列输入和序列输出（例如机器翻译：RNN读取英语句子然后以法语的形式输出）。</li>
<li>同步序列输入和输出（例如视频分类，对视频的每个帧打标签）。</li>
</ol>

<p>注意，每个案例都没有对序列长度进行预先规定，因为循环变换（绿色）是固定的，且根据需要可以多次使用。</p>

<p>正如你预想的那样，与使用固定数量的计算步骤的固定网络相比，序列组织方法的操作要更为强大。RNN通过固定的（但可以学习的）函数把输入向量与其状态向量结合起来以产生新的状态向量。这在编程术语中可以被解释为，运行一个具有某些输入和一些内部变量的固定程序。从这个角度看，RNN本质上是在描述程序。事实上，就它可以模拟任意程序（使用恰当的权值向量）而言，<a href="http://binds.cs.umass.edu/papers/1995_Siegelmann_Science.pdf">RNN是图灵完备的</a>。但是类似于神经网络的通用近似定理，你不用过于关注其中的细节。</p>

<blockquote>
<p>如果训练Vanilla神经网络是对函数进行优化，那么训练循环网络就是对程序进行优化。</p>
</blockquote>

<p>序列缺失下的序列化处理。你可能会想，将序列作为输入或输出是相当少见的，但重要的是要认识到，即使输入或输出是固定向量，你仍然可以使用这种强大的形式体系以序列化的方式对它们进行处理。例如，下图显示的结果来自<a href="https://deepmind.com/">DeepMind</a>的两篇非常不错的论文。在左边，算法学习一种循环网络策略，可以将它的注意力集中在图像周围。具体地说，就是它学习从左到右阅读门牌号码（<a href="https://arxiv.org/abs/1412.7755">Ba et al.</a>）。在右边，循环网络通过学习在画布上序列化地添加颜色来生成数字图像（<a href="https://arxiv.org/abs/1502.04623">Gregor et al.</a>）。</p>

<p><img src="http://codemany.com/uploads/house-read.gif" alt="house-read">
<img src="http://codemany.com/uploads/house-generate.gif" alt="house-generate"></p>

<p><em>左边：RNN学习阅读门牌号码。右边：RNN学习绘制门牌号码。</em></p>

<p>言外之意就是，即使数据不是序列的形式，你仍然可以制定和训练出强大的模型来学习序列化地处理它。你是在学习处理固定大小数据的有状态程序。</p>

<p>RNN计算。那么这些是如何工作的呢？主要是RNN有个看似简单的API：它接收输入向量x，然后给出输出向量y。然而最重要的是，该输出向量的内容不仅受到刚才输入的影响，还受到过去整个历史输入的影响。写成类的话，RNN的API由单个step函数构成。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rnn = RNN()
</span><span class='line'>y = rnn.step(x)  # x是输入向量，y是RNN的输出向量</span></code></pre></td></tr></table></div></figure>

<p>每当step函数被调用时，RNN的某些内部状态就会被更新。在最简单的案例中，这个状态由单个隐藏向量h构成。以下是Vanilla RNN中step函数的实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class RNN:
</span><span class='line'>  # ...
</span><span class='line'>  def step(self, x):
</span><span class='line'>    # update the hidden state
</span><span class='line'>    self.h = np.tanh(np.dot(self.W_hh, self.h) + np.dot(self.W_xh, x))
</span><span class='line'>    # compute the output vector
</span><span class='line'>    y = np.dot(self.W_hy, self.h)
</span><span class='line'>    return y</span></code></pre></td></tr></table></div></figure>

<p>上面的代码详细说明了vanilla RNN的前向传播。这个RNN的参数是3个矩阵：W_hh、W_xh、W_hy。隐藏状态self.h被初始化为零向量。np.tanh函数实现一个非线性，将激活值压缩到范围[-1, 1]。注意代码是如何工作的：tanh内有两个条件，一是基于前面的隐藏状态，一是基于当前的输入。在NumPy中，np.dot是矩阵乘法。两个中间变量相加，然后被tanh压缩为新的状态向量。如果你更享受数学公式，我们也可以将隐藏状态写成：<img src="http://codemany.com/uploads/equation.png" alt="equation">。</p>

<p>我们用随机数初始化RNN的矩阵，训练中的大部分工作是寻找那些能够产生期望行为的矩阵，通过一些损失函数来度量，这些函数表示对于输入序列x你偏好什么类型的输出y。</p>

<p>深度网络。RNN是神经网络，如果你进行深度学习并且开始像叠煎饼一样堆叠模型，它将会工作得越来越好（如果做得正确的话）。例如，我们可以通过以下方式建立一个2层的循环网络：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>y1 = rnn1.step(x)
</span><span class='line'>y = rnn2.step(y1)</span></code></pre></td></tr></table></div></figure>

<p>换句话说，我们有两个独立的RNN：一个RNN接收输入向量，而第二个RNN以第一个RNN的输出作为其输入。RNN其实并不关心这些——它们都只是向量的进出，以及在反向传播期间某些梯度流经每个模块。</p>

<p>需要指明的是，在实践中我们大多数人使用略有不同的长短期记忆（LSTM）网络。LSTM是一种特殊类型的循环网络，由于其强大的更新方程和一些吸引人的动态反向传播机制，它在实践中的效果略好一些。除了用于更新计算（self.h=...）的数学形式变得有点复杂外，其它所有都与本文介绍的RNN的内容完全相同。从这里开始，我会混合使用术语RNN和LSTM，但是本文中的所有实验都是用LSTM完成的。</p>

<h3 id="字符级别的语言模型">字符级别的语言模型</h3>

<p>现在我们已经知道RNN是什么，为什么它如此令人兴奋，以及它是如何工作的。我们现在就用它来实现一个有趣的应用：我们将训练RNN字符级别的语言模型。也就是说，我们提供RNN巨量的文本，然后让其建模，根据序列中以前的字符序列给出下一个字符的概率分布。这将允许我们一次一个字符地生成新文本。</p>

<p>作为示例，假设我们拥有只有四个字符“helo”的词汇表，想用训练序列“hello”训练一个RNN。这个训练序列实际上是4个独立的训练示例的来源：</p>

<ol>
<li>“h”出现时下一个字符最有可能是“e”。</li>
<li>“he”出现时下一个字符最有可能是“l”。</li>
<li>“hel”出现时下一个字符最有可能是“l”。</li>
<li>“hell”出现时下一个字符最有可能是“o”。</li>
</ol>

<p>具体来说，我们会使用1-of-k编码方式（即除对应字符为1外其余都为0）将每个字符编码成一个向量，并且使用step函数将它们一次一个地喂给RNN。然后，我们观察四维输出向量（每个字符一维）的序列，我们将其解释为RNN当前分配给序列中下次到来的每个字符的置信度。以下是示意图：</p>

<p><img src="http://codemany.com/uploads/charseq.jpg" alt="charseq"></p>

<p>这个RNN示例具有4维输入和输出层，以及3个单位（神经元）的隐藏层。该示意图显示了当RNN把字符“hell”当作输入时前向传播中的激活值。输出层包含RNN为下一个字符分配的置信度（词汇表是“h,e,l,o”）。我们希望绿色数值尽可能高，红色数值尽可能低。</p>

<p>例如，我们可以看到，在第1个时间步骤中，当RNN看到字符“h”时，它将下一个可能出现字符的置信度分别设成“h”为1，“e”为2.2，“l”为-3.0，“o”为4.1。因为在训练数据（字符串“hello”）中，下一个正确的字符是“e”，所以我们希望增加其置信度（绿色）并降低所有其它字符的置信度（红色）。同样，在4个时间步骤中的每个步骤都有理想的目标字符需要网络给予更大的置信度。由于RNN完全由可微分的操作组成，我们可以运行反向传播算法（这只是微积分链式法则的递归应用）以计算出在哪个方向上我们应该调整其每个权重以增加正确目标（绿色粗体数值）的分数。我们然后可以执行参数更新，即在这个梯度方向上微调每个权重。如果我们在参数更新之后将相同的输入喂给RNN，我们会发现正确字符的分数（例如，第一个时间步骤中的“e”）将会略微变高（例如，从2.2变成2.3），而不正确字符的分数将会略微变低。然后我们重复这个过程多次直到网络收敛，并且它的预测最终与训练数据一致，即总能正确预测下一个字符。</p>

<p>更技术的解释是我们对每个输出向量同时使用标准的Softmax分类器（通常也称为交叉熵损失）。使用迷你批量的随机梯度下降训练RNN，并且我喜欢使用<a href="http://arxiv.org/abs/1502.04390">RMSProp</a>或Adam（每个参数的自适应学习速率方法）来稳定参数的更新。</p>

<p>另外要注意的是，输入字符“l”第一次的目标为“l”，但第二次为“o”。因此，RNN不能单独依赖输入，必须使用其循环连接来跟踪上下文以实现此任务。</p>

<p>在测试的时候，我们喂给RNN一个字符，并得到下次可能到来的字符的分布。我们从这个分布中取样，然后将其反馈给RNN以获得下一个字符。重复这个过程你就会得到文本！现在让我们在不同的数据集上训练RNN，看看会发生什么。</p>

<p>为了进一步说明，出于教育目的我还写过<a href="https://gist.github.com/karpathy/d4dee566867f8291f086">使用Python/NumPy的最小字符级别的RNN语言模型</a>。它只有大约100行左右，如果你更擅长阅读代码而不是文本，希望它能对上述内容给出一个简洁、具体和有用的总结。现在我们将深入实例结果，它由更高效的Lua/Torch代码库产生。</p>

<h3 id="rnn的乐趣">RNN的乐趣</h3>

<p>以下5个示例的字符模型都使用我在GitHub上发布的<a href="https://github.com/karpathy/char-rnn">代码</a>进行训练。每个案例中的输入都是单个文本文件，我们将训练RNN来预测序列中的下一个字符。</p>

<h4 id="paul-graham生成器">Paul Graham生成器</h4>

<p>让我们先尝试用一个小的英文数据集作为完整性检查。我最喜欢的数据集是<a href="http://www.paulgraham.com/articles.html">Paul Graham的文集</a>。基本想法是，这些文章中有很多的智慧，但不幸的是，Paul Graham的写作速度比较慢。如果我们可以根据需要生成创业智慧的样本，岂不美哉？这时就轮到RNN出场了。</p>

<p>合并Paul Graham过去5年的所有文章，我们可以得到大约1MB的文本文件，或者说大约100万个字符（顺便提一句，这是个非常小的数据集）。<em>技术：</em>训练一个2层的LSTM，含有512个隐藏节点（约350万个参数），每层之后有0.5的dropout。我们将通过每批次100个实例和长度为100个字符的截断式沿时间反向传播来训练。使用这些设置，每个批次在TITAN Z GPU上耗时大约0.46秒（这可以通过性能代价微不足道的50个字符的BPTT，即Backpropagation Through Time让耗时减半）。言归正传，让我们看看来自RNN的样本：</p>

<blockquote>
<p>The surprised in investors weren’t going to raise money. I’m not the company with the time there are all interesting quickly, don’t have to get off the same programmers. There’s a super-angel round fundraising, why do you can do. If you have a different physical investment are become in people who reduced in a startup with the way to argument the acquirer could see them just that you’re also the founders will part of users’ affords that and an alternation to the idea. [2] Don’t work at first member to see the way kids will seem in advance of a bad successful startup. And if you have to act the big company too.</p>
</blockquote>

<p>好吧，显然上面的样本暂时还无法取代Paul Graham，但是别忘了，RNN必须使用一个小的数据集（包括逗号，撇号和空格）完全从零开始学习英语。我也很喜欢它学会通过引用来支持自己的论点（例如上面的[2]）。有时候它会说一些有洞见的话，比如“a company is a meeting to think to investors”。如果你想看到更多，<a href="http://cs.stanford.edu/people/karpathy/char-rnn/pg.txt">这里</a>有5万个字符的样本。</p>

<p>温度。我们还可以在取样的时候调节Softmax的温度。将温度从1降至更低的数值（例如0.5）可以让RNN有更高的置信度，但其样本也会更保守。相反地，较高的温度将会带来更多的多样性，但是会以更多的错误为代价（例如拼写错误等）。特别是，将温度设置得非常接近于0时就会得到与Paul Graham更相似的言论：</p>

<blockquote>
<p>is that they were all the same thing that was a startup is that they were all the same thing that was a startup is that they were all the same thing that was a startup is that they were all the same</p>
</blockquote>

<p>看起来我们已经陷入了创业的死循环。</p>

<h4 id="莎士比亚">莎士比亚</h4>

<p>看起来RNN可以学习拼写英文单词。但是如果数据中有更多的结构和风格呢？为检验这一点，我下载了莎士比亚的所有作品，并将它们合并成单个（4.4MB）文件。现在我们可以训练一个更大的网络，在这个案例中，我们将尝试一个3层的RNN，每层有512个隐藏节点。在训练网络几个小时之后，我们得到如下的样本：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>PANDARUS:
</span><span class='line'>Alas, I think he shall be come approached and the day
</span><span class='line'>When little srain would be attain'd into being never fed,
</span><span class='line'>And who is but a chain and subjects of his death,
</span><span class='line'>I should not sleep.
</span><span class='line'>
</span><span class='line'>Second Senator:
</span><span class='line'>They are away this miseries, produced upon my soul,
</span><span class='line'>Breaking and strongly should be buried, when I perish
</span><span class='line'>The earth and thoughts of many states.
</span><span class='line'>
</span><span class='line'>DUKE VINCENTIO:
</span><span class='line'>Well, your wit is in the care of side and that.
</span><span class='line'>
</span><span class='line'>Second Lord:
</span><span class='line'>They would be ruled after this chamber, and
</span><span class='line'>my fair nues begun out of the fact, to be conveyed,
</span><span class='line'>Whose noble souls I'll have the heart of the wars.
</span><span class='line'>
</span><span class='line'>Clown:
</span><span class='line'>Come, sir, I will make did behold your worship.
</span><span class='line'>
</span><span class='line'>VIOLA:
</span><span class='line'>I'll drink it.</span></code></pre></td></tr></table></div></figure>

<p>记住，RNN只知道字符，所以它会对发言者的名字和内容进行取样。有时候我们也会得到相对延伸的独白短文，比如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>VIOLA:
</span><span class='line'>Why, Salisbury must find his flesh and thought
</span><span class='line'>That which I am not aps, not a man and in fire,
</span><span class='line'>To show the reining of the raven and the wars
</span><span class='line'>To grace my hand reproach within, and not a fair are hand,
</span><span class='line'>That Caesar and my goodly father's world;
</span><span class='line'>When I was heaven of presence and our fleets,
</span><span class='line'>We spare with hours, but cut thy council I am great,
</span><span class='line'>Murdered and by thy master's ready there
</span><span class='line'>My power to give thee but so much as hell:
</span><span class='line'>Some service in the noble bondman here,
</span><span class='line'>Would show him to her wine.
</span><span class='line'>
</span><span class='line'>KING LEAR:
</span><span class='line'>O, if you were a feeble sight, the courtesy of your law,
</span><span class='line'>Your sight and several breath, will wear the gods
</span><span class='line'>With his heads, and my hands are wonder'd at the deeds,
</span><span class='line'>So drop upon your lordship's head, and your opinion
</span><span class='line'>Shall be against your honour.</span></code></pre></td></tr></table></div></figure>

<p>我几乎不能把这些样本从莎士比亚的原作中辨别出来:)如果你喜欢莎士比亚，你可能会喜欢这<a href="http://cs.stanford.edu/people/karpathy/char-rnn/shakespear.txt">10万个字符的样本</a>。当然，你也可以使用我提供的代码在不同温度下生成无限数量的你自己的样本。</p>

<h4 id="维基百科">维基百科</h4>

<p>我们看到，LSTM可以学习拼写单词和复制一般的句法结构。让我们进一步增加难度，在结构化的markdown上面训练它。具体地说，就是使用<a href="http://prize.hutter1.net/">Hutter Prize</a> 的维基百科原始数据集（100MB）训练一个LSTM。和<a href="http://arxiv.org/abs/1308.0850">Graves et al.</a>一样，我使用前面的96MB来训练，剩下的用于验证以及在晚上跑几个模型。我们现在可以对维基百科的文章进行取样！以下是一些有趣的摘录：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Naturalism and decision for the majority of Arab countries' capitalide was grounded
</span><span class='line'>by the Irish language by [[John Clair]], [[An Imperial Japanese Revolt]], associated
</span><span class='line'>with Guangzham's sovereignty. His generals were the powerful ruler of the Portugal
</span><span class='line'>in the [[Protestant Immineners]], which could be said to be directly in Cantonese
</span><span class='line'>Communication, which followed a ceremony and set inspired prison, training. The
</span><span class='line'>emperor travelled back to [[Antioch, Perth, October 25|21]] to note, the Kingdom
</span><span class='line'>of Costa Rica, unsuccessful fashioned the [[Thrales]], [[Cynth's Dajoard]], known
</span><span class='line'>in western [[Scotland]], near Italy to the conquest of India with the conflict.
</span><span class='line'>Copyright was the succession of independence in the slop of Syrian influence that
</span><span class='line'>was a famous German movement based on a more popular servicious, non-doctrinal
</span><span class='line'>and sexual power post. Many governments recognize the military housing of the
</span><span class='line'>[[Civil Liberalization and Infantry Resolution 265 National Party in Hungary]],
</span><span class='line'>that is sympathetic to be to the [[Punjab Resolution]]
</span><span class='line'>(PJS)[http://www.humah.yahoo.com/guardian.
</span><span class='line'>cfm/7754800786d17551963s89.htm Official economics Adjoint for the Nazism, Montgomery
</span><span class='line'>was swear to advance to the resources for those Socialism's rule,
</span><span class='line'>was starting to signing a major tripad of aid exile.]]</span></code></pre></td></tr></table></div></figure>

<p>你可能会注意到，上面的雅虎网址实际上并不存在，是模型生造出来的。另外，还要注意到模型学会了正确地打开和关闭括号。模型学会的结构化markdown还有很多，比如有时候它会创建标题，列表等：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{ { cite journal | id=Cerling Nonforest Department|format=Newlymeslated|none } }
</span><span class='line'>''www.e-complete''.
</span><span class='line'>
</span><span class='line'>'''See also''': [[List of ethical consent processing]]
</span><span class='line'>
</span><span class='line'>== See also ==
</span><span class='line'>*[[Iender dome of the ED]]
</span><span class='line'>*[[Anti-autism]]
</span><span class='line'>
</span><span class='line'>===[[Religion|Religion]]===
</span><span class='line'>*[[French Writings]]
</span><span class='line'>*[[Maria]]
</span><span class='line'>*[[Revelation]]
</span><span class='line'>*[[Mount Agamul]]
</span><span class='line'>
</span><span class='line'>== External links==
</span><span class='line'>* [http://www.biblegateway.nih.gov/entrepre/ Website of the World Festival. The labour of India-county defeats at the Ripper of California Road.]
</span><span class='line'>
</span><span class='line'>==External links==
</span><span class='line'>* [http://www.romanology.com/ Constitution of the Netherlands and Hispanic Competition for Bilabial and Commonwealth Industry (Republican Constitution of the Extent of the Netherlands)]</span></code></pre></td></tr></table></div></figure>

<p>有时候，模型会生成随机但是有效的XML文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;page&gt;
</span><span class='line'>  &lt;title&gt;Antichrist&lt;/title&gt;
</span><span class='line'>  &lt;id&gt;865&lt;/id&gt;
</span><span class='line'>  &lt;revision&gt;
</span><span class='line'>    &lt;id&gt;15900676&lt;/id&gt;
</span><span class='line'>    &lt;timestamp&gt;2002-08-03T18:14:12Z&lt;/timestamp&gt;
</span><span class='line'>    &lt;contributor&gt;
</span><span class='line'>      &lt;username&gt;Paris&lt;/username&gt;
</span><span class='line'>      &lt;id&gt;23&lt;/id&gt;
</span><span class='line'>    &lt;/contributor&gt;
</span><span class='line'>    &lt;minor /&gt;
</span><span class='line'>    &lt;comment&gt;Automated conversion&lt;/comment&gt;
</span><span class='line'>    &lt;text xml:space="preserve"&gt;#REDIRECT [[Christianity]]&lt;/text&gt;
</span><span class='line'>  &lt;/revision&gt;
</span><span class='line'>&lt;/page&gt;</span></code></pre></td></tr></table></div></figure>

<p>模型生成timestamp，id等等。另外，还要注意到它会以正确的嵌套顺序恰当地关闭相应的标签。如果你有兴趣看到更多，这里有<a href="http://cs.stanford.edu/people/karpathy/char-rnn/wiki.txt">10万个字符的维基百科样本</a>。</p>

<h4 id="代数几何（latex）">代数几何（Latex）</h4>

<p>以上结果表明，该模型在学习复杂句法结构方面确实相当擅长。这些结果令人印象深刻，我和我的实验室同事（<a href="http://cs.stanford.edu/people/jcjohns/">Justin Johnson</a>）决定在结构化的领域进一步推进。我们找到关于代数叠/几何的<a href="http://stacks.math.columbia.edu/">这本书</a>，下载它的原始Latex源文件（16MB），然后训练一个多层的LSTM。令人惊讶的是，产生的Latex样本几乎是可以编译的。在我们手动修复一些问题后，就得到了看起来似乎合理的数学推论，这是相当惊人的：</p>

<p><img src="http://codemany.com/uploads/latex4.jpg" alt="latex4"></p>

<p><em>代数几何样本（假的），<a href="http://cs.stanford.edu/people/jcjohns/fake-math/4.pdf">这里是真正的PDF文件</a>。</em></p>

<p>这是另一份样本：</p>

<p><img src="http://codemany.com/uploads/latex3.jpg" alt="latex3"></p>

<p><em>更像代数几何了，还出现了图表（右）。</em></p>

<p>正如你在上面看到的，有时候这个模型试图生成Latex图表，但显然它并不明白图表的具体意思。我也很喜欢它跳过证明的部分（左上角的“Proof omitted”）。当然，Latex有着相对困难的结构化语法格式，甚至我自己都没有完全掌握。例如，这里是一份来自模型的原始样本（未编辑）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>\begin{proof}
</span><span class='line'>We may assume that $\mathcal{I}$ is an abelian sheaf on $\mathcal{C}$.
</span><span class='line'>\item Given a morphism $\Delta : \mathcal{F} \to \mathcal{I}$
</span><span class='line'>is an injective and let $\mathfrak q$ be an abelian sheaf on $X$.
</span><span class='line'>Let $\mathcal{F}$ be a fibered complex. Let $\mathcal{F}$ be a category.
</span><span class='line'>\begin{enumerate}
</span><span class='line'>\item \hyperref[setain-construction-phantom]{Lemma}
</span><span class='line'>\label{lemma-characterize-quasi-finite}
</span><span class='line'>Let $\mathcal{F}$ be an abelian quasi-coherent sheaf on $\mathcal{C}$.
</span><span class='line'>Let $\mathcal{F}$ be a coherent $\mathcal{O}_X$-module. Then
</span><span class='line'>$\mathcal{F}$ is an abelian catenary over $\mathcal{C}$.
</span><span class='line'>\item The following are equivalent
</span><span class='line'>\begin{enumerate}
</span><span class='line'>\item $\mathcal{F}$ is an $\mathcal{O}_X$-module.
</span><span class='line'>\end{lemma}</span></code></pre></td></tr></table></div></figure>

<p>这份样本来自相对像样的模型，它展示了一些常见的错误。例如，模型打开一个\begin{proof}环境，但却以\end{lemma}结束。我们必须手动修复这种问题，它可能是由于依赖关系太长期的缘故：当模型完成proof的时候，它已经忘记是在做proof还是lemma。同样地，它打开一个\begin{enumerate}，但却忘记关闭它。我们观察到，在使用更大/更好的模型时，这些问题会变少，但尽管如此，这些问题还是会出现。</p>

<h4 id="linux源代码">Linux源代码</h4>

<p>我想把结构化的数据推到极限，所以最后的挑战是我决定使用代码。首先，我从<a href="https://github.com/torvalds/linux">GitHub上的Linux库</a>中提取所有的源文件和头文件，将它们合并成单个巨大的文件（474MB的C代码）（我本来只打算在内核上训练，但是其大小只有约16MB）。然后，我花几天的时间训练出几个大小刚好适合我的GPU的3层LSTM网络。这些模型有大约1000万个参数，对于RNN模型来说仍然很少。结果超级有趣：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*
</span><span class='line'> * Increment the size file of the new incorrect UI_FILTER group information
</span><span class='line'> * of the size generatively.
</span><span class='line'> */
</span><span class='line'>static int indicate_policy(void)
</span><span class='line'>{
</span><span class='line'>  int error;
</span><span class='line'>  if (fd == MARN_EPT) {
</span><span class='line'>    /*
</span><span class='line'>     * The kernel blank will coeld it to userspace.
</span><span class='line'>     */
</span><span class='line'>    if (ss-&gt;segment &lt; mem_total)
</span><span class='line'>      unblock_graph_and_set_blocked();
</span><span class='line'>    else
</span><span class='line'>      ret = 1;
</span><span class='line'>    goto bail;
</span><span class='line'>  }
</span><span class='line'>  segaddr = in_SB(in.addr);
</span><span class='line'>  selector = seg / 16;
</span><span class='line'>  setup_works = true;
</span><span class='line'>  for (i = 0; i &lt; blocks; i++) {
</span><span class='line'>    seq = buf[i++];
</span><span class='line'>    bpf = bd-&gt;bd.next + i * search;
</span><span class='line'>    if (fd) {
</span><span class='line'>      current = blocked;
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>  rw-&gt;name = "Getjbbregs";
</span><span class='line'>  bprm_self_clearl(&iv-&gt;version);
</span><span class='line'>  regs-&gt;new = blocks[(BPF_STATS &lt;&lt; info-&gt;historidac)] | PFMR_CLOBATHINC_SECONDS &lt;&lt; 12;
</span><span class='line'>  return segtable;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>这些代码整体上看起来非常棒。当然，这些代码是不能够编译的，但是当你滚动这些生成的代码的时候，它给你的感觉非常像是一个巨大的C代码库。注意，RNN会随机地生成带有注释的代码。它很少会犯语法错误。比如，它能正确地使用字符串、指针表示法等。它也能正确地打开和关闭括号{[，学会很好地缩进代码。一个常见的错误是它不能跟踪变量：它经常使用未定义的变量（例如上面的rw），声明从不使用的变量（例如int error），或者返回不存在的变量。让我们看看更多的示例。这是另外一段代码，显示RNN学到的更多操作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*
</span><span class='line'> * If this error is set, we will need anything right after that BSD.
</span><span class='line'> */
</span><span class='line'>static void action_new_function(struct s_stat_info *wb)
</span><span class='line'>{
</span><span class='line'>  unsigned long flags;
</span><span class='line'>  int lel_idx_bit = e-&gt;edd, *sys & ~((unsigned long) *FIRST_COMPAT);
</span><span class='line'>  buf[0] = 0xFFFFFFFF & (bit &lt;&lt; 4);
</span><span class='line'>  min(inc, slist-&gt;bytes);
</span><span class='line'>  printk(KERN_WARNING "Memory allocated %02x/%02x, "
</span><span class='line'>    "original MLL instead\n"),
</span><span class='line'>    min(min(multi_run - s-&gt;len, max) * num_data_in),
</span><span class='line'>    frame_pos, sz + first_seg);
</span><span class='line'>  div_u64_w(val, inb_p);
</span><span class='line'>  spin_unlock(&disk-&gt;queue_lock);
</span><span class='line'>  mutex_unlock(&s-&gt;sock-&gt;mutex);
</span><span class='line'>  mutex_unlock(&func-&gt;mutex);
</span><span class='line'>  return disassemble(info-&gt;pending_bh);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>static void num_serial_settings(struct tty_struct *tty)
</span><span class='line'>{
</span><span class='line'>  if (tty == tty)
</span><span class='line'>    disable_single_st_p(dev);
</span><span class='line'>  pci_disable_spool(port);
</span><span class='line'>  return 0;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>static void do_command(struct seq_file *m, void *v)
</span><span class='line'>{
</span><span class='line'>  int column = 32 &lt;&lt; (cmd[2] & 0x80);
</span><span class='line'>  if (state)
</span><span class='line'>    cmd = (int)(int_state ^ (in_8(&ch-&gt;ch_flags) & Cmd) ? 2 : 1);
</span><span class='line'>  else
</span><span class='line'>    seq = 1;
</span><span class='line'>  for (i = 0; i &lt; 16; i++) {
</span><span class='line'>    if (k & (1 &lt;&lt; 1))
</span><span class='line'>      pipe = (in_use & UMXTHREAD_UNCCA) +
</span><span class='line'>        ((count & 0x00000000fffffff8) & 0x000000f) &lt;&lt; 8;
</span><span class='line'>    if (count == 0)
</span><span class='line'>      sub(pid, ppc_md.kexec_handle, 0x20000000);
</span><span class='line'>    pipe_set_bytes(i, 0);
</span><span class='line'>  }
</span><span class='line'>  /* Free our user pages pointer to place camera if all dash */
</span><span class='line'>  subsystem_info = &of_changes[PAGE_SIZE];
</span><span class='line'>  rek_controls(offset, idx, &soffset);
</span><span class='line'>  /* Now we want to deliberately put it to device */
</span><span class='line'>  control_check_polarity(&context, val, 0);
</span><span class='line'>  for (i = 0; i &lt; COUNTER; i++)
</span><span class='line'>    seq_puts(s, "policy ");
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>注意，在第二个函数中，模型会比较tty == tty，这永远为真。另一方面，至少变量tty这次在函数范围内存在！在最后一个函数中，代码没有返回任何值，这是正确的，因为函数签名是void。但是，前面两个函数同样声明为void，确有返回值。这又是由于长期相互作用导致的常见错误。</p>

<p>有时候模型会决定是时候对新文件进行取样。这通常是非常有趣的部分：模型首先一个字符一个字符地复述GNU许可证，包含几个头文件，声明一些宏，然后就开始生成代码部分：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*
</span><span class='line'> *  Copyright (c) 2006-2010, Intel Mobile Communications.  All rights reserved.
</span><span class='line'> *
</span><span class='line'> *   This program is free software; you can redistribute it and/or modify it
</span><span class='line'> * under the terms of the GNU General Public License version 2 as published by
</span><span class='line'> * the Free Software Foundation.
</span><span class='line'> *
</span><span class='line'> *        This program is distributed in the hope that it will be useful,
</span><span class='line'> * but WITHOUT ANY WARRANTY; without even the implied warranty of
</span><span class='line'> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
</span><span class='line'> *
</span><span class='line'> *  GNU General Public License for more details.
</span><span class='line'> *
</span><span class='line'> *   You should have received a copy of the GNU General Public License
</span><span class='line'> *    along with this program; if not, write to the Free Software Foundation,
</span><span class='line'> *  Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
</span><span class='line'> */
</span><span class='line'>
</span><span class='line'>#include &lt;linux/kexec.h&gt;
</span><span class='line'>#include &lt;linux/errno.h&gt;
</span><span class='line'>#include &lt;linux/io.h&gt;
</span><span class='line'>#include &lt;linux/platform_device.h&gt;
</span><span class='line'>#include &lt;linux/multi.h&gt;
</span><span class='line'>#include &lt;linux/ckevent.h&gt;
</span><span class='line'>
</span><span class='line'>#include &lt;asm/io.h&gt;
</span><span class='line'>#include &lt;asm/prom.h&gt;
</span><span class='line'>#include &lt;asm/e820.h&gt;
</span><span class='line'>#include &lt;asm/system_info.h&gt;
</span><span class='line'>#include &lt;asm/setew.h&gt;
</span><span class='line'>#include &lt;asm/pgproto.h&gt;
</span><span class='line'>
</span><span class='line'>#define REG_PG    vesa_slot_addr_pack
</span><span class='line'>#define PFM_NOCOMP  AFSR(0, load)
</span><span class='line'>#define STACK_DDR(type)     (func)
</span><span class='line'>
</span><span class='line'>#define SWAP_ALLOCATE(nr)     (e)
</span><span class='line'>#define emulate_sigs()  arch_get_unaligned_child()
</span><span class='line'>#define access_rw(TST)  asm volatile("movd %%esp, %0, %3" : : "r" (0));   \
</span><span class='line'>  if (__type & DO_READ)
</span><span class='line'>
</span><span class='line'>static void stat_PC_SEC __read_mostly offsetof(struct seq_argsqueue, \
</span><span class='line'>          pC&gt;[1]);
</span><span class='line'>
</span><span class='line'>static void
</span><span class='line'>os_prefix(unsigned long sys)
</span><span class='line'>{
</span><span class='line'>#ifdef CONFIG_PREEMPT
</span><span class='line'>  PUT_PARAM_RAID(2, sel) = get_state_state();
</span><span class='line'>  set_pid_sum((unsigned long)state, current_state_str(),
</span><span class='line'>           (unsigned long)-1-&gt;lr_full; low;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>这里面有太多有趣的地方需要涉及——仅仅这部分我大概就能写一整篇文章。现在我就不再多说，这里有<a href="http://cs.stanford.edu/people/karpathy/char-rnn/linux.txt">1MB的Linux代码样本</a>供你欣赏。</p>

<h4 id="生成婴儿名字">生成婴儿名字</h4>

<p>让我们尝试一个更好玩的。给RNN提供一个包含8000个婴儿名字的文本文件，每个名字一行（名字从<a href="http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/areas/nlp/corpora/names/">这里</a>获得）。 我们可以把这些名字喂给RNN，然后生成新的名字！以下是一些示例名字，只显示训练数据中没有出现的（90%不会）：</p>

<p><em>Rudi Levette Berice Lussa Hany Mareanne Chrestina Carissy Marylen Hammine Janye Marlise Jacacrie Hendred Romand Charienna Nenotto Ette Dorane Wallen Marly Darine Salina Elvyn Ersia Maralena Minoria Ellia Charmin Antley Nerille Chelon Walmor Evena Jeryly Stachon Charisa Allisa Anatha Cathanie Geetra Alexie Jerin Cassen Herbett Cossie Velen Daurenge Robester Shermond Terisa Licia Roselen Ferine Jayn Lusine Charyanne Sales Sanny Resa Wallon Martine Merus Jelen Candica Wallin Tel Rachene Tarine Ozila Ketia Shanne Arnande Karella Roselina Alessia Chasty Deland Berther Geamar Jackein Mellisand Sagdy Nenc Lessie Rasemy Guen Gavi Milea Anneda Margoris Janin Rodelin Zeanna Elyne Janah Ferzina Susta Pey Castina</em></p>

<p>你可以在<a href="http://cs.stanford.edu/people/karpathy/namesGenUnique.txt">这里</a>看到更多。我最喜欢的名字包括“Baby”（哈哈）、“Killie”、“Char”、“R”、“More”、“Mars”、“Hi”、“Saddie”、“With”和“Ahbort”。这确实很有意思。当然，你还可以在写小说、命名或者给创业公司起名字的时候把它当作相当有用的灵感来源:)</p>

<h3 id="理解到底发生了什么">理解到底发生了什么</h3>

<p>我们看到，训练结束时的结果令人印象深刻，但是这些工作是如何进行的呢？让我们跑两个快速的实验来简单地窥视一下。</p>

<h4 id="训练中样本的演变">训练中样本的演变</h4>

<p>首先，看看样本文本在模型训练的过程中是如何演变的。例如，我用列夫·托尔斯泰的《战争与和平》来训练LSTM，然后每100次训练就产生一次样本。在第100次迭代时，模型取样的文本是随机杂凑的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tyntd-iafhatawiaoihrdemot  lytdws  e ,tfti, astai f ogoh eoase rrranbyne 'nhthnee e
</span><span class='line'>plia tklrgd t o idoe ns,smtt   h ne etie h,hregtrs nigtike,aoaenns lng</span></code></pre></td></tr></table></div></figure>

<p>但是请注意，至少它开始意识到单词要用空格分开。有时候它偶尔会插入两个空格。它也不知道逗号后面几乎总是有个空格。在迭代300次后，我们看到模型开始学会使用引号和句号：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"Tmont thithey" fomesscerliund
</span><span class='line'>Keushey. Thom here
</span><span class='line'>sheulke, anmerenith ol sivh I lalterthend Bleipile shuwy fil on aseterlome
</span><span class='line'>coaniogennc Phe lism thond hon at. MeiDimorotion in ther thize."</span></code></pre></td></tr></table></div></figure>

<p>这些单词同样被空格分开，模型开始在句子结尾处使用句号。在第500次迭代时：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>we counter. He stutn co des. His stanted out one ofler that concossions and was
</span><span class='line'>to gearang reay Jotrets and with fre colt otf paitt thin wall. Which das stimn</span></code></pre></td></tr></table></div></figure>

<p>模式已经学会拼写最短和最常见的单词，如“we”、“He”、“His”、“Which”、“and”等。在第700次迭代时，我们开始看到越来越像英语的文本出现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Aftair fall unsuch that the hall for Prince Velzonski's that me of
</span><span class='line'>her hearly, and behs to so arwage fiving were to it beloge, pavu say falling misfort
</span><span class='line'>how, and Gogition is so overelical and ofter.</span></code></pre></td></tr></table></div></figure>

<p>在第1200次迭代时，我们看到引号、问号和感叹号的使用。同时还出现了更长的单词：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"Kite vouch!" he repeated by her
</span><span class='line'>door. "But I would be done and quarts, feeling, then, son is people...."</span></code></pre></td></tr></table></div></figure>

<p>直到大约第2000次迭代时，我们才开始得到正确拼写的单词、引述、名字等等：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"Why do what that day," replied Natasha, and wishing to himself the fact the
</span><span class='line'>princess, Princess Mary was easier, fed in had oftened him.
</span><span class='line'>Pierre aking his soul came to the packs and drove up his father-in-law women.</span></code></pre></td></tr></table></div></figure>

<p>从上面的描述可以知道，模型首先是发现单词-空格这样普遍的结构，然后迅速开始学习单词：首先从简短的单词开始，然后是更长的单词。跨越多个单词的话题和主题（以及一般的长期依赖关系）要到很久以后才会出现。</p>

<h4 id="可视化rnn中的预测与神经元激活">可视化RNN中的预测与神经元激活</h4>

<p>另一个有趣的可视化是看看字符的预测分布。在下面的可视化中，我们把验证集的字符数据（蓝色/绿色的行）喂给维基百科RNN模型，然后在每个字符下面可视化（用红色）前5个最有可能的下一个字符。颜色深浅由它们的概率大小决定（所以暗红色被认为是非常可能的，白色是不太可能的）。注意，有时候模型对下一个字符的预测是非常有信心的（例如，模型对<code>http://www.</code>序列中的字符就是）。</p>

<p>输入字符序列（蓝/绿）的颜色深浅取决于RNN隐藏层中随机选择的神经元的激活情况。绿色表示非常兴奋，蓝色表示不太兴奋（对于那些熟悉LSTM细节的人来说，这些是隐藏状态向量中[-1,1]之间的值，也就是经过门限操作和tanh计算的LSTM单元状态）。直观地说，这是在RNN读取输入序列的时候，将它的“大脑”中的一些神经元的激活率可视化。不同的神经元可能在寻找不同的模式。下面我们来看看4个不同的神经元，我认为它们是有趣的或者可解释的：</p>

<p><img src="http://codemany.com/uploads/under1.jpg" alt="under1"></p>

<p><em>此图中高亮的神经元似乎对URL感到非常兴奋，在URL之外则不太兴奋。LSTM很可能使用这个神经元来记住它是否在URL内部。</em></p>

<p><img src="http://codemany.com/uploads/under2.jpg" alt="under2"></p>

<p><em>当RNN在[[]]环境内时，此处高亮的神经元变得非常兴奋，在其外部则不太兴奋。有趣的是，神经元在看到字符“[”后不会兴奋，必须等待第二个“[”才能激活。计算模型是否已经看到一个或两个“[”的任务很可能用不同的神经元来完成。</em></p>

<p><img src="http://codemany.com/uploads/under3.jpg" alt="under3"></p>

<p><em>在这里，我们看到神经元在跨越[[]]环境时似乎是线性变化的。换句话说，它的激活值给RNN提供了一个跨越[[]]范围的时间对齐的坐标系统。RNN可以使用这些信息来生成不同的字符，这或多或少可能取决于字符在[[]]范围内出现的早/晚（也许？）。</em></p>

<p><img src="http://codemany.com/uploads/under4.jpg" alt="under4"></p>

<p><em>这里是另一个具有非常局部行为的神经元：它是相对安静的，但在碰到“www”序列中的第一个“w”之后立即变得不太兴奋。RNN可以使用这个神经元来计算它在“www”序列中有多远，以便它可以知道是否应该输出另一个“w”，或者是否应该开始URL。</em></p>

<p>当然，由于RNN的隐藏状态是极多的、高维的和分散的，所以这些结论有些需要手动调整。这些可视化是由自定义的HTML/CSS/JavaScript生成的，如果你想创建类似的东西，你可以看<a href="http://cs.stanford.edu/people/karpathy/viscode.zip">这里</a>的模板。</p>

<p>我们也可以通过排除最有可能的预测来精简这个可视化，仅仅显现文本，通过单元的激活值来决定颜色深浅。我们可以看到，除了大部分没有做任何解释的单元之外，大约5%的单元最终学会了相当有趣和可解释的算法：</p>

<p><img src="http://codemany.com/uploads/pane1.png" alt="pane1">
<img src="http://codemany.com/uploads/pane2.png" alt="pane2"></p>

<p>此外，在试图预测下一个字符（例如，它可能有助于跟踪你目前是否在引号内）的任何时候我们都不必硬编码，这是多么美妙的一件事情！我们刚刚使用原始数据训练LSTM，它就决定这是个有用的东西需要跟踪。换句话说，其中一个单元在训练中逐渐把自己调整成为引号检测单元，因为这有助于它更好地完成最终任务。这是深度学习模型（更普遍的端到端训练）的能力来自哪里的最干净和最引人注目的示例之一。</p>

<h3 id="源代码">源代码</h3>

<p>希望我已经让你深信，训练字符级别的语言模型是一个非常有趣的练习。你可以使用我在GitHub上发布的<a href="https://github.com/karpathy/char-rnn">字符RNN代码</a>（采用MIT许可证）来训练自己的模型。它需要一个大的文本文件来训练字符级别的模型，然后你就可以从中取样。此外，如果你有一个GPU的话会更好，否则在CPU上训练会多花大约10倍的时间。不管怎样，如果你用某些数据进行训练并最终得到有趣的结果，请告诉我！如果你迷失在Torch/Lua的代码库中，请记住，它只是这<a href="https://gist.github.com/karpathy/d4dee566867f8291f086">100行要点</a>的更高级版本。</p>

<p><em>题外话。</em>代码是用<a href="http://torch.ch/">Torch 7</a>编写的，它最近已经成为我最喜欢的深度学习框架。我在最近的几个月才开始使用Torch/Lua，它们并不简单（我花了很多时间在GitHub上挖掘原始的Torch代码，并在gitter上询问他们问题以完成工作），但是一旦你掌握了足够的知识，它就会给你带来很大的灵活性和速度提升。我以前同样使用过Caffe和Theano，我认为，虽然Torch还不完美，但是它的抽象层次和哲学要比其它的好。在我看来，一个高效的框架应该具有以下特征：</p>

<ol>
<li>具有许多功能的CPU/GPU透明张量库（切片、数组/矩阵操作等）</li>
<li>一套基于脚本语言（最好是Python）的完全独立的代码库，能够对张量进行操作，实现所有深度学习的东西（前向/反向传播、图计算等）</li>
<li>可以轻松地分享预训练的模型（Caffe做的很好，其它的不行）</li>
<li>最关键的：没有编译步骤（或者至少不要像Theano现在这样）。深度学习的趋势是更大更复杂的网络，它们在复杂图中花费的时间会成倍地增加。不需要长时间编译或开发是非常重要的。其次，编译会丢失可解释性和有效日志/调试的能力。如果有选项可以在图被开发完成后选择是否编译，那是相当好的。</li>
</ol>

<h3 id="进一步阅读">进一步阅读</h3>

<p>在结束这篇文章前，我还想把RNN放到更广泛的背景中，并提供当前研究方向的概述。RNN最近在深度学习领域颇受欢迎。和卷积网络类似，它已经存在了几十年，但是它的全部潜力最近才开始得到广泛的认可，这在很大程度上是由于我们不断增长的计算资源。这里简要概述一些最近的发展情况（肯定不是完整的清单，很多这样的工作可以追溯到20世纪90年代的研究，请参阅相关的研究部分）：</p>

<p>在NLP/语音领域，RNN<a href="http://www.jmlr.org/proceedings/papers/v32/graves14.pdf">将语音转录为文本</a>，执行<a href="http://arxiv.org/abs/1409.3215">机器翻译</a>，<a href="http://www.cs.toronto.edu/%7Egraves/handwriting.html">生成手写文本</a>，当然，它也被用作强大的语言模型（<a href="http://www.cs.utoronto.ca/%7Eilya/pubs/2011/LANG-RNN.pdf">Sutskever et al.</a>）（<a href="http://arxiv.org/abs/1308.0850">Graves</a>）（<a href="http://www.rnnlm.org/">Mikolov et al.</a>）（都是在字符和单词层面）。目前看来，单词级别的模型比字符级别的模型更好，但这肯定是暂时的。</p>

<p>计算机视觉。RNN在计算机视觉中也很快变得普及。例如，将RNN用于帧级别的<a href="http://arxiv.org/abs/1411.4389">视频分类</a>，<a href="http://arxiv.org/abs/1411.4555">图像标注</a>（也包括我自己的工作以及其它许多内容），<a href="http://arxiv.org/abs/1505.00487">视频标注</a>以及最近的<a href="http://arxiv.org/abs/1505.02074">视觉问答</a>。在计算机视觉论文中，我个人最喜欢的RNN是<a href="http://arxiv.org/abs/1406.6247">可视化注意力的循环模型</a>，这是由于其高层次的方向（对图像扫视后的序列化处理）和低层次的建模（REINFORCE学习规则是强化学习中策略梯度方法的一个特例，可以训练出执行不可微分计算的模型（在这种情况下对图像周围进行扫视））。我相信，这种由CNN做原始感知加上RNN在顶部做扫视策略的混合模型将变得普及，特别是在那些不仅仅是对普通视图中某些对象进行分类的更复杂的任务中。</p>

<p>归纳推理、记忆和注意力。另一个极其令人兴奋的研究方向是面向解决Vanilla循环网络的局限性。RNN的一个问题是不具有归纳性：它能很好地记忆序列，但不一定总是以正确的方式显示令人信服的泛化符号。第二个问题是它不必要地将表征大小与每个步骤的计算量相结合。例如，如果将隐藏状态矢量的大小加倍，由于矩阵乘法的原因，每个步骤的FLOPS（译者注：浮点运算时间）数量会增加四倍。理想情况下，我们希望在保持巨大的表征/记忆（例如，包含所有维基百科或许多中间状态变量）的同时，能够保持每个时间步骤的计算量固定不变。</p>

<p>在这些方向上，第一个有说服力的示例已经在DeepMind的<a href="http://arxiv.org/abs/1410.5401">神经图灵机</a>论文中被建立。论文勾勒出一个模型的路径，该模型可以在大型外部存储阵列和较小的记忆寄存器集（运算发生的地方，可以将其视作我们的工作记忆）之间执行读/写操作。至关重要的是，该论文还特别提出一个非常有趣的记忆寻址机制，该机制是通过（“软”的和完全可微分的）注意力模型来实现的。“软”注意力的概念已被证明是一个强大的建模特性，也被<a href="http://arxiv.org/abs/1409.0473">通过共同学习对齐和翻译的神经机器翻译</a>提出用于机器翻译和被<a href="http://arxiv.org/abs/1503.08895">记忆网络</a>提出用于（玩具）问答。事实上，我可以这么说：</p>

<blockquote>
<p>注意力的概念是近期神经网络中最有趣的架构创新。</p>
</blockquote>

<p>现在，我不想讲太多的细节，但是记忆寻址的“软”注意力方案是很方便的，因为它使得模型完全可微分的，但不幸的是会牺牲一些效率，因为所有可以被注意的东西都被注意到了。可以将其视作C语言中的指针，它不指向特定地址，而是定义了整个记忆地址，并且间接引用指针，返回指向内容的权重和（这是非常昂贵的操作！）。这让很多研究者从“软”注意力模型转向“硬”注意力模型，以便对某个特定的需要注意的记忆块进行采样（例如，在某种程度上对某些记忆单元读/写而不是对所有单元读/写）。这个模型在哲学上更有吸引力、可扩展和高效，但不幸的是它也是不可微分的。这就要求使用来自强化学习文献（例如REINFORCE）的技术，其中人们完全习惯于不可微分的相互作用的概念。这项工作现在还在进展中，但是这些“硬”注意力模型已经被探索过，例如，<a href="http://arxiv.org/abs/1503.01007">使用栈增强循环网络的推理算法模式</a>、<a href="http://arxiv.org/abs/1505.00521">强化学习神经图灵机</a>和<a href="http://arxiv.org/abs/1502.03044">Show Attend and Tell</a>。</p>

<p>研究者。如果你想详细研究RNN，我推荐<a href="http://www.cs.toronto.edu/%7Egraves/">Alex Graves</a>、<a href="http://www.cs.toronto.edu/%7Eilya/">Ilya Sutskever</a>和<a href="http://www.rnnlm.org/">Tomas Mikolov</a>的论文。想要知道更多关于REINFORCE和更通用的强化学习和策略梯度方法（REINFORCE是它的一个特例）的内容，可以学习<a href="http://www0.cs.ucl.ac.uk/staff/d.silver/web/Home.html">David Silver</a>或者<a href="http://www.cs.berkeley.edu/%7Epabbeel/">Pieter Abbeel</a>的公开课。</p>

<p>代码。如果你想训练RNN，Theano上的<a href="https://github.com/fchollet/keras">Keras</a>或<a href="https://github.com/IndicoDataSolutions/Passage">Passage</a>很不错，或者是本文配套的<a href="https://github.com/karpathy/char-rnn">Torch代码</a>，或者是我不久以前写的原始NumPy代码的<a href="https://gist.github.com/karpathy/587454dc0146a6ae21fc">要点</a>，它实现了一个高效、批量的LSTM前向和反向传播。你也可以看看我的基于NumPy的<a href="https://github.com/karpathy/neuraltalk">NeuralTalk</a>，它使用RNN/LSTM来标注图像，或者看看Jeff Donahue的这个<a href="http://jeffdonahue.com/lrcn/">Caffe实现</a>。</p>

<h3 id="总结">总结</h3>

<p>我们已经学习了RNN，它是如何工作的，以及为什么它如此重要。我们还使用几个有趣的数据集来训练RNN字符级别的语言模型，并且我们已经看到RNN是如何进行这个过程的。你可以自信地期待RNN领域的大量创新，我相信它将成为智能系统的普遍和关键组成部分。</p>

<p>最后，为给这篇文章增加一些元素，我使用这篇博文的源文件来训练一个RNN。不幸的是，文章的长度不足以很好地训练RNN。以下是返回的样本（使用低温生成以获得更典型的样本）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>I've the RNN with and works, but the computed with program of the
</span><span class='line'>RNN with and the computed of the RNN with with and the code</span></code></pre></td></tr></table></div></figure>

<p>是的，这篇文章讲的是RNN以及它的效果如何，很明显它工作良好:)下次再见！</p>

<p>额外链接：</p>

<p>视频:</p>

<ul>
<li>我在<a href="https://skillsmatter.com/skillscasts/6611-visualizing-and-understanding-recurrent-networks">伦敦深度学习会议（视频）</a>上关于这项工作发表的讲话。</li>
</ul>

<p>讨论:</p>

<ul>
<li><a href="https://news.ycombinator.com/item?id=9584325">HN上的讨论</a></li>
<li>Reddit的<a href="http://www.reddit.com/r/MachineLearning/comments/36s673/the_unreasonable_effectiveness_of_recurrent/">r/machinelearning</a>上的讨论</li>
<li>Reddit的<a href="http://www.reddit.com/r/programming/comments/36su8d/the_unreasonable_effectiveness_of_recurrent/">r/programming</a>上的讨论</li>
</ul>

<p>回复:</p>

<ul>
<li><a href="https://twitter.com/yoavgo">Yoav Goldberg</a>把这些RNN结果和<a href="http://nbviewer.ipython.org/gist/yoavg/d76121dfde2618422139">n-gram最大似然（计数）基线</a>做比较</li>
<li><a href="https://twitter.com/nylk">@nylk</a>使用<a href="https://gist.github.com/nylki/1efbaa36635956d35bcc">烹饪食谱</a>训练字符RNN。它看起来非常棒！</li>
<li><a href="https://twitter.com/MrChrisJohnson">@MrChrisJohnson</a>使用Eminem的歌词训练字符RNN，然后合成一首说唱歌曲并用机器声音演唱它。极其滑稽的:)</li>
<li><a href="https://twitter.com/samim">@samim</a>使用<a href="https://medium.com/@samim/obama-rnn-machine-generated-political-speeches-c8abd18a2ea0">奥巴马的演讲</a>训练字符RNN。它看起来很有趣！</li>
<li><a href="https://twitter.com/seaandsailor">João Felipe</a>使用爱尔兰民间音乐训练字符RNN，这里是<a href="https://soundcloud.com/seaandsailor/sets/char-rnn-composes-irish-folk-music">音乐样本</a></li>
<li><a href="https://twitter.com/boblsturm">Bob Sturm</a>使用<a href="https://highnoongmt.wordpress.com/2015/05/22/lisls-stis-recurrent-neural-networks-for-folk-music-generation/">ABC记谱法的音乐</a>训练字符RNN</li>
<li><a href="https://twitter.com/the__glu/with_replies">Maximilien</a>的<a href="https://twitter.com/RNN_Bible">RNN圣经机器人</a></li>
<li><a href="http://cpury.github.io/learning-holiness/">这篇博文</a>介绍如何使用RNN学习《圣经》</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何验证邮箱是否存在？]]></title>
    <link href="http://codemany.com/blog/how-to-verify-mailbox-exist/"/>
    <updated>2017-12-23T11:45:10+08:00</updated>
    <id>http://codemany.com/blog/how-to-verify-mailbox-exist</id>
    <content type="html"><![CDATA[<p>事情的起因是想要注销某个免费的163邮箱，但是查找资料后发现：</p>

<blockquote>
<p>163免费邮箱不支持直接注销。</p>

<p>如果连续180天没登录过网易任何产品的帐号，系统将自动清空所有信息和资料，并删除帐号。</p>
</blockquote>

<p>那么问题来了，超过上述期限没有登录的话，如何才能验证该邮箱是否真的被销号？直接登录肯定不行，如果那时邮箱正处于冻结状态，你登录不就相当于重新激活吗！或者向该邮箱发送测试邮件，如果投递成功就说明邮箱还没被注销，但这种方法太过麻烦，尤其对于注销多个邮箱的情况。要想优雅地解决这个问题，我们需要从了解电子邮件传输协议开始。</p>

<h3 id="电子邮件传输协议">电子邮件传输协议</h3>

<p>电子邮件传输协议主要包括SMTP协议、ESMTP协议、POP协议、IMAP协议等，具体的标准可以参考<a href="https://www.rfc-editor.org/">RFC Editor</a>网站下的相关RFC文档。POP3是Post Office Protocol 3的缩写，IMAP是Internet Message Access Protocol的缩写，两者的作用都是收取邮件，关键的区别在于邮件是放在服务器上（IMAP）还是放在本地电脑上（POP3）。SMTP是Simple Mail Transfer Protocol的缩写，ESMTP即Extension-SMTP，是为对付滥用SMTP服务器发邮件而引入的，它和SMTP的主要区别在于增加了发信认证机制。</p>

<p>下图是一个典型的电子邮件收发路径：</p>

<p><img src="http://codemany.com/uploads/email-architecture.png" alt="email-architecture"></p>

<p>在你写完邮件点击“发送”时，你的邮件客户端会将消息发送给SMTP服务器（就如同我们将信交给本地的邮局），然后SMTP服务器根据收信人的地址向DNS服务器查询邮箱地址后缀的MX记录，找到目的邮件服务器（就好像邮局根据收信人的地址选择邮递路线，经过飞机或火车等交通工具到达收信人所在地邮局），然后收信人就可以使用自己的帐号登录POP3服务器收取邮件（就像收信人从邮箱取信）。</p>

<p>由此推断，通过SMTP服务器或者MX服务器能够验证邮箱是否存在。下面我们就来进行测试。</p>

<h3 id="实践">实践</h3>

<p>我们先从SMTP服务器开始。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>C:\&gt;telnet smtp.163.com 25
</span><span class='line'>220 163.com Anti-spam GT for Coremail System (163com[20141201])
</span><span class='line'>
</span><span class='line'>hello    # SMTP协议没有这个指令
</span><span class='line'>502 Error: command not implemented
</span><span class='line'>
</span><span class='line'>helo hi  # 因为每次按键都会被传送到服务器，所以输入错误时不能使用退格键删除，只能换行重新输入
</span><span class='line'>500 Error: bad syntax
</span><span class='line'>
</span><span class='line'>helo hi
</span><span class='line'>250 OK
</span><span class='line'>
</span><span class='line'>vrfy noname@163.com  # 现在的邮件服务器都使用ESTMP协议，VRFY、EXPN这些指令都已经被禁用或不被支持
</span><span class='line'>502 Error: command not implemented
</span><span class='line'>
</span><span class='line'>mail from: &lt;noname@example.com&gt;  # 必须是同域的邮箱才能发邮件
</span><span class='line'>553 Local user only,163 smtp7,C8CowAA3eUZ7jEBaXE8hDg--.38995S2 1514179735
</span><span class='line'>
</span><span class='line'>mail from: &lt;noname@163.com&gt;      # 必须登录服务器才能发邮件
</span><span class='line'>553 authentication is required,163 smtp7,C8CowAA3eUZ7jEBaXE8hDg--.38995S3 1514179751
</span><span class='line'>
</span><span class='line'>quit
</span><span class='line'>221 Bye</span></code></pre></td></tr></table></div></figure>

<p>因为邮件服务器使用ESMTP协议的缘故，必须使用同域的其它邮箱登录SMTP服务器后才能验证邮箱是否存在，这显然不是什么好的方法。</p>

<p>再来试试MX服务器，希望不要如此麻烦，否则的话就完蛋了～</p>

<p>首先找到163免费邮箱的MX服务器：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>C:\&gt;nslookup -q=mx 163.com
</span><span class='line'>Non-authoritative answer:
</span><span class='line'>163.com MX preference = 10, mail exchanger = 163mx03.mxmail.netease.com
</span><span class='line'>163.com MX preference = 10, mail exchanger = 163mx01.mxmail.netease.com
</span><span class='line'>163.com MX preference = 10, mail exchanger = 163mx02.mxmail.netease.com
</span><span class='line'>163.com MX preference = 50, mail exchanger = 163mx00.mxmail.netease.com
</span><span class='line'>
</span><span class='line'>163.com nameserver = ns6.nease.net
</span><span class='line'>163.com nameserver = ns3.nease.net
</span><span class='line'>163.com nameserver = ns4.nease.net
</span><span class='line'>163.com nameserver = ns1.nease.net
</span><span class='line'>163.com nameserver = ns8.166.com
</span><span class='line'>163.com nameserver = ns2.166.com
</span><span class='line'>163.com nameserver = ns5.nease.net
</span><span class='line'>163mx01.mxmail.netease.com      internet address = 220.181.14.138
</span><span class='line'>163mx01.mxmail.netease.com      internet address = 220.181.14.139
</span><span class='line'>163mx01.mxmail.netease.com      internet address = 220.181.14.140
</span><span class='line'>163mx01.mxmail.netease.com      internet address = 220.181.14.141
</span><span class='line'>163mx01.mxmail.netease.com      internet address = 220.181.14.142
</span><span class='line'>163mx01.mxmail.netease.com      internet address = 220.181.14.143
</span><span class='line'>163mx01.mxmail.netease.com      internet address = 220.181.14.135
</span><span class='line'>163mx01.mxmail.netease.com      internet address = 220.181.14.136
</span><span class='line'>163mx01.mxmail.netease.com      internet address = 220.181.14.137</span></code></pre></td></tr></table></div></figure>

<p>找到MX服务器后，我们就可以像对待SMTP服务器那样对待它：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>C:\&gt;telnet 163mx03.mxmail.netease.com 25
</span><span class='line'>220 163.com Anti-spam GT for Coremail System (163com[20141201])
</span><span class='line'>
</span><span class='line'>helo hi
</span><span class='line'>250 OK
</span><span class='line'>
</span><span class='line'>vrfy noname@163.com              # VRFY指令也处于禁用
</span><span class='line'>502 Error: command not implemented
</span><span class='line'>
</span><span class='line'>mail from: &lt;noname@example.com&gt;  # 注意：不同域的邮箱也能发邮件啦
</span><span class='line'>250 Mail OK
</span><span class='line'>
</span><span class='line'>rcpt to: &lt;fewfwe&gt;
</span><span class='line'>550 Invalid User: fewfwe
</span><span class='line'>
</span><span class='line'>rcpt to: &lt;fewfwe@163.com&gt;        # 邮箱不存在
</span><span class='line'>550 User not found: fewfwe@163.com
</span><span class='line'>
</span><span class='line'>rcpt to: &lt;fake@163.com&gt;          # 邮箱存在
</span><span class='line'>250 Mail OK
</span><span class='line'>
</span><span class='line'>quit
</span><span class='line'>221 Bye</span></code></pre></td></tr></table></div></figure>

<h3 id="总结">总结</h3>

<ul>
<li>验证邮箱是否存在的最好方法是在MX服务器上使用RCPT TO指令。</li>
<li>连续180天没登录过的163免费邮箱不会被注销。</li>
</ul>

<p>写到这里才想起我手里还有以前收集的大批邮箱，即使按照上面的步骤逐个验证也不现实，看来需要找个时间码个程序来自动化批量处理它们。这次就暂时先这样子吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Scrapy爬取小说（6）]]></title>
    <link href="http://codemany.com/blog/crawl-novel-with-scrapy-part6/"/>
    <updated>2017-12-06T17:18:51+08:00</updated>
    <id>http://codemany.com/blog/crawl-novel-with-scrapy-part6</id>
    <content type="html"><![CDATA[<h3 id="使用“下一页”链接抓取小说">使用“下一页”链接抓取小说</h3>

<p>在前文中，我们首先抓取小说目录页面的所有章节链接，然后再使用这些链接分别抓取各个章节的正文内容。这样需要分析两个不同页面的结构。其实，还有个更简单点的方法，只要分析内容页面的结构即可。</p>

<p>在小说的内容页面中通常都会有“上一页”和“下一页”这样的链接。我们只需要先抓取小说的首个章节，然后抽取出它的“下一页”链接，接着抓取这个链接对应的章节，再抽取出这个章节的“下一页”链接，重复这个循环直到不再有“下一页”链接为止。</p>

<p>抽取“下一页”链接的XPath表达式是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//a[text()='下一页']/@href</span></code></pre></td></tr></table></div></figure>

<p>修改后的novel_spider.py如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class NovelSpider(scrapy.Spider):
</span><span class='line'>  name = 'novelspider'
</span><span class='line'>  allowed_domains = ['example.com']
</span><span class='line'>  # 把原来的目录页链接改成第一章的链接
</span><span class='line'>  start_urls = ['http://example.com/wuxia/hzlz/ssjx/001.htm']
</span><span class='line'>
</span><span class='line'>  def parse(self, response):
</span><span class='line'>    # 有些小说网站的页眉和页脚都有“下一页”链接，我们
</span><span class='line'>    # 不需要管它有几个，只要获取第一个出现的就行。
</span><span class='line'>    link = response.xpath("//a[text()='下一页']/@href").extract_first()
</span><span class='line'>    next_url = response.urljoin(link)
</span><span class='line'>    yield scrapy.Request(next_url, callback=self.parse)  # 注意callback的值
</span><span class='line'>
</span><span class='line'>    item = NovelItem()
</span><span class='line'>    title = response.xpath('//center/table/tr[2]/td/text()').extract()
</span><span class='line'>    content = response.xpath('//center/table/tr[4]/td/text()').extract()
</span><span class='line'>    item['title'] = title
</span><span class='line'>    item['content'] = content
</span><span class='line'>    return item</span></code></pre></td></tr></table></div></figure>

<p>满怀愉悦地运行Spider，结果什么都没有，抓取失败。这是怎么回事？百思不得其解。</p>

<h3 id="郁闷之旅由此开始～">郁闷之旅由此开始～</h3>

<p>把yield关键词删掉试试？！修改后的代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>link = response.xpath("//a[text()='下一页']/@href").extract_first()
</span><span class='line'>next_url = response.urljoin(link)
</span><span class='line'>scrapy.Request(next_url, callback=self.parse)</span></code></pre></td></tr></table></div></figure>

<p>结果只输出第一章的内容。</p>

<p>把parse方法改成下面这样呢？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def parse(self, response):
</span><span class='line'>  item = NovelItem()
</span><span class='line'>  title = response.xpath('//center/table/tr[2]/td/text()').extract()
</span><span class='line'>  content = response.xpath('//center/table/tr[4]/td/text()').extract()
</span><span class='line'>  item['title'] = title
</span><span class='line'>  item['content'] = content
</span><span class='line'>  yield item
</span><span class='line'>
</span><span class='line'>  link = response.xpath("//a[text()='下一页']/@href").extract_first()
</span><span class='line'>  next_url = response.urljoin(link)
</span><span class='line'>  return scrapy.Request(next_url, callback=self.parse)</span></code></pre></td></tr></table></div></figure>

<p>也只能输出第一章的内容。</p>

<p>读到这里可能有看官会疑惑，为什么我会做出上面这两种修改？首先，我知道问题是在yield语句那里。其次，因为在我的印象中，yield的作用是延迟执行后面的语句。但现在从实际执行的情况来看显然不是如此。</p>

<h3 id="真实的yield">真实的yield</h3>

<p>查阅资料以后发现，包含yield的函数不再是普通函数，Python解释器会将其视为生成器。我们用个例子来详细说明下。</p>

<p>Fibonacci数列是个非常简单的递归数列，除第1和第2个数外，任何一个数都可以由前两个数相加得到。下面是输出Fibonacci数列前N个数的测试代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def fab(max):
</span><span class='line'>  n = 0
</span><span class='line'>  a, b = 0, 1
</span><span class='line'>  while n &lt; max:
</span><span class='line'>    yield b
</span><span class='line'>    a, b = b, a + b
</span><span class='line'>    n = n + 1
</span><span class='line'>
</span><span class='line'>print(fab(5))</span></code></pre></td></tr></table></div></figure>

<p>猜猜会输出什么？有人以为会打印出Fibonacci数列，但实际上输出的是生成器对象的信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;generator object fab at 0x7fd41edfcd58&gt;</span></code></pre></td></tr></table></div></figure>

<p>fab(5)看起来像函数调用，但它其实是返回一个生成器对象。在对其调用next函数之前，它不会执行任何函数代码。虽然仍按函数的流程执行，但每执行到一条yield语句就会中断，并返回一个迭代值，下次执行时从yield处继续执行。看起来就好像一个函数在正常执行的过程中被yield中断了数次，每次中断都会通过yield返回当时的迭代值。</p>

<p>所以正确的打印代码应该这样写（for循环会自动对生成器对象调用next函数）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for n in fab(5)
</span><span class='line'>  print(n)</span></code></pre></td></tr></table></div></figure>

<p>也可以手动调用next函数，这样我们就可以更清楚地看到它的执行流程：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt;&gt;&gt; f = fab(5)
</span><span class='line'>&gt;&gt;&gt; next(f)
</span><span class='line'>1
</span><span class='line'>&gt;&gt;&gt; next(f)
</span><span class='line'>1
</span><span class='line'>&gt;&gt;&gt; next(f)
</span><span class='line'>2
</span><span class='line'>&gt;&gt;&gt; next(f)
</span><span class='line'>3
</span><span class='line'>&gt;&gt;&gt; next(f)
</span><span class='line'>5
</span><span class='line'>&gt;&gt;&gt; next(f)
</span><span class='line'>Traceback (most recent call last):
</span><span class='line'> File "&lt;stdin&gt;", line 1, in &lt;module&gt;
</span><span class='line'>StopIteration</span></code></pre></td></tr></table></div></figure>

<p>当函数执行结束时，生成器自动抛出StopIteration异常，表示迭代完成。在for循环中，无需处理StopIteration异常，循环会正常结束。</p>

<h3 id="正确的解决方案">正确的解决方案</h3>

<p>明白yield到底起什么作用后，再回过头来看前面的修改。</p>

<p>第2次修改明显是没有思考，胡乱盲目地尝试。它只是创建一个Request对象而已，能有什么用！代码也清楚地表明，parse方法仅会被回调1次，这也是仅能输出第一章内容的原因。现在回想起来
怎么也弄不明白当初为什么会这么写？！</p>

<p>第3次修改的代码首先是解析Response对象，把第一章的标题和内容封装起来返回给Scrapy。因为这个函数是生成器函数，所以Scrapy在输出第一章内容后会继续执行yield item后面的语句，直到函数结束，抛出StopIteration异常。因为有return语句，所以会把返回的值当作StopIteration异常的属性。</p>

<p>第1次修改和第3次修改类似，不同的是它返回“下一页”的Request对象给Scrapy，所以parse方法会被不断地循环回调，直到没有“下一页”为止。</p>

<p>归根结底，第1和第3次修改不能输出所有章节内容的原因是因为StopIteration异常吞掉了return返回的值，所以也要把它改成yield。修改后的代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def parse(self, response):
</span><span class='line'>  item = NovelItem()
</span><span class='line'>  title = response.xpath('//center/table/tr[2]/td/text()').extract()
</span><span class='line'>  content = response.xpath('//center/table/tr[4]/td/text()').extract()
</span><span class='line'>  item['title'] = title
</span><span class='line'>  item['content'] = content
</span><span class='line'>  yield item
</span><span class='line'>
</span><span class='line'>  link = response.xpath("//a[text()='下一页']/@href").extract_first()
</span><span class='line'>  next_url = response.urljoin(link)
</span><span class='line'>  yield scrapy.Request(next_url, callback=self.parse)</span></code></pre></td></tr></table></div></figure>

<p>给代码做个美容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def parse(self, response):
</span><span class='line'>  yield {
</span><span class='line'>    'title': response.xpath('//center/table/tr[2]/td/text()').extract(),
</span><span class='line'>    'content': response.xpath('//center/table/tr[4]/td/text()').extract(),
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  link = response.xpath("//a[text()='下一页']/@href").extract_first()
</span><span class='line'>  next_url = response.urljoin(link)
</span><span class='line'>  yield scrapy.Request(next_url, callback=self.parse)</span></code></pre></td></tr></table></div></figure>

<p>打完收工。写文章比写代码累多了！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Scrapy爬取小说（5）]]></title>
    <link href="http://codemany.com/blog/crawl-novel-with-scrapy-part5/"/>
    <updated>2017-11-18T21:55:30+08:00</updated>
    <id>http://codemany.com/blog/crawl-novel-with-scrapy-part5</id>
    <content type="html"><![CDATA[<h3 id="重构代码以提升健壮性">重构代码以提升健壮性</h3>

<p>今天的任务是重构TxtPipeline。</p>

<p>先看下TxtPipeline中负责写文件的代码片段：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>f = open(filename, 'w')
</span><span class='line'>f.write(title)
</span><span class='line'>f.write(content)
</span><span class='line'>f.close()</span></code></pre></td></tr></table></div></figure>

<p>我们经常会看到这样的代码，但它存在严重的问题，你能把它找出来吗？</p>

<p>首先，open函数打开文件，并返回文件句柄，该句柄是由操作系统分配的。接着就是调用write方法写文件。最后是调用close方法关闭文件。文件使用完毕后必须关闭，因为文件句柄会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的。</p>

<p>由于文件读写时都有可能产生IOError，一旦出错，后面的close方法就不会被调用。所以，为确保无论是否出错都能正常地关闭文件和释放文件句柄，我们需要使用如下方法来实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>try:
</span><span class='line'>  f = open(filename, 'w')
</span><span class='line'>  f.write(title)
</span><span class='line'>  f.write(content)
</span><span class='line'>finally:
</span><span class='line'>  if f:
</span><span class='line'>    f.close()</span></code></pre></td></tr></table></div></figure>

<p>但每次都这么写实在太繁琐。其实，我们可以使用with语句来帮我们自动管理文件资源：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>with open(filename, 'w') as f:
</span><span class='line'>  f.write(title)
</span><span class='line'>  f.write(content)</span></code></pre></td></tr></table></div></figure>

<p>这和前面的try-finally是一样的，但是代码更加简洁，而且不必调用close方法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Scrapy爬取小说（4）]]></title>
    <link href="http://codemany.com/blog/crawl-novel-with-scrapy-part4/"/>
    <updated>2017-11-11T14:17:36+08:00</updated>
    <id>http://codemany.com/blog/crawl-novel-with-scrapy-part4</id>
    <content type="html"><![CDATA[<h3 id="重构代码以提升可移植性">重构代码以提升可移植性</h3>

<p>在前文中，我们使用range(1, 310)来确定小说章节链接的范围，这很不好。我们编程的时候应该要注意尽量避免代码中的硬编码和魔数，提高代码的可移植性。如果小说章节的链接不是这种连续的数字，或者章节的数量是在逐步增加的，那么这段代码就是无效的，或者会慢慢变得无效。</p>

<p>如何才能把这段代码写得更具可移植性呢？</p>

<p><img src="http://codemany.com/uploads/novel-chapter-urls.png" alt="novel-chapter-urls"></p>

<p>我们不必关心章节链接的格式，我们只要知道它是个链接，一定是以<code>&lt;a href=&quot;url&quot;&gt;text&lt;/a&gt;</code>这种形式呈现（如上图所示）。我们也不必关心章节数量是否变化，只要把所有这种形式的链接抓取下来即可。与此对应的XPath表达式是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//center/table[@bordercolorlight]//a/@href</span></code></pre></td></tr></table></div></figure>

<p>因为页面文档中可能有多个表格，所以要在table后面添加@bordercolorlight属性来指定我们要查找的那个。</p>

<p>那么在Scrapy中如何实现这样的能力呢？以下是具体的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def parse(self, response):
</span><span class='line'>  links = response.xpath('//center/table[@bordercolorlight]//a/@href').extract()
</span><span class='line'>  for link in links:
</span><span class='line'>    next = response.urljoin(link)
</span><span class='line'>    yield scrapy.Request(next, callback=self.parse_chapter)</span></code></pre></td></tr></table></div></figure>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Scrapy爬取小说（3）]]></title>
    <link href="http://codemany.com/blog/crawl-novel-with-scrapy-part3/"/>
    <updated>2017-11-04T09:55:53+08:00</updated>
    <id>http://codemany.com/blog/crawl-novel-with-scrapy-part3</id>
    <content type="html"><![CDATA[<h3 id="将小说保存到mongodb">将小说保存到MongoDB</h3>

<p>在前文中，我们将小说的每个章节保存为独立的文本文件。今天我们准备把小说内容输出到数据库。对于数据存储，我选择MongoDB。为什么是MongoDB而不是其它？原因是以前没用过，想尝试下。</p>

<p>现在我们已经知道，要把抓取来的数据保存到数据库，只需实现Item Pipeline即可。我们可以仿照前面的实现依葫芦画瓢。</p>

<p>以下是将小说内容保存到MongoDB的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import pymongo
</span><span class='line'>
</span><span class='line'>class MongoPipeline(object):
</span><span class='line'>  def open_spider(self, spider):
</span><span class='line'>    self.client = pymongo.MongoClient('localhost', 27017)
</span><span class='line'>    self.novel = self.client['novel']
</span><span class='line'>    self.ssjx = self.novel['ssjx']
</span><span class='line'>
</span><span class='line'>  def process_item(self, item, spider):
</span><span class='line'>    data = {
</span><span class='line'>      # 标题和内容都是列表类型，必须先转换成字符串
</span><span class='line'>      'title' : ''.join(item['title']),
</span><span class='line'>      'content' : ''.join(item['content']),
</span><span class='line'>    }
</span><span class='line'>    self.ssjx.insert(data)
</span><span class='line'>    return item
</span><span class='line'>
</span><span class='line'>  def close_spider(self, spider):
</span><span class='line'>    self.client.close()</span></code></pre></td></tr></table></div></figure>

<p>将组件添加到novel/settings.py的ITEM_PIPELINES配置中以启用它：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ITEM_PIPELINES = {
</span><span class='line'>  'novel.pipelines.TxtPipeline' : 300,
</span><span class='line'>  'novel.pipelines.MongoPipeline' : 400,
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>在项目的根目录中使用下面的指令运行Spider：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scrapy crawl novelspider</span></code></pre></td></tr></table></div></figure>

<p>如果没有问题的话，爬虫会不停地运行，小说的章节内容也会被一个个地保存到数据库。下面的截图是最终的抓取结果：</p>

<p><img src="http://codemany.com/uploads/novel-mongo-gui.png" alt="novel-mongo-gui"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Scrapy爬取小说（2）]]></title>
    <link href="http://codemany.com/blog/crawl-novel-with-scrapy-part2/"/>
    <updated>2017-10-28T20:35:23+08:00</updated>
    <id>http://codemany.com/blog/crawl-novel-with-scrapy-part2</id>
    <content type="html"><![CDATA[<h3 id="将小说按章节保存为文本文件">将小说按章节保存为文本文件</h3>

<p>在前文中，我们通过<code>-o</code>选项将抓取的小说内容保存成本地文件。虽然它工作的很好，但是有两个缺点：一是把所有小说内容保存到单个文件会导致该文件太大，用文本编辑器打开随机浏览的速度非常慢；二是小说章节不是按照顺序保存的，导致阅读指定的章节内容很不方便。</p>

<p>再写个小工具按章节内容分割小说文件？无需如此麻烦。我们可以在Scrapy中直接将每个章节保存为单独的文本文件。Scrapy中的Item Pipeline就是干这类事情的。看下面的Scrapy架构图：</p>

<p><img src="http://codemany.com/uploads/scrapy-architecture.png" alt="scrapy-architecture"></p>

<p>当Item在Spider中被收集之后，它们会被传递到Item Pipeline，这些Pipeline组件按照一定的顺序执行对Item的处理，同时也决定此Item是否继续通过，或是被丢弃而不再进行处理。</p>

<p>以下是Item Pipeline的一些典型应用：</p>

<ul>
<li>清理HTML数据</li>
<li>验证爬取的数据</li>
<li>查重</li>
<li>将爬取结果保存到数据库中</li>
</ul>

<h3 id="编写item-pipeline">编写Item Pipeline</h3>

<p>编写自己的Item Pipeline非常简单，每个Item Pipeline都是实现以下方法的Python类：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>process_item(self, item, spider)</span></code></pre></td></tr></table></div></figure>

<p>此外，下面的方法是可选实现的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>open_spider(self, spider)  # 该方法在Spider被开启时调用
</span><span class='line'>close_spider(spider)       # 该方法在Spider被关闭时调用</span></code></pre></td></tr></table></div></figure>

<p>明白原理后，我们就可以开始编写自己的Item Pipeline。以下就是将小说的每个章节写成单独文本文件的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class TxtPipeline(object):
</span><span class='line'>  def process_item(self, item, spider):
</span><span class='line'>    # 标题和内容都是列表类型，必须先转换成字符串
</span><span class='line'>    title = ''.join(item['title'])
</span><span class='line'>    content = ''.join(item['content'])
</span><span class='line'>    # 使用章节名来创建文件
</span><span class='line'>    # 使用strip()来过滤非法字符r'\/:*?"&lt;&gt;|'
</span><span class='line'>    filename = '{}.txt'.format(title.strip())
</span><span class='line'>    f = open(filename, 'w')
</span><span class='line'>    f.write(title)
</span><span class='line'>    f.write(content)
</span><span class='line'>    f.close()
</span><span class='line'>    return item</span></code></pre></td></tr></table></div></figure>

<h3 id="启用item-pipeline">启用Item Pipeline</h3>

<p>要启用Pipeline组件，你必须将它添加到novel/settings.py的ITEM_PIPELINES配置中，就像下面这样:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ITEM_PIPELINES = {
</span><span class='line'>  'novel.pipelines.TxtPipeline' : 300,
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>Pipeline后面的整数值确定它们的运行顺序，Item按数字从低到高通过每个Pipeline。通常将这些值定义在0-1000范围内。</p>

<h3 id="运行spider">运行Spider</h3>

<p>在项目的根目录中执行如下的命令（因为不再把所有的小说内容保存为单个文件，所有不需要指定<code>-o</code>选项）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scrapy crawl novelspider</span></code></pre></td></tr></table></div></figure>

<p>没有报错的话，等个几分钟，就能看到很多文本文件躺在自己的电脑上面。</p>

<p><img src="http://codemany.com/uploads/novel-txt-list.png" alt="novel-txt-list"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Scrapy爬取小说（1）]]></title>
    <link href="http://codemany.com/blog/crawl-novel-with-scrapy-part1/"/>
    <updated>2017-10-21T08:49:54+08:00</updated>
    <id>http://codemany.com/blog/crawl-novel-with-scrapy-part1</id>
    <content type="html"><![CDATA[<p>这几天正在看《Python网络数据采集》，在这过程中觉得有必要写个爬虫来实践学到的知识。便给自己定个小目标：试着用Scrapy爬取小说《蜀山剑侠传》，并把内容保存到本地文件中。</p>

<p>Scrapy是一个开源的Python数据抓取框架，速度快且强大，而且使用简单，可以很方便地抓取网站页面并从中提取结构化的数据。Scrapy用途广泛，可以用于数据挖掘、监测和自动化测试。</p>

<p>好吧，废话不多说，让我们直接开干！</p>

<h3 id="创建项目">创建项目</h3>

<p>在抓取之前，必须先创建一个Scrapy项目，可以直接用以下命令生成：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scrapy startproject novel</span></code></pre></td></tr></table></div></figure>

<p>这是新建项目的目录结构：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.
</span><span class='line'>├── novel                # 项目模块
</span><span class='line'>│   ├── __init__.py
</span><span class='line'>│   ├── items.py         # 定义爬取的数据
</span><span class='line'>│   ├── middlewares.py   # 定义爬取时的中间件
</span><span class='line'>│   ├── pipelines.py     # 定义数据管道
</span><span class='line'>│   ├── __pycache__
</span><span class='line'>│   ├── settings.py      # 项目的设置文件
</span><span class='line'>│   └── spiders          # 放置爬虫代码的文件夹
</span><span class='line'>│       ├── __init__.py
</span><span class='line'>│       └── __pycache__
</span><span class='line'>└── scrapy.cfg           # Scrapy部署时的配置文件</span></code></pre></td></tr></table></div></figure>

<h3 id="分析页面结构">分析页面结构</h3>

<p>主要分析两个页面。一是小说的目录页面，目的是获取小说所有章节的链接以备抓取。二是任意章节页面，用于爬取其中的标题和正文。</p>

<p>通过观察目录页面的源码可以发现，所有章节的链接都类似<code>NUMBER.htm</code>。其中，NUMBER是3位整数，从001到309。</p>

<p><img src="http://codemany.com/uploads/novel-chapter-urls.png" alt="novel-chapter-urls"></p>

<p>使用Firefox浏览器的检查器（Inspector）查看章节页面，尝试把光标放在正文上，你应该可以看到正文周围的蓝色方块（如下图左侧所示），如果你点击这个方块，就可以选中检查器面板中相对应的HTML代码。可以看到小说的标题和正文都在td标签内。</p>

<p><img src="http://codemany.com/uploads/novel-page-inspector.png" alt="novel-page-inspector"></p>

<p>与此对应的XPath表达式分别是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//center/table/tr[2]/td/text()  # 标题的XPath路径
</span><span class='line'>//center/table/tr[4]/td/text()  # 正文的XPath路径</span></code></pre></td></tr></table></div></figure>

<p>需要注意的是，上面XPath表达式里的中括号内的数字为节点索引，是从1开始的，而不是0。</p>

<h3 id="定义爬取的数据">定义爬取的数据</h3>

<p>当需要从某个网站抓取信息时，首先是定义我们要爬取的数据。在Scrapy中，可以通过Item来完成。以下是我们定义的Item：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import scrapy
</span><span class='line'>
</span><span class='line'>class NovelItem(scrapy.Item):
</span><span class='line'>  title = scrapy.Field()
</span><span class='line'>  content = scrapy.Field()</span></code></pre></td></tr></table></div></figure>

<h3 id="编写爬取数据的spider">编写爬取数据的Spider</h3>

<p>现在我们需要添加一个爬虫来真正做点什么。创建文件novel/spiders/novel_spider.py，添加如下内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import scrapy
</span><span class='line'>from novel.items import NovelItem
</span><span class='line'>
</span><span class='line'>class NovelSpider(scrapy.Spider):
</span><span class='line'>  name = 'novelspider'
</span><span class='line'>  allowed_domains = ['example.com']
</span><span class='line'>  start_urls = ['http://example.com/wuxia/hzlz/ssjx/']
</span><span class='line'>
</span><span class='line'>  def parse(self, response):
</span><span class='line'>    # 还记得前面分析目录页面时的结果吗：000、001...309。
</span><span class='line'>    for i in range(1, 310):
</span><span class='line'>      # 生成每个章节的绝对链接
</span><span class='line'>      next = response.urljoin('{0:03d}.htm'.format(i))
</span><span class='line'>      # 生成新的请求对象解析小说的标题和正文
</span><span class='line'>      yield scrapy.Request(next, callback=self.parse_chapter)
</span><span class='line'>
</span><span class='line'>  def parse_chapter(self, response):
</span><span class='line'>    item = NovelItem()
</span><span class='line'>    title = response.xpath('//center/table/tr[2]/td/text()').extract()
</span><span class='line'>    print('Title is', title)
</span><span class='line'>    content = response.xpath('//center/table/tr[4]/td/text()').extract()
</span><span class='line'>    print('Content is', content)
</span><span class='line'>    item['title'] = title
</span><span class='line'>    item['content'] = content
</span><span class='line'>    return item</span></code></pre></td></tr></table></div></figure>

<h3 id="运行spider">运行Spider</h3>

<p>完成爬虫后，如何通过它来得到我们想要的结果呢？在项目的根目录中执行如下的命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scrapy crawl novelspider -o novel.json</span></code></pre></td></tr></table></div></figure>

<p>没有报错的话，等个几分钟，就能看到一个完整的JSON数据文件躺在自己的电脑上面。</p>

<p>不过如果打开的话，可能只会看到“\uXXXX”这样的乱码，它们都是中文字符的Unicode编码。要直接显示成中文的话，需要在novel/settings.py中添加以下设置：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>FEED_EXPORT_ENCODING = 'utf-8'</span></code></pre></td></tr></table></div></figure>

<p>最终的结果如图：</p>

<p><img src="http://codemany.com/uploads/novel-json-chinese.png" alt="novel-json-chinese"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件版本号的思考]]></title>
    <link href="http://codemany.com/blog/thinking-on-software-version/"/>
    <updated>2017-09-30T07:45:55+08:00</updated>
    <id>http://codemany.com/blog/thinking-on-software-version</id>
    <content type="html"><![CDATA[<p><img src="http://codemany.com/uploads/software-version.png" alt="software-version"></p>

<p>产品的名称用来表明产品目的，通常在产品的整个生命周期中都使用它。软件产品的版本号则用来表明产品在特定时间段内所拥有的功能集。它们关注的是以何种方式对提供给用户的软件版本进行识别。</p>

<p>版本号用于捕获相关产品修订和变种（通常与可移植性、国际化或者性能特征相关）的信息。目标是采用尽量少的标识符去收集所有信息。遗憾的是，在工业生产中还没有一种标准的版本编号机制，或者说，不存在单一的、通用的算法。更多情况是，需要你针对发布的内容和目标群体做些细微不同的调整。</p>

<p>但不管你的目标群体是什么，完全发布最好通过以下方式进行标识。这是经过不断地反复实践，被各种封闭、开源软件所广泛使用的惯例。</p>

<ul>
<li>软件的名称。</li>
<li>用x.y.z.build四位元组去捕捉修订信息。</li>
<li>根据需要生成的任意变种信息。</li>
</ul>

<p>版本编号中的元组定义：</p>

<table><thead>
<tr>
<th>元组</th>
<th>定义</th>
</tr>
</thead><tbody>
<tr>
<td>x</td>
<td>主版本号。表示产品的当前主要版本。用来表示提供给客户的产品功能的主要增强。在一个极端的例子中，主版本号的增加用来说明产品现在已经拥有一个全新的功能类。</td>
</tr>
<tr>
<td>y</td>
<td>次版本号。表示给产品新增了一些特征，或者是在原来文档中描述的特征上做了重要的修改。用来确定次版本号什么时候需要修改的一个衡量标准就是产品功能说明书。</td>
</tr>
<tr>
<td>z</td>
<td>修订版本号。用来表示给产品所做的缺陷维护行为的等级。产品缺陷是在产品的功能说明书中没有定义，并且已经或者可能对产品的使用者造成不利影响的任何行为。缺陷维护可以看作是支持该版本功能说明的一切活动。</td>
</tr>
<tr>
<td>build</td>
<td>构建版本号。一般是编译器在编译过程中自动生成。</td>
</tr>
</tbody></table>

<p>除z和build的意义比较明确外，对x和y的解释都太笼统。我们需要更加详细的说明以指导我们的开发工作。</p>

<p>修订过的版本编号中的元组定义：</p>

<table><thead>
<tr>
<th>元组</th>
<th>定义</th>
</tr>
</thead><tbody>
<tr>
<td>x</td>
<td>主版本号。用于有扩展性的、客户可见的架构上或特性上的改变。以一个管理大型数据库的系统为例，你可能在以下情况时需要定义一个主要的版本发布：</td>
</tr>
<tr>
<td></td>
<td>* 改变数据库的结构，导致单纯的升级系统对客户产生比较严重的影响。</td>
</tr>
<tr>
<td></td>
<td>* 改变已经发布的API，导致它与前一版本不兼容。</td>
</tr>
<tr>
<td></td>
<td>* 删除功能（好的架构师应该删除一些不需要的功能）。</td>
</tr>
<tr>
<td></td>
<td>* 持续增加新的功能，例如对新的操作系统的支持。</td>
</tr>
<tr>
<td></td>
<td>x的增加也可以是出于纯粹的商业理由。例如，客户的技术支持合同标明，在下个主要版本发布以后，软件可以得到18个月的技术支持。通过增加x，你将强迫客户去升级。</td>
</tr>
<tr>
<td>y</td>
<td>次版本号。通常与期望的功能或其它改进措施相关。当市场部门认为这个版本的一系列特性已经通过证实，次要版本号就会增加。决定增加x或y可能会比较随意。市场架构师应该定义触发任何一个增加的事件（定义与x相关的触发事件比定义y要更容易）。</td>
</tr>
<tr>
<td>z</td>
<td>修订版本号。主要版本号和次要版本号都相同的维护版本应该彼此兼容。</td>
</tr>
<tr>
<td>build</td>
<td>构建版本号。一般是编译器在编译过程中自动生成。</td>
</tr>
</tbody></table>

<p>注意：这里的版本编号规则仅适用于发布周期较长的软件产品。如果发布周期很短，像Chrome和Firefox那样，可能就不太适用。</p>

<h3 id="参考资料">参考资料</h3>

<ul>
<li><a href="http://semver.org/">语义化版本</a></li>
<li>《软件发布方法》</li>
<li>《超越软件架构：创建和维护优秀解决方案》</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[追逐时髦的技术]]></title>
    <link href="http://codemany.com/blog/chasing-the-shiny-and-new-in-software/"/>
    <updated>2017-08-29T11:50:09+08:00</updated>
    <id>http://codemany.com/blog/chasing-the-shiny-and-new-in-software</id>
    <content type="html"><![CDATA[<p>英文原文：<a href="https://www.nemil.com/musings/shinyandnew.html">https://www.nemil.com/musings/shinyandnew.html</a></p>

<p>有关当前最好的框架或编程语言的争论经常发生在Web开发中。就这点而言，<a href="https://www.scribd.com/">Scribd</a>的联合创始人Jared Friedman在2015年写了<a href="http://blog.jaredfriedman.com/2015/09/15/why-i-wouldnt-use-rails-for-a-new-company/">一篇文章</a>推荐创业公司使用Node.js代替Rails。</p>

<p>他提出几个关键点：</p>

<ul>
<li>Rails很慢。</li>
<li>黑客学院的毕业生都在使用Rails，贬低了它对高级工程师的价值，并减少了它的未来前景。</li>
<li>创业公司应该使用那些前瞻性工程师今后将使用的技术，以保证它们的应用不过时。</li>
<li>在Scribd，过去几年里它们已经从Prototype转换到jQuery，再到CoffeeScript，再到Angular，再到React。</li>
</ul>

<p>Node.js是创业公司的绝佳选择，但它饱受批评的两个部分令我担忧。首先，一名创业公司的工程师应该了解什么技术将会在几年后流行，以保证它们的技术栈不过时。第二，杰出的软件工程师将被时髦的技术栈吸引到创业公司，而不是有趣的技术问题。在过去我还听到过更恶劣的传闻，创业公司的开发者拒绝接受使用ES5 JavaScript编程的工作（那时CoffeeScript刚出来），Mongo发布不久工程师就执意在生产环境下使用Mongo替代Postgres，渴望用最新的前端框架不断重构项目。</p>

<p>我担心有些程序员（和他们的雇主）有这种倾向，即把注意力放在转换技术栈到最新上。他们主要基于框架选择公司，力求在工作中使用最新而不是最好的工具。他们把时间花在新的库和框架上，而不是提高他们的核心技术能力。我们把他们称为技术栈追逐者——他们奋力追求在创业公司的技术栈中使用那些对核心输出（用户重视的软件功能、开发团队的生产力）提升有限的新技术（或者他们自己喜欢的技术）。</p>

<h3 id="“时髦的”web开发">“时髦的”Web开发</h3>

<p>很同情那些在<a href="https://news.ycombinator.com/">Hacker News</a>上的时髦的Web或移动应用开发者。作为在2012年的全栈创业公司的开发者，你正在构建后端使用Ruby/Rails，前端使用Backbone/CoffeeScript/Underscore的网站，同时使用Capistrano（或相关的Python类似物）部署你的应用。到2013年，你已经将后端转换到Node/Express/Mongo，前端为Grunt/Ember。在2014年，你已经彻底切换到MEAN技术栈，但在尝试过Koa以后考虑转移到Go（在Express核心贡献者<a href="https://medium.com/@tjholowaychuk/farewell-node-js-4ba9e7f3e52b">告别Node.js转向Go</a>以后）。在2015年，你在后端使用Express/Go，前端使用Gulp/ES2015/React，使用React Native代替原生移动语言，并且慢慢地将系统转换为使用Docker的微服务。很快，你将会被转换到Phoenix，如果Angular 2是正确的选择也会转换过去——甚至可能创造一个Go可以工作在Android上以及开源Swift可以适合你的技术栈的世界。（我显然是夸大效果，尽管这是HN头条新闻流行什么的一个合理表示。）</p>

<p>有几个原因表明这可能是合理的。时髦的Web工程师需要“时尚”才能获得未来的工作或合同。雇主使用框架或语言作为过滤器，而不是测试批判性思维和技能。雇主没有意识到有实力的开发者如果有正确的支持，可以在几个星期，通常是几天内成为许多语言或者框架的专家。有时趋势是无法阻止的：Swift正在取代Objective-C，世界正在转向更薄、更小的单体后端和更重、反应更灵敏的前端。通常，转变有着巨大的优势：生产力大幅上升，或者新的用户功能突然变得可能。然而，所有的变化都不会导致早期到中期的公司不采用就死，而为了乐趣或业余项目学习技术和认为它是生产环境的关键是迥然不同的。</p>

<p>我们可以用创业公司的时髦的Web或移动开发者与我们的计算机科学家作为对比。我的一个朋友是一家顶级科技公司的计算机神经学家——跟几乎所有从事技术工作的人一样，他的世界每隔几个月就会被重塑——得益于计算能力、脑成像和深度学习算法的快速发展。基本的编程工具其实变化不大。公平地说，只有C++从 11转换到14引起了一些焦虑。还有分布式计算系统、键/值存储和其它外部服务，但这些都是使用稳定的API构建的。他的大部分时间都花在单个DSL中的架构和算法上，而不是重写功能相似的代码或者快速学习提供有争议的好处和改变的库。</p>

<h3 id="选择工具">选择工具</h3>

<p>人们可能会建议创业公司选择时髦的技术栈，因为它是招聘杰出的工程师的关键工具。我自己的观察是，杰出的工程师注重其它的东西。到目前为止，最重要的是提供有趣的问题去解决——有趣的人与他们合作。吸引力和强大的使命感是吸引优秀人才（工程师或者其他）的其它途径。</p>

<p>我并不是在抱怨技术发展太快，也不是说我们都应该用汇编语言或者C++或者Ruby编程。软件工程师清楚他们的目标——我们的领域以令人目眩的速度发展，但对于我们拥有的影响力这都是值得的，因为有10亿人上网。我认为你需要有能力快速地学会新的框架、语言或库（如何完成它的<a href="https://news.ycombinator.com/item?id=7733249">Ask HN</a>）——依靠周围那些经验丰富的工程师，你的目标应该是尽快地具有生产力。除此之外，你应该深刻理解多种语言，而不仅仅是一种（但是同样的态度，不应盲目地扩展到框架或者轻量级的DSL）。</p>

<p>对于创业公司而言，Paul Graham<a href="http://castig.org/an-interview-with-paul-graham-hackers-painters-10-years-later/">在2013年被问到关于理想的语言</a>：“我的意思是，我们有的创业公司在用PHP编写代码——这让我有点担心，但这并不像其它事情那么让我担心。”GitHub的技术主管Sam Lambert在<a href="https://medium.com/s-c-a-l-e/github-scaling-on-ruby-with-a-nomadic-tech-team-4db562b96dcd">最近的一次采访</a>中谈到，他在2013年被GitHub的CTO面试时，对GitHub的技术栈是Rails、C和Bash脚本感到惊讶：“随着面试的继续，我发现他们实际上是一群非常务实的黑客，他们只钻研Ruby和C，使用更稳定的技术栈以便花时间工作在更有趣的事情上，而不是追逐最新最酷炫的技术。”GitHub的方法在我看来是Web和移动开发者的合理的平衡：广泛地探索工具，然后务实地选择解决你所面临的问题的工具（<a href="https://martinfowler.com/bliki/Yagni.html">YAGNI</a>适用于更多的地方，而不仅仅是面向用户的功能开发）。</p>

<p>令我担心的是，某些开发者，特别是在职业生涯早期的开发者，可能会以为创业公司的工程师不是问题解决者或计算机科学家，而是一个荣誉查找表——他们的任务是每隔几个月记住一个新的DSL——只能获得有限的好处。这使我们这些早期的工程师贬值——构建人们想要的东西，从事有趣的技术问题，快速交付代码。</p>

<p>无论如何，要在额外的时间里广泛地实践。如果好处是压倒性的，则切换生产环境中的语言/框架，但要考虑是哪些好处。警惕那些追求新技术却不考虑它对团队的预期优势的人。花时间学习概念和解决有趣的技术或用户问题。如果你有正确的应用边界，并选择你有现成生产力的框架，一旦你这样做了，你将具有一定的灵活性，但需要足够坚持才能达到产品与市场的匹配和超越。</p>

<p>任何一天打开<a href="https://news.ycombinator.com/">Hacker News</a>，你都能看到有帖子诱惑你使用某个框架、语言、类库或者服务去贡献和构建应用（包括一些像Mongo这样有大笔现金的公司，因此在它们的平台后面有营销预算）。有些工具拥有改变游戏规则的能力，其余的只有一些关键的不同功能，但是它们都需要时间才能成为专家。有些工具会大声宣告它们才是未来，并且嘲笑你所学到的东西——但是它们需要你的技能和意识与现有的技术真正地竞争。你会如何选择？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[checked/unchecked应该翻译成什么？]]></title>
    <link href="http://codemany.com/blog/what-should-checked-and-unchecked-translate/"/>
    <updated>2017-07-29T12:17:06+08:00</updated>
    <id>http://codemany.com/blog/what-should-checked-and-unchecked-translate</id>
    <content type="html"><![CDATA[<p>翻译有关Java异常的文章时，总是犹豫是否该把checked/unchecked也翻译过来。原因是，不是很清楚该如何优雅传神地翻译这两个单词。</p>

<p>《Java核心技术》将它们翻译成“已检查/未检查”。《Java编程思想》和《Effictive Java中文版》则翻译成“被检查的/不检查的”。至于技术文章的翻译更是花样百出，有“检测/非检测”、“可检测/非检测”、“可查/不可查”、“受查/非受查”、“检查型/非检查型”、“检查/非检查”等。</p>

<p>到底该翻译成什么呢？在回答这个问题前，让我们先确定什么是checked/unchecked异常？</p>

<p><img src="http://codemany.com/uploads/exception-hierarchy.png" alt="exception-hierarchy"></p>

<p>上图是Java中的异常层次结构图。Java语言规范将派生自RuntimeException类和Error类的所有异常称为“unchecked异常”，其它的异常称为“checked异常”。</p>

<blockquote>
<p>The unchecked exception classes are the run-time exception classes and the error classes.</p>

<p>The checked exception classes are all exception classes other than the unchecked exception classes. That is, the checked exception classes are Throwable and all its subclasses other than RuntimeException and its subclasses and Error and its subclasses.</p>
</blockquote>

<p>并且，在编译时编译器会检查程序是否为所有的“checked异常”提供处理器。</p>

<blockquote>
<p>This compile-time checking for the presence of exception handlers is designed to reduce the number of exceptions which are not properly handled.</p>
</blockquote>

<p>从上述的描述可以得出，“checked异常”和“unchecked异常”是两种异常类型，且“checked异常”隐含有必须要检查的思想。</p>

<p>紧紧围绕这些描述，细细地思考和比较，个人认为：1. 《Java核心技术》的翻译存在问题，“已检查”和“未检查”说明的是异常的检查状态，没有表达出异常的分类这个概念。2. 《Java编程思想》和《Effictive Java中文版》的翻译则正确地表达了异常的分类，但“被检查”翻译的有点无厘头，如果能改成“要检查”则会更好，缺陷是连接“异常”这个词组后是短语，而非名词，读来费劲，也不上口；如果去掉“的”的话，后者会有歧义，听起来像是命令。3. “检测/非检测”和“检查/非检查”是同个意思。4. “可检测”这个翻译看上去似乎表示异常是可以检查的，和Java语言规范要求的该类异常必须要检查不符。5. “可查/不可查”也是如此。6. “受查/非受查”的翻译则有些莫名其妙的感觉。7. “检查型/非检查型”翻译的很好，既表达了异常的分类，也表达了一种异常是要检查的，另一种异常是不要检查的意义，只是前者还缺少点强制的意味。</p>

<p>分析到这里，结果已经是不言而明。“要检查的/不检查的”和“检查型/非检查型”是两种更好的翻译，都能把Java语言规范对checked/unchecked异常的描述尽量地表述出来。而后者在实际使用中更为简洁适宜。</p>

<p>接下来的事情就是把以前译文中未翻译的checked/unchecked修改成“检查型/非检查型”。在以后的翻译中也继续使用这个翻译结果，除非能找到更好的表述方式。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[费曼技巧：最好的学习方法]]></title>
    <link href="http://codemany.com/blog/learn-anything-faster-with-the-feynman-technique/"/>
    <updated>2017-06-02T08:30:09+08:00</updated>
    <id>http://codemany.com/blog/learn-anything-faster-with-the-feynman-technique</id>
    <content type="html"><![CDATA[<p>英文原文：<a href="https://www.farnamstreetblog.com/2012/04/learn-anything-faster-with-the-feynman-technique/">https://www.farnamstreetblog.com/2012/04/learn-anything-faster-with-the-feynman-technique/</a></p>

<p>费曼技巧有4个简单的步骤，我将在下面解释它们：</p>

<ul>
<li>选择一个概念</li>
<li>把它教给某个小孩</li>
<li>识别薄弱环节，回到原始材料</li>
<li>回顾和简化（可选）</li>
</ul>

<p>如果你不学习就会固步自封。那么，学习新主题并识别现有知识的薄弱环节的最好方式是什么？</p>

<h3 id="两种类型的知识">两种类型的知识</h3>

<p>有<a href="https://www.farnamstreetblog.com/2015/09/two-types-of-knowledge/">两种类型的知识</a>，我们大多数人关注错误的那种。第一类知识注重知道某事物的名称。第二类注重知道某事物。它们不是一回事。著名的诺贝尔物理学奖获得者理查德·费曼（Richard Feynman）明白<a href="https://www.farnamstreetblog.com/2015/01/richard-feynman-knowing-something/">知道某事物和知道某事物的名称之间的差异</a>，这是他成功的最重要的原因之一。事实上，他创造了一个学习公式，确保他比其他人更明白某些东西。</p>

<p>这被称为费曼技巧，它将帮助你更快更明白地学到东西。最重要的是，它极其容易实现。</p>

<blockquote>
<p>一个人如果说他知道他在想些什么，却表达不出来，通常是他其实并不知道自己在想些什么。——莫提默·艾德勒</p>
</blockquote>

<h3 id="费曼技巧">费曼技巧</h3>

<p>费曼技巧有4个步骤。</p>

<h4 id="步骤1：把它教给某个小孩">步骤1：把它教给某个小孩</h4>

<p>拿出一张白纸，在顶部写下你想要学习的主题。写出你对这个主题的了解，好像你正在把它教给某个小孩。不是你聪明的成年朋友，而是一个8岁的小孩，他刚好有足够的词汇和注意力来涵盖基本的概念和关系。</p>

<p>很多人倾向于使用复杂的词汇和行话来掩盖他们不明白的东西。问题是我们仅仅愚弄自己，因为我们不知道我们不明白。另外，使用行话会掩盖周围的人对我们的误解。</p>

<p>当你自始至终都用孩子可以理解的简单的语言写出某个想法时（提示：只用最常见的单词），你迫使自己在更深的层次上去理解这个概念，并简化想法之间的关系和连接。如果你努力，你会清楚地知道自己在哪里还有薄弱环节。这种压力很好——它预示着学习的机会。</p>

<h4 id="步骤2：回顾">步骤2：回顾</h4>

<p>在第一步中，你不可避免地会遇到你的知识的薄弱环节，你忘记了某些重要的东西，或者不能解释它，或者只是很难把重要的概念联系起来。</p>

<p>这是宝贵的反馈，因为你已经发现你的知识的边缘。胜任力是知道你能力的极限，你刚刚已经识别出一个！</p>

<p>这是学习开始的地方。现在你知道在哪里会遇到困难，回到原始材料并重新学习，直到你可以用基本的术语去解释它们。</p>

<p>识别你的理解的边界也限制了你可能犯的错误，并增加了在应用知识时成功的机会。</p>

<h4 id="步骤3：整理和简化">步骤3：整理和简化</h4>

<p>现在你有一套手工制作的笔记。检查它们以确保你没有错误地从原始材料中借用任何行话。将它们组织成一个丰满的简单的故事。</p>

<p>把它们大声地朗读出来，如果解释不直白或者听起来很混乱，这表明你在该领域的理解仍需要做些工作。</p>

<h4 id="步骤4（可选）：传播">步骤4（可选）：传播</h4>

<p>如果你真的想要确保自己的理解没有任何偏差，那就把它告诉别人（理想状态是这个人对该主题知之甚少，或者就找个8岁的小孩）。对你的知识的最终考验是你将其传达给另一个人的能力。</p>

<p>这不仅是学习的一个妙诀，它也是一种不同的思维方式的窗口，允许你将想法分解，然后从头开始重建。（Elon Musk称它为<a href="https://www.farnamstreetblog.com/2015/04/elon-musk-framework-thinking/">从第一个原则思考</a>）。这会导致对想法和概念的更深入的理解。重要的是，以这种方式解决问题，你可以在别人不知道他们自己在说什么的情况下理解这个问题。</p>

<p>费曼的方法直观地认为智力是一个成长的过程，这与卡罗尔·德韦克（Carol Dweck）的工作非常吻合，卡罗尔·德韦克漂亮地描述了<a href="https://www.farnamstreetblog.com/2015/03/carol-dweck-mindset/">固定型和成长型思维之间的区别</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[100%代码覆盖率的悲剧]]></title>
    <link href="http://codemany.com/blog/code-coverage-100-percent-tragedy/"/>
    <updated>2017-05-13T19:00:41+08:00</updated>
    <id>http://codemany.com/blog/code-coverage-100-percent-tragedy</id>
    <content type="html"><![CDATA[<p>英文原文：<a href="http://labs.ig.com/code-coverage-100-percent-tragedy">http://labs.ig.com/code-coverage-100-percent-tragedy</a></p>

<p>有趣的是，我对测试的观点正在发生变化。十五年来，我一直在宣扬TDD（测试驱动开发，或者被称为测试先行方法），或至少让开发者写些单元测试。不过，最近我发现自己更经常地说，“你为什么要写测试？”而不是“你应该写测试”。</p>

<h3 id="怎么回事？">怎么回事？</h3>

<p>在办公室四处走走时，开发者要求我帮助他进行单元测试。看来他在使用Mockito测试以下代码时遇到了麻烦：</p>

<p><img src="http://codemany.com/uploads/initialise-method.png" alt="initialise-method"></p>

<p>我想他是非常惊讶于我的回应：“你不需要测试。”</p>

<p>“但我不得不测啊！”他说。“否则如何知道这段代码是正常的？”</p>

<p>“这段代码很明显。没有条件，没有循环，没有转换，没有任何东西。它们只是一些普通的旧式胶水代码。”</p>

<p>“但没有测试，任何人都可以来修改和破坏这段代码呀！”</p>

<p>“看，如果那个虚构的邪恶/无知的开发者来了，破坏了这些简单的代码，如果相关的单元测试中断，你认为他会做什么？他只会删除它。”</p>

<p>“但是如果非要写测试怎么办？”</p>

<p>“在这种情况下，我将这样写测试：”</p>

<p><img src="http://codemany.com/uploads/initialise-test.png" alt="initialise-test"></p>

<p>“但是你没有使用Mockito啊！”</p>

<p>“那又怎么样呢？Mockito没有帮助你。恰恰相反：它会妨碍你，并且它也不会使测试变得更易读或更简单。”</p>

<p>“但是我们决定使用Mockito进行所有测试！”</p>

<p>我：“……”</p>

<p>后来我碰到他，他自豪地说，他已经设法用Mockito写了测试。我明白让测试代码正常运行的心理满足感，但尽管如此，这种解决方案让我难过。</p>

<h3 id="另一个例子">另一个例子</h3>

<p>我加入的某个开发团队，他们对新应用程序的高代码覆盖率以及对BDD（行为驱动设计）的新发现感到兴奋。查看代码，可以发现如下的Cucumber测试：</p>

<p><img src="http://codemany.com/uploads/cucumber-test.png" alt="cucumber-test"></p>

<p>如果你以前使用过Cucumber，你就不会震惊于它所需的支持代码的数量：</p>

<p><img src="http://codemany.com/uploads/cucumber-support.png" alt="cucumber-support"></p>

<p><img src="http://codemany.com/uploads/cucumber-support2.png" alt="cucumber-support2"></p>

<p>和所有要测试的代码：</p>

<p><img src="http://codemany.com/uploads/cucumber-code.png" alt="cucumber-code"></p>

<p>是的，一个简单的地图查找。我和这个开发者有足够的信任去直言不讳地说，“这是在浪费时间。”</p>

<p>“但我的老板希望我能为所有的类写测试，”他回答。</p>

<p>“代价是什么？”</p>

<p>“费用？”</p>

<p>“无论如何，这些测试与BDD无关。”</p>

<p>“我知道，但是我们决定使用Cucumber进行所有测试”</p>

<p>我：“……”</p>

<p>我明白按照自己意愿改造工具的心理满足感，但尽管如此，这种解决方案让我难过。</p>

<h3 id="悲剧在哪里？">悲剧在哪里？</h3>

<p>悲剧是两位聪明的开发者（我需要带他们去团队面试）浪费时间写那种测试，测试是毫无意义的，但需要后来的IG开发者维护。</p>

<p>悲剧是不使用正确的工具，因为没有特别好的理由，我们决定坚持不懈地使用错误的工具。</p>

<p>悲剧是一旦某个“良好实践”成为主流，我们似乎就忘记它是怎么来的，它的好处是什么，最主要的是，使用它的代价是什么。</p>

<p>如果我们只是机械地应用它而没有太多的思考，这通常意味着我们最终得到最平庸的结果，失去大部分的好处，但支付所有（甚至更多）的成本。根据我的经验，编写好的单元测试并非易事。</p>

<h3 id="那么100-的代码覆盖率值得追求吗？">那么100%的代码覆盖率值得追求吗？</h3>

<p>是的，每个人都应该实现它……在一个项目中。我认为你必须用极端的手段去了解限制是什么。</p>

<p>我们已经有了一个极端的大量经验：0个单元测试的项目，所以我们知道在这上面工作的痛苦。我们通常缺乏的是在另一个极端的经验：强制100%代码覆盖率和一切都是TDD的项目。单元测试（尤其是测试先行方法）是一个非常好的实践，但我们应该学习哪些测试是有用的，哪些是适得其反的。</p>

<p>要记住没有什么是免费的，没有什么是银弹。使用工具前请停下来想一想。</p>

<h4 id="关于作者">关于作者</h4>

<p>Daniel Lebrero在IG的大数据团队担任技术架构师。拥有超过15年的Java经验和4年的Clojure经验，他现在是函数式编程的大力倡导者。可以在<a href="https://twitter.com/DanLebrero">Twitter</a>，<a href="https://www.linkedin.com/in/daniel-lebrero-4729906">LinkedIn</a>或者他的个人<a href="http://danlebrero.com/">博客</a>找到他。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[学习新编程语言的非传统方式]]></title>
    <link href="http://codemany.com/blog/unconventional-way-of-learning-a-new-programming-language/"/>
    <updated>2017-04-08T09:23:59+08:00</updated>
    <id>http://codemany.com/blog/unconventional-way-of-learning-a-new-programming-language</id>
    <content type="html"><![CDATA[<p>英文原文：<a href="https://hackernoon.com/unconventional-way-of-learning-a-new-programming-language-e4d1f600342c">https://hackernoon.com/unconventional-way-of-learning-a-new-programming-language-e4d1f600342c</a></p>

<p>现在已经有500多种编程语言。因此，开始学习新的编程语言对你来说是很正常的。你可能知道C++和Java，但是你的工作需要Python；或者你精通Python，但是需要用Java编写代码；或者也许你想要学习这种很酷的语言只是为了扩展你的编程技能。</p>

<p>如果你想学习新的编程语言，你会选择哪种方式？</p>

<ul>
<li>从若干在线教程中学习</li>
<li>或者从若干在线课程（MOOC）中学习</li>
</ul>

<p>有些人甚至可能认为，学习新语言的最佳方式应该是这样的：</p>

<ul>
<li>学习这门新的编程语言的语法</li>
<li>再用这门语言构建一些个人项目</li>
</ul>

<p>有道理！这样可以确保你能够应用学习语言的语法而获得的知识。</p>

<p>我开发过20多个迷你项目，同时学习不同的语言。相信我，当你为个人项目编写代码的时候，不管这些项目是周末项目还是紧急快速补丁，你编写代码都只是为了完成任务。你只会关注——“我的代码是否工作？”你几乎不关心代码的质量。</p>

<blockquote>
<p>任何傻瓜都能写出计算机可以理解的代码。好的程序员能写出人类可以理解的代码。——Martin Fowler</p>
</blockquote>

<p>那么，你是如何学习你正在尝试学习的新的编程语言的良好实践呢？</p>

<h3 id="向该语言的开源项目贡献代码">向该语言的开源项目贡献代码</h3>

<p>惊讶吗？有些人可能在想——“等等，开源是很难的。只有当我们是该语言的专家时，我们才能为开源项目贡献代码，对吗？”答案是不。</p>

<p>让我给你们讲个故事。</p>

<p>去年，我收到Booking.com全职工作的邀请，而且我知道我将使用Perl（这是该公司后端使用的主要语言）工作。2016年6月，当我完成大学学位后，我开始学习Perl，以便为自己在大学毕业后的首份工作做准备。因为我会在7月的第二周入职，所以我差不多有1个月的时间。</p>

<p>我开始阅读Perl的语法，并开始理解这门语言的一些常见模式。现在，我真的想使用Perl构建一些东西，以便我可以应用我的这门语言的知识和实践这门语言的各种概念。当我在寻找使用Perl构建某些东西的想法时，我在GitHub偶遇DuckDuckGo的开源组织。我注意到这个组织的某些开放项目是用Perl写的。我浏览这些项目的Issues发现有很多“新手”问题。我立即开始去解决它们，并提交了几个pull request。到今天为止，我已经是该组织的几个开放项目的主要贡献者之一，也是DuckDuckGo的20个开源社区领袖之一。</p>

<blockquote>
<p>故事的寓意——通过向用Perl编写的开源项目贡献代码我学会了Perl。</p>
</blockquote>

<h3 id="为什么这种方法奏效呢？">为什么这种方法奏效呢？</h3>

<p>就在我学会Perl的语法之后，我开始向开源项目贡献代码。当这样做的时候，我总是习惯看看现有的模块。我经常留意在Perl中使用的模式。此后，我开始在自己的代码中吸收这些良好的实践，它帮助我学习如何使用Perl编写好的代码。</p>

<p>这并不是偶然。让我给你们讲个另外类似的故事。</p>

<p>最近，当我在Booking.com工作的时候，我挑选了一些任务，包括给用Go语言编写的服务之一添加新功能。以下是我和队友的对话：</p>

<blockquote>
<p>我：我真的喜欢这项任务。我想做它。你怎么看？</p>

<p>他：是的，它的确很有意思。但是，它需要Go的知识。你知道Go吗？</p>

<p>我：不知道。</p>

<p>他：你想学习Go吗？</p>

<p>我：是的！</p>

<p>他：&#x1f60a; 那就去吧！</p>
</blockquote>

<p>我去了，那也是我学习另外一门编程语言——Go的起点！</p>

<p>我开始阅读Go的语法，并在它的官方网站上发现了一个非常棒的初学者语言教程。它足以让我熟悉该语言的所有基本概念。</p>

<p>再次地，我开始寻找含有“新手”或“易于修复”问题的Go开源项目。我发现了一个Google的项目，它基本上是GitHub的REST API的Go包装器。</p>

<p>在我开始学习Go的2天后，我有了这个项目的第一个PR。下图是我过去1年的<a href="https://github.com/sahildua2305">贡献图表</a>：</p>

<p><img src="http://codemany.com/uploads/contribution-graph.png" alt="contribution-graph"></p>

<h3 id="开源是如何帮助的？">开源是如何帮助的？</h3>

<p>现在你可能会疑惑给开源贡献代码如何帮助你学习一门语言的良好实践。它有多个方面。让我们来逐个讨论。</p>

<h4 id="代码质量">代码质量</h4>

<p>大多数良好的开源项目都有严格的编码指导原则，你必须遵守它们才能使你的代码被合并。参与开源将帮助你适应这些指导原则，从而编写优质的代码，即使你只是在学习这门语言。</p>

<p>不仅如此，你还有机会查看其余的代码，学习别人是如何写代码和/或写文档的。</p>

<h4 id="代码审查">代码审查</h4>

<p>给开源贡献代码的最好部分是代码审查。当你推送代码时，你将获得与该项目相关的专家的反馈，因此可以让你有机会提升对语言的理解。</p>

<p>这就像获得了关于如何编写好代码的一次免费的个人指导。</p>

<h4 id="赞赏">赞赏</h4>

<p>下图是我在Go语言上的第一个PR的首个<a href="https://github.com/google/go-github/pull/497">评论</a>：</p>

<p><img src="http://codemany.com/uploads/go-appreciation-comment.png" alt="go-appreciation-comment"></p>

<p>作为软件开发者，我们的工作真的需要得到赞赏。而开源社区能够确保这些。在我的整个开源贡献经历中，我从来没有收到过甚至一条侮辱或者挫伤的评论。每个人都善于鼓舞和乐于助人。</p>

<p>下图是DuckDuckGo社区中另个人的评论：</p>

<p><img src="http://codemany.com/uploads/duckduckgo-appreciation-comment.png" alt="duckduckgo-appreciation-comment"></p>

<p>所以，下次你想学习一门新语言，只管去学！找个开源项目贡献代码，在学习这门语言和它微妙之处的道路上奋勇前进吧;)</p>

<p>务必让我知道这种非传统方式是否对你有效。另外，如果你认为这种方式对某人有用，请推荐（&#10084;）这篇文章。</p>

<p>如果有任何其它有效的方法也请告诉我。可以在Twitter上关注我<a href="https://twitter.com/sahildua2305">@sahildua2305</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GitHub对软件职业生涯的影响]]></title>
    <link href="http://codemany.com/blog/the-impact-github-is-having-on-your-software-career-right-now/"/>
    <updated>2017-03-20T20:50:30+08:00</updated>
    <id>http://codemany.com/blog/the-impact-github-is-having-on-your-software-career-right-now</id>
    <content type="html"><![CDATA[<p>英文原文：<a href="https://medium.com/@sitapati/the-impact-github-is-having-on-your-software-career-right-now-6ce536ec0b50">https://medium.com/@sitapati/the-impact-github-is-having-on-your-software-career-right-now-6ce536ec0b50</a></p>

<p>在未来的12-24个月里——换句话说，即2018到2019年间——程序员的聘用方式将彻底改变。</p>

<p>2004-2014年间，我任职于Red Hat，世界上最大的开源软件工程公司。2004年7月，在我工作的第一天，我的上司Marty Messer对我说：“你在这里所做的一切工作都是开源的。在将来，你不再需要简历，人们可以直接Google你。”</p>

<p>在那时，它是在Red Hat工作的一个独特之处：我们有机会在开源社区创立自己的个人品牌和声誉。我们通过邮件列表、缺陷追踪器以及提交源代码到Mercurial、Subversion和CVS版本库
来和其他软件工程师进行交流。所有这些都是公开的，并且可以被Google索引。</p>

<p>快进到2017，我们生活的这个世界已经被开源软件所吞噬。</p>

<p>有两个因素可以让你真切地感受到开源时代的到来：</p>

<ol>
<li>微软——曾经是闭源私有软件的典型代表和反对开源的圣战士——已经全心全意地拥抱开源软件，成立.NET基金会（Red Hat是其中的一员）和加入Linux基金会。现在.NET已经作为开源项目进行开发。</li>
<li>GitHub已经成为一个奇特的社交网络，它把问题追踪和分布式代码控制捆绑在一起。</li>
</ol>

<p>对于来自主要是闭源背景的软件开发者来说，刚刚发生了什么还不是很清楚。对他们来说，开源等于“在业余时间免费工作”。</p>

<p>然而，对于我们这些在过去10年里建成一个10亿美元开源软件公司的人来说，为开源工作没有什么免费或业余时间。并且，为开源工作的好处和结果是显而易见的：你的声誉是你的，而且在公司间是可携带的。GitHub是一个社交网络，在那里，你的社会资本，通过你的提交和对你正在工作的任何技术的全球交流的贡献创造的，是你的——不会绑定到你正在临时工作的公司。</p>

<p>聪明人会利用这个优势——他们会向他们日常工作中使用的语言和框架贡献补丁、问题和评论——TypeScript、.NET、Redux。</p>

<p>他们同样会提倡并创造性地安排他们的工作尽可能地以公开的方式完成——即使那只是他们对私有版本库的贡献图。</p>

<p>GitHub是一个很好的均衡器。你可能不能从印度找到一份澳大利亚的工作，但没有什么阻止你在印度利用GitHub与澳大利亚人进行合作。</p>

<p>在过去的十年里，从Red Hat获取一份工作的方式是显而易见的。你只要开始与Red Hat的工程师一起协作开发他们的一些开源项目，然后作出有价值的贡献并且得到他们的认可，你就可以申请一份工作。或者他们会找你。</p>

<p>现在，同样的途径对每个人都开放，不过仅限于技术职位。随着世界被开源所吞噬，同样的求职方式在各个地方开始流行起来。</p>

<p>在<a href="http://www.theregister.co.uk/2017/02/15/think_different_shut_up_and_work_harder_says_linus_torvalds/">最近的访谈</a>中，Linux和Git的发明者Linus Torvalds（在GitHub上有4.9万关注者）这样说道：</p>

<blockquote>
<p>你提交大量的小补丁，直到项目的维护者信任你，到那时你会成为信任网络的一部分，而不仅仅是个发送补丁的家伙。</p>
</blockquote>

<p>你的声誉是你在信任网络中的定位。当你换公司时，它们会减弱并且有所丢失。如果你生活在一个小镇，并且已经在那里很长一段时间，那么小镇里所有的人都了解你。如果你去了其他国家，那么你最终到了一个没人了解你的地方——更糟糕的是，没人知道有谁了解你。</p>

<p>你已经丢失了你的第一度和第二度，甚至可能是第三度连接（译者：不明白什么是“度”的可以搜索六度分隔理论）。除非你已经通过在会议上演讲或者其它一些重要的事情建立品牌，否则你通过与其他人合作以及给企业内部版本库提交代码建立的信任将会不复存在。</p>

<p>但是，如果这些工作一直都在GitHub上完成，它就不会消失。它是可见的。它连接到了一个可见的信任网络。</p>

<p>首先发生的事情之一是弱势群体将开始利用这个优势。学生、新毕业生、移民，他们将利用这个优势搬到澳大利亚。</p>

<p>并且这也将改变整个软件开发的生态环境。以前的特权开发者会突然发现他们的网络被破坏了。开源的原则之一是精英政治——最好的想法胜出，最多的提交胜出，通过测试最多的胜出，最好的实现胜出，等等。</p>

<p>它并不完美（没有什么是完美的）。并且它不会让成为一个好同事的努力废除或打折。在Red Hat，我们解雇过一些摇滚明星工程师，他们只是不能很好地与其他人一起工作——这样的事情不会出现在GitHub，因为大部分开发者都在与其他贡献者互动。</p>

<p>正如有些人用稻草人谬误描述它一样，GitHub不仅仅是代码版本库和原始提交数字的列表。它是一个社交网络。这么说吧：</p>

<blockquote>
<p>它不是你的代码在GitHub上的计数——它是其他人在GitHub上谈及你的代码的计数。</p>
</blockquote>

<p>那是你的可携带声誉。在未来的12-24个月里，由于一些开发者开发这种声誉而其他开发者不，它将成为一个鲜明的区分因素。就像有电子邮箱和没电子邮箱（现在每个人都有电子邮箱）、有蜂窝电话和没蜂窝电话（现在每个人都有蜂窝电话）。最终绝大多数将会以开源的方式工作，它将再次是区别于其它因素的一个公平竞争的领域。</p>

<p>但现在，开发者的职业生涯空间正在被GitHub破坏。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何修改Android的hosts文件]]></title>
    <link href="http://codemany.com/blog/how-to-modify-hosts-in-android/"/>
    <updated>2017-02-16T11:52:56+08:00</updated>
    <id>http://codemany.com/blog/how-to-modify-hosts-in-android</id>
    <content type="html"><![CDATA[<p>由于「你懂的」的原因，某些时候我们需要修改Android的hosts文件。Android的hosts文件路径是/system/etc/hosts，在修改该文件前首先需要Android手机获取root权限。至于如何root你的手机，这里就不加详述，可以自行在网络上查找，很多也很简单。</p>

<p>本文将要阐述的是如何在命令行下通过adb程序访问root过的手机，把hosts拖到电脑上修改，然后再复制回手机来实现修改hosts的方法。</p>

<p>下面就开始具体的步骤：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>C:\tools&gt;adb pull /system/etc/hosts hosts.mod
</span><span class='line'>[100%] /system/etc/hosts</span></code></pre></td></tr></table></div></figure>

<p>上面的命令是把手机上的hosts文件拖到电脑上，[100%]表明文件已经传输完成，可以修改hosts文件了。在修改完成后就使用以下命令上传到手机：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>C:\tools&gt;adb push hosts.mod /system/etc/hosts
</span><span class='line'>adb: error: failed to copy 'hosts.mod' to '/system/etc/hosts': Read-only file system</span></code></pre></td></tr></table></div></figure>

<p>从回显的消息可以看到，文件系统是只读的，所以不能直接上传。</p>

<p>试试以下的命令看能不能成功？！</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>C:\tools&gt;adb root  # 帮助文档说该命令可以让adbd守护进程获得root权限
</span><span class='line'>C:\tools&gt;adb push hosts.mod /system/etc/hosts
</span><span class='line'>adb: error: failed to copy 'hosts.mod' to '/system/etc/hosts': Read-only file system</span></code></pre></td></tr></table></div></figure>

<p>还是不行，看来要重新挂载/system目录才可以。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>C:\tools&gt;adb remount
</span><span class='line'>remount failed: Operation not permitted</span></code></pre></td></tr></table></div></figure>

<p>没有权限？这是必须祭起shell大法的节奏啊！</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>C:\tools&gt;adb shell
</span><span class='line'>* daemon not running. starting it now on port 5037 *
</span><span class='line'>* daemon started successfully *
</span><span class='line'>shell@maguro:/ $ ls -al /system/etc/hosts
</span><span class='line'>-rw-r--r-- root     root           25 2013-08-14 07:00 hosts</span></code></pre></td></tr></table></div></figure>

<p>从上面最后一行可以看出hosts这个文件只有它的拥有者能写入，对于其他人来说都是只读的。要想让其他人也能做修改，必须使用以下命令进行提权，再改变hosts文件的属性才行。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>shell@maguro:/ $ su</span></code></pre></td></tr></table></div></figure>

<p>如果是第一次执行这个命令，手机会亮起，SuperSU应用会提示你是否同意权限的分配。这里当然是要同意的！接着你就可以看到终端下的提示符从$变成了#，@前的字符也由shell变成了root。然后我们就可以修改hosts文件的权限属性了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@maguro:/ # chmod +666 /system/etc/hosts
</span><span class='line'>Bad mode
</span><span class='line'>root@maguro:/ # chmod 666 /system/etc/hosts
</span><span class='line'>Unable to chmod /system/etc/hosts: Read-only file system</span></code></pre></td></tr></table></div></figure>

<p>又是Read-only file system！输入以下命令看看/system目录的文件系统详情呢。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@maguro:/ # mount | grep system
</span><span class='line'>/dev/block/platform/omap/omap_hsmmc.0/by-name/system /system ext4 ro,seclabel,relatime...</span></code></pre></td></tr></table></div></figure>

<p>看到ext4后面的ro了吗？它是read only的缩写，即只读的意思。这说明/system目录是只读的。接下来我们要把它改成可以读写。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@maguro:/ # mount -o rw,remount /system</span></code></pre></td></tr></table></div></figure>

<p>上面的-o用于指定加载文件系统时的选项。这些选项包括：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>remount 重新加载设备。通常用于改变设备的设置状态。
</span><span class='line'>ro 以只读模式加载。
</span><span class='line'>rw 以可读写模式加载。</span></code></pre></td></tr></table></div></figure>

<p>再次查看，可以看到原来ro的位置已经变成rw了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@maguro:/ # mount | grep system
</span><span class='line'>/dev/block/platform/omap/omap_hsmmc.0/by-name/system /system ext4 rw,seclabel,relatime...</span></code></pre></td></tr></table></div></figure>

<p>不过到这里我们还不能向手机拷贝hosts文件，因为hosts文件的权限属性还没被改过，如果强行上传的话，会得到如下的错误消息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>C:\tools&gt;adb push hosts.mod /system/etc/hosts
</span><span class='line'>adb: error: failed to copy 'hosts.mod' to '/system/etc/hosts': Permission denied</span></code></pre></td></tr></table></div></figure>

<p>运行以下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@maguro:/ # chmod 666 /system/etc/hosts</span></code></pre></td></tr></table></div></figure>

<p>然后查看hosts文件的属性。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@maguro:/ # ls -al /system/etc/hosts
</span><span class='line'>-rw-rw-rw- root     root           25 2013-08-14 07:00 hosts</span></code></pre></td></tr></table></div></figure>

<p>可以看到所有人都可以读写hosts文件了。</p>

<p>既然一切都准备就绪，那就再来试试上传修改后的hosts文件吧。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>C:\tools&gt;adb push hosts.mod /system/etc/hosts
</span><span class='line'>adb: error: failed to copy 'hosts.mod' to '/system/etc/hosts': Read-only file system</span></code></pre></td></tr></table></div></figure>

<p>怎么回事，为什么还是拷贝失败呢？不是已经把文件系统改为可读写了吗？</p>

<p>并且在查找原因的过程中还发现一个奇怪的事情。在root模式下/system目录是可读写的，但在shell模式下/system却是只读的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@maguro:/ # mount | grep system
</span><span class='line'>/dev/block/platform/omap/omap_hsmmc.0/by-name/system /system ext4 rw,seclabel,relatime...
</span><span class='line'>root@maguro:/ # exit
</span><span class='line'>shell@maguro:/ # mount | grep system
</span><span class='line'>/dev/block/platform/omap/omap_hsmmc.0/by-name/system /system ext4 ro,seclabel,relatime...</span></code></pre></td></tr></table></div></figure>

<p>而且在手机上的Terminal Emulator中把/system目录mount成可读写之后，在adb shell的root模式下查看/system的状态仍然显示为只读。</p>

<p>在网上找啊找啊找啊，都快要绝望了，终于找到可能之问题所在。就是这个帖子：<a href="http://android.stackexchange.com/questions/142271/mount-in-shell-as-user-or-root-with-different-output">mount in shell as user or root with different output</a>。有个回答提到mount namespace这样东西。然后才知道：</p>

<blockquote>
<p>A mount namespace is the set of filesystem mounts that are visible to a process.</p>
</blockquote>

<p>每个进程的挂载点对其它进程是不可见的。Terminal Emulator中mount后的挂载点属于该进程，而adb shell中shell模式和root模式的挂载点分别属于各自的进程。这就是前面root模式下修改/system目录为可读写后在shell模式下仍显示为只读的原因。</p>

<p>知道问题的原因了，那如何解决呢？</p>

<p>在SuperSu应用的设置中有个mount namespace separation的选项，如下图所示：</p>

<p><img src="http://codemany.com/uploads/mount-namespace-separation.png" alt="mount-namespace-separation"></p>

<p>把勾选取消，然后mount的挂载点就是全局性的了，不再为mount它们的进程所独有。不过要记住的是，只有在重启手机后该修改才有效。</p>

<p>下面是取消mount namespace separation后在上传的结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>C:\tools&gt;adb push hosts.mod /system/etc/hosts
</span><span class='line'>[100%] /system/etc/hosts</span></code></pre></td></tr></table></div></figure>

<p>可以看到[100%]的回显，说明文件已经上传完成。</p>

<p>查看hosts文件的属性：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@maguro:/ # ls -al /system/etc/hosts
</span><span class='line'>-rw-rw-rw- root     root       137679 2017-02-16 00:20 hosts</span></code></pre></td></tr></table></div></figure>

<p>文件的大小已经由25变成137679，说明文件已经替换完成。</p>

<p>下面就是恢复手机到原先的状态：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@maguro:/ # chmod 644 /system/etc/hosts
</span><span class='line'>root@maguro:/ # ls -al /system/etc/hosts
</span><span class='line'>-rw-r--r-- root     root       137679 2017-02-16 00:20 hosts
</span><span class='line'>root@maguro:/ # mount -o ro,remount /system</span></code></pre></td></tr></table></div></figure>

<p>至此，修改hosts文件的工作就算大功告成。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（33）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part33/"/>
    <updated>2016-12-03T09:22:11+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part33</id>
    <content type="html"><![CDATA[<p>ANTLR的语法分析器可以生成错误信息，也可以从大量不同情况的错误中恢复。我们还可以自定义错误信息以及将它们重定向到不同的错误监听器。所有这些功能都被封装在指定ANTLR错误处理策略的对象中。接下来我们就将详细研究该策略，以学习更多关于自定义语法分析器如何响应错误的知识。</p>

<h3 id="更改antlr的错误处理策略">更改ANTLR的错误处理策略</h3>

<p>默认的错误处理机制工作得很好，但在有些非典型的情况下我们可能要更改它。首先，我们可能由于运行时开销而想要禁用一些内联错误处理。其次，我们可能希望在出现第一个语法错误时就退出语法分析器。例如，当为类似bash这样的shell解析命令行时，没必要试图从错误中恢复。无论如何我们不能冒险执行该命令，所以语法分析器可以在一遇到麻烦时就推出。</p>

<p>要了解错误处理策略，请查看接口ANTLRErrorStrategy及其具体的实现类DefaultErrorStrategy。这个类持有与默认错误处理行为相关联的一切。ANTLR语法分析器指示该对象报告错误并恢复。例如，下面是在每个ANTLR生成的规则函数里面的捕获块：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>_errHandler.reportError(this, re);
</span><span class='line'>_errHandler.recover(this, re);</span></code></pre></td></tr></table></div></figure>

<p>_errHandler是一个持有DefaultErrorStrategy实例的引用的变量。方法reportError()和recover()表示错误报告和同步和返回功能。reportError()根据抛出的异常类型将错误报告委托给3个方法的其中之一。</p>

<p>回到第一种非典型的情况，让我们来降低语法分析器上的错误处理在运行时的负担。看看下面这段ANTLR为语法Simple中member+子规则生成的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>_errHandler.sync(this);
</span><span class='line'>_la = _input.LA(1);
</span><span class='line'>do {
</span><span class='line'>    setState(22); member();
</span><span class='line'>    setState(26);
</span><span class='line'>    _errHandler.sync(this);
</span><span class='line'>    _la = _input.LA(1);
</span><span class='line'>} while ( _la==6 );</span></code></pre></td></tr></table></div></figure>

<p>对于可以安全地假设输入语法是正确的应用程序，比如网络协议，我们最好避免检测并从错误中恢复的开销。我们可以通过继承DefaultErrorStrategy并用空方法覆写sync()来做到这点。Java编译器可能会内联并消除_errHandler.sync(this)调用。我们将在下个例子中阐述如何通知语法分析器使用不同的错误策略。</p>

<p>另一种非典型的情况是在出现第一个语法错误时就退出语法分析器。为使它工作，我们必须覆写3个关键的恢复方法，如下面的代码所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import org.antlr.v4.runtime.*;
</span><span class='line'>
</span><span class='line'>public class BailErrorStrategy extends DefaultErrorStrategy {
</span><span class='line'>    /** Instead of recovering from exception e, rethrow it wrapped
</span><span class='line'>     *  in a generic RuntimeException so it is not caught by the
</span><span class='line'>     *  rule function catches. Exception e is the "cause" of the
</span><span class='line'>     *  RuntimeException.
</span><span class='line'>     */
</span><span class='line'>    @Override
</span><span class='line'>    public void recover(Parser recognizer, RecognitionException e) {
</span><span class='line'>        throw new RuntimeException(e);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /** Make sure we don't attempt to recover inline; if the parser
</span><span class='line'>     *  successfully recovers, it won't throw an exception.
</span><span class='line'>     */
</span><span class='line'>    @Override
</span><span class='line'>    public Token recoverInline(Parser recognizer) throws RecognitionException {
</span><span class='line'>        throw new RuntimeException(new InputMismatchException(recognizer));
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /** Make sure we don't attempt to recover from problems in subrules. */
</span><span class='line'>    @Override
</span><span class='line'>    public void sync(Parser recognizer) { }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>对于测试平台，我们可以重复使用我们典型的样板代码。除了创建并启动语法分析器，我们需要创建一个新的BailErrorStrategy实例，并告诉语法分析器使用它替换默认的策略。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>parser.setErrorHandler(new BailErrorStrategy());</span></code></pre></td></tr></table></div></figure>

<p>当我们处理这个问题的时候，我们也应该在出现第一个词汇错误时退出。要做到这点，我们必须重写Lexer中的recover()方法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static class BailSimpleLexer extends SimpleLexer {
</span><span class='line'>    public BailSimpleLexer(CharStream input) { super(input); }
</span><span class='line'>
</span><span class='line'>    public void recover(LexerNoViableAltException e) {
</span><span class='line'>        throw new RuntimeException(e);    // Bail out
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>让我们先尝试一个词法错误，通过在输入开头插入一个#字符，词法分析器会抛出异常并从控制流中返回到主程序。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ antlr Simple.g
</span><span class='line'>$ compile Simple TestBail
</span><span class='line'>$ run TestBail
</span><span class='line'># class T { int i; }
</span><span class='line'>EOF
</span><span class='line'>line 1:1 token recognition error at: '#'
</span><span class='line'>Exception in thread "main"
</span><span class='line'>java.lang.RuntimeException: LexerNoViableAltException('#')
</span><span class='line'>at TestBail$BailSimpleLexer.recover(TestBail.java:9)
</span><span class='line'>at org.antlr.v4.runtime.Lexer.nextToken(Lexer.java:165)
</span><span class='line'>at org.antlr.v4.runtime.BufferedTokenStream.fetch(BufferedT...Stream.java:139)
</span><span class='line'>at org.antlr.v4.runtime.BufferedTokenStream.sync(BufferedT...Stream.java:133)
</span><span class='line'>at org.antlr.v4.runtime.CommonTokenStream.setup(CommonTokenStream.java:129)
</span><span class='line'>at org.antlr.v4.runtime.CommonTokenStream.LT(CommonTokenStream.java:111)
</span><span class='line'>at org.antlr.v4.runtime.Parser.enterRule(Parser.java:424)
</span><span class='line'>at SimpleParser.prog(SimpleParser.java:68)
</span><span class='line'>at TestBail.main(TestBail.java:23)
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>

<p>语法分析器也会从第一个语法错误中退出（在这里是缺少类名）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ run TestBail
</span><span class='line'>class { }
</span><span class='line'>EOF
</span><span class='line'>Exception in thread "main" java.lang.RuntimeException:
</span><span class='line'>org.antlr.v4.runtime.InputMismatchException
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>

<p>我们将通过下面更改语法分析器报告错误的方式来演示ANTLRErrorStrategy接口的灵活性。要改变标准的消息“noviable alternative at input X,”，我们可以覆盖reportNoViableAlternative()并将消息更改为其它不同的内容。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import org.antlr.v4.runtime.*;
</span><span class='line'>
</span><span class='line'>public class MyErrorStrategy extends DefaultErrorStrategy {
</span><span class='line'>    @Override
</span><span class='line'>    public void reportNoViableAlternative(Parser parser, NoViableAltException e)
</span><span class='line'>        throws RecognitionException {
</span><span class='line'>        // ANTLR generates Parser subclasses from grammars and
</span><span class='line'>        // Parser extends Recognizer. Parameter parser is a
</span><span class='line'>        // pointer to the parser that detected the error
</span><span class='line'>        String msg = "can't choose between alternatives";    // nonstandard msg
</span><span class='line'>        parser.notifyErrorListeners(e.getOffendingToken(), msg, e);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

<p>到这里，我们已经涵盖了ANTLR内所有重要的错误报告和恢复设施。因为ANTLRErrorListener和ANTLRErrorStategy接口，我们在错误消息发生的地方具有很大的灵活性：这些消息是什么，以及语法分析器如何从错误中恢复。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[共享代码的风险]]></title>
    <link href="http://codemany.com/blog/the-perils-of-shared-code/"/>
    <updated>2016-11-25T18:51:10+08:00</updated>
    <id>http://codemany.com/blog/the-perils-of-shared-code</id>
    <content type="html"><![CDATA[<p>英文原文：<a href="https://www.innoq.com/en/blog/the-perils-of-shared-code/">https://www.innoq.com/en/blog/the-perils-of-shared-code/</a></p>

<p>通往地狱的道路往往是由良好的意愿铺就。在各种软件项目中，我看到人们走在这样的道路上，他们在微服务之间借助库共享代码。在几乎每个组织支持微服务架构的项目中，各个团队和开发者都期望以某些核心库为基础构建他们的微服务。显然，即使可能带来的问题已经被知道很长时间了，很多人仍然不知道它们。在这篇博文中，我想研究为什么使用这样的库可能起初听起来有吸引力，为什么可能会出现问题，以及如何能够减轻这些问题。</p>

<h3 id="共享代码的目的">共享代码的目的</h3>

<p>通过库来共享代码有两个主要目的：共享领域逻辑和共享基础设施层中的抽象。</p>

<ol>
<li><p><em>共享的领域模型：</em>领域模型的特定部分在两个或多个有界上下文之间是共同的，因此，作为三番五次实现它的替换，你消除了重复的需要和引入该领域逻辑的不一致实现的可能性。通常，人们想要像那样共享的领域模型的部分是核心领域或一个或多个通用子领域。在领域驱动设计的行话中，这也被称为共享内核。通常，你可以在这里找到像会话和身份验证逻辑这样的概念，但不限于此。一套相关的方法是规范数据模型。</p></li>
<li><p><em>基础设施层抽象：</em>你想避免一次又一次地实现基础设施层的有用抽象，因此你把它们放进一个库里。通常，这些库在数据库访问、消息传递和序列化等方面提供一套统一的方法。</p></li>
</ol>

<p>两者的动机是相同的——避免重复，也就是说，遵循DRY原则（Don’t repeat yourself!）。一旦实现这些逻辑有几个好处：</p>

<blockquote>
<p>你不需要花费宝贵的时间致力于那些已经被解决的问题。</p>

<p>有一套统一的方式做消息传递、数据库访问等。这意味着，当开发者需要去阅读和修改其他开发者最初创建的微服务中的代码时，他们很容易找到他们的方式。</p>

<p>关于彼此行为略有不同的业务逻辑或基础设施关注点，你不想有不同的实现。取而代之的是，有一套做正确事情的规范实现。</p>
</blockquote>

<h3 id="共享代码的问题">共享代码的问题</h3>

<p>在理论上听起来很棒的东西不会没有自己的问题，而且这些问题可能比你试图用你的库解决的问题更令人痛苦。Stefan Tilkov已经详细解释了<a href="https://www.innoq.com/en/blog/thoughts-on-a-canonical-data-model/">为什么你应该避免规范的数据模型</a>。除此之外，让我指出一些其它的问题。</p>

<h4 id="分布式单体">分布式单体</h4>

<p>通常，似乎存在一个隐含的假设，将东西放入库意味着你永远不必担心使用错误或过时的实现构成的服务，因为他们只需要更新其对库的依赖关系到最新版本。</p>

<p>每当你依靠通过将所有的微服务更新到同样的新版本库，来对所有微服务的某些行为作出一致的改变时，你就会在它们之间引入强耦合。你失去了微服务的一个主要优点，即它们彼此独立地演进和部署的能力。</p>

<p>我见过这样的案例，所有的服务必须同时部署，以便服务仍能正常工作。如果你达到这种状态，不可否认，你实际上构建了一个分布式的单体。</p>

<p>一个流行的示例是使用代码生成，例如，基于服务API的Swagger描述，以便为你的服务提供一个客户端库。比你想象的更多，开发者可能会滥用此种方式进行重大变更，因为依赖服务“只”需要使用新版本的客户端库。这不是你如何<a href="http://olivergierke.de/2016/10/evolving-distributed-systems/">演进一个分布式系统</a>。</p>

<h4 id="依赖地狱">依赖地狱</h4>

<p>库，尤其是那些旨在为基础设施关注点提供通用解决方案的库，往往有个额外的问题：它们会附上它们依赖的一整套额外的库。你的库的传递依赖树越大，它导致俗称为依赖地狱的噩梦的可能性就越高。因为你的微服务可能需要自己的额外的依赖，它们同样具有传递依赖性，直到它们中的某些库间接地拉进一些库的冲突版本，这只是个时间问题，只在不同版本之间选择是不可能的，因为它们是二进制不兼容的。</p>

<p>当然，你的解决方案也许只是提供微服务可能需要的所有库作为你的核心库的依赖。那仍然意味着你的微服务不能独立地演进，例如通过升级到它们依赖的唯一的特定库的更高版本——它们都与核心库的发布周期步调一致。除此之外，为什么你要强制每个服务接受一整堆的依赖，当它们实际上可能只需要依赖中的一些时？</p>

<h4 id="自顶而下的库设计">自顶而下的库设计</h4>

<p>通常情况下，我见过的库被一个或多个架构师强加于开发者，采用自顶而下的方法进行库设计。</p>

<p>通常，在这种情况下发生的是，由库暴露的API太受限制和不灵活，或者使用了错误的抽象级别，因为它们是由不够熟悉广泛的不同的真实世界用例的人设计的。这样的库经常导致不得不使用它的开发者遭受挫折，以及导致人们试图绕过库的限制。</p>

<h4 id="单语言解决一切">单语言解决一切</h4>

<p>强制使用库的最明显的缺陷之一是，这使得它更难以切换到不同的编程语言（或者平台，比如JVM或.NET），再次失去了微服务架构的一个优势，即选择最适合给定问题的技术的能力。如果你后来意识到，你终究需要这种语言或者平台的多样性，你必须创造各种奇怪的支持。例如，Netflix提出的<a href="https://github.com/Netflix/Prana">Prana</a>，一个同时运行非JVM服务的附加件，为他们提供到Netflix技术栈的一套HTTP API。</p>

<h3 id="我们能不能做得更好？">我们能不能做得更好？</h3>

<p>由于所有的问题都是通过库共享代码引入的，最极端的解决方案是根本没有这样的库。如果你这样做，你将不得不做一些复制和粘贴或者为新的微服务提供一个模板项目，以便从前面所述的步调一致中释放你的服务。基础设施代码以及领域模型的共享内核中都可以这么做。事实上，Eric Evans在他的关于领域驱动设计的经典蓝皮书中提到，“通常各个团队只是在各自的内核备份上改动，每隔一定时间才会与其他团队集成”[1]。共享内核不一定要是库。</p>

<p>如果你不喜欢复制和粘贴的想法，那也很好。毕竟，如上所述，通过库共享代码有一定的优势。在这种情况下，这里有一些重要的事情需要考虑：</p>

<h4 id="最少依赖的小型库">最少依赖的小型库</h4>

<p>尝试将大的共享库分成一组非常小的、高度集中的库，每个库解决一个特定的问题。试着让这些库成为零依赖库，只依靠语言的标准库。是的，仅仅针对语言的标准库来编程并不总是令人愉快的，但是对于你公司的所有团队的巨大好处（甚至超出你的公司，如果你的馆是开源的）显然大于这个微小的不便。</p>

<p>当然，零依赖并不总是可能的，特别是对于基础设施关注点。对于这些，通过你的每个小型库最小化所需的依赖。另外，有时可以独立于库的核心，提供与别的库的绑定或集成作为单独的工件。</p>

<h4 id="留下选择余地">留下选择余地</h4>

<p>不要指望服务将在特定时间点更新到共享库的最新版本的事实。换句话说，不要强制团队进行库更新，而是让他们可以按照自己的节奏自由更新。这可能需要你以向后和向前兼容的方式修改库，但它会解耦你的服务，不仅给你微服务架构的运营成本，而且还有一些优势。</p>

<p>如果可能，不仅要避免强制库更新，还要使库本身的使用可选。</p>

<h4 id="自底而上的库设计">自底而上的库设计</h4>

<p>最后，如果你想拥有共享库，我见过的获得成功的项目是使用自底而上的方法。让你的团队实现他们的微服务，而不是让象牙塔架构师设计在现实世界中几乎不可用的库，而当在多个服务的生产中已经证明它们自己的一些常见模式出现时，将它们提取到库中。</p>

<p>[1] Evans, Eric: Domain-Driven Design: Tackling Complexity in the Heart of Software, p. 355</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANTLR 4权威参考读书笔记（32）]]></title>
    <link href="http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part32/"/>
    <updated>2016-11-18T05:58:56+08:00</updated>
    <id>http://codemany.com/blog/reading-notes-the-definitive-antlr4-reference-part32</id>
    <content type="html"><![CDATA[<p>前面我们介绍过ANTLR的自动错误恢复机制，现在让我们看看手动机制，有些时候它能够提供更好的错误恢复。</p>

<h3 id="错误选项">错误选项</h3>

<p>某些语法错误非常常见，所以值得特别处理。例如，程序员经常在带有嵌套参数的函数调用结尾处忘记写大括号。特别是处理这些情况，我们所要做的就是添加选项来匹配错误但常见的语法。下面的语法识别单个参数或者可能在参数中使用嵌套括号的函数调用。规则fcall有两个所谓的错误选项。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>stat: fcall ';' ;
</span><span class='line'>fcall
</span><span class='line'>    : ID '(' expr ')'
</span><span class='line'>    | ID '(' expr ')' ')' { notifyErrorListeners("Too many parentheses"); }
</span><span class='line'>    | ID '(' expr         { notifyErrorListeners("Missing closing ')'"); }
</span><span class='line'>    ;
</span><span class='line'>expr: '(' expr ')'
</span><span class='line'>    | INT
</span><span class='line'>    ;</span></code></pre></td></tr></table></div></figure>

<p>虽然这些错误选项可能使ANTLR生成的语法分析器在选项之间选择时更困难，但它们不以任何方式混淆语法分析器。就像任何其它选项，如果它们与当前的输入一致，语法分析器就会匹配它们。现在，让我们从一个有效的函数调用开始，尝试一些匹配错误选项的输入序列。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ antlr Call.g
</span><span class='line'>$ compile Call
</span><span class='line'>$ grun Call stat
</span><span class='line'>f(34);
</span><span class='line'>EOF
</span><span class='line'>$ grun Call stat
</span><span class='line'>f((34);
</span><span class='line'>EOF
</span><span class='line'>line 1:6 Missing closing ')'
</span><span class='line'>$ grun Call stat
</span><span class='line'>f((34)));
</span><span class='line'>EOF
</span><span class='line'>line 1:8 Too many parentheses</span></code></pre></td></tr></table></div></figure>
]]></content>
  </entry>
  
</feed>
